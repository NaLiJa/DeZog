# File rom128_1.asm
0000			; **************************************  
0000			; *** SPECTRUM 128 ROM 1 DISASSEMBLY ***  
0000			; **************************************  
0000			  
0000			; The Spectrum ROMs are copyright Amstrad, who have kindly given permission  
0000			; to reverse engineer and publish ROM disassemblies.  
0000			  
0000			  
0000			; =====  
0000			; NOTES  
0000			; =====  
0000			  
0000			; ------------  
0000			; Release Date  
0000			; ------------  
0000			; 13th December 2011  
0000			  
0000			; ------------------------  
0000			; Disassembly Contributors  
0000			; ------------------------  
0000			; Geoff Wearmouth (gwearmouth-AT-hotmail.com)  
0000			; Paul Farrow     (www.fruitcake.plus.com)  
0000			  
0000			  
0000			; =================  
0000			; ASSEMBLER DEFINES  
0000			; =================  
0000			  
0000			;TASM directives:  
0000			  
0000			;#define DEFB .BYTE        
0000			;#define DEFW .WORD  
0000			;#define DEFM .TEXT  
0000			;#DEFINE DEFS .FILL  
0000			;#define END  .END  
0000			;#define EQU  .EQU  
0000			;#define ORG  .ORG  
0000			  
0000			; The Sinclair Interface1 ROM written by Dr. Ian Logan calls numerous  
0000			; routines in this ROM. Non-standard entry points have a label beginning  
0000			; with X.   
0000			  
0000			        ORG     $0000  
0000			  
0000			;*****************************************  
0000			;** Part 1. RESTART ROUTINES AND TABLES **  
0000			;*****************************************  
0000			  
0000			; -----------  
0000			; THE 'START'  
0000			; -----------  
0000			; At switch on, the Z80 chip is in interrupt mode 0.  
0000			; This location can also be 'called' to reset the machine.  
0000			; Typically with PRINT USR 0.  
0000			  
0000			;; START  
0000 f3			L0000:  DI                      ; disable interrupts.  
0001 af			        XOR     A               ; signal coming from START.  
0002 11 ff ff		        LD      DE,$FFFF        ; top of possible physical RAM.  
0005 c3 cb 11		        JP      L11CB           ; jump forward to common code at START-NEW.  
0008			  
0008			; -------------------  
0008			; THE 'ERROR' RESTART  
0008			; -------------------  
0008			; The error pointer is made to point to the position of the error to enable  
0008			; the editor to show the error if it occurred during syntax checking.  
0008			; It is used at 37 places in the program.  
0008			; An instruction fetch on address $0008 may page in a peripheral ROM  
0008			; such as the Sinclair Interface 1 or Disciple Disk Interface.   
0008			; This was not however an original design concept and not all errors pass  
0008			; through here.  
0008			  
0008			;; ERROR-1  
0008 2a 5d 5c		L0008:  LD      HL,($5C5D)      ; fetch the character address from CH_ADD.  
000b 22 5f 5c		        LD      ($5C5F),HL      ; copy it to the error pointer X_PTR.  
000e 18 43		        JR      L0053           ; forward to continue at ERROR-2.  
0010			  
0010			; -----------------------------  
0010			; THE 'PRINT CHARACTER' RESTART  
0010			; -----------------------------  
0010			; The A register holds the code of the character that is to be sent to  
0010			; the output stream of the current channel.  
0010			; The alternate register set is used to output a character in the A register  
0010			; so there is no need to preserve any of the current registers (HL,DE,BC).  
0010			; This restart is used 21 times.  
0010			  
0010			;; PRINT-A  
0010 c3 f2 15		L0010:  JP      L15F2           ; jump forward to continue at PRINT-A-2.  
0013			  
0013			; ---  
0013			  
0013 ff			X0013:  DEFB    $FF             ; this byte is used by the SPECTRUM command in  
0014			                                ; ROM 0 to generate an error report "0 OK".  
0014			  
0014 ff ff		        DEFB    $FF, $FF        ; four unused locations.  
0016 ff ff		        DEFB    $FF, $FF        ;  
0018			  
0018			; -------------------------------  
0018			; THE 'COLLECT CHARACTER' RESTART  
0018			; -------------------------------  
0018			; The contents of the location currently addressed by CH_ADD are fetched.  
0018			; A return is made if the value represents a character that has  
0018			; relevance to the BASIC parser. Otherwise CH_ADD is incremented and the  
0018			; tests repeated. CH_ADD will be addressing somewhere -  
0018			; 1) in the BASIC program area during line execution.  
0018			; 2) in workspace if evaluating, for example, a string expression.  
0018			; 3) in the edit buffer if parsing a direct command or a new BASIC line.  
0018			; 4) in workspace if accepting input but not that from INPUT LINE.  
0018			  
0018			;; GET-CHAR  
0018 2a 5d 5c		L0018:  LD      HL,($5C5D)      ; fetch the address from CH_ADD.  
001b 7e			        LD      A,(HL)          ; use it to pick up current character.  
001c			  
001c			;; TEST-CHAR  
001c cd 7d 00		L001C:  CALL    L007D           ; routine SKIP-OVER tests if the character  
001f d0			        RET     NC              ; is relevant. Return if it is so.  
0020			  
0020			; ------------------------------------  
0020			; THE 'COLLECT NEXT CHARACTER' RESTART  
0020			; ------------------------------------  
0020			; As the BASIC commands and expressions are interpreted, this routine is  
0020			; called repeatedly to step along the line. It is used 83 times.  
0020			  
0020			;; NEXT-CHAR  
0020 cd 74 00		L0020:  CALL    L0074           ; routine CH-ADD+1 fetches the next immediate  
0023			                                ; character.  
0023 18 f7		        JR      L001C           ; jump back to TEST-CHAR until a valid  
0025			                                ; character is found.  
0025			  
0025			; ---  
0025			  
0025 ff ff ff		        DEFB    $FF, $FF, $FF   ; unused  
0028			  
0028			; -----------------------  
0028			; THE 'CALCULATE' RESTART  
0028			; -----------------------  
0028			; This restart enters the Spectrum's internal, floating-point,  
0028			; stack-based, FORTH-like language.  
0028			; It is further used recursively from within the calculator.  
0028			; It is used on 77 occasions.  
0028			  
0028			;; FP-CALC  
0028 c3 5b 33		L0028:  JP      L335B           ; jump forward to the CALCULATE routine.  
002b			  
002b			; ---  
002b			  
002b ff ff ff		        DEFB    $FF, $FF, $FF   ; spare - note that on the ZX81, space being a   
002e ff ff		        DEFB    $FF, $FF        ; little cramped, these same locations were  
0030			                                ; used for the five-byte end-calc literal.  
0030			  
0030			; ------------------------------  
0030			; THE 'CREATE BC SPACES' RESTART  
0030			; ------------------------------  
0030			; This restart is used on only 12 occasions to create BC spaces  
0030			; between workspace and the calculator stack.  
0030			  
0030			;; BC-SPACES  
0030 c5			L0030:  PUSH    BC              ; save number of spaces.  
0031 2a 61 5c		        LD      HL,($5C61)      ; fetch WORKSP.  
0034 e5			        PUSH    HL              ; save address of workspace.  
0035 c3 9e 16		        JP      L169E           ; jump forward to continuation code RESERVE.  
0038			  
0038			; --------------------------------  
0038			; THE 'MASKABLE INTERRUPT' ROUTINE  
0038			; --------------------------------  
0038			; This routine increments the Spectrum's three-byte FRAMES counter  
0038			; fifty times a second (sixty times a second in the USA ).  
0038			; Both this routine and the called KEYBOARD subroutine use   
0038			; the IY register to access system variables and flags so a user-written  
0038			; program must disable interrupts to make use of the IY register.  
0038			  
0038			;; MASK-INT  
0038 f5			L0038:  PUSH    AF              ; save the registers.  
0039 e5			        PUSH    HL              ; but not IY unfortunately.  
003a 2a 78 5c		        LD      HL,($5C78)      ; fetch two bytes at FRAMES1.  
003d 23			        INC     HL              ; increment lowest two bytes of counter.  
003e 22 78 5c		        LD      ($5C78),HL      ; place back in FRAMES1.  
0041 7c			        LD      A,H             ; test if the result  
0042 b5			        OR      L               ; was zero.  
0043 20 03		        JR      NZ,L0048        ; forward to KEY-INT if not.  
0045			  
0045 fd 34 40		        INC     (IY+$40)        ; otherwise increment FRAMES3 the third byte.  
0048			  
0048			; now save the rest of the main registers and read and decode the keyboard.  
0048			  
0048			;; KEY-INT  
0048 c5			L0048:  PUSH    BC              ; save the other  
0049 d5			        PUSH    DE              ; main registers.  
004a cd 6e 38		        CALL    L386E           ; Spectrum 128 patch: read the keypad and keyboard  
004d			                                ; in the process of reading a key-press.  
004d d1			L004D:  POP     DE              ;  
004e c1			        POP     BC              ; restore registers.  
004f			  
004f e1			        POP     HL              ;  
0050 f1			        POP     AF              ;  
0051 fb			        EI                      ; enable interrupts.  
0052 c9			        RET                     ; return.  
0053			  
0053			; ---------------------  
0053			; THE 'ERROR-2' ROUTINE  
0053			; ---------------------  
0053			; A continuation of the code at 0008.  
0053			; The error code is stored and after clearing down stacks,  
0053			; an indirect jump is made to MAIN-4, etc. to handle the error.  
0053			  
0053			;; ERROR-2  
0053 e1			L0053:  POP     HL              ; drop the return address - the location  
0054			                                ; after the RST 08H instruction.  
0054 6e			        LD      L,(HL)          ; fetch the error code that follows.  
0055			                                ; (nice to see this instruction used.)  
0055			  
0055			; Note. this entry point is used when out of memory at REPORT-4.  
0055			; The L register has been loaded with the report code but X-PTR is not  
0055			; updated.  
0055			  
0055			;; ERROR-3  
0055 fd 75 00		L0055:  LD      (IY+$00),L      ; store it in the system variable ERR_NR.  
0058 ed 7b 3d 5c	        LD      SP,($5C3D)      ; ERR_SP points to an error handler on the  
005c			                                ; machine stack. There may be a hierarchy  
005c			                                ; of routines.  
005c			                                ; to MAIN-4 initially at base.  
005c			                                ; or REPORT-G on line entry.  
005c			                                ; or  ED-ERROR when editing.  
005c			                                ; or   ED-FULL during ed-enter.  
005c			                                ; or  IN-VAR-1 during runtime input etc.  
005c			  
005c c3 c5 16		        JP      L16C5           ; jump to SET-STK to clear the calculator  
005f			                                ; stack and reset MEM to usual place in the  
005f			                                ; systems variables area.  
005f			                                ; and then indirectly to MAIN-4, etc.  
005f			  
005f			; ---  
005f			  
005f ff ff ff		        DEFB    $FF, $FF, $FF   ; unused locations  
0062 ff ff ff		        DEFB    $FF, $FF, $FF   ; before the fixed-position  
0065 ff			        DEFB    $FF             ; NMI routine.  
0066			  
0066			; ------------------------------------  
0066			; THE 'NON-MASKABLE INTERRUPT' ROUTINE  
0066			; ------------------------------------  
0066			; There is no NMI switch on the standard Spectrum.  
0066			; When activated, a location in the system variables is tested  
0066			; and if the contents are zero a jump made to that location else  
0066			; a return is made. Perhaps a disabled development feature but  
0066			; if the logic was reversed, no program would be safe from  
0066			; copy-protection and the Spectrum would have had no software base.  
0066			; The location NMIADD was later used by Interface 1 for other purposes.  
0066			; On later Spectrums, and the Brazilian Spectrum, the logic of this  
0066			; routine was reversed.  
0066			  
0066			;; RESET  
0066 f5			L0066:  PUSH    AF              ; save the  
0067 e5			        PUSH    HL              ; registers.  
0068 2a b0 5c		        LD      HL,($5CB0)      ; fetch the system variable NMIADD.  
006b 7c			        LD      A,H             ; test address  
006c b5			        OR      L               ; for zero.  
006d 20 01		        JR      NZ,L0070        ; skip to NO-RESET if NOT ZERO  
006f			  
006f e9			        JP      (HL)            ; jump to routine ( i.e. L0000 )  
0070			  
0070			;; NO-RESET  
0070 e1			L0070:  POP     HL              ; restore the  
0071 f1			        POP     AF              ; registers.  
0072 ed 45		        RETN                    ; return to previous interrupt state.  
0074			  
0074			; ---------------------------  
0074			; THE 'CH ADD + 1' SUBROUTINE  
0074			; ---------------------------  
0074			; This subroutine is called from RST 20, and three times from elsewhere  
0074			; to fetch the next immediate character following the current valid character  
0074			; address and update the associated system variable.  
0074			; The entry point TEMP-PTR1 is used from the SCANNING routine.  
0074			; Both TEMP-PTR1 and TEMP-PTR2 are used by the READ command routine.  
0074			  
0074			;; CH-ADD+1  
0074 2a 5d 5c		L0074:  LD      HL,($5C5D)      ; fetch address from CH_ADD.  
0077			  
0077			;; TEMP-PTR1  
0077 23			L0077:  INC     HL              ; increase the character address by one.  
0078			  
0078			;; TEMP-PTR2  
0078 22 5d 5c		L0078:  LD      ($5C5D),HL      ; update CH_ADD with character address.  
007b			  
007b 7e			X007B:  LD      A,(HL)          ; load character to A from HL.  
007c c9			        RET                     ; and return.  
007d			  
007d			; --------------------------  
007d			; THE 'SKIP OVER' SUBROUTINE  
007d			; --------------------------  
007d			; This subroutine is called once from RST 18 to skip over white-space and  
007d			; other characters irrelevant to the parsing of a BASIC line etc. .  
007d			; Initially the A register holds the character to be considered  
007d			; and HL holds its address which will not be within quoted text  
007d			; when a BASIC line is parsed.  
007d			; Although the 'tab' and 'at' characters will not appear in a BASIC line,  
007d			; they could be present in a string expression, and in other situations.  
007d			; Note. although white-space is usually placed in a program to indent loops  
007d			; and make it more readable, it can also be used for the opposite effect and  
007d			; spaces may appear in variable names although the parser never sees them.  
007d			; It is this routine that helps make the variables 'Anum bEr5 3BUS' and  
007d			; 'a number 53 bus' appear the same to the parser.  
007d			  
007d			;; SKIP-OVER  
007d fe 21		L007D:  CP      $21             ; test if higher than space.  
007f d0			        RET     NC              ; return with carry clear if so.  
0080			  
0080 fe 0d		        CP      $0D             ; carriage return ?  
0082 c8			        RET     Z               ; return also with carry clear if so.  
0083			  
0083			                                ; all other characters have no relevance  
0083			                                ; to the parser and must be returned with  
0083			                                ; carry set.  
0083			  
0083 fe 10		        CP      $10             ; test if 0-15d  
0085 d8			        RET     C               ; return, if so, with carry set.  
0086			  
0086 fe 18		        CP      $18             ; test if 24-32d  
0088 3f			        CCF                     ; complement carry flag.  
0089 d8			        RET     C               ; return with carry set if so.  
008a			  
008a			                                ; now leaves 16d-23d  
008a			  
008a 23			        INC     HL              ; all above have at least one extra character  
008b			                                ; to be stepped over.  
008b			  
008b fe 16		        CP      $16             ; controls 22d ('at') and 23d ('tab') have two.  
008d 38 01		        JR      C,L0090         ; forward to SKIPS with ink, paper, flash,  
008f			                                ; bright, inverse or over controls.  
008f			                                ; Note. the high byte of tab is for RS232 only.  
008f			                                ; it has no relevance on this machine.  
008f			  
008f 23			        INC     HL              ; step over the second character of 'at'/'tab'.  
0090			  
0090			;; SKIPS  
0090 37			L0090:  SCF                     ; set the carry flag  
0091 22 5d 5c		        LD      ($5C5D),HL      ; update the CH_ADD system variable.  
0094 c9			        RET                     ; return with carry set.  
0095			  
0095			  
0095			; ------------------  
0095			; THE 'TOKEN TABLES'  
0095			; ------------------  
0095			; The tokenized characters 134d (RND) to 255d (COPY) are expanded using  
0095			; this table. The last byte of a token is inverted to denote the end of  
0095			; the word. The first is an inverted step-over byte.  
0095			  
0095			;; TKN-TABLE  
0095 bf			L0095:  DEFB    $80+'?'  
0096 ..			        DEFM    "RN"  
0098 c4			        DEFB    $80+'D'  
0099 ..			        DEFM    "INKEY"  
009e a4			        DEFB    $80+'$'  
009f .. c9		        DEFB    'P',$80+'I'  
00a1 .. ce		        DEFB    'F',$80+'N'  
00a3 ..			        DEFM    "POIN"  
00a7 d4			        DEFB    $80+'T'  
00a8 ..			        DEFM    "SCREEN"  
00ae a4			        DEFB    $80+'$'  
00af ..			        DEFM    "ATT"  
00b2 d2			        DEFB    $80+'R'  
00b3 .. d4		        DEFB    'A',$80+'T'  
00b5 ..			        DEFM    "TA"  
00b7 c2			        DEFB    $80+'B'  
00b8 ..			        DEFM    "VAL"  
00bb a4			        DEFB    $80+'$'  
00bc ..			        DEFM    "COD"  
00bf c5			        DEFB    $80+'E'  
00c0 ..			        DEFM    "VA"  
00c2 cc			        DEFB    $80+'L'  
00c3 ..			        DEFM    "LE"  
00c5 ce			        DEFB    $80+'N'  
00c6 ..			        DEFM    "SI"  
00c8 ce			        DEFB    $80+'N'  
00c9 ..			        DEFM    "CO"  
00cb d3			        DEFB    $80+'S'  
00cc ..			        DEFM    "TA"  
00ce ce			        DEFB    $80+'N'  
00cf ..			        DEFM    "AS"  
00d1 ce			        DEFB    $80+'N'  
00d2 ..			        DEFM    "AC"  
00d4 d3			        DEFB    $80+'S'  
00d5 ..			        DEFM    "AT"  
00d7 ce			        DEFB    $80+'N'  
00d8 .. ce		        DEFB    'L',$80+'N'  
00da ..			        DEFM    "EX"  
00dc d0			        DEFB    $80+'P'  
00dd ..			        DEFM    "IN"  
00df d4			        DEFB    $80+'T'  
00e0 ..			        DEFM    "SQ"  
00e2 d2			        DEFB    $80+'R'  
00e3 ..			        DEFM    "SG"  
00e5 ce			        DEFB    $80+'N'  
00e6 ..			        DEFM    "AB"  
00e8 d3			        DEFB    $80+'S'  
00e9 ..			        DEFM    "PEE"  
00ec cb			        DEFB    $80+'K'  
00ed .. ce		        DEFB    'I',$80+'N'  
00ef ..			        DEFM    "US"  
00f1 d2			        DEFB    $80+'R'  
00f2 ..			        DEFM    "STR"  
00f5 a4			        DEFB    $80+'$'  
00f6 ..			        DEFM    "CHR"  
00f9 a4			        DEFB    $80+'$'  
00fa ..			        DEFM    "NO"  
00fc d4			        DEFB    $80+'T'  
00fd ..			        DEFM    "BI"  
00ff ce			        DEFB    $80+'N'  
0100			  
0100			; The previous 32 function-type words are printed without a leading space  
0100			; The following have a leading space if they begin with a letter  
0100			  
0100 .. d2		        DEFB    'O',$80+'R'  
0102 ..			        DEFM    "AN"  
0104 c4			        DEFB    $80+'D'  
0105 3c bd		        DEFB    $3C,$80+'='             ; <=  
0107 3e bd		        DEFB    $3E,$80+'='             ; >=  
0109 3c be		        DEFB    $3C,$3E+$80             ; <>  
010b ..			        DEFM    "LIN"  
010e c5			        DEFB    $80+'E'  
010f ..			        DEFM    "THE"  
0112 ce			        DEFB    $80+'N'  
0113 .. cf		        DEFB    'T',$80+'O'  
0115 ..			        DEFM    "STE"  
0118 d0			        DEFB    $80+'P'  
0119 ..			        DEFM    "DEF F"  
011e ce			        DEFB    $80+'N'  
011f ..			        DEFM    "CA"  
0121 d4			        DEFB    $80+'T'  
0122 ..			        DEFM    "FORMA"  
0127 d4			        DEFB    $80+'T'  
0128 ..			        DEFM    "MOV"  
012b c5			        DEFB    $80+'E'  
012c ..			        DEFM    "ERAS"  
0130 c5			        DEFB    $80+'E'  
0131 ..			        DEFM    "OPEN "  
0136 a3			        DEFB    $80+'#'  
0137 ..			        DEFM    "CLOSE "  
013d a3			        DEFB    $80+'#'  
013e ..			        DEFM    "MERG"  
0142 c5			        DEFB    $80+'E'  
0143 ..			        DEFM    "VERIF"  
0148 d9			        DEFB    $80+'Y'  
0149 ..			        DEFM    "BEE"  
014c d0			        DEFB    $80+'P'  
014d ..			        DEFM    "CIRCL"  
0152 c5			        DEFB    $80+'E'  
0153 ..			        DEFM    "IN"  
0155 cb			        DEFB    $80+'K'  
0156 ..			        DEFM    "PAPE"  
015a d2			        DEFB    $80+'R'  
015b ..			        DEFM    "FLAS"  
015f c8			        DEFB    $80+'H'  
0160 ..			        DEFM    "BRIGH"  
0165 d4			        DEFB    $80+'T'  
0166 ..			        DEFM    "INVERS"  
016c c5			        DEFB    $80+'E'  
016d ..			        DEFM    "OVE"  
0170 d2			        DEFB    $80+'R'  
0171 ..			        DEFM    "OU"  
0173 d4			        DEFB    $80+'T'  
0174 ..			        DEFM    "LPRIN"  
0179 d4			        DEFB    $80+'T'  
017a ..			        DEFM    "LLIS"  
017e d4			        DEFB    $80+'T'  
017f ..			        DEFM    "STO"  
0182 d0			        DEFB    $80+'P'  
0183 ..			        DEFM    "REA"  
0186 c4			        DEFB    $80+'D'  
0187 ..			        DEFM    "DAT"  
018a c1			        DEFB    $80+'A'  
018b ..			        DEFM    "RESTOR"  
0191 c5			        DEFB    $80+'E'  
0192 ..			        DEFM    "NE"  
0194 d7			        DEFB    $80+'W'  
0195 ..			        DEFM    "BORDE"  
019a d2			        DEFB    $80+'R'  
019b ..			        DEFM    "CONTINU"  
01a2 c5			        DEFB    $80+'E'  
01a3 ..			        DEFM    "DI"  
01a5 cd			        DEFB    $80+'M'  
01a6 ..			        DEFM    "RE"  
01a8 cd			        DEFB    $80+'M'  
01a9 ..			        DEFM    "FO"  
01ab d2			        DEFB    $80+'R'  
01ac ..			        DEFM    "GO T"  
01b0 cf			        DEFB    $80+'O'  
01b1 ..			        DEFM    "GO SU"  
01b6 c2			        DEFB    $80+'B'  
01b7 ..			        DEFM    "INPU"  
01bb d4			        DEFB    $80+'T'  
01bc ..			        DEFM    "LOA"  
01bf c4			        DEFB    $80+'D'  
01c0 ..			        DEFM    "LIS"  
01c3 d4			        DEFB    $80+'T'  
01c4 ..			        DEFM    "LE"  
01c6 d4			        DEFB    $80+'T'  
01c7 ..			        DEFM    "PAUS"  
01cb c5			        DEFB    $80+'E'  
01cc ..			        DEFM    "NEX"  
01cf d4			        DEFB    $80+'T'  
01d0 ..			        DEFM    "POK"  
01d3 c5			        DEFB    $80+'E'  
01d4 ..			        DEFM    "PRIN"  
01d8 d4			        DEFB    $80+'T'  
01d9 ..			        DEFM    "PLO"  
01dc d4			        DEFB    $80+'T'  
01dd ..			        DEFM    "RU"  
01df ce			        DEFB    $80+'N'  
01e0 ..			        DEFM    "SAV"  
01e3 c5			        DEFB    $80+'E'  
01e4 ..			        DEFM    "RANDOMIZ"  
01ec c5			        DEFB    $80+'E'  
01ed .. c6		        DEFB    'I',$80+'F'  
01ef ..			        DEFM    "CL"  
01f1 d3			        DEFB    $80+'S'  
01f2 ..			        DEFM    "DRA"  
01f5 d7			        DEFB    $80+'W'  
01f6 ..			        DEFM    "CLEA"  
01fa d2			        DEFB    $80+'R'  
01fb ..			        DEFM    "RETUR"  
0200 ce			        DEFB    $80+'N'  
0201 ..			        DEFM    "COP"  
0204 d9			        DEFB    $80+'Y'  
0205			  
0205			; ----------------  
0205			; THE 'KEY' TABLES  
0205			; ----------------  
0205			; These six look-up tables are used by the keyboard reading routine  
0205			; to decode the key values.  
0205			  
0205			; The first table contains the maps for the 39 keys of the standard  
0205			; 40-key Spectrum keyboard. The remaining key [SHIFT $27] is read directly.  
0205			; The keys consist of the 26 upper-case alphabetic characters, the 10 digit  
0205			; keys and the space, ENTER and symbol shift key.  
0205			; Unshifted alphabetic keys have $20 added to the value.  
0205			; The keywords for the main alphabetic keys are obtained by adding $A5 to  
0205			; the values obtained from this table.  
0205			  
0205			;; MAIN-KEYS  
0205 42			L0205:  DEFB    $42             ; B  
0206 48			        DEFB    $48             ; H  
0207 59			        DEFB    $59             ; Y  
0208 36			        DEFB    $36             ; 6  
0209 35			        DEFB    $35             ; 5  
020a 54			        DEFB    $54             ; T  
020b 47			        DEFB    $47             ; G  
020c 56			        DEFB    $56             ; V  
020d 4e			        DEFB    $4E             ; N  
020e 4a			        DEFB    $4A             ; J  
020f 55			        DEFB    $55             ; U  
0210 37			        DEFB    $37             ; 7  
0211 34			        DEFB    $34             ; 4  
0212 52			        DEFB    $52             ; R  
0213 46			        DEFB    $46             ; F  
0214 43			        DEFB    $43             ; C  
0215 4d			        DEFB    $4D             ; M  
0216 4b			        DEFB    $4B             ; K  
0217 49			        DEFB    $49             ; I  
0218 38			        DEFB    $38             ; 8  
0219 33			        DEFB    $33             ; 3  
021a 45			        DEFB    $45             ; E  
021b 44			        DEFB    $44             ; D  
021c 58			        DEFB    $58             ; X  
021d 0e			        DEFB    $0E             ; SYMBOL SHIFT  
021e 4c			        DEFB    $4C             ; L  
021f 4f			        DEFB    $4F             ; O  
0220 39			        DEFB    $39             ; 9  
0221 32			        DEFB    $32             ; 2  
0222 57			        DEFB    $57             ; W  
0223 53			        DEFB    $53             ; S  
0224 5a			        DEFB    $5A             ; Z  
0225 20			        DEFB    $20             ; SPACE  
0226 0d			        DEFB    $0D             ; ENTER  
0227 50			        DEFB    $50             ; P  
0228 30			        DEFB    $30             ; 0  
0229 31			        DEFB    $31             ; 1  
022a 51			        DEFB    $51             ; Q  
022b 41			        DEFB    $41             ; A  
022c			  
022c			  
022c			;; E-UNSHIFT  
022c			;  The 26 unshifted extended mode keys for the alphabetic characters.  
022c			;  The green keywords on the original keyboard.  
022c e3			L022C:  DEFB    $E3             ; READ  
022d c4			        DEFB    $C4             ; BIN  
022e e0			        DEFB    $E0             ; LPRINT  
022f e4			        DEFB    $E4             ; DATA  
0230 b4			        DEFB    $B4             ; TAN  
0231 bc			        DEFB    $BC             ; SGN  
0232 bd			        DEFB    $BD             ; ABS  
0233 bb			        DEFB    $BB             ; SQR  
0234 af			        DEFB    $AF             ; CODE  
0235 b0			        DEFB    $B0             ; VAL  
0236 b1			        DEFB    $B1             ; LEN  
0237 c0			        DEFB    $C0             ; USR  
0238 a7			        DEFB    $A7             ; PI  
0239 a6			        DEFB    $A6             ; INKEY$  
023a be			        DEFB    $BE             ; PEEK  
023b ad			        DEFB    $AD             ; TAB  
023c b2			        DEFB    $B2             ; SIN  
023d ba			        DEFB    $BA             ; INT  
023e e5			        DEFB    $E5             ; RESTORE  
023f a5			        DEFB    $A5             ; RND  
0240 c2			        DEFB    $C2             ; CHR$  
0241 e1			        DEFB    $E1             ; LLIST  
0242 b3			        DEFB    $B3             ; COS  
0243 b9			        DEFB    $B9             ; EXP  
0244 c1			        DEFB    $C1             ; STR$  
0245 b8			        DEFB    $B8             ; LN  
0246			  
0246			  
0246			;; EXT-SHIFT  
0246			;  The 26 shifted extended mode keys for the alphabetic characters.  
0246			;  The red keywords below keys on the original keyboard.  
0246 7e			L0246:  DEFB    $7E             ; ~  
0247 dc			        DEFB    $DC             ; BRIGHT  
0248 da			        DEFB    $DA             ; PAPER  
0249 5c			        DEFB    $5C             ; \  
024a b7			        DEFB    $B7             ; ATN  
024b 7b			        DEFB    $7B             ; {  
024c 7d			        DEFB    $7D             ; }  
024d d8			        DEFB    $D8             ; CIRCLE  
024e bf			        DEFB    $BF             ; IN  
024f ae			        DEFB    $AE             ; VAL$  
0250 aa			        DEFB    $AA             ; SCREEN$  
0251 ab			        DEFB    $AB             ; ATTR  
0252 dd			        DEFB    $DD             ; INVERSE  
0253 de			        DEFB    $DE             ; OVER  
0254 df			        DEFB    $DF             ; OUT  
0255 7f			        DEFB    $7F             ; (Copyright character)  
0256 b5			        DEFB    $B5             ; ASN  
0257 d6			        DEFB    $D6             ; VERIFY  
0258 7c			        DEFB    $7C             ; |  
0259 d5			        DEFB    $D5             ; MERGE  
025a 5d			        DEFB    $5D             ; ]  
025b db			        DEFB    $DB             ; FLASH  
025c b6			        DEFB    $B6             ; ACS  
025d d9			        DEFB    $D9             ; INK  
025e 5b			        DEFB    $5B             ; [  
025f d7			        DEFB    $D7             ; BEEP  
0260			  
0260			  
0260			;; CTL-CODES  
0260			;  The ten control codes assigned to the top line of digits when the shift   
0260			;  key is pressed.  
0260 0c			L0260:  DEFB    $0C             ; DELETE  
0261 07			        DEFB    $07             ; EDIT  
0262 06			        DEFB    $06             ; CAPS LOCK  
0263 04			        DEFB    $04             ; TRUE VIDEO  
0264 05			        DEFB    $05             ; INVERSE VIDEO  
0265 08			        DEFB    $08             ; CURSOR LEFT  
0266 0a			        DEFB    $0A             ; CURSOR DOWN  
0267 0b			        DEFB    $0B             ; CURSOR UP  
0268 09			        DEFB    $09             ; CURSOR RIGHT  
0269 0f			        DEFB    $0F             ; GRAPHICS  
026a			  
026a			  
026a			;; SYM-CODES  
026a			;  The 26 red symbols assigned to the alphabetic characters of the keyboard.  
026a			;  The ten single-character digit symbols are converted without the aid of  
026a			;  a table using subtraction and minor manipulation.   
026a e2			L026A:  DEFB    $E2             ; STOP  
026b 2a			        DEFB    $2A             ; *  
026c 3f			        DEFB    $3F             ; ?  
026d cd			        DEFB    $CD             ; STEP  
026e c8			        DEFB    $C8             ; >=  
026f cc			        DEFB    $CC             ; TO  
0270 cb			        DEFB    $CB             ; THEN  
0271 5e			        DEFB    $5E             ; ^  
0272 ac			        DEFB    $AC             ; AT  
0273 2d			        DEFB    $2D             ; -  
0274 2b			        DEFB    $2B             ; +  
0275 3d			        DEFB    $3D             ; =  
0276 2e			        DEFB    $2E             ; .  
0277 2c			        DEFB    $2C             ; ,  
0278 3b			        DEFB    $3B             ; ;  
0279 22			        DEFB    $22             ; "  
027a c7			        DEFB    $C7             ; <=  
027b 3c			        DEFB    $3C             ; <  
027c c3			        DEFB    $C3             ; NOT  
027d 3e			        DEFB    $3E             ; >  
027e c5			        DEFB    $C5             ; OR  
027f 2f			        DEFB    $2F             ; /  
0280 c9			        DEFB    $C9             ; <>  
0281 60			        DEFB    $60             ; pound  
0282 c6			        DEFB    $C6             ; AND  
0283 3a			        DEFB    $3A             ; :  
0284			  
0284			;; E-DIGITS  
0284			;  The ten keywords assigned to the digits in extended mode.  
0284			;  The remaining red keywords below the keys.  
0284 d0			L0284:  DEFB    $D0             ; FORMAT  
0285 ce			        DEFB    $CE             ; DEF FN  
0286 a8			        DEFB    $A8             ; FN  
0287 ca			        DEFB    $CA             ; LINE  
0288 d3			        DEFB    $D3             ; OPEN#  
0289 d4			        DEFB    $D4             ; CLOSE#  
028a d1			        DEFB    $D1             ; MOVE  
028b d2			        DEFB    $D2             ; ERASE  
028c a9			        DEFB    $A9             ; POINT  
028d cf			        DEFB    $CF             ; CAT  
028e			  
028e			  
028e			;*******************************  
028e			;** Part 2. KEYBOARD ROUTINES **  
028e			;*******************************  
028e			  
028e			; Using shift keys and a combination of modes the Spectrum 40-key keyboard  
028e			; can be mapped to 256 input characters  
028e			  
028e			; ---------------------------------------------------------------------------  
028e			;  
028e			;         0     1     2     3     4 -Bits-  4     3     2     1     0  
028e			; PORT                                                                    PORT  
028e			;  
028e			; F7FE  [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ]  |  [ 6 ] [ 7 ] [ 8 ] [ 9 ] [ 0 ]   EFFE  
028e			;  ^                                   |                                   v  
028e			; FBFE  [ Q ] [ W ] [ E ] [ R ] [ T ]  |  [ Y ] [ U ] [ I ] [ O ] [ P ]   DFFE  
028e			;  ^                                   |                                   v  
028e			; FDFE  [ A ] [ S ] [ D ] [ F ] [ G ]  |  [ H ] [ J ] [ K ] [ L ] [ ENT ] BFFE  
028e			;  ^                                   |                                   v  
028e			; FEFE  [SHI] [ Z ] [ X ] [ C ] [ V ]  |  [ B ] [ N ] [ M ] [sym] [ SPC ] 7FFE  
028e			;  ^     $27                                                 $18           v  
028e			; Start                                                                   End  
028e			;        00100111                                            00011000  
028e			;  
028e			; ---------------------------------------------------------------------------  
028e			; The above map may help in reading.  
028e			; The neat arrangement of ports means that the B register need only be  
028e			; rotated left to work up the left hand side and then down the right  
028e			; hand side of the keyboard. When the reset bit drops into the carry  
028e			; then all 8 half-rows have been read. Shift is the first key to be  
028e			; read. The lower six bits of the shifts are unambiguous.  
028e			  
028e			; -------------------------------  
028e			; THE 'KEYBOARD SCANNING' ROUTINE  
028e			; -------------------------------  
028e			; from keyboard and s-inkey$  
028e			; returns 1 or 2 keys in DE, most significant shift first if any  
028e			; key values 0-39 else 255  
028e			  
028e			;; KEY-SCAN  
028e 2e 2f		L028E:  LD      L,$2F           ; initial key value  
0290			                                ; valid values are obtained by subtracting  
0290			                                ; eight five times.  
0290 11 ff ff		        LD      DE,$FFFF        ; a buffer to receive 2 keys.  
0293			  
0293 01 fe fe		        LD      BC,$FEFE        ; the commencing port address  
0296			                                ; B holds 11111110 initially and is also  
0296			                                ; used to count the 8 half-rows  
0296			;; KEY-LINE  
0296 ed 78		L0296:  IN      A,(C)           ; read the port to A - bits will be reset  
0298			                                ; if a key is pressed else set.  
0298 2f			        CPL                     ; complement - pressed key-bits are now set  
0299 e6 1f		        AND     $1F             ; apply 00011111 mask to pick up the  
029b			                                ; relevant set bits.  
029b			  
029b 28 0e		        JR      Z,L02AB         ; forward to KEY-DONE if zero and therefore  
029d			                                ; no keys pressed in row at all.  
029d			  
029d 67			        LD      H,A             ; transfer row bits to H  
029e 7d			        LD      A,L             ; load the initial key value to A  
029f			  
029f			;; KEY-3KEYS  
029f 14			L029F:  INC     D               ; now test the key buffer  
02a0 c0			        RET     NZ              ; if we have collected 2 keys already  
02a1			                                ; then too many so quit.  
02a1			  
02a1			;; KEY-BITS  
02a1 d6 08		L02A1:  SUB     $08             ; subtract 8 from the key value  
02a3			                                ; cycling through key values (top = $27)  
02a3			                                ; e.g. 2F>   27>1F>17>0F>07  
02a3			                                ;      2E>   26>1E>16>0E>06  
02a3 cb 3c		        SRL     H               ; shift key bits right into carry.  
02a5 30 fa		        JR      NC,L02A1        ; back to KEY-BITS if not pressed  
02a7			                                ; but if pressed we have a value (0-39d)  
02a7			  
02a7 53			        LD      D,E             ; transfer a possible previous key to D  
02a8 5f			        LD      E,A             ; transfer the new key to E  
02a9 20 f4		        JR      NZ,L029F        ; back to KEY-3KEYS if there were more  
02ab			                                ; set bits - H was not yet zero.  
02ab			  
02ab			;; KEY-DONE  
02ab 2d			L02AB:  DEC     L               ; cycles 2F>2E>2D>2C>2B>2A>29>28 for  
02ac			                                ; each half-row.  
02ac cb 00		        RLC     B               ; form next port address e.g. FEFE > FDFE  
02ae 38 e6		        JR      C,L0296         ; back to KEY-LINE if still more rows to do.  
02b0			  
02b0 7a			        LD      A,D             ; now test if D is still FF ?  
02b1 3c			        INC     A               ; if it is zero we have at most 1 key  
02b2			                                ; range now $01-$28  (1-40d)  
02b2 c8			        RET     Z               ; return if one key or no key.  
02b3			  
02b3 fe 28		        CP      $28             ; is it capsshift (was $27) ?  
02b5 c8			        RET     Z               ; return if so.  
02b6			  
02b6 fe 19		        CP      $19             ; is it symbol shift (was $18) ?  
02b8 c8			        RET     Z               ; return also  
02b9			  
02b9 7b			        LD      A,E             ; now test E  
02ba 5a			        LD      E,D             ; but first switch  
02bb 57			        LD      D,A             ; the two keys.  
02bc fe 18		        CP      $18             ; is it symbol shift ?  
02be c9			        RET                     ; return (with zero set if it was).  
02bf			                                ; but with symbol shift now in D  
02bf			  
02bf			; ------------------------------  
02bf			; Scan keyboard and decode value  
02bf			; ------------------------------  
02bf			; from interrupt 50 times a second  
02bf			;  
02bf			  
02bf			;; KEYBOARD  
02bf cd 8e 02		L02BF:  CALL    L028E           ; routine KEY-SCAN  
02c2 c0			        RET     NZ              ; return if invalid combinations  
02c3			  
02c3			; then decrease the counters within the two key-state maps  
02c3			; as this could cause one to become free.  
02c3			; if the keyboard has not been pressed during the last five interrupts  
02c3			; then both sets will be free.  
02c3			  
02c3			  
02c3 21 00 5c		        LD      HL,$5C00        ; point to KSTATE-0  
02c6			  
02c6			;; K-ST-LOOP  
02c6 cb 7e		L02C6:  BIT     7,(HL)          ; is it free ?  ($FF)  
02c8 20 07		        JR      NZ,L02D1        ; forward to K-CH-SET if so  
02ca			  
02ca 23			        INC     HL              ; address 5-counter  
02cb 35			        DEC     (HL)            ; decrease counter  
02cc 2b			        DEC     HL              ; step back  
02cd 20 02		        JR      NZ,L02D1        ; forward to K-CH-SET if not at end of count  
02cf			  
02cf 36 ff		        LD      (HL),$FF        ; else mark it free.  
02d1			  
02d1			;; K-CH-SET  
02d1 7d			L02D1:  LD      A,L             ; store low address byte.  
02d2 21 04 5c		        LD      HL,$5C04        ; point to KSTATE-4  
02d5			                                ; (ld l, $04)  
02d5 bd			        CP      L               ; have 2 been done ?  
02d6 20 ee		        JR      NZ,L02C6        ; back to K-ST-LOOP to consider this 2nd set  
02d8			  
02d8			; now the raw key (0-38) is converted to a main key (uppercase).  
02d8			  
02d8 cd 1e 03		        CALL    L031E           ; routine K-TEST to get main key in A  
02db d0			        RET     NC              ; return if single shift  
02dc			  
02dc 21 00 5c		        LD      HL,$5C00        ; point to KSTATE-0  
02df be			        CP      (HL)            ; does it match ?  
02e0 28 2e		        JR      Z,L0310         ; forward to K-REPEAT if so  
02e2			  
02e2			; if not consider the second key map.  
02e2			  
02e2 eb			        EX      DE,HL           ; save kstate-0 in de  
02e3 21 04 5c		        LD      HL,$5C04        ; point to KSTATE-4  
02e6 be			        CP      (HL)            ; does it match ?  
02e7 28 27		        JR      Z,L0310         ; forward to K-REPEAT if so  
02e9			  
02e9			; having excluded a repeating key we can now consider a new key.  
02e9			; the second set is always examined before the first.  
02e9			  
02e9 cb 7e		        BIT     7,(HL)          ; is it free ?  
02eb 20 04		        JR      NZ,L02F1        ; forward to K-NEW if so.  
02ed			  
02ed eb			        EX      DE,HL           ; bring back kstate-0  
02ee cb 7e		        BIT     7,(HL)          ; is it free ?  
02f0 c8			        RET     Z               ; return if not.  
02f1			                                ; as we have a key but nowhere to put it yet.  
02f1			  
02f1			; continue or jump to here if one of the buffers was free.  
02f1			  
02f1			;; K-NEW  
02f1 5f			L02F1:  LD      E,A             ; store key in E  
02f2 77			        LD      (HL),A          ; place in free location  
02f3 23			        INC     HL              ; advance to interrupt counter  
02f4 36 05		        LD      (HL),$05        ; and initialize to 5  
02f6 23			        INC     HL              ; advance to delay  
02f7 3a 09 5c		        LD      A,($5C09)       ; pick up system variable REPDEL  
02fa 77			        LD      (HL),A          ; and insert that for first repeat delay.  
02fb 23			        INC     HL              ; advance to last location of state map.  
02fc			  
02fc fd 4e 07		        LD      C,(IY+$07)      ; pick up MODE  (3 bytes)  
02ff fd 56 01		        LD      D,(IY+$01)      ; pick up FLAGS (3 bytes)  
0302 e5			        PUSH    HL              ; save state map location  
0303			                                ; Note. could now have used.  
0303			                                ; ld l,$41; ld c,(hl); ld l,$3B; ld d,(hl).  
0303			                                ; six and two threes of course.  
0303 cd 33 03		        CALL    L0333           ; routine K-DECODE  
0306 e1			        POP     HL              ; restore map pointer  
0307 77			        LD      (HL),A          ; put decoded key in last location of map.  
0308			  
0308			;; K-END  
0308 32 08 5c		L0308:  LD      ($5C08),A       ; update LASTK system variable.  
030b fd cb 01 ee	        SET     5,(IY+$01)      ; update FLAGS  - signal new key.  
030f c9			        RET                     ; done  
0310			  
0310			; ---------------------------  
0310			; THE 'REPEAT KEY' SUBROUTINE  
0310			; ---------------------------  
0310			; A possible repeat has been identified. HL addresses the raw (main) key.  
0310			; The last location holds the decoded key (from the first context).  
0310			  
0310			;; K-REPEAT  
0310 23			L0310:  INC     HL              ; advance  
0311 36 05		        LD      (HL),$05        ; maintain interrupt counter at 5  
0313 23			        INC     HL              ; advance  
0314 35			        DEC     (HL)            ; decrease REPDEL value.  
0315 c0			        RET     NZ              ; return if not yet zero.  
0316			  
0316 3a 0a 5c		        LD      A,($5C0A)       ; REPPER  
0319 77			        LD      (HL),A          ; but for subsequent repeats REPPER will be used.  
031a 23			        INC     HL              ; advance  
031b			                                ;  
031b 7e			        LD      A,(HL)          ; pick up the key decoded possibly in another  
031c			                                ; context.  
031c 18 ea		        JR      L0308           ; back to K-END  
031e			  
031e			; --------------  
031e			; Test key value  
031e			; --------------  
031e			; also called from s-inkey$  
031e			; begin by testing for a shift with no other.  
031e			  
031e			;; K-TEST  
031e 42			L031E:  LD      B,D             ; load most significant key to B  
031f			                                ; will be $FF if not shift.  
031f 16 00		        LD      D,$00           ; and reset D to index into main table  
0321 7b			        LD      A,E             ; load least significant key from E  
0322 fe 27		        CP      $27             ; is it higher than 39d   i.e. FF  
0324 d0			        RET     NC              ; return with just a shift (in B now)  
0325			  
0325 fe 18		        CP      $18             ; is it symbol shift ?  
0327 20 03		        JR      NZ,L032C        ; forward to K-MAIN if not  
0329			  
0329			; but we could have just symbol shift and no other  
0329			  
0329 cb 78		        BIT     7,B             ; is other key $FF (ie not shift)  
032b c0			        RET     NZ              ; return with solitary symbol shift  
032c			  
032c			  
032c			;; K-MAIN  
032c 21 05 02		L032C:  LD      HL,L0205        ; address: MAIN-KEYS  
032f 19			        ADD     HL,DE           ; add offset 0-38  
0330 7e			        LD      A,(HL)          ; pick up main key value  
0331 37			        SCF                     ; set carry flag  
0332 c9			        RET                     ; return    (B has other key still)  
0333			  
0333			; -----------------  
0333			; Keyboard decoding  
0333			; -----------------  
0333			; also called from s-inkey$  
0333			  
0333			;; K-DECODE  
0333 7b			L0333:  LD      A,E             ; pick up the stored main key  
0334 fe 3a		        CP      $3A             ; an arbitrary point between digits and letters  
0336 38 2f		        JR      C,L0367         ; forward to K-DIGIT with digits, space, enter.  
0338			  
0338 0d			        DEC     C               ; decrease MODE ( 0='KLC', 1='E', 2='G')  
0339			  
0339 fa 4f 03		        JP      M,L034F         ; to K-KLC-LET if was zero  
033c			  
033c 28 03		        JR      Z,L0341         ; to K-E-LET if was 1 for extended letters.  
033e			  
033e			; proceed with graphic codes.  
033e			; Note. should selectively drop return address if code > 'U' ($55).  
033e			; i.e. abort the KEYBOARD call.  
033e			; e.g. cp 'V'; jr c addit; pop af; ;;addit etc. (5 bytes of instruction).  
033e			; (s-inkey$ never gets into graphics mode.)  
033e			  
033e			;; addit  
033e c6 4f		        ADD     A,$4F           ; add offset to augment 'A' to graphics A say.  
0340 c9			        RET                     ; return.  
0341			                                ; Note. ( but [GRAPH] V gives RND, etc ).  
0341			  
0341			; ---  
0341			  
0341			; the jump was to here with extended mode with uppercase A-Z.  
0341			  
0341			;; K-E-LET  
0341 21 eb 01		L0341:  LD      HL,L022C-$41    ; base address of E-UNSHIFT L022c  
0344			                                ; ( $01EB in standard ROM )   
0344 04			        INC     B               ; test B is it empty i.e. not a shift  
0345 28 03		        JR      Z,L034A         ; forward to K-LOOK-UP if neither shift  
0347			  
0347 21 05 02		        LD      HL,L0246-$41    ; Address: $0205 L0246-$41 EXT-SHIFT base  
034a			  
034a			;; K-LOOK-UP  
034a 16 00		L034A:  LD      D,$00           ; prepare to index  
034c 19			        ADD     HL,DE           ; add the main key value  
034d 7e			        LD      A,(HL)          ; pick up other mode value  
034e c9			        RET                     ; return  
034f			  
034f			; ---  
034f			  
034f			; the jump was here with mode = 0  
034f			  
034f			;; K-KLC-LET  
034f 21 29 02		L034F:  LD      HL,L026A-$41    ; prepare base of sym-codes  
0352 cb 40		        BIT     0,B             ; shift=$27 sym-shift=$18  
0354 28 f4		        JR      Z,L034A         ; back to K-LOOK-UP with symbol-shift  
0356			  
0356 cb 5a		        BIT     3,D             ; test FLAGS is it 'K' mode (from OUT-CURS)  
0358 28 0a		        JR      Z,L0364         ; skip to K-TOKENS if so  
035a			  
035a fd cb 30 5e	        BIT     3,(IY+$30)      ; test FLAGS2 - consider CAPS LOCK ?  
035e c0			        RET     NZ              ; return if so with main code.  
035f			  
035f 04			        INC     B               ; is shift being pressed ?  
0360			                                ; result zero if not  
0360 c0			        RET     NZ              ; return if shift pressed.  
0361			  
0361 c6 20		        ADD     A,$20           ; else convert the code to lower case.  
0363 c9			        RET                     ; return.  
0364			  
0364			; ---  
0364			  
0364			; the jump was here for tokens  
0364			  
0364			;; K-TOKENS  
0364 c6 a5		L0364:  ADD     A,$A5           ; add offset to main code so that 'A'  
0366			                                ; becomes 'NEW' etc.  
0366 c9			        RET                     ; return  
0367			  
0367			; ---  
0367			  
0367			; the jump was here with digits, space, enter and symbol shift (< $xx)  
0367			  
0367			;; K-DIGIT  
0367 fe 30		L0367:  CP      $30             ; is it '0' or higher ?  
0369 d8			        RET     C               ; return with space, enter and symbol-shift  
036a			  
036a 0d			        DEC     C               ; test MODE (was 0='KLC', 1='E', 2='G')  
036b fa 9d 03		        JP      M,L039D         ; jump to K-KLC-DGT if was 0.  
036e			  
036e 20 19		        JR      NZ,L0389        ; forward to K-GRA-DGT if mode was 2.  
0370			  
0370			; continue with extended digits 0-9.  
0370			  
0370 21 54 02		        LD      HL,L0284-$30    ; $0254 - base of E-DIGITS  
0373 cb 68		        BIT     5,B             ; test - shift=$27 sym-shift=$18  
0375 28 d3		        JR      Z,L034A         ; to K-LOOK-UP if sym-shift  
0377			  
0377 fe 38		        CP      $38             ; is character '8' ?  
0379 30 07		        JR      NC,L0382        ; to K-8-&-9 if greater than '7'  
037b			  
037b d6 20		        SUB     $20             ; reduce to ink range $10-$17  
037d 04			        INC     B               ; shift ?  
037e c8			        RET     Z               ; return if not.  
037f			  
037f c6 08		        ADD     A,$08           ; add 8 to give paper range $18 - $1F  
0381 c9			        RET                     ; return  
0382			  
0382			; ---  
0382			  
0382			; 89  
0382			  
0382			;; K-8-&-9  
0382 d6 36		L0382:  SUB     $36             ; reduce to 02 and 03  bright codes  
0384 04			        INC     B               ; test if shift pressed.  
0385 c8			        RET     Z               ; return if not.  
0386			  
0386 c6 fe		        ADD     A,$FE           ; subtract 2 setting carry  
0388 c9			        RET                     ; to give 0 and 1    flash codes.  
0389			  
0389			; ---  
0389			  
0389			;  graphics mode with digits  
0389			  
0389			;; K-GRA-DGT  
0389 21 30 02		L0389:  LD      HL,L0260-$30    ; $0230 base address of CTL-CODES  
038c			  
038c fe 39		        CP      $39             ; is key '9' ?  
038e 28 ba		        JR      Z,L034A         ; back to K-LOOK-UP - changed to $0F, GRAPHICS.  
0390			  
0390 fe 30		        CP      $30             ; is key '0' ?  
0392 28 b6		        JR      Z,L034A         ; back to K-LOOK-UP - changed to $0C, delete.  
0394			  
0394			; for keys '0' - '7' we assign a mosaic character depending on shift.  
0394			  
0394 e6 07		        AND     $07             ; convert character to number. 0 - 7.  
0396 c6 80		        ADD     A,$80           ; add offset - they start at $80  
0398			  
0398 04			        INC     B               ; destructively test for shift  
0399 c8			        RET     Z               ; and return if not pressed.  
039a			  
039a ee 0f		        XOR     $0F             ; toggle bits becomes range $88-$8F  
039c c9			        RET                     ; return.  
039d			  
039d			; ---  
039d			  
039d			; now digits in 'KLC' mode  
039d			  
039d			;; K-KLC-DGT  
039d 04			L039D:  INC     B               ; return with digit codes if neither  
039e c8			        RET     Z               ; shift key pressed.  
039f			  
039f cb 68		        BIT     5,B             ; test for caps shift.  
03a1			  
03a1 21 30 02		        LD      HL,L0260-$30    ; prepare base of table CTL-CODES.  
03a4 20 a4		        JR      NZ,L034A        ; back to K-LOOK-UP if shift pressed.  
03a6			  
03a6			; must have been symbol shift  
03a6			  
03a6 d6 10		        SUB     $10             ; for ASCII most will now be correct  
03a8			                                ; on a standard typewriter.  
03a8 fe 22		        CP      $22             ; but '@' is not - see below.  
03aa 28 06		        JR      Z,L03B2         ; forward to to K-@-CHAR if so  
03ac			  
03ac fe 20		        CP      $20             ; '_' is the other one that fails  
03ae c0			        RET     NZ              ; return if not.  
03af			  
03af 3e 5f		        LD      A,$5F           ; substitute ASCII '_'  
03b1 c9			        RET                     ; return.  
03b2			  
03b2			; ---  
03b2			  
03b2			;; K-@-CHAR  
03b2 3e 40		L03B2:  LD      A,$40           ; substitute ASCII '@'  
03b4 c9			        RET                     ; return.  
03b5			  
03b5			  
03b5			; ------------------------------------------------------------------------  
03b5			; The Spectrum Input character keys. One or two are abbreviated.  
03b5			; From $00 Flash 0 to $FF COPY. The routine above has decoded all these.  
03b5			  
03b5			;  | 00 Fl0| 01 Fl1| 02 Br0| 03 Br1| 04 In0| 05 In1| 06 CAP| 07 EDT|  
03b5			;  | 08 LFT| 09 RIG| 0A DWN| 0B UP | 0C DEL| 0D ENT| 0E SYM| 0F GRA|  
03b5			;  | 10 Ik0| 11 Ik1| 12 Ik2| 13 Ik3| 14 Ik4| 15 Ik5| 16 Ik6| 17 Ik7|  
03b5			;  | 18 Pa0| 19 Pa1| 1A Pa2| 1B Pa3| 1C Pa4| 1D Pa5| 1E Pa6| 1F Pa7|  
03b5			;  | 20 SP | 21  ! | 22  " | 23  # | 24  $ | 25  % | 26  & | 27  ' |  
03b5			;  | 28  ( | 29  ) | 2A  * | 2B  + | 2C  , | 2D  - | 2E  . | 2F  / |  
03b5			;  | 30  0 | 31  1 | 32  2 | 33  3 | 34  4 | 35  5 | 36  6 | 37  7 |  
03b5			;  | 38  8 | 39  9 | 3A  : | 3B  ; | 3C  < | 3D  = | 3E  > | 3F  ? |  
03b5			;  | 40  @ | 41  A | 42  B | 43  C | 44  D | 45  E | 46  F | 47  G |  
03b5			;  | 48  H | 49  I | 4A  J | 4B  K | 4C  L | 4D  M | 4E  N | 4F  O |  
03b5			;  | 50  P | 51  Q | 52  R | 53  S | 54  T | 55  U | 56  V | 57  W |  
03b5			;  | 58  X | 59  Y | 5A  Z | 5B  [ | 5C  \ | 5D  ] | 5E  ^ | 5F  _ |  
03b5			;  | 60 ukp| 61  a | 62  b | 63  c | 64  d | 65  e | 66  f | 67  g |  
03b5			;  | 68  h | 69  i | 6A  j | 6B  k | 6C  l | 6D  m | 6E  n | 6F  o |  
03b5			;  | 70  p | 71  q | 72  r | 73  s | 74  t | 75  u | 76  v | 77  w |  
03b5			;  | 78  x | 79  y | 7A  z | 7B  { | 7C  | | 7D  } | 7E  ~ | 7F (c)|  
03b5			;  | 80 128| 81 129| 82 130| 83 131| 84 132| 85 133| 86 134| 87 135|  
03b5			;  | 88 136| 89 137| 8A 138| 8B 139| 8C 140| 8D 141| 8E 142| 8F 143|  
03b5			;  | 90 [A]| 91 [B]| 92 [C]| 93 [D]| 94 [E]| 95 [F]| 96 [G]| 97 [H]|  
03b5			;  | 98 [I]| 99 [J]| 9A [K]| 9B [L]| 9C [M]| 9D [N]| 9E [O]| 9F [P]|  
03b5			;  | A0 [Q]| A1 [R]| A2 [S]| A3 [T]| A4 [U]| A5 RND| A6 IK$| A7 PI |  
03b5			;  | A8 FN | A9 PNT| AA SC$| AB ATT| AC AT | AD TAB| AE VL$| AF COD|  
03b5			;  | B0 VAL| B1 LEN| B2 SIN| B3 COS| B4 TAN| B5 ASN| B6 ACS| B7 ATN|  
03b5			;  | B8 LN | B9 EXP| BA INT| BB SQR| BC SGN| BD ABS| BE PEK| BF IN |  
03b5			;  | C0 USR| C1 ST$| C2 CH$| C3 NOT| C4 BIN| C5 OR | C6 AND| C7 <= |  
03b5			;  | C8 >= | C9 <> | CA LIN| CB THN| CC TO | CD STP| CE DEF| CF CAT|  
03b5			;  | D0 FMT| D1 MOV| D2 ERS| D3 OPN| D4 CLO| D5 MRG| D6 VFY| D7 BEP|  
03b5			;  | D8 CIR| D9 INK| DA PAP| DB FLA| DC BRI| DD INV| DE OVR| DF OUT|  
03b5			;  | E0 LPR| E1 LLI| E2 STP| E3 REA| E4 DAT| E5 RES| E6 NEW| E7 BDR|  
03b5			;  | E8 CON| E9 DIM| EA REM| EB FOR| EC GTO| ED GSB| EE INP| EF LOA|  
03b5			;  | F0 LIS| F1 LET| F2 PAU| F3 NXT| F4 POK| F5 PRI| F6 PLO| F7 RUN|  
03b5			;  | F8 SAV| F9 RAN| FA IF | FB CLS| FC DRW| FD CLR| FE RET| FF CPY|  
03b5			  
03b5			; Note that for simplicity, Sinclair have located all the control codes  
03b5			; below the space character.  
03b5			; ASCII DEL, $7F, has been made a copyright symbol.  
03b5			; Also $60, '`', not used in BASIC but used in other languages, has been  
03b5			; allocated the local currency symbol for the relevant country -  
03b5			; ukp in most Spectrums.  
03b5			  
03b5			; ------------------------------------------------------------------------  
03b5			  
03b5			;**********************************  
03b5			;** Part 3. LOUDSPEAKER ROUTINES **  
03b5			;**********************************  
03b5			  
03b5			  
03b5			; Documented by Alvin Albrecht.  
03b5			  
03b5			  
03b5			; ------------------------------  
03b5			; Routine to control loudspeaker  
03b5			; ------------------------------  
03b5			; Outputs a square wave of given duration and frequency  
03b5			; to the loudspeaker.  
03b5			;   Enter with: DE = #cycles - 1  
03b5			;               HL = tone period as described next  
03b5			;  
03b5			; The tone period is measured in T states and consists of  
03b5			; three parts: a coarse part (H register), a medium part  
03b5			; (bits 7..2 of L) and a fine part (bits 1..0 of L) which  
03b5			; contribute to the waveform timing as follows:  
03b5			;  
03b5			;                          coarse    medium       fine  
03b5			; duration of low  = 118 + 1024*H + 16*(L>>2) + 4*(L&0x3)  
03b5			; duration of hi   = 118 + 1024*H + 16*(L>>2) + 4*(L&0x3)  
03b5			; Tp = tone period = 236 + 2048*H + 32*(L>>2) + 8*(L&0x3)  
03b5			;                  = 236 + 2048*H + 8*L = 236 + 8*HL  
03b5			;  
03b5			; As an example, to output five seconds of middle C (261.624 Hz):  
03b5			;   (a) Tone period = 1/261.624 = 3.822ms  
03b5			;   (b) Tone period in T-States = 3.822ms*fCPU = 13378  
03b5			;         where fCPU = clock frequency of the CPU = 3.5 MHz  
03b5			;   (c) Find H and L for desired tone period:  
03b5			;         HL = (Tp - 236) / 8 = (13378 - 236) / 8 = 1643 = 0x066B  
03b5			;   (d) Tone duration in cycles = 5s/3.822ms = 1308 cycles  
03b5			;         DE = 1308 - 1 = 0x051B  
03b5			;  
03b5			; The resulting waveform has a duty ratio of exactly 50%.  
03b5			;  
03b5			;  
03b5			;; BEEPER  
03b5 f3			L03B5:  DI                      ; Disable Interrupts so they don't disturb timing  
03b6 7d			        LD      A,L             ;  
03b7 cb 3d		        SRL     L               ;  
03b9 cb 3d		        SRL     L               ; L = medium part of tone period  
03bb 2f			        CPL                     ;  
03bc e6 03		        AND     $03             ; A = 3 - fine part of tone period  
03be 4f			        LD      C,A             ;  
03bf 06 00		        LD      B,$00           ;  
03c1 dd 21 d1 03	        LD      IX,L03D1        ; Address: BE-IX+3  
03c5 dd 09		        ADD     IX,BC           ;   IX holds address of entry into the loop  
03c7			                                ;   the loop will contain 0-3 NOPs, implementing  
03c7			                                ;   the fine part of the tone period.  
03c7 3a 48 5c		        LD      A,($5C48)       ; BORDCR  
03ca e6 38		        AND     $38             ; bits 5..3 contain border colour  
03cc 0f			        RRCA                    ; border colour bits moved to 2..0  
03cd 0f			        RRCA                    ;   to match border bits on port #FE  
03ce 0f			        RRCA                    ;  
03cf f6 08		        OR       $08            ; bit 3 set (tape output bit on port #FE)  
03d1			                                ;   for loud sound output  
03d1			;; BE-IX+3  
03d1 00			L03D1:  NOP              ;(4)   ; optionally executed NOPs for small  
03d2			                                ;   adjustments to tone period  
03d2			;; BE-IX+2  
03d2 00			L03D2:  NOP              ;(4)   ;  
03d3			  
03d3			;; BE-IX+1  
03d3 00			L03D3:  NOP              ;(4)   ;  
03d4			  
03d4			;; BE-IX+0  
03d4 04			L03D4:  INC     B        ;(4)   ;  
03d5 0c			        INC     C        ;(4)   ;  
03d6			  
03d6			;; BE-H&L-LP  
03d6 0d			L03D6:  DEC     C        ;(4)   ; timing loop for duration of  
03d7 20 fd		        JR      NZ,L03D6 ;(12/7);   high or low pulse of waveform  
03d9			  
03d9 0e 3f		        LD      C,$3F    ;(7)   ;  
03db 05			        DEC     B        ;(4)   ;  
03dc c2 d6 03		        JP      NZ,L03D6 ;(10)  ; to BE-H&L-LP  
03df			  
03df ee 10		        XOR     $10      ;(7)   ; toggle output beep bit  
03e1 d3 fe		        OUT     ($FE),A  ;(11)  ; output pulse  
03e3 44			        LD      B,H      ;(4)   ; B = coarse part of tone period  
03e4 4f			        LD      C,A      ;(4)   ; save port #FE output byte  
03e5 cb 67		        BIT     4,A      ;(8)   ; if new output bit is high, go  
03e7 20 09		        JR      NZ,L03F2 ;(12/7);   to BE-AGAIN  
03e9			  
03e9 7a			        LD      A,D      ;(4)   ; one cycle of waveform has completed  
03ea b3			        OR      E        ;(4)   ;   (low->low). if cycle countdown = 0  
03eb 28 09		        JR      Z,L03F6  ;(12/7);   go to BE-END  
03ed			  
03ed 79			        LD      A,C      ;(4)   ; restore output byte for port #FE  
03ee 4d			        LD      C,L      ;(4)   ; C = medium part of tone period  
03ef 1b			        DEC     DE       ;(6)   ; decrement cycle count  
03f0 dd e9		        JP      (IX)     ;(8)   ; do another cycle  
03f2			  
03f2			;; BE-AGAIN                     ; halfway through cycle  
03f2 4d			L03F2:  LD      C,L      ;(4)   ; C = medium part of tone period  
03f3 0c			        INC     C        ;(4)   ; adds 16 cycles to make duration of high = duration of low  
03f4 dd e9		        JP      (IX)     ;(8)   ; do high pulse of tone  
03f6			  
03f6			;; BE-END  
03f6 fb			L03F6:  EI                      ; Enable Interrupts  
03f7 c9			        RET                     ;  
03f8			  
03f8			  
03f8			; -------------------  
03f8			; Handle BEEP command  
03f8			; -------------------  
03f8			; BASIC interface to BEEPER subroutine.  
03f8			; Invoked in BASIC with:  
03f8			;   BEEP dur, pitch  
03f8			;   where dur   = duration in seconds  
03f8			;         pitch = # of semitones above/below middle C  
03f8			;  
03f8			; Enter with: pitch on top of calculator stack  
03f8			;             duration next on calculator stack  
03f8			;  
03f8			;; beep  
03f8 ef			L03F8:  RST     28H             ;; FP-CALC  
03f9 31			        DEFB    $31             ;;duplicate                  ; duplicate pitch  
03fa 27			        DEFB    $27             ;;int                        ; convert to integer  
03fb c0			        DEFB    $C0             ;;st-mem-0                   ; store integer pitch to memory 0  
03fc 03			        DEFB    $03             ;;subtract                   ; calculate fractional part of pitch = fp_pitch - int_pitch  
03fd 34			        DEFB    $34             ;;stk-data                   ; push constant  
03fe ec			        DEFB    $EC             ;;Exponent: $7C, Bytes: 4    ; constant = 0.05762265  
03ff 6c 98 1f f5	        DEFB    $6C,$98,$1F,$F5 ;;($6C,$98,$1F,$F5)  
0403 04			        DEFB    $04             ;;multiply                   ; compute:  
0404 a1			        DEFB    $A1             ;;stk-one                    ; 1 + 0.05762265 * fraction_part(pitch)  
0405 0f			        DEFB    $0F             ;;addition  
0406 38			        DEFB    $38             ;;end-calc                   ; leave on calc stack  
0407			  
0407 21 92 5c		        LD      HL,$5C92        ; MEM-0: number stored here is in 16 bit integer format (pitch)  
040a			                                ;   0, 0/FF (pos/neg), LSB, MSB, 0  
040a			                                ;   LSB/MSB is stored in two's complement  
040a			                                ; In the following, the pitch is checked if it is in the range -128<=p<=127  
040a 7e			        LD      A,(HL)          ; First byte must be zero, otherwise  
040b a7			        AND     A               ;   error in integer conversion  
040c 20 5e		        JR      NZ,L046C        ; to REPORT-B  
040e			  
040e 23			        INC     HL              ;  
040f 4e			        LD      C,(HL)          ; C = pos/neg flag = 0/FF  
0410 23			        INC     HL              ;  
0411 46			        LD      B,(HL)          ; B = LSB, two's complement  
0412 78			        LD      A,B             ;  
0413 17			        RLA                     ;  
0414 9f			        SBC     A,A             ; A = 0/FF if B is pos/neg  
0415 b9			        CP      C               ; must be the same as C if the pitch is -128<=p<=127  
0416 20 54		        JR      NZ,L046C        ; if no, error REPORT-B  
0418			  
0418 23			        INC     HL              ; if -128<=p<=127, MSB will be 0/FF if B is pos/neg  
0419 be			        CP      (HL)            ; verify this  
041a 20 50		        JR      NZ,L046C        ; if no, error REPORT-B  
041c			                                ; now we know -128<=p<=127  
041c 78			        LD      A,B             ; A = pitch + 60  
041d c6 3c		        ADD     A,$3C           ; if -60<=pitch<=67,  
041f f2 25 04		        JP      P,L0425         ;   goto BE-i-OK  
0422			  
0422 e2 6c 04		        JP      PO,L046C        ; if pitch <= 67 goto REPORT-B  
0425			                                ;   lower bound of pitch set at -60  
0425			  
0425			;; BE-I-OK                      ; here, -60<=pitch<=127  
0425			                                ; and A=pitch+60 -> 0<=A<=187  
0425			  
0425 06 fa		L0425:  LD      B,$FA           ; 6 octaves below middle C  
0427			  
0427			;; BE-OCTAVE                    ; A=# semitones above 5 octaves below middle C  
0427 04			L0427:  INC     B               ; increment octave  
0428 d6 0c		        SUB     $0C             ; 12 semitones = one octave  
042a 30 fb		        JR      NC,L0427        ; to BE-OCTAVE  
042c			  
042c c6 0c		        ADD     A,$0C           ; A = # semitones above C (0-11)  
042e c5			        PUSH    BC              ; B = octave displacement from middle C, 2's complement: -5<=B<=10  
042f 21 6e 04		        LD      HL,L046E        ; Address: semi-tone  
0432 cd 06 34		        CALL    L3406           ; routine LOC-MEM  
0435			                                ;   HL = 5*A + $046E  
0435 cd b4 33		        CALL    L33B4           ; routine STACK-NUM  
0438			                                ;   read FP value (freq) from semitone table (HL) and push onto calc stack  
0438			  
0438 ef			        RST     28H             ;; FP-CALC  
0439 04			        DEFB    $04             ;;multiply   mult freq by 1 + 0.0576 * fraction_part(pitch) stacked earlier  
043a			                                ;;             thus taking into account fractional part of pitch.  
043a			                                ;;           the number 0.0576*frequency is the distance in Hz to the next  
043a			                                ;;             note (verify with the frequencies recorded in the semitone  
043a			                                ;;             table below) so that the fraction_part of the pitch does  
043a			                                ;;             indeed represent a fractional distance to the next note.  
043a 38			        DEFB    $38             ;;end-calc   HL points to first byte of fp num on stack = middle frequency to generate  
043b			  
043b f1			        POP     AF              ; A = octave displacement from middle C, 2's complement: -5<=A<=10  
043c 86			        ADD     A,(HL)          ; increase exponent by A (equivalent to multiplying by 2^A)  
043d 77			        LD      (HL),A          ;  
043e			  
043e ef			        RST     28H             ;; FP-CALC  
043f c0			        DEFB    $C0             ;;st-mem-0          ; store frequency in memory 0  
0440 02			        DEFB    $02             ;;delete            ; remove from calc stack  
0441 31			        DEFB    $31             ;;duplicate         ; duplicate duration (seconds)  
0442 38			        DEFB    $38             ;;end-calc  
0443			  
0443 cd 94 1e		        CALL    L1E94           ; routine FIND-INT1 ; FP duration to A  
0446 fe 0b		        CP      $0B             ; if dur > 10 seconds,  
0448 30 22		        JR      NC,L046C        ;   goto REPORT-B  
044a			  
044a			        ;;; The following calculation finds the tone period for HL and the cycle count  
044a			        ;;; for DE expected in the BEEPER subroutine.  From the example in the BEEPER comments,  
044a			        ;;;  
044a			        ;;; HL = ((fCPU / f) - 236) / 8 = fCPU/8/f - 236/8 = 437500/f -29.5  
044a			        ;;; DE = duration * frequency - 1  
044a			        ;;;  
044a			        ;;; Note the different constant (30.125) used in the calculation of HL  
044a			        ;;; below.  This is probably an error.  
044a			  
044a ef			        RST     28H             ;; FP-CALC  
044b e0			        DEFB    $E0             ;;get-mem-0                 ; push frequency  
044c 04			        DEFB    $04             ;;multiply                  ; result1: #cycles = duration * frequency  
044d e0			        DEFB    $E0             ;;get-mem-0                 ; push frequency  
044e 34			        DEFB    $34             ;;stk-data                  ; push constant  
044f 80			        DEFB    $80             ;;Exponent $93, Bytes: 3    ; constant = 437500  
0450 43 55 9f 80	        DEFB    $43,$55,$9F,$80 ;;($55,$9F,$80,$00)  
0454 01			        DEFB    $01             ;;exchange                  ; frequency on top  
0455 05			        DEFB    $05             ;;division                  ; 437500 / frequency  
0456 34			        DEFB    $34             ;;stk-data                  ; push constant  
0457 35			        DEFB    $35             ;;Exponent: $85, Bytes: 1   ; constant = 30.125  
0458 71			        DEFB    $71             ;;($71,$00,$00,$00)  
0459 03			        DEFB    $03             ;;subtract                  ; result2: tone_period(HL) = 437500 / freq - 30.125  
045a 38			        DEFB    $38             ;;end-calc  
045b			  
045b cd 99 1e		        CALL    L1E99           ; routine FIND-INT2  
045e c5			        PUSH    BC              ;   BC = tone_period(HL)  
045f cd 99 1e		        CALL    L1E99           ; routine FIND-INT2, BC = #cycles to generate  
0462 e1			        POP     HL              ; HL = tone period  
0463 50			        LD      D,B             ;  
0464 59			        LD      E,C             ; DE = #cycles  
0465 7a			        LD      A,D             ;  
0466 b3			        OR      E               ;  
0467 c8			        RET     Z               ; if duration = 0, skip BEEP and avoid 65536 cycle  
0468			                                ;   boondoggle that would occur next  
0468 1b			        DEC     DE              ; DE = #cycles - 1  
0469 c3 b5 03		        JP      L03B5           ; to BEEPER  
046c			  
046c			; ---  
046c			  
046c			  
046c			;; REPORT-B  
046c cf			L046C:  RST     08H             ; ERROR-1  
046d 0a			        DEFB    $0A             ; Error Report: Integer out of range  
046e			  
046e			  
046e			  
046e			; ---------------  
046e			; Semi-tone table  
046e			; ---------------  
046e			;  
046e			; Holds frequencies corresponding to semitones in middle octave.  
046e			; To move n octaves higher or lower, frequencies are multiplied by 2^n.  
046e			  
046e			;; semi-tone         five byte fp         decimal freq     note (middle)  
046e 89 02 d0 12 86	L046E:  DEFB    $89, $02, $D0, $12, $86;  261.625565290         C  
0473 89 0a 97 60 75	        DEFB    $89, $0A, $97, $60, $75;  277.182631135         C#  
0478 89 12 d5 17 1f	        DEFB    $89, $12, $D5, $17, $1F;  293.664768100         D  
047d 89 1b 90 41 02	        DEFB    $89, $1B, $90, $41, $02;  311.126983881         D#  
0482 89 24 d0 53 ca	        DEFB    $89, $24, $D0, $53, $CA;  329.627557039         E  
0487 89 2e 9d 36 b1	        DEFB    $89, $2E, $9D, $36, $B1;  349.228231549         F  
048c 89 38 ff 49 3e	        DEFB    $89, $38, $FF, $49, $3E;  369.994422674         F#  
0491 89 43 ff 6a 73	        DEFB    $89, $43, $FF, $6A, $73;  391.995436072         G  
0496 89 4f a7 00 54	        DEFB    $89, $4F, $A7, $00, $54;  415.304697513         G#  
049b 89 5c 00 00 00	        DEFB    $89, $5C, $00, $00, $00;  440.000000000         A  
04a0 89 69 14 f6 24	        DEFB    $89, $69, $14, $F6, $24;  466.163761616         A#  
04a5 89 76 f1 10 05	        DEFB    $89, $76, $F1, $10, $05;  493.883301378         B  
04aa			  
04aa			  
04aa			;****************************************  
04aa			;** Part 4. CASSETTE HANDLING ROUTINES **  
04aa			;****************************************  
04aa			  
04aa			; These routines begin with the service routines followed by a single  
04aa			; command entry point.  
04aa			; The first of these service routines is a curiosity.  
04aa			  
04aa			; -----------------------  
04aa			; THE 'ZX81 NAME' ROUTINE  
04aa			; -----------------------  
04aa			;   This routine fetches a filename in ZX81 format and is not used by the   
04aa			;   cassette handling routines in this ROM.  
04aa			  
04aa			;; zx81-name  
04aa cd fb 24		L04AA:  CALL    L24FB           ; routine SCANNING to evaluate expression.  
04ad 3a 3b 5c		        LD      A,($5C3B)       ; fetch system variable FLAGS.  
04b0 87			        ADD     A,A             ; test bit 7 - syntax, bit 6 - result type.  
04b1 fa 8a 1c		        JP      M,L1C8A         ; to REPORT-C if not string result  
04b4			                                ; 'Nonsense in BASIC'.  
04b4			  
04b4 e1			        POP     HL              ; drop return address.  
04b5 d0			        RET     NC              ; return early if checking syntax.  
04b6			  
04b6 e5			        PUSH    HL              ; re-save return address.  
04b7 cd f1 2b		        CALL    L2BF1           ; routine STK-FETCH fetches string parameters.  
04ba 62			        LD      H,D             ; transfer start of filename  
04bb 6b			        LD      L,E             ; to the HL register.  
04bc 0d			        DEC     C               ; adjust to point to last character and  
04bd f8			        RET     M               ; return if the null string.  
04be			                                ; or multiple of 256!  
04be			  
04be 09			        ADD     HL,BC           ; find last character of the filename.  
04bf			                                ; and also clear carry.  
04bf cb fe		        SET     7,(HL)          ; invert it.  
04c1 c9			        RET                     ; return.  
04c2			  
04c2			; =========================================  
04c2			;  
04c2			; PORT 254 ($FE)  
04c2			;  
04c2			;                      spk mic { border  }    
04c2			;          ___ ___ ___ ___ ___ ___ ___ ___   
04c2			; PORT    |   |   |   |   |   |   |   |   |  
04c2			; 254     |   |   |   |   |   |   |   |   |  
04c2			; $FE     |___|___|___|___|___|___|___|___|  
04c2			;           7   6   5   4   3   2   1   0  
04c2			;  
04c2			  
04c2			; ----------------------------------  
04c2			; Save header and program/data bytes  
04c2			; ----------------------------------  
04c2			; This routine saves a section of data. It is called from SA-CTRL to save the  
04c2			; seventeen bytes of header data. It is also the exit route from that routine  
04c2			; when it is set up to save the actual data.  
04c2			; On entry -  
04c2			; HL points to start of data.  
04c2			; IX points to descriptor.  
04c2			; The accumulator is set to  $00 for a header, $FF for data.  
04c2			  
04c2			;; SA-BYTES  
04c2 21 3f 05		L04C2:  LD      HL,L053F        ; address: SA/LD-RET  
04c5 e5			        PUSH    HL              ; is pushed as common exit route.  
04c6			                                ; however there is only one non-terminal exit   
04c6			                                ; point.  
04c6			  
04c6 21 80 1f		        LD      HL,$1F80        ; a timing constant H=$1F, L=$80  
04c9			                                ; inner and outer loop counters  
04c9			                                ; a five second lead-in is used for a header.  
04c9			  
04c9 cb 7f		        BIT     7,A             ; test one bit of accumulator.  
04cb			                                ; (AND A ?)  
04cb 28 03		        JR      Z,L04D0         ; skip to SA-FLAG if a header is being saved.  
04cd			  
04cd			; else is data bytes and a shorter lead-in is used.  
04cd			  
04cd 21 98 0c		        LD      HL,$0C98        ; another timing value H=$0C, L=$98.  
04d0			                                ; a two second lead-in is used for the data.  
04d0			  
04d0			  
04d0			;; SA-FLAG  
04d0 08			L04D0:  EX      AF,AF'          ; save flag  
04d1 13			        INC     DE              ; increase length by one.  
04d2 dd 2b		        DEC     IX              ; decrease start.  
04d4			  
04d4 f3			        DI                      ; disable interrupts  
04d5			  
04d5 3e 02		        LD      A,$02           ; select red for border, microphone bit on.  
04d7 47			        LD      B,A             ; also does as an initial slight counter value.  
04d8			  
04d8			;; SA-LEADER  
04d8 10 fe		L04D8:  DJNZ    L04D8           ; self loop to SA-LEADER for delay.  
04da			                                ; after initial loop, count is $A4 (or $A3)  
04da			  
04da d3 fe		        OUT     ($FE),A         ; output byte $02/$0D to tape port.  
04dc			  
04dc ee 0f		        XOR     $0F             ; switch from RED (mic on) to CYAN (mic off).  
04de			  
04de 06 a4		        LD      B,$A4           ; hold count. also timed instruction.  
04e0			  
04e0 2d			        DEC     L               ; originally $80 or $98.  
04e1			                                ; but subsequently cycles 256 times.  
04e1 20 f5		        JR      NZ,L04D8        ; back to SA-LEADER until L is zero.  
04e3			  
04e3			; the outer loop is counted by H  
04e3			  
04e3 05			        DEC     B               ; decrement count  
04e4 25			        DEC     H               ; originally  twelve or thirty-one.  
04e5 f2 d8 04		        JP      P,L04D8         ; back to SA-LEADER until H becomes $FF  
04e8			  
04e8			; now send a synch pulse. At this stage mic is off and A holds value  
04e8			; for mic on.  
04e8			; A synch pulse is much shorter than the steady pulses of the lead-in.  
04e8			  
04e8 06 2f		        LD      B,$2F           ; another short timed delay.  
04ea			  
04ea			;; SA-SYNC-1  
04ea 10 fe		L04EA:  DJNZ    L04EA           ; self loop to SA-SYNC-1  
04ec			  
04ec d3 fe		        OUT     ($FE),A         ; switch to mic on and red.  
04ee 3e 0d		        LD      A,$0D           ; prepare mic off - cyan  
04f0 06 37		        LD      B,$37           ; another short timed delay.  
04f2			  
04f2			;; SA-SYNC-2  
04f2 10 fe		L04F2:  DJNZ    L04F2           ; self loop to SA-SYNC-2  
04f4			  
04f4 d3 fe		        OUT     ($FE),A         ; output mic off, cyan border.  
04f6 01 0e 3b		        LD      BC,$3B0E        ; B=$3B time(*), C=$0E, YELLOW, MIC OFF.  
04f9			  
04f9			;   
04f9			  
04f9 08			        EX      AF,AF'          ; restore saved flag  
04fa			                                ; which is 1st byte to be saved.  
04fa			  
04fa 6f			        LD      L,A             ; and transfer to L.  
04fb			                                ; the initial parity is A, $FF or $00.  
04fb c3 07 05		        JP      L0507           ; JUMP forward to SA-START     ->  
04fe			                                ; the mid entry point of loop.  
04fe			  
04fe			; -------------------------  
04fe			; During the save loop a parity byte is maintained in H.  
04fe			; the save loop begins by testing if reduced length is zero and if so  
04fe			; the final parity byte is saved reducing count to $FFFF.  
04fe			  
04fe			;; SA-LOOP  
04fe 7a			L04FE:  LD      A,D             ; fetch high byte  
04ff b3			        OR      E               ; test against low byte.  
0500 28 0c		        JR      Z,L050E         ; forward to SA-PARITY if zero.  
0502			  
0502 dd 6e 00		        LD      L,(IX+$00)      ; load currently addressed byte to L.  
0505			  
0505			;; SA-LOOP-P  
0505 7c			L0505:  LD      A,H             ; fetch parity byte.  
0506 ad			        XOR     L               ; exclusive or with new byte.  
0507			  
0507			; -> the mid entry point of loop.  
0507			  
0507			;; SA-START  
0507 67			L0507:  LD      H,A             ; put parity byte in H.  
0508 3e 01		        LD      A,$01           ; prepare blue, mic=on.  
050a 37			        SCF                     ; set carry flag ready to rotate in.  
050b c3 25 05		        JP      L0525           ; JUMP forward to SA-8-BITS            -8->  
050e			  
050e			; ---  
050e			  
050e			;; SA-PARITY  
050e 6c			L050E:  LD      L,H             ; transfer the running parity byte to L and  
050f 18 f4		        JR      L0505           ; back to SA-LOOP-P   
0511			                                ; to output that byte before quitting normally.  
0511			  
0511			; ---  
0511			  
0511			; entry point to save yellow part of bit.  
0511			; a bit consists of a period with mic on and blue border followed by   
0511			; a period of mic off with yellow border.   
0511			; Note. since the DJNZ instruction does not affect flags, the zero flag is used  
0511			; to indicate which of the two passes is in effect and the carry maintains the  
0511			; state of the bit to be saved.  
0511			  
0511			;; SA-BIT-2  
0511 79			L0511:  LD      A,C             ; fetch 'mic on and yellow' which is   
0512			                                ; held permanently in C.  
0512 cb 78		        BIT     7,B             ; set the zero flag. B holds $3E.  
0514			  
0514			; entry point to save 1 entire bit. For first bit B holds $3B(*).  
0514			; Carry is set if saved bit is 1. zero is reset NZ on entry.  
0514			  
0514			;; SA-BIT-1  
0514 10 fe		L0514:  DJNZ    L0514           ; self loop for delay to SA-BIT-1  
0516			  
0516 30 04		        JR      NC,L051C        ; forward to SA-OUT if bit is 0.  
0518			  
0518			; but if bit is 1 then the mic state is held for longer.  
0518			  
0518 06 42		        LD      B,$42           ; set timed delay. (66 decimal)  
051a			  
051a			;; SA-SET  
051a 10 fe		L051A:  DJNZ    L051A           ; self loop to SA-SET   
051c			                                ; (roughly an extra 66*13 clock cycles)  
051c			  
051c			;; SA-OUT  
051c d3 fe		L051C:  OUT     ($FE),A         ; blue and mic on OR  yellow and mic off.  
051e			  
051e 06 3e		        LD      B,$3E           ; set up delay  
0520 20 ef		        JR      NZ,L0511        ; back to SA-BIT-2 if zero reset NZ (first pass)  
0522			  
0522			; proceed when the blue and yellow bands have been output.  
0522			  
0522 05			        DEC     B               ; change value $3E to $3D.  
0523 af			        XOR     A               ; clear carry flag (ready to rotate in).  
0524 3c			        INC     A               ; reset zero flag ie. NZ.  
0525			  
0525			; -8->   
0525			  
0525			;; SA-8-BITS  
0525 cb 15		L0525:  RL      L               ; rotate left through carry  
0527			                                ; C<76543210<C    
0527 c2 14 05		        JP      NZ,L0514        ; JUMP back to SA-BIT-1   
052a			                                ; until all 8 bits done.  
052a			  
052a			; when the initial set carry is passed out again then a byte is complete.  
052a			  
052a 1b			        DEC     DE              ; decrease length  
052b dd 23		        INC     IX              ; increase byte pointer  
052d 06 31		        LD      B,$31           ; set up timing.  
052f			  
052f 3e 7f		        LD      A,$7F           ; test the space key and  
0531 db fe		        IN      A,($FE)         ; return to common exit (to restore border)  
0533 1f			        RRA                     ; if a space is pressed  
0534 d0			        RET     NC              ; return to SA/LD-RET.   - - >  
0535			  
0535			; now test if byte counter has reached $FFFF.  
0535			  
0535 7a			        LD      A,D             ; fetch high byte  
0536 3c			        INC     A               ; increment.  
0537 c2 fe 04		        JP      NZ,L04FE        ; JUMP to SA-LOOP if more bytes.  
053a			  
053a 06 3b		        LD      B,$3B           ; a final delay.   
053c			  
053c			;; SA-DELAY  
053c 10 fe		L053C:  DJNZ    L053C           ; self loop to SA-DELAY  
053e			  
053e c9			        RET                     ; return - - >  
053f			  
053f			; --------------------------------------------------  
053f			; Reset border and check BREAK key for LOAD and SAVE  
053f			; --------------------------------------------------  
053f			; the address of this routine is pushed on the stack prior to any load/save  
053f			; operation and it handles normal completion with the restoration of the  
053f			; border and also abnormal termination when the break key, or to be more  
053f			; precise the space key is pressed during a tape operation.  
053f			; - - >  
053f			  
053f			;; SA/LD-RET  
053f f5			L053F:  PUSH    AF              ; preserve accumulator throughout.  
0540 3a 48 5c		        LD      A,($5C48)       ; fetch border colour from BORDCR.  
0543 e6 38		        AND     $38             ; mask off paper bits.  
0545 0f			        RRCA                    ; rotate  
0546 0f			        RRCA                    ; to the  
0547 0f			        RRCA                    ; range 0-7.  
0548			  
0548 d3 fe		        OUT     ($FE),A         ; change the border colour.  
054a			  
054a 3e 7f		        LD      A,$7F           ; read from port address $7FFE the  
054c db fe		        IN      A,($FE)         ; row with the space key at outside.  
054e			   
054e 1f			        RRA                     ; test for space key pressed.  
054f fb			        EI                      ; enable interrupts  
0550 38 02		        JR      C,L0554         ; forward to SA/LD-END if not  
0552			  
0552			  
0552			;; REPORT-Da  
0552 cf			L0552:  RST     08H             ; ERROR-1  
0553 0c			        DEFB    $0C             ; Error Report: BREAK - CONT repeats  
0554			  
0554			; ---  
0554			  
0554			;; SA/LD-END  
0554 f1			L0554:  POP     AF              ; restore the accumulator.  
0555 c9			        RET                     ; return.  
0556			  
0556			; ------------------------------------  
0556			; Load header or block of information  
0556			; ------------------------------------  
0556			; This routine is used to load bytes and on entry A is set to $00 for a   
0556			; header or to $FF for data.  IX points to the start of receiving location   
0556			; and DE holds the length of bytes to be loaded. If, on entry the carry flag   
0556			; is set then data is loaded, if reset then it is verified.  
0556			  
0556			;; LD-BYTES  
0556 14			L0556:  INC     D               ; reset the zero flag without disturbing carry.  
0557 08			        EX      AF,AF'          ; preserve entry flags.  
0558 15			        DEC     D               ; restore high byte of length.  
0559			  
0559 f3			        DI                      ; disable interrupts  
055a			  
055a 3e 0f		        LD      A,$0F           ; make the border white and mic off.  
055c d3 fe		        OUT     ($FE),A         ; output to port.  
055e			  
055e 21 3f 05		        LD      HL,L053F        ; Address: SA/LD-RET  
0561 e5			        PUSH    HL              ; is saved on stack as terminating routine.  
0562			  
0562			; the reading of the EAR bit (D6) will always be preceded by a test of the   
0562			; space key (D0), so store the initial post-test state.  
0562			  
0562 db fe		        IN      A,($FE)         ; read the ear state - bit 6.  
0564 1f			        RRA                     ; rotate to bit 5.  
0565 e6 20		        AND     $20             ; isolate this bit.  
0567 f6 02		        OR      $02             ; combine with red border colour.  
0569 4f			        LD      C,A             ; and store initial state long-term in C.  
056a bf			        CP      A               ; set the zero flag.  
056b			  
056b			;   
056b			  
056b			;; LD-BREAK  
056b c0			L056B:  RET     NZ              ; return if at any time space is pressed.  
056c			  
056c			;; LD-START  
056c cd e7 05		L056C:  CALL    L05E7           ; routine LD-EDGE-1  
056f 30 fa		        JR      NC,L056B        ; back to LD-BREAK with time out and no  
0571			                                ; edge present on tape.  
0571			  
0571			; but continue when a transition is found on tape.  
0571			  
0571 21 15 04		        LD      HL,$0415        ; set up 16-bit outer loop counter for   
0574			                                ; approx 1 second delay.  
0574			  
0574			;; LD-WAIT  
0574 10 fe		L0574:  DJNZ    L0574           ; self loop to LD-WAIT (for 256 times)  
0576			  
0576 2b			        DEC     HL              ; decrease outer loop counter.  
0577 7c			        LD      A,H             ; test for  
0578 b5			        OR      L               ; zero.  
0579 20 f9		        JR      NZ,L0574        ; back to LD-WAIT, if not zero, with zero in B.  
057b			  
057b			; continue after delay with H holding zero and B also.  
057b			; sample 256 edges to check that we are in the middle of a lead-in section.   
057b			  
057b cd e3 05		        CALL    L05E3           ; routine LD-EDGE-2  
057e 30 eb		        JR      NC,L056B        ; back to LD-BREAK  
0580			                                ; if no edges at all.  
0580			  
0580			;; LD-LEADER  
0580 06 9c		L0580:  LD      B,$9C           ; set timing value.  
0582 cd e3 05		        CALL    L05E3           ; routine LD-EDGE-2  
0585 30 e4		        JR      NC,L056B        ; back to LD-BREAK if time-out  
0587			  
0587 3e c6		        LD      A,$C6           ; two edges must be spaced apart.  
0589 b8			        CP      B               ; compare  
058a 30 e0		        JR      NC,L056C        ; back to LD-START if too close together for a   
058c			                                ; lead-in.  
058c			  
058c 24			        INC     H               ; proceed to test 256 edged sample.  
058d 20 f1		        JR      NZ,L0580        ; back to LD-LEADER while more to do.  
058f			  
058f			; sample indicates we are in the middle of a two or five second lead-in.  
058f			; Now test every edge looking for the terminal synch signal.  
058f			  
058f			;; LD-SYNC  
058f 06 c9		L058F:  LD      B,$C9           ; initial timing value in B.  
0591 cd e7 05		        CALL    L05E7           ; routine LD-EDGE-1  
0594 30 d5		        JR      NC,L056B        ; back to LD-BREAK with time-out.  
0596			  
0596 78			        LD      A,B             ; fetch augmented timing value from B.  
0597 fe d4		        CP      $D4             ; compare   
0599 30 f4		        JR      NC,L058F        ; back to LD-SYNC if gap too big, that is,  
059b			                                ; a normal lead-in edge gap.  
059b			  
059b			; but a short gap will be the synch pulse.  
059b			; in which case another edge should appear before B rises to $FF  
059b			  
059b cd e7 05		        CALL    L05E7           ; routine LD-EDGE-1  
059e d0			        RET     NC              ; return with time-out.  
059f			  
059f			; proceed when the synch at the end of the lead-in is found.  
059f			; We are about to load data so change the border colours.  
059f			  
059f 79			        LD      A,C             ; fetch long-term mask from C  
05a0 ee 03		        XOR     $03             ; and make blue/yellow.  
05a2			  
05a2 4f			        LD      C,A             ; store the new long-term byte.  
05a3			  
05a3 26 00		        LD      H,$00           ; set up parity byte as zero.  
05a5 06 b0		        LD      B,$B0           ; timing.  
05a7 18 1f		        JR      L05C8           ; forward to LD-MARKER   
05a9			                                ; the loop mid entry point with the alternate   
05a9			                                ; zero flag reset to indicate first byte   
05a9			                                ; is discarded.  
05a9			  
05a9			; --------------  
05a9			; the loading loop loads each byte and is entered at the mid point.  
05a9			  
05a9			;; LD-LOOP  
05a9 08			L05A9:  EX      AF,AF'          ; restore entry flags and type in A.  
05aa 20 07		        JR      NZ,L05B3        ; forward to LD-FLAG if awaiting initial flag  
05ac			                                ; which is to be discarded.  
05ac			  
05ac 30 0f		        JR      NC,L05BD        ; forward to LD-VERIFY if not to be loaded.  
05ae			  
05ae dd 75 00		        LD      (IX+$00),L      ; place loaded byte at memory location.  
05b1 18 0f		        JR      L05C2           ; forward to LD-NEXT  
05b3			  
05b3			; ---  
05b3			  
05b3			;; LD-FLAG  
05b3 cb 11		L05B3:  RL      C               ; preserve carry (verify) flag in long-term  
05b5			                                ; state byte. Bit 7 can be lost.  
05b5			  
05b5 ad			        XOR     L               ; compare type in A with first byte in L.  
05b6 c0			        RET     NZ              ; return if no match e.g. CODE vs DATA.  
05b7			  
05b7			; continue when data type matches.  
05b7			  
05b7 79			        LD      A,C             ; fetch byte with stored carry  
05b8 1f			        RRA                     ; rotate it to carry flag again  
05b9 4f			        LD      C,A             ; restore long-term port state.  
05ba			  
05ba 13			        INC     DE              ; increment length ??  
05bb 18 07		        JR      L05C4           ; forward to LD-DEC.  
05bd			                                ; but why not to location after ?  
05bd			  
05bd			; ---  
05bd			; for verification the byte read from tape is compared with that in memory.  
05bd			  
05bd			;; LD-VERIFY  
05bd dd 7e 00		L05BD:  LD      A,(IX+$00)      ; fetch byte from memory.  
05c0 ad			        XOR     L               ; compare with that on tape  
05c1 c0			        RET     NZ              ; return if not zero.   
05c2			  
05c2			;; LD-NEXT  
05c2 dd 23		L05C2:  INC     IX              ; increment byte pointer.  
05c4			  
05c4			;; LD-DEC  
05c4 1b			L05C4:  DEC     DE              ; decrement length.  
05c5 08			        EX      AF,AF'          ; store the flags.  
05c6 06 b2		        LD      B,$B2           ; timing.  
05c8			  
05c8			; when starting to read 8 bits the receiving byte is marked with bit at right.  
05c8			; when this is rotated out again then 8 bits have been read.  
05c8			  
05c8			;; LD-MARKER  
05c8 2e 01		L05C8:  LD      L,$01           ; initialize as %00000001  
05ca			  
05ca			;; LD-8-BITS  
05ca cd e3 05		L05CA:  CALL    L05E3           ; routine LD-EDGE-2 increments B relative to  
05cd			                                ; gap between 2 edges.  
05cd d0			        RET     NC              ; return with time-out.  
05ce			  
05ce 3e cb		        LD      A,$CB           ; the comparison byte.  
05d0 b8			        CP      B               ; compare to incremented value of B.  
05d1			                                ; if B is higher then bit on tape was set.  
05d1			                                ; if <= then bit on tape is reset.   
05d1			  
05d1 cb 15		        RL      L               ; rotate the carry bit into L.  
05d3			  
05d3 06 b0		        LD      B,$B0           ; reset the B timer byte.  
05d5 d2 ca 05		        JP      NC,L05CA        ; JUMP back to LD-8-BITS  
05d8			  
05d8			; when carry set then marker bit has been passed out and byte is complete.  
05d8			  
05d8 7c			        LD      A,H             ; fetch the running parity byte.  
05d9 ad			        XOR     L               ; include the new byte.  
05da 67			        LD      H,A             ; and store back in parity register.  
05db			  
05db 7a			        LD      A,D             ; check length of  
05dc b3			        OR      E               ; expected bytes.  
05dd 20 ca		        JR      NZ,L05A9        ; back to LD-LOOP   
05df			                                ; while there are more.  
05df			  
05df			; when all bytes loaded then parity byte should be zero.  
05df			  
05df 7c			        LD      A,H             ; fetch parity byte.  
05e0 fe 01		        CP      $01             ; set carry if zero.  
05e2 c9			        RET                     ; return  
05e3			                                ; in no carry then error as checksum disagrees.  
05e3			  
05e3			; -------------------------  
05e3			; Check signal being loaded  
05e3			; -------------------------  
05e3			; An edge is a transition from one mic state to another.  
05e3			; More specifically a change in bit 6 of value input from port $FE.  
05e3			; Graphically it is a change of border colour, say, blue to yellow.  
05e3			; The first entry point looks for two adjacent edges. The second entry point  
05e3			; is used to find a single edge.  
05e3			; The B register holds a count, up to 256, within which the edge (or edges)   
05e3			; must be found. The gap between two edges will be more for a '1' than a '0'  
05e3			; so the value of B denotes the state of the bit (two edges) read from tape.  
05e3			  
05e3			; ->  
05e3			  
05e3			;; LD-EDGE-2  
05e3 cd e7 05		L05E3:  CALL    L05E7           ; call routine LD-EDGE-1 below.  
05e6 d0			        RET     NC              ; return if space pressed or time-out.  
05e7			                                ; else continue and look for another adjacent   
05e7			                                ; edge which together represent a bit on the   
05e7			                                ; tape.  
05e7			  
05e7			; ->   
05e7			; this entry point is used to find a single edge from above but also   
05e7			; when detecting a read-in signal on the tape.  
05e7			  
05e7			;; LD-EDGE-1  
05e7 3e 16		L05E7:  LD      A,$16           ; a delay value of twenty two.  
05e9			  
05e9			;; LD-DELAY  
05e9 3d			L05E9:  DEC     A               ; decrement counter  
05ea 20 fd		        JR      NZ,L05E9        ; loop back to LD-DELAY 22 times.  
05ec			  
05ec a7			        AND      A              ; clear carry.  
05ed			  
05ed			;; LD-SAMPLE  
05ed 04			L05ED:  INC     B               ; increment the time-out counter.  
05ee c8			        RET     Z               ; return with failure when $FF passed.  
05ef			  
05ef 3e 7f		        LD      A,$7F           ; prepare to read keyboard and EAR port  
05f1 db fe		        IN      A,($FE)         ; row $7FFE. bit 6 is EAR, bit 0 is SPACE key.  
05f3 1f			        RRA                     ; test outer key the space. (bit 6 moves to 5)  
05f4 d0			        RET     NC              ; return if space pressed.  >>>  
05f5			  
05f5 a9			        XOR     C               ; compare with initial long-term state.  
05f6 e6 20		        AND     $20             ; isolate bit 5  
05f8 28 f3		        JR      Z,L05ED         ; back to LD-SAMPLE if no edge.  
05fa			  
05fa			; but an edge, a transition of the EAR bit, has been found so switch the  
05fa			; long-term comparison byte containing both border colour and EAR bit.   
05fa			  
05fa 79			        LD      A,C             ; fetch comparison value.  
05fb 2f			        CPL                     ; switch the bits  
05fc 4f			        LD      C,A             ; and put back in C for long-term.  
05fd			  
05fd e6 07		        AND     $07             ; isolate new colour bits.  
05ff f6 08		        OR      $08             ; set bit 3 - MIC off.  
0601 d3 fe		        OUT     ($FE),A         ; send to port to effect change of colour.   
0603			  
0603 37			        SCF                     ; set carry flag signaling edge found within  
0604			                                ; time allowed.  
0604 c9			        RET                     ; return.  
0605			  
0605			; ---------------------------------  
0605			; Entry point for all tape commands  
0605			; ---------------------------------  
0605			; This is the single entry point for the four tape commands.  
0605			; The routine first determines in what context it has been called by examining  
0605			; the low byte of the Syntax table entry which was stored in T_ADDR.  
0605			; Subtracting $EO (the present arrangement) gives a value of  
0605			; $00 - SAVE  
0605			; $01 - LOAD  
0605			; $02 - VERIFY  
0605			; $03 - MERGE  
0605			; As with all commands the address STMT-RET is on the stack.  
0605			  
0605			;; SAVE-ETC  
0605 f1			L0605:  POP     AF              ; discard address STMT-RET.  
0606 3a 74 5c		        LD      A,($5C74)       ; fetch T_ADDR  
0609			  
0609			; Now reduce the low byte of the Syntax table entry to give command.  
0609			; Note. For ZASM use SUB $E0 as next instruction.  
0609			  
0609			L0609:  ;SUB     L1ADF + 1 % 256 ; subtract the known offset.  
0609 d6 e0		        SUB $E0                  ; ( is SUB $E0 in standard ROM )  
060b			  
060b 32 74 5c		        LD      ($5C74),A       ; and put back in T_ADDR as 0,1,2, or 3  
060e			                                ; for future reference.  
060e			  
060e cd 8c 1c		        CALL    L1C8C           ; routine EXPT-EXP checks that a string  
0611			                                ; expression follows and stacks the  
0611			                                ; parameters in run-time.  
0611			  
0611 cd 30 25		        CALL    L2530           ; routine SYNTAX-Z  
0614 28 3c		        JR      Z,L0652         ; forward to SA-DATA if checking syntax.  
0616			  
0616 01 11 00		        LD      BC,$0011        ; presume seventeen bytes for a header.  
0619 3a 74 5c		        LD      A,($5C74)       ; fetch command from T_ADDR.  
061c a7			        AND     A               ; test for zero - SAVE.  
061d 28 02		        JR      Z,L0621         ; forward to SA-SPACE if so.  
061f			  
061f 0e 22		        LD      C,$22           ; else double length to thirty four.  
0621			  
0621			;; SA-SPACE  
0621 f7			L0621:  RST     30H             ; BC-SPACES creates 17/34 bytes in workspace.  
0622			  
0622 d5			        PUSH    DE              ; transfer the start of new space to  
0623 dd e1		        POP     IX              ; the available index register.  
0625			  
0625			; ten spaces are required for the default filename but it is simpler to  
0625			; overwrite the first file-type indicator byte as well.  
0625			  
0625 06 0b		        LD      B,$0B           ; set counter to eleven.  
0627 3e 20		        LD      A,$20           ; prepare a space.  
0629			  
0629			;; SA-BLANK  
0629 12			L0629:  LD      (DE),A          ; set workspace location to space.  
062a 13			        INC     DE              ; next location.  
062b 10 fc		        DJNZ    L0629           ; loop back to SA-BLANK till all eleven done.  
062d			  
062d dd 36 01 ff	        LD      (IX+$01),$FF    ; set first byte of ten character filename  
0631			                                ; to $FF as a default to signal null string.  
0631			  
0631 cd f1 2b		        CALL    L2BF1           ; routine STK-FETCH fetches the filename  
0634			                                ; parameters from the calculator stack.  
0634			                                ; length of string in BC.  
0634			                                ; start of string in DE.  
0634			  
0634 21 f6 ff		        LD      HL,$FFF6        ; prepare the value minus ten.  
0637 0b			        DEC     BC              ; decrement length.  
0638			                                ; ten becomes nine, zero becomes $FFFF.  
0638 09			        ADD     HL,BC           ; trial addition.  
0639 03			        INC     BC              ; restore true length.  
063a 30 0f		        JR      NC,L064B        ; forward to SA-NAME if length is one to ten.  
063c			  
063c			; the filename is more than ten characters in length or the null string.  
063c			  
063c 3a 74 5c		        LD      A,($5C74)       ; fetch command from T_ADDR.  
063f a7			        AND     A               ; test for zero - SAVE.  
0640 20 02		        JR      NZ,L0644        ; forward to SA-NULL if not the SAVE command.  
0642			  
0642			; but no more than ten characters are allowed for SAVE.  
0642			; The first ten characters of any other command parameter are acceptable.  
0642			; Weird, but necessary, if saving to sectors.  
0642			; Note. the golden rule that there are no restriction on anything is broken.  
0642			  
0642			;; REPORT-Fa  
0642 cf			L0642:  RST     08H             ; ERROR-1  
0643 0e			        DEFB    $0E             ; Error Report: Invalid file name  
0644			  
0644			; continue with LOAD, MERGE, VERIFY and also SAVE within ten character limit.  
0644			  
0644			;; SA-NULL  
0644 78			L0644:  LD      A,B             ; test length of filename  
0645 b1			        OR      C               ; for zero.  
0646 28 0a		        JR      Z,L0652         ; forward to SA-DATA if so using the 255   
0648			                                ; indicator followed by spaces.  
0648			  
0648 01 0a 00		        LD      BC,$000A        ; else trim length to ten.  
064b			  
064b			; other paths rejoin here with BC holding length in range 1 - 10.  
064b			  
064b			;; SA-NAME  
064b dd e5		L064B:  PUSH    IX              ; push start of file descriptor.  
064d e1			        POP     HL              ; and pop into HL.  
064e			  
064e 23			        INC     HL              ; HL now addresses first byte of filename.  
064f eb			        EX      DE,HL           ; transfer destination address to DE, start  
0650			                                ; of string in command to HL.  
0650 ed b0		        LDIR                    ; copy up to ten bytes  
0652			                                ; if less than ten then trailing spaces follow.  
0652			  
0652			; the case for the null string rejoins here.  
0652			  
0652			;; SA-DATA  
0652 df			L0652:  RST     18H             ; GET-CHAR  
0653 fe e4		        CP      $E4             ; is character after filename the token 'DATA' ?  
0655 20 49		        JR      NZ,L06A0        ; forward to SA-SCR$ to consider SCREEN$ if  
0657			                                ; not.  
0657			  
0657			; continue to consider DATA.  
0657			  
0657 3a 74 5c		        LD      A,($5C74)       ; fetch command from T_ADDR  
065a fe 03		        CP      $03             ; is it 'VERIFY' ?  
065c ca 8a 1c		        JP      Z,L1C8A         ; jump forward to REPORT-C if so.  
065f			                                ; 'Nonsense in BASIC'  
065f			                                ; VERIFY "d" DATA is not allowed.  
065f			  
065f			; continue with SAVE, LOAD, MERGE of DATA.  
065f			  
065f e7			        RST     20H             ; NEXT-CHAR  
0660 cd b2 28		        CALL    L28B2           ; routine LOOK-VARS searches variables area  
0663			                                ; returning with carry reset if found or  
0663			                                ; checking syntax.  
0663 cb f9		        SET     7,C             ; this converts a simple string to a   
0665			                                ; string array. The test for an array or string  
0665			                                ; comes later.  
0665 30 0b		        JR      NC,L0672        ; forward to SA-V-OLD if variable found.  
0667			  
0667 21 00 00		        LD      HL,$0000        ; set destination to zero as not fixed.  
066a 3a 74 5c		        LD      A,($5C74)       ; fetch command from T_ADDR  
066d 3d			        DEC     A               ; test for 1 - LOAD  
066e 28 15		        JR      Z,L0685         ; forward to SA-V-NEW with LOAD DATA.  
0670			                                ; to load a new array.  
0670			  
0670			; otherwise the variable was not found in run-time with SAVE/MERGE.  
0670			  
0670			;; REPORT-2a  
0670 cf			L0670:  RST     08H             ; ERROR-1  
0671 01			        DEFB    $01             ; Error Report: Variable not found  
0672			  
0672			; continue with SAVE/LOAD  DATA  
0672			  
0672			;; SA-V-OLD  
0672 c2 8a 1c		L0672:  JP      NZ,L1C8A        ; to REPORT-C if not an array variable.  
0675			                                ; or erroneously a simple string.  
0675			                                ; 'Nonsense in BASIC'  
0675			  
0675			  
0675 cd 30 25		        CALL    L2530           ; routine SYNTAX-Z  
0678 28 18		        JR      Z,L0692         ; forward to SA-DATA-1 if checking syntax.  
067a			  
067a 23			        INC     HL              ; step past single character variable name.  
067b 7e			        LD      A,(HL)          ; fetch low byte of length.  
067c dd 77 0b		        LD      (IX+$0B),A      ; place in descriptor.  
067f 23			        INC     HL              ; point to high byte.  
0680 7e			        LD      A,(HL)          ; and transfer that  
0681 dd 77 0c		        LD      (IX+$0C),A      ; to descriptor.  
0684 23			        INC     HL              ; increase pointer within variable.  
0685			  
0685			;; SA-V-NEW  
0685 dd 71 0e		L0685:  LD      (IX+$0E),C      ; place character array name in  header.  
0688 3e 01		        LD      A,$01           ; default to type numeric.  
068a cb 71		        BIT     6,C             ; test result from look-vars.  
068c 28 01		        JR      Z,L068F         ; forward to SA-V-TYPE if numeric.  
068e			  
068e 3c			        INC     A               ; set type to 2 - string array.  
068f			  
068f			;; SA-V-TYPE  
068f dd 77 00		L068F:  LD      (IX+$00),A      ; place type 0, 1 or 2 in descriptor.  
0692			  
0692			;; SA-DATA-1  
0692 eb			L0692:  EX      DE,HL           ; save var pointer in DE  
0693			  
0693 e7			        RST     20H             ; NEXT-CHAR  
0694 fe 29		        CP      $29             ; is character ')' ?  
0696 20 da		        JR      NZ,L0672        ; back if not to SA-V-OLD to report  
0698			                                ; 'Nonsense in BASIC'  
0698			  
0698 e7			        RST     20H             ; NEXT-CHAR advances character address.  
0699 cd ee 1b		        CALL    L1BEE           ; routine CHECK-END errors if not end of  
069c			                                ; the statement.  
069c			  
069c eb			        EX      DE,HL           ; bring back variables data pointer.  
069d c3 5a 07		        JP      L075A           ; jump forward to SA-ALL  
06a0			  
06a0			; ---  
06a0			; the branch was here to consider a 'SCREEN$', the display file.  
06a0			  
06a0			;; SA-SCR$  
06a0 fe aa		L06A0:  CP      $AA             ; is character the token 'SCREEN$' ?  
06a2 20 1f		        JR      NZ,L06C3        ; forward to SA-CODE if not.  
06a4			  
06a4 3a 74 5c		        LD      A,($5C74)       ; fetch command from T_ADDR  
06a7 fe 03		        CP      $03             ; is it MERGE ?  
06a9 ca 8a 1c		        JP       Z,L1C8A        ; jump to REPORT-C if so.  
06ac			                                ; 'Nonsense in BASIC'  
06ac			  
06ac			; continue with SAVE/LOAD/VERIFY SCREEN$.  
06ac			  
06ac e7			        RST     20H             ; NEXT-CHAR  
06ad cd ee 1b		        CALL    L1BEE           ; routine CHECK-END errors if not at end of  
06b0			                                ; statement.  
06b0			  
06b0			; continue in runtime.  
06b0			  
06b0 dd 36 0b 00	        LD      (IX+$0B),$00    ; set descriptor length  
06b4 dd 36 0c 1b	        LD      (IX+$0C),$1B    ; to $1b00 to include bitmaps and attributes.  
06b8			  
06b8 21 00 40		        LD      HL,$4000        ; set start to display file start.  
06bb dd 75 0d		        LD      (IX+$0D),L      ; place start in  
06be dd 74 0e		        LD      (IX+$0E),H      ; the descriptor.  
06c1 18 4d		        JR      L0710           ; forward to SA-TYPE-3  
06c3			  
06c3			; ---  
06c3			; the branch was here to consider CODE.  
06c3			  
06c3			;; SA-CODE  
06c3 fe af		L06C3:  CP      $AF             ; is character the token 'CODE' ?  
06c5 20 4f		        JR      NZ,L0716        ; forward if not to SA-LINE to consider an  
06c7			                                ; auto-started BASIC program.  
06c7			  
06c7 3a 74 5c		        LD      A,($5C74)       ; fetch command from T_ADDR  
06ca fe 03		        CP      $03             ; is it MERGE ?  
06cc ca 8a 1c		        JP      Z,L1C8A         ; jump forward to REPORT-C if so.  
06cf			                                ; 'Nonsense in BASIC'  
06cf			  
06cf			  
06cf e7			        RST     20H             ; NEXT-CHAR advances character address.  
06d0 cd 48 20		        CALL    L2048           ; routine PR-ST-END checks if a carriage  
06d3			                                ; return or ':' follows.  
06d3 20 0c		        JR      NZ,L06E1        ; forward to SA-CODE-1 if there are parameters.  
06d5			  
06d5 3a 74 5c		        LD      A,($5C74)       ; else fetch the command from T_ADDR.  
06d8 a7			        AND     A               ; test for zero - SAVE without a specification.  
06d9 ca 8a 1c		        JP      Z,L1C8A         ; jump to REPORT-C if so.  
06dc			                                ; 'Nonsense in BASIC'  
06dc			  
06dc			; for LOAD/VERIFY put zero on stack to signify handle at location saved from.  
06dc			  
06dc cd e6 1c		        CALL    L1CE6           ; routine USE-ZERO  
06df 18 0f		        JR      L06F0           ; forward to SA-CODE-2  
06e1			  
06e1			; ---  
06e1			; if there are more characters after CODE expect start and possibly length.  
06e1			  
06e1			;; SA-CODE-1  
06e1 cd 82 1c		L06E1:  CALL    L1C82           ; routine EXPT-1NUM checks for numeric  
06e4			                                ; expression and stacks it in run-time.  
06e4			  
06e4 df			        RST     18H             ; GET-CHAR  
06e5 fe 2c		        CP      $2C             ; does a comma follow ?  
06e7 28 0c		        JR      Z,L06F5         ; forward if so to SA-CODE-3  
06e9			  
06e9			; else allow saved code to be loaded to a specified address.  
06e9			  
06e9 3a 74 5c		        LD      A,($5C74)       ; fetch command from T_ADDR.  
06ec a7			        AND     A               ; is the command SAVE which requires length ?  
06ed ca 8a 1c		        JP      Z,L1C8A         ; jump to REPORT-C if so.  
06f0			                                ; 'Nonsense in BASIC'  
06f0			  
06f0			; the command LOAD code may rejoin here with zero stacked as start.  
06f0			  
06f0			;; SA-CODE-2  
06f0 cd e6 1c		L06F0:  CALL    L1CE6           ; routine USE-ZERO stacks zero for length.  
06f3 18 04		        JR      L06F9           ; forward to SA-CODE-4  
06f5			  
06f5			; ---  
06f5			; the branch was here with SAVE CODE start,   
06f5			  
06f5			;; SA-CODE-3  
06f5 e7			L06F5:  RST     20H             ; NEXT-CHAR advances character address.  
06f6 cd 82 1c		        CALL    L1C82           ; routine EXPT-1NUM checks for expression  
06f9			                                ; and stacks in run-time.  
06f9			  
06f9			; paths converge here and nothing must follow.  
06f9			  
06f9			;; SA-CODE-4  
06f9 cd ee 1b		L06F9:  CALL    L1BEE           ; routine CHECK-END errors with extraneous  
06fc			                                ; characters and quits if checking syntax.  
06fc			  
06fc			; in run-time there are two 16-bit parameters on the calculator stack.  
06fc			  
06fc cd 99 1e		        CALL    L1E99           ; routine FIND-INT2 gets length.  
06ff dd 71 0b		        LD      (IX+$0B),C      ; place length   
0702 dd 70 0c		        LD      (IX+$0C),B      ; in descriptor.  
0705 cd 99 1e		        CALL    L1E99           ; routine FIND-INT2 gets start.  
0708 dd 71 0d		        LD      (IX+$0D),C      ; place start  
070b dd 70 0e		        LD      (IX+$0E),B      ; in descriptor.  
070e 60			        LD      H,B             ; transfer the  
070f 69			        LD      L,C             ; start to HL also.  
0710			  
0710			;; SA-TYPE-3  
0710 dd 36 00 03	L0710:  LD      (IX+$00),$03    ; place type 3 - code in descriptor.   
0714 18 44		        JR      L075A           ; forward to SA-ALL.  
0716			  
0716			; ---  
0716			; the branch was here with BASIC to consider an optional auto-start line  
0716			; number.  
0716			  
0716			;; SA-LINE  
0716 fe ca		L0716:  CP      $CA             ; is character the token 'LINE' ?  
0718 28 09		        JR      Z,L0723         ; forward to SA-LINE-1 if so.  
071a			  
071a			; else all possibilities have been considered and nothing must follow.  
071a			  
071a cd ee 1b		        CALL    L1BEE           ; routine CHECK-END  
071d			  
071d			; continue in run-time to save BASIC without auto-start.  
071d			  
071d dd 36 0e 80	        LD      (IX+$0E),$80    ; place high line number in descriptor to  
0721			                                ; disable auto-start.  
0721 18 17		        JR      L073A           ; forward to SA-TYPE-0 to save program.  
0723			  
0723			; ---  
0723			; the branch was here to consider auto-start.  
0723			  
0723			;; SA-LINE-1  
0723 3a 74 5c		L0723:  LD      A,($5C74)       ; fetch command from T_ADDR  
0726 a7			        AND     A               ; test for SAVE.  
0727 c2 8a 1c		        JP      NZ,L1C8A        ; jump forward to REPORT-C with anything else.  
072a			                                ; 'Nonsense in BASIC'  
072a			  
072a			;   
072a			  
072a e7			        RST     20H             ; NEXT-CHAR  
072b cd 82 1c		        CALL    L1C82           ; routine EXPT-1NUM checks for numeric  
072e			                                ; expression and stacks in run-time.  
072e cd ee 1b		        CALL    L1BEE           ; routine CHECK-END quits if syntax path.  
0731 cd 99 1e		        CALL    L1E99           ; routine FIND-INT2 fetches the numeric  
0734			                                ; expression.  
0734 dd 71 0d		        LD      (IX+$0D),C      ; place the auto-start  
0737 dd 70 0e		        LD      (IX+$0E),B      ; line number in the descriptor.  
073a			  
073a			; Note. this isn't checked, but is subsequently handled by the system.  
073a			; If the user typed 40000 instead of 4000 then it won't auto-start  
073a			; at line 4000, or indeed, at all.  
073a			  
073a			; continue to save program and any variables.  
073a			  
073a			;; SA-TYPE-0  
073a dd 36 00 00	L073A:  LD      (IX+$00),$00    ; place type zero - program in descriptor.  
073e 2a 59 5c		        LD      HL,($5C59)      ; fetch E_LINE to HL.  
0741 ed 5b 53 5c	        LD      DE,($5C53)      ; fetch PROG to DE.  
0745 37			        SCF                     ; set carry flag to calculate from end of  
0746			                                ; variables E_LINE -1.  
0746 ed 52		        SBC     HL,DE           ; subtract to give total length.  
0748			  
0748 dd 75 0b		        LD      (IX+$0B),L      ; place total length  
074b dd 74 0c		        LD      (IX+$0C),H      ; in descriptor.  
074e 2a 4b 5c		        LD      HL,($5C4B)      ; load HL from system variable VARS  
0751 ed 52		        SBC     HL,DE           ; subtract to give program length.  
0753 dd 75 0f		        LD      (IX+$0F),L      ; place length of program  
0756 dd 74 10		        LD      (IX+$10),H      ; in the descriptor.  
0759 eb			        EX      DE,HL           ; start to HL, length to DE.  
075a			  
075a			;; SA-ALL  
075a 3a 74 5c		L075A:  LD      A,($5C74)       ; fetch command from T_ADDR  
075d a7			        AND     A               ; test for zero - SAVE.  
075e ca 70 09		        JP      Z,L0970         ; jump forward to SA-CONTRL with SAVE  ->  
0761			  
0761			; ---  
0761			; continue with LOAD, MERGE and VERIFY.  
0761			  
0761 e5			        PUSH    HL              ; save start.  
0762 01 11 00		        LD      BC,$0011        ; prepare to add seventeen  
0765 dd 09		        ADD     IX,BC           ; to point IX at second descriptor.  
0767			  
0767			;; LD-LOOK-H  
0767 dd e5		L0767:  PUSH    IX              ; save IX  
0769 11 11 00		        LD      DE,$0011        ; seventeen bytes  
076c af			        XOR     A               ; reset zero flag  
076d 37			        SCF                     ; set carry flag  
076e cd 56 05		        CALL    L0556           ; routine LD-BYTES loads a header from tape  
0771			                                ; to second descriptor.  
0771 dd e1		        POP     IX              ; restore IX.  
0773 30 f2		        JR      NC,L0767        ; loop back to LD-LOOK-H until header found.  
0775			  
0775 3e fe		        LD      A,$FE           ; select system channel 'S'  
0777 cd 01 16		        CALL    L1601           ; routine CHAN-OPEN opens it.  
077a			  
077a fd 36 52 03	        LD      (IY+$52),$03    ; set SCR_CT to 3 lines.  
077e			  
077e 0e 80		        LD      C,$80           ; C has bit 7 set to indicate type mismatch as  
0780			                                ; a default startpoint.  
0780			  
0780 dd 7e 00		        LD      A,(IX+$00)      ; fetch loaded header type to A  
0783 dd be ef		        CP      (IX-$11)        ; compare with expected type.  
0786 20 02		        JR      NZ,L078A        ; forward to LD-TYPE with mis-match.  
0788			  
0788 0e f6		        LD      C,$F6           ; set C to minus ten - will count characters  
078a			                                ; up to zero.  
078a			  
078a			;; LD-TYPE  
078a fe 04		L078A:  CP      $04             ; check if type in acceptable range 0 - 3.  
078c 30 d9		        JR      NC,L0767        ; back to LD-LOOK-H with 4 and over.  
078e			  
078e			; else A indicates type 0-3.  
078e			  
078e 11 c0 09		        LD      DE,L09C0        ; address base of last 4 tape messages  
0791 c5			        PUSH    BC              ; save BC  
0792 cd 0a 0c		        CALL    L0C0A           ; routine PO-MSG outputs relevant message.  
0795			                                ; Note. all messages have a leading newline.  
0795 c1			        POP     BC              ; restore BC  
0796			  
0796 dd e5		        PUSH    IX              ; transfer IX,  
0798 d1			        POP     DE              ; the 2nd descriptor, to DE.  
0799 21 f0 ff		        LD      HL,$FFF0        ; prepare minus seventeen.  
079c 19			        ADD     HL,DE           ; add to point HL to 1st descriptor.  
079d 06 0a		        LD      B,$0A           ; the count will be ten characters for the  
079f			                                ; filename.  
079f			  
079f 7e			        LD      A,(HL)          ; fetch first character and test for   
07a0 3c			        INC     A               ; value 255.  
07a1 20 03		        JR      NZ,L07A6        ; forward to LD-NAME if not the wildcard.  
07a3			  
07a3			; but if it is the wildcard, then add ten to C which is minus ten for a type  
07a3			; match or -128 for a type mismatch. Although characters have to be counted  
07a3			; bit 7 of C will not alter from state set here.  
07a3			  
07a3 79			        LD      A,C             ; transfer $F6 or $80 to A  
07a4 80			        ADD     A,B             ; add $0A  
07a5 4f			        LD      C,A             ; place result, zero or -118, in C.  
07a6			  
07a6			; At this point we have either a type mismatch, a wildcard match or ten  
07a6			; characters to be counted. The characters must be shown on the screen.  
07a6			  
07a6			;; LD-NAME  
07a6 13			L07A6:  INC     DE              ; address next input character  
07a7 1a			        LD      A,(DE)          ; fetch character  
07a8 be			        CP      (HL)            ; compare to expected  
07a9 23			        INC     HL              ; address next expected character  
07aa 20 01		        JR      NZ,L07AD        ; forward to LD-CH-PR with mismatch  
07ac			  
07ac 0c			        INC     C               ; increment matched character count  
07ad			  
07ad			;; LD-CH-PR  
07ad d7			L07AD:  RST     10H             ; PRINT-A prints character  
07ae 10 f6		        DJNZ    L07A6           ; loop back to LD-NAME for ten characters.  
07b0			  
07b0			; if ten characters matched and the types previously matched then C will   
07b0			; now hold zero.  
07b0			  
07b0 cb 79		        BIT     7,C             ; test if all matched  
07b2 20 b3		        JR      NZ,L0767        ; back to LD-LOOK-H if not  
07b4			  
07b4			; else print a terminal carriage return.  
07b4			  
07b4 3e 0d		        LD      A,$0D           ; prepare carriage return.  
07b6 d7			        RST     10H             ; PRINT-A outputs it.  
07b7			  
07b7			; The various control routines for LOAD, VERIFY and MERGE are executed   
07b7			; during the one-second gap following the header on tape.  
07b7			  
07b7 e1			        POP     HL              ; restore xx  
07b8 dd 7e 00		        LD      A,(IX+$00)      ; fetch incoming type   
07bb fe 03		        CP      $03             ; compare with CODE  
07bd 28 0c		        JR      Z,L07CB         ; forward to VR-CONTROL if it is CODE.  
07bf			  
07bf			;  type is a program or an array.  
07bf			  
07bf 3a 74 5c		        LD      A,($5C74)       ; fetch command from T_ADDR  
07c2 3d			        DEC     A               ; was it LOAD ?  
07c3 ca 08 08		        JP      Z,L0808         ; JUMP forward to LD-CONTRL if so to   
07c6			                                ; load BASIC or variables.  
07c6			  
07c6 fe 02		        CP      $02             ; was command MERGE ?  
07c8 ca b6 08		        JP      Z,L08B6         ; jump forward to ME-CONTRL if so.  
07cb			  
07cb			; else continue into VERIFY control routine to verify.  
07cb			  
07cb			; ---------------------  
07cb			; Handle VERIFY control  
07cb			; ---------------------  
07cb			; There are two branches to this routine.  
07cb			; 1) From above to verify a program or array  
07cb			; 2) from earlier with no carry to load or verify code.  
07cb			  
07cb			;; VR-CONTROL  
07cb e5			L07CB:  PUSH    HL              ; save pointer to data.  
07cc dd 6e fa		        LD      L,(IX-$06)      ; fetch length of old data   
07cf dd 66 fb		        LD      H,(IX-$05)      ; to HL.  
07d2 dd 5e 0b		        LD      E,(IX+$0B)      ; fetch length of new data  
07d5 dd 56 0c		        LD      D,(IX+$0C)      ; to DE.  
07d8 7c			        LD      A,H             ; check length of old  
07d9 b5			        OR      L               ; for zero.  
07da 28 0d		        JR      Z,L07E9         ; forward to VR-CONT-1 if length unspecified  
07dc			                                ; e.g LOAD "x" CODE  
07dc			  
07dc			; as opposed to, say, LOAD 'x' CODE 32768,300.  
07dc			  
07dc ed 52		        SBC     HL,DE           ; subtract the two lengths.  
07de 38 26		        JR      C,L0806         ; forward to REPORT-R if the length on tape is   
07e0			                                ; larger than that specified in command.  
07e0			                                ; 'Tape loading error'  
07e0			  
07e0 28 07		        JR      Z,L07E9         ; forward to VR-CONT-1 if lengths match.  
07e2			  
07e2			; a length on tape shorter than expected is not allowed for CODE  
07e2			  
07e2 dd 7e 00		        LD      A,(IX+$00)      ; else fetch type from tape.  
07e5 fe 03		        CP      $03             ; is it CODE ?  
07e7 20 1d		        JR      NZ,L0806        ; forward to REPORT-R if so  
07e9			                                ; 'Tape loading error'  
07e9			  
07e9			;; VR-CONT-1  
07e9 e1			L07E9:  POP     HL              ; pop pointer to data  
07ea 7c			        LD      A,H             ; test for zero  
07eb b5			        OR      L               ; e.g. LOAD 'x' CODE  
07ec 20 06		        JR      NZ,L07F4        ; forward to VR-CONT-2 if destination specified.  
07ee			  
07ee dd 6e 0d		        LD      L,(IX+$0D)      ; else use the destination in the header  
07f1 dd 66 0e		        LD      H,(IX+$0E)      ; and load code at address saved from.  
07f4			  
07f4			;; VR-CONT-2  
07f4 e5			L07F4:  PUSH    HL              ; push pointer to start of data block.  
07f5 dd e1		        POP     IX              ; transfer to IX.  
07f7 3a 74 5c		        LD      A,($5C74)       ; fetch reduced command from T_ADDR  
07fa fe 02		        CP      $02             ; is it VERIFY ?  
07fc 37			        SCF                     ; prepare a set carry flag  
07fd 20 01		        JR      NZ,L0800        ; skip to VR-CONT-3 if not  
07ff			  
07ff a7			        AND     A               ; clear carry flag for VERIFY so that   
0800			                                ; data is not loaded.  
0800			  
0800			;; VR-CONT-3  
0800 3e ff		L0800:  LD      A,$FF           ; signal data block to be loaded  
0802			  
0802			; -----------------  
0802			; Load a data block  
0802			; -----------------  
0802			; This routine is called from 3 places other than above to load a data block.  
0802			; In all cases the accumulator is first set to $FF so the routine could be   
0802			; called at the previous instruction.  
0802			  
0802			;; LD-BLOCK  
0802 cd 56 05		L0802:  CALL    L0556           ; routine LD-BYTES  
0805 d8			        RET     C               ; return if successful.  
0806			  
0806			  
0806			;; REPORT-R  
0806 cf			L0806:  RST     08H             ; ERROR-1  
0807 1a			        DEFB    $1A             ; Error Report: Tape loading error  
0808			  
0808			; -------------------  
0808			; Handle LOAD control  
0808			; -------------------  
0808			; This branch is taken when the command is LOAD with type 0, 1 or 2.   
0808			  
0808			;; LD-CONTRL  
0808 dd 5e 0b		L0808:  LD      E,(IX+$0B)      ; fetch length of found data block   
080b dd 56 0c		        LD      D,(IX+$0C)      ; from 2nd descriptor.  
080e e5			        PUSH    HL              ; save destination  
080f 7c			        LD      A,H             ; test for zero  
0810 b5			        OR      L               ;  
0811 20 06		        JR      NZ,L0819        ; forward if not to LD-CONT-1  
0813			  
0813 13			        INC     DE              ; increase length  
0814 13			        INC     DE              ; for letter name  
0815 13			        INC     DE              ; and 16-bit length  
0816 eb			        EX      DE,HL           ; length to HL,   
0817 18 0c		        JR      L0825           ; forward to LD-CONT-2  
0819			  
0819			; ---  
0819			  
0819			;; LD-CONT-1  
0819 dd 6e fa		L0819:  LD      L,(IX-$06)      ; fetch length from   
081c dd 66 fb		        LD      H,(IX-$05)      ; the first header.  
081f eb			        EX      DE,HL           ;  
0820 37			        SCF                     ; set carry flag  
0821 ed 52		        SBC     HL,DE           ;  
0823 38 09		        JR      C,L082E         ; to LD-DATA  
0825			  
0825			;; LD-CONT-2  
0825 11 05 00		L0825:  LD      DE,$0005        ; allow overhead of five bytes.  
0828 19			        ADD     HL,DE           ; add in the difference in data lengths.  
0829 44			        LD      B,H             ; transfer to  
082a 4d			        LD      C,L             ; the BC register pair  
082b cd 05 1f		        CALL    L1F05           ; routine TEST-ROOM fails if not enough room.  
082e			  
082e			;; LD-DATA  
082e e1			L082E:  POP     HL              ; pop destination  
082f dd 7e 00		        LD      A,(IX+$00)      ; fetch type 0, 1 or 2.  
0832 a7			        AND     A               ; test for program and variables.  
0833 28 3e		        JR      Z,L0873         ; forward if so to LD-PROG  
0835			  
0835			; the type is a numeric or string array.  
0835			  
0835 7c			        LD      A,H             ; test the destination for zero  
0836 b5			        OR      L               ; indicating variable does not already exist.  
0837 28 13		        JR      Z,L084C         ; forward if so to LD-DATA-1  
0839			  
0839			; else the destination is the first dimension within the array structure  
0839			  
0839 2b			        DEC     HL              ; address high byte of total length  
083a 46			        LD      B,(HL)          ; transfer to B.  
083b 2b			        DEC     HL              ; address low byte of total length.  
083c 4e			        LD      C,(HL)          ; transfer to C.  
083d 2b			        DEC     HL              ; point to letter of variable.  
083e 03			        INC     BC              ; adjust length to  
083f 03			        INC     BC              ; include these  
0840 03			        INC     BC              ; three bytes also.  
0841 dd 22 5f 5c	        LD      ($5C5F),IX      ; save header pointer in X_PTR.  
0845 cd e8 19		        CALL    L19E8           ; routine RECLAIM-2 reclaims the old variable  
0848			                                ; sliding workspace including the two headers   
0848			                                ; downwards.  
0848 dd 2a 5f 5c	        LD      IX,($5C5F)      ; reload IX from X_PTR which will have been  
084c			                                ; adjusted down by POINTERS routine.  
084c			  
084c			;; LD-DATA-1  
084c 2a 59 5c		L084C:  LD      HL,($5C59)      ; address E_LINE  
084f 2b			        DEC     HL              ; now point to the $80 variables end-marker.  
0850 dd 4e 0b		        LD      C,(IX+$0B)      ; fetch new data length   
0853 dd 46 0c		        LD      B,(IX+$0C)      ; from 2nd header.  
0856 c5			        PUSH    BC              ; * save it.  
0857 03			        INC     BC              ; adjust the   
0858 03			        INC     BC              ; length to include  
0859 03			        INC     BC              ; letter name and total length.  
085a dd 7e fd		        LD      A,(IX-$03)      ; fetch letter name from old header.  
085d f5			        PUSH    AF              ; preserve accumulator though not corrupted.  
085e			  
085e cd 55 16		        CALL    L1655           ; routine MAKE-ROOM creates space for variable  
0861			                                ; sliding workspace up. IX no longer addresses  
0861			                                ; anywhere meaningful.  
0861 23			        INC     HL              ; point to first new location.  
0862			  
0862 f1			        POP     AF              ; fetch back the letter name.  
0863 77			        LD      (HL),A          ; place in first new location.  
0864 d1			        POP     DE              ; * pop the data length.  
0865 23			        INC     HL              ; address 2nd location  
0866 73			        LD      (HL),E          ; store low byte of length.  
0867 23			        INC     HL              ; address next.  
0868 72			        LD      (HL),D          ; store high byte.  
0869 23			        INC     HL              ; address start of data.  
086a e5			        PUSH    HL              ; transfer address  
086b dd e1		        POP     IX              ; to IX register pair.  
086d 37			        SCF                     ; set carry flag indicating load not verify.  
086e 3e ff		        LD      A,$FF           ; signal data not header.  
0870 c3 02 08		        JP      L0802           ; JUMP back to LD-BLOCK  
0873			  
0873			; -----------------  
0873			; the branch is here when a program as opposed to an array is to be loaded.  
0873			  
0873			;; LD-PROG  
0873 eb			L0873:  EX      DE,HL           ; transfer dest to DE.  
0874 2a 59 5c		        LD      HL,($5C59)      ; address E_LINE  
0877 2b			        DEC     HL              ; now variables end-marker.  
0878 dd 22 5f 5c	        LD      ($5C5F),IX      ; place the IX header pointer in X_PTR  
087c dd 4e 0b		        LD      C,(IX+$0B)      ; get new length  
087f dd 46 0c		        LD      B,(IX+$0C)      ; from 2nd header  
0882 c5			        PUSH    BC              ; and save it.  
0883			  
0883 cd e5 19		        CALL    L19E5           ; routine RECLAIM-1 reclaims program and vars.  
0886			                                ; adjusting X-PTR.  
0886			  
0886 c1			        POP     BC              ; restore new length.  
0887 e5			        PUSH    HL              ; * save start  
0888 c5			        PUSH    BC              ; ** and length.  
0889			  
0889 cd 55 16		        CALL    L1655           ; routine MAKE-ROOM creates the space.  
088c			  
088c dd 2a 5f 5c	        LD      IX,($5C5F)      ; reload IX from adjusted X_PTR  
0890 23			        INC     HL              ; point to start of new area.  
0891 dd 4e 0f		        LD      C,(IX+$0F)      ; fetch length of BASIC on tape  
0894 dd 46 10		        LD      B,(IX+$10)      ; from 2nd descriptor  
0897 09			        ADD     HL,BC           ; add to address the start of variables.  
0898 22 4b 5c		        LD      ($5C4B),HL      ; set system variable VARS  
089b			  
089b dd 66 0e		        LD      H,(IX+$0E)      ; fetch high byte of autostart line number.  
089e 7c			        LD      A,H             ; transfer to A  
089f e6 c0		        AND     $C0             ; test if greater than $3F.  
08a1 20 0a		        JR      NZ,L08AD        ; forward to LD-PROG-1 if so with no autostart.  
08a3			  
08a3 dd 6e 0d		        LD      L,(IX+$0D)      ; else fetch the low byte.  
08a6 22 42 5c		        LD      ($5C42),HL      ; set sytem variable to line number NEWPPC  
08a9 fd 36 0a 00	        LD      (IY+$0A),$00    ; set statement NSPPC to zero.  
08ad			  
08ad			;; LD-PROG-1  
08ad d1			L08AD:  POP     DE              ; ** pop the length  
08ae dd e1		        POP     IX              ; * and start.  
08b0 37			        SCF                     ; set carry flag  
08b1 3e ff		        LD      A,$FF           ; signal data as opposed to a header.  
08b3 c3 02 08		        JP      L0802           ; jump back to LD-BLOCK  
08b6			  
08b6			; --------------------  
08b6			; Handle MERGE control  
08b6			; --------------------  
08b6			; the branch was here to merge a program and its variables or an array.  
08b6			;  
08b6			  
08b6			;; ME-CONTRL  
08b6 dd 4e 0b		L08B6:  LD      C,(IX+$0B)      ; fetch length  
08b9 dd 46 0c		        LD      B,(IX+$0C)      ; of data block on tape.  
08bc c5			        PUSH    BC              ; save it.  
08bd 03			        INC     BC              ; one for the pot.  
08be			  
08be f7			        RST     30H             ; BC-SPACES creates room in workspace.  
08bf			                                ; HL addresses last new location.  
08bf 36 80		        LD      (HL),$80        ; place end-marker at end.  
08c1 eb			        EX      DE,HL           ; transfer first location to HL.  
08c2 d1			        POP     DE              ; restore length to DE.  
08c3 e5			        PUSH    HL              ; save start.  
08c4			  
08c4 e5			        PUSH    HL              ; and transfer it  
08c5 dd e1		        POP     IX              ; to IX register.  
08c7 37			        SCF                     ; set carry flag to load data on tape.  
08c8 3e ff		        LD      A,$FF           ; signal data not a header.  
08ca cd 02 08		        CALL    L0802           ; routine LD-BLOCK loads to workspace.  
08cd e1			        POP     HL              ; restore first location in workspace to HL.  
08ce ed 5b 53 5c	X08CE:  LD      DE,($5C53)      ; set DE from system variable PROG.  
08d2			  
08d2			; now enter a loop to merge the data block in workspace with the program and   
08d2			; variables.   
08d2			  
08d2			;; ME-NEW-LP  
08d2 7e			L08D2:  LD      A,(HL)          ; fetch next byte from workspace.  
08d3 e6 c0		        AND     $C0             ; compare with $3F.  
08d5 20 19		        JR      NZ,L08F0        ; forward to ME-VAR-LP if a variable or   
08d7			                                ; end-marker.  
08d7			  
08d7			; continue when HL addresses a BASIC line number.  
08d7			  
08d7			;; ME-OLD-LP  
08d7 1a			L08D7:  LD      A,(DE)          ; fetch high byte from program area.  
08d8 13			        INC     DE              ; bump prog address.  
08d9 be			        CP      (HL)            ; compare with that in workspace.  
08da 23			        INC     HL              ; bump workspace address.  
08db 20 02		        JR      NZ,L08DF        ; forward to ME-OLD-L1 if high bytes don't match  
08dd			  
08dd 1a			        LD      A,(DE)          ; fetch the low byte of program line number.  
08de be			        CP      (HL)            ; compare with that in workspace.  
08df			  
08df			;; ME-OLD-L1  
08df 1b			L08DF:  DEC     DE              ; point to start of  
08e0 2b			        DEC     HL              ; respective lines again.  
08e1 30 08		        JR      NC,L08EB        ; forward to ME-NEW-L2 if line number in   
08e3			                                ; workspace is less than or equal to current  
08e3			                                ; program line as has to be added to program.  
08e3			  
08e3 e5			        PUSH    HL              ; else save workspace pointer.   
08e4 eb			        EX      DE,HL           ; transfer prog pointer to HL  
08e5 cd b8 19		        CALL    L19B8           ; routine NEXT-ONE finds next line in DE.  
08e8 e1			        POP     HL              ; restore workspace pointer  
08e9 18 ec		        JR      L08D7           ; back to ME-OLD-LP until destination position   
08eb			                                ; in program area found.  
08eb			  
08eb			; ---  
08eb			; the branch was here with an insertion or replacement point.  
08eb			  
08eb			;; ME-NEW-L2  
08eb cd 2c 09		L08EB:  CALL    L092C           ; routine ME-ENTER enters the line  
08ee 18 e2		        JR      L08D2           ; loop back to ME-NEW-LP.  
08f0			  
08f0			; ---  
08f0			; the branch was here when the location in workspace held a variable.  
08f0			  
08f0			;; ME-VAR-LP  
08f0 7e			L08F0:  LD      A,(HL)          ; fetch first byte of workspace variable.  
08f1 4f			        LD      C,A             ; copy to C also.  
08f2 fe 80		        CP      $80             ; is it the end-marker ?  
08f4 c8			        RET     Z               ; return if so as complete.  >>>>>  
08f5			  
08f5 e5			        PUSH    HL              ; save workspace area pointer.  
08f6 2a 4b 5c		        LD      HL,($5C4B)      ; load HL with VARS - start of variables area.  
08f9			  
08f9			;; ME-OLD-VP  
08f9 7e			L08F9:  LD      A,(HL)          ; fetch first byte.  
08fa fe 80		        CP      $80             ; is it the end-marker ?  
08fc 28 25		        JR      Z,L0923         ; forward if so to ME-VAR-L2 to add  
08fe			                                ; variable at end of variables area.  
08fe			  
08fe b9			        CP      C               ; compare with variable in workspace area.  
08ff 28 08		        JR      Z,L0909         ; forward to ME-OLD-V2 if a match to replace.  
0901			  
0901			; else entire variables area has to be searched.  
0901			  
0901			;; ME-OLD-V1  
0901 c5			L0901:  PUSH    BC              ; save character in C.  
0902 cd b8 19		        CALL    L19B8           ; routine NEXT-ONE gets following variable   
0905			                                ; address in DE.  
0905 c1			        POP     BC              ; restore character in C  
0906 eb			        EX      DE,HL           ; transfer next address to HL.  
0907 18 f0		        JR      L08F9           ; loop back to ME-OLD-VP  
0909			  
0909			; ---   
0909			; the branch was here when first characters of name matched.   
0909			  
0909			;; ME-OLD-V2  
0909 e6 e0		L0909:  AND     $E0             ; keep bits 11100000  
090b fe a0		        CP      $A0             ; compare   10100000 - a long-named variable.  
090d			  
090d 20 12		        JR      NZ,L0921        ; forward to ME-VAR-L1 if just one-character.  
090f			  
090f			; but long-named variables have to be matched character by character.  
090f			  
090f d1			        POP     DE              ; fetch workspace 1st character pointer  
0910 d5			        PUSH    DE              ; and save it on the stack again.  
0911 e5			        PUSH    HL              ; save variables area pointer on stack.  
0912			  
0912			;; ME-OLD-V3  
0912 23			L0912:  INC     HL              ; address next character in vars area.  
0913 13			        INC     DE              ; address next character in workspace area.  
0914 1a			        LD      A,(DE)          ; fetch workspace character.  
0915 be			        CP      (HL)            ; compare to variables character.  
0916 20 06		        JR      NZ,L091E        ; forward to ME-OLD-V4 with a mismatch.  
0918			  
0918 17			        RLA                     ; test if the terminal inverted character.  
0919 30 f7		        JR      NC,L0912        ; loop back to ME-OLD-V3 if more to test.  
091b			  
091b			; otherwise the long name matches in its entirety.  
091b			  
091b e1			        POP     HL              ; restore pointer to first character of variable  
091c 18 03		        JR      L0921           ; forward to ME-VAR-L1  
091e			  
091e			; ---  
091e			; the branch is here when two characters don't match  
091e			  
091e			;; ME-OLD-V4  
091e e1			L091E:  POP     HL              ; restore the prog/vars pointer.  
091f 18 e0		        JR      L0901           ; back to ME-OLD-V1 to resume search.  
0921			  
0921			; ---  
0921			; branch here when variable is to replace an existing one  
0921			  
0921			;; ME-VAR-L1  
0921 3e ff		L0921:  LD      A,$FF           ; indicate a replacement.  
0923			  
0923			; this entry point is when A holds $80 indicating a new variable.  
0923			  
0923			;; ME-VAR-L2  
0923 d1			L0923:  POP     DE              ; pop workspace pointer.  
0924 eb			        EX      DE,HL           ; now make HL workspace pointer, DE vars pointer  
0925 3c			        INC     A               ; zero flag set if replacement.  
0926 37			        SCF                     ; set carry flag indicating a variable not a  
0927			                                ; program line.  
0927 cd 2c 09		        CALL    L092C           ; routine ME-ENTER copies variable in.  
092a 18 c4		        JR      L08F0           ; loop back to ME-VAR-LP  
092c			  
092c			; ------------------------  
092c			; Merge a Line or Variable  
092c			; ------------------------  
092c			; A BASIC line or variable is inserted at the current point. If the line numbers  
092c			; or variable names match (zero flag set) then a replacement takes place.  
092c			  
092c			;; ME-ENTER  
092c 20 10		L092C:  JR      NZ,L093E        ; forward to ME-ENT-1 for insertion only.  
092e			  
092e			; but the program line or variable matches so old one is reclaimed.  
092e			  
092e 08			        EX      AF,AF'          ; save flag??  
092f 22 5f 5c		        LD      ($5C5F),HL      ; preserve workspace pointer in dynamic X_PTR  
0932 eb			        EX      DE,HL           ; transfer program dest pointer to HL.  
0933 cd b8 19		        CALL    L19B8           ; routine NEXT-ONE finds following location  
0936			                                ; in program or variables area.  
0936 cd e8 19		        CALL    L19E8           ; routine RECLAIM-2 reclaims the space between.  
0939 eb			        EX      DE,HL           ; transfer program dest pointer back to DE.  
093a 2a 5f 5c		        LD      HL,($5C5F)      ; fetch adjusted workspace pointer from X_PTR  
093d 08			        EX      AF,AF'          ; restore flags.  
093e			  
093e			; now the new line or variable is entered.  
093e			  
093e			;; ME-ENT-1  
093e 08			L093E:  EX      AF,AF'          ; save or re-save flags.  
093f d5			        PUSH    DE              ; save dest pointer in prog/vars area.  
0940 cd b8 19		        CALL    L19B8           ; routine NEXT-ONE finds next in workspace.  
0943			                                ; gets next in DE, difference in BC.  
0943			                                ; prev addr in HL  
0943 22 5f 5c		        LD      ($5C5F),HL      ; store pointer in X_PTR  
0946 2a 53 5c		        LD      HL,($5C53)      ; load HL from system variable PROG  
0949 e3			        EX      (SP),HL         ; swap with prog/vars pointer on stack.   
094a c5			        PUSH    BC              ; ** save length of new program line/variable.  
094b 08			        EX      AF,AF'          ; fetch flags back.  
094c 38 07		        JR      C,L0955         ; skip to ME-ENT-2 if variable  
094e			  
094e 2b			        DEC     HL              ; address location before pointer  
094f cd 55 16		        CALL    L1655           ; routine MAKE-ROOM creates room for BASIC line  
0952 23			        INC     HL              ; address next.  
0953 18 03		        JR      L0958           ; forward to ME-ENT-3  
0955			  
0955			; ---  
0955			  
0955			;; ME-ENT-2  
0955 cd 55 16		L0955:  CALL    L1655           ; routine MAKE-ROOM creates room for variable.  
0958			  
0958			;; ME-ENT-3  
0958 23			L0958:  INC     HL              ; address next?  
0959			  
0959 c1			        POP     BC              ; ** pop length  
095a d1			        POP     DE              ; * pop value for PROG which may have been   
095b			                                ; altered by POINTERS if first line.  
095b ed 53 53 5c	        LD      ($5C53),DE      ; set PROG to original value.  
095f ed 5b 5f 5c	        LD      DE,($5C5F)      ; fetch adjusted workspace pointer from X_PTR  
0963 c5			        PUSH    BC              ; save length  
0964 d5			        PUSH    DE              ; and workspace pointer  
0965 eb			        EX      DE,HL           ; make workspace pointer source, prog/vars  
0966			                                ; pointer the destination  
0966 ed b0		        LDIR                    ; copy bytes of line or variable into new area.  
0968 e1			        POP     HL              ; restore workspace pointer.  
0969 c1			        POP     BC              ; restore length.  
096a d5			        PUSH    DE              ; save new prog/vars pointer.  
096b cd e8 19		        CALL    L19E8           ; routine RECLAIM-2 reclaims the space used  
096e			                                ; by the line or variable in workspace block  
096e			                                ; as no longer required and space could be   
096e			                                ; useful for adding more lines.  
096e d1			        POP     DE              ; restore the prog/vars pointer  
096f c9			        RET                     ; return.  
0970			  
0970			; -------------------  
0970			; Handle SAVE control  
0970			; -------------------  
0970			; A branch from the main SAVE-ETC routine at SAVE-ALL.  
0970			; First the header data is saved. Then after a wait of 1 second  
0970			; the data itself is saved.  
0970			; HL points to start of data.  
0970			; IX points to start of descriptor.  
0970			  
0970			;; SA-CONTRL  
0970 e5			L0970:  PUSH    HL              ; save start of data  
0971			  
0971 3e fd		        LD      A,$FD           ; select system channel 'S'  
0973 cd 01 16		        CALL    L1601           ; routine CHAN-OPEN  
0976			  
0976 af			        XOR     A               ; clear to address table directly  
0977 11 a1 09		        LD      DE,L09A1        ; address: tape-msgs  
097a cd 0a 0c		        CALL    L0C0A           ; routine PO-MSG -  
097d			                                ; 'Start tape then press any key.'  
097d			  
097d fd cb 02 ee	        SET     5,(IY+$02)      ; TV_FLAG  - Signal lower screen requires  
0981			                                ; clearing  
0981 cd d4 15		        CALL    L15D4           ; routine WAIT-KEY  
0984			  
0984 dd e5		        PUSH    IX              ; save pointer to descriptor.  
0986 11 11 00		        LD      DE,$0011        ; there are seventeen bytes.  
0989 af			        XOR     A               ; signal a header.  
098a cd c2 04		        CALL    L04C2           ; routine SA-BYTES  
098d			  
098d dd e1		        POP     IX              ; restore descriptor pointer.  
098f			  
098f 06 32		        LD      B,$32           ; wait for a second - 50 interrupts.  
0991			  
0991			;; SA-1-SEC  
0991 76			L0991:  HALT                    ; wait for interrupt  
0992 10 fd		        DJNZ    L0991           ; back to SA-1-SEC until pause complete.  
0994			  
0994 dd 5e 0b		        LD      E,(IX+$0B)      ; fetch length of bytes from the  
0997 dd 56 0c		        LD      D,(IX+$0C)      ; descriptor.  
099a			  
099a 3e ff		        LD      A,$FF           ; signal data bytes.  
099c			  
099c dd e1		        POP     IX              ; retrieve pointer to start  
099e c3 c2 04		        JP      L04C2           ; jump back to SA-BYTES  
09a1			  
09a1			  
09a1			; Arrangement of two headers in workspace.  
09a1			; Originally IX addresses first location and only one header is required  
09a1			; when saving.  
09a1			;  
09a1			;   OLD     NEW         PROG   DATA  DATA  CODE   
09a1			;   HEADER  HEADER             num   chr          NOTES.  
09a1			;   ------  ------      ----   ----  ----  ----   -----------------------------  
09a1			;   IX-$11  IX+$00      0      1     2     3      Type.  
09a1			;   IX-$10  IX+$01      x      x     x     x      F  ($FF if filename is null).  
09a1			;   IX-$0F  IX+$02      x      x     x     x      i  
09a1			;   IX-$0E  IX+$03      x      x     x     x      l  
09a1			;   IX-$0D  IX+$04      x      x     x     x      e  
09a1			;   IX-$0C  IX+$05      x      x     x     x      n  
09a1			;   IX-$0B  IX+$06      x      x     x     x      a  
09a1			;   IX-$0A  IX+$07      x      x     x     x      m  
09a1			;   IX-$09  IX+$08      x      x     x     x      e  
09a1			;   IX-$08  IX+$09      x      x     x     x      .  
09a1			;   IX-$07  IX+$0A      x      x     x     x      (terminal spaces).  
09a1			;   IX-$06  IX+$0B      lo     lo    lo    lo     Total    
09a1			;   IX-$05  IX+$0C      hi     hi    hi    hi     Length of datablock.  
09a1			;   IX-$04  IX+$0D      Auto   -     -     Start  Various  
09a1			;   IX-$03  IX+$0E      Start  a-z   a-z   addr   ($80 if no autostart).  
09a1			;   IX-$02  IX+$0F      lo     -     -     -      Length of Program   
09a1			;   IX-$01  IX+$10      hi     -     -     -      only i.e. without variables.  
09a1			;  
09a1			  
09a1			  
09a1			; ------------------------  
09a1			; Canned cassette messages  
09a1			; ------------------------  
09a1			; The last-character-inverted Cassette messages.  
09a1			; Starts with normal initial step-over byte.  
09a1			  
09a1			;; tape-msgs  
09a1 80			L09A1:  DEFB    $80  
09a2 ..			        DEFM    "Start tape, then press any key"  
09c0 ae			L09C0:  DEFB    $80+'.'  
09c1 0d			        DEFB    $0D  
09c2 ..			        DEFM    "Program:"  
09ca a0			        DEFB    $80+' '  
09cb 0d			        DEFB    $0D  
09cc ..			        DEFM    "Number array:"  
09d9 a0			        DEFB    $80+' '  
09da 0d			        DEFB    $0D  
09db ..			        DEFM    "Character array:"  
09eb a0			        DEFB    $80+' '  
09ec 0d			        DEFB    $0D  
09ed ..			        DEFM    "Bytes:"  
09f3 a0			        DEFB    $80+' '  
09f4			  
09f4			  
09f4			;**************************************************  
09f4			;** Part 5. SCREEN AND PRINTER HANDLING ROUTINES **  
09f4			;**************************************************  
09f4			  
09f4			; ---------------------  
09f4			; General PRINT routine  
09f4			; ---------------------  
09f4			; This is the routine most often used by the RST 10 restart although the  
09f4			; subroutine is on two occasions called directly when it is known that  
09f4			; output will definitely be to the lower screen.  
09f4			  
09f4			;; PRINT-OUT  
09f4 cd 03 0b		L09F4:  CALL    L0B03           ; routine PO-FETCH fetches print position  
09f7			                                ; to HL register pair.  
09f7 fe 20		        CP      $20             ; is character a space or higher ?  
09f9 d2 d9 0a		        JP      NC,L0AD9        ; jump forward to PO-ABLE if so.  
09fc			  
09fc fe 06		        CP      $06             ; is character in range 00-05 ?  
09fe 38 69		        JR      C,L0A69         ; to PO-QUEST to print '?' if so.  
0a00			  
0a00 fe 18		        CP      $18             ; is character in range 24d - 31d ?  
0a02 30 65		        JR      NC,L0A69        ; to PO-QUEST to also print '?' if so.  
0a04			  
0a04 21 0b 0a		        LD      HL,L0A11 - 6    ; address 0A0B - the base address of control  
0a07			                                ; character table - where zero would be.  
0a07 5f			        LD      E,A             ; control character 06 - 23d  
0a08 16 00		        LD      D,$00           ; is transferred to DE.  
0a0a			  
0a0a 19			        ADD     HL,DE           ; index into table.  
0a0b			  
0a0b 5e			        LD      E,(HL)          ; fetch the offset to routine.  
0a0c 19			        ADD     HL,DE           ; add to make HL the address.  
0a0d e5			        PUSH    HL              ; push the address.  
0a0e c3 03 0b		        JP      L0B03           ; to PO-FETCH, as the screen/printer position  
0a11			                                ; has been disturbed, and indirectly to  
0a11			                                ; routine on stack.  
0a11			  
0a11			; -----------------------  
0a11			; Control character table  
0a11			; -----------------------  
0a11			; For control characters in the range 6 - 23d the following table  
0a11			; is indexed to provide an offset to the handling routine that  
0a11			; follows the table.  
0a11			  
0a11			;; ctlchrtab  
0a11 4e			L0A11:  DEFB    L0A5F - $       ; 06d offset $4E to Address: PO-COMMA  
0a12 57			        DEFB    L0A69 - $       ; 07d offset $57 to Address: PO-QUEST  
0a13 10			        DEFB    L0A23 - $       ; 08d offset $10 to Address: PO-BACK-1  
0a14 29			        DEFB    L0A3D - $       ; 09d offset $29 to Address: PO-RIGHT  
0a15 54			        DEFB    L0A69 - $       ; 10d offset $54 to Address: PO-QUEST  
0a16 53			        DEFB    L0A69 - $       ; 11d offset $53 to Address: PO-QUEST  
0a17 52			        DEFB    L0A69 - $       ; 12d offset $52 to Address: PO-QUEST  
0a18 37			        DEFB    L0A4F - $       ; 13d offset $37 to Address: PO-ENTER  
0a19 50			        DEFB    L0A69 - $       ; 14d offset $50 to Address: PO-QUEST  
0a1a 4f			        DEFB    L0A69 - $       ; 15d offset $4F to Address: PO-QUEST  
0a1b 5f			        DEFB    L0A7A - $       ; 16d offset $5F to Address: PO-1-OPER  
0a1c 5e			        DEFB    L0A7A - $       ; 17d offset $5E to Address: PO-1-OPER  
0a1d 5d			        DEFB    L0A7A - $       ; 18d offset $5D to Address: PO-1-OPER  
0a1e 5c			        DEFB    L0A7A - $       ; 19d offset $5C to Address: PO-1-OPER  
0a1f 5b			        DEFB    L0A7A - $       ; 20d offset $5B to Address: PO-1-OPER  
0a20 5a			        DEFB    L0A7A - $       ; 21d offset $5A to Address: PO-1-OPER  
0a21 54			        DEFB    L0A75 - $       ; 22d offset $54 to Address: PO-2-OPER  
0a22 53			        DEFB    L0A75 - $       ; 23d offset $53 to Address: PO-2-OPER  
0a23			  
0a23			  
0a23			; -------------------  
0a23			; Cursor left routine  
0a23			; -------------------  
0a23			; Backspace and up a line if that action is from the left of screen.  
0a23			; For ZX printer backspace up to first column but not beyond.  
0a23			  
0a23			;; PO-BACK-1  
0a23 0c			L0A23:  INC     C               ; move left one column.  
0a24 3e 22		        LD      A,$22           ; value $21 is leftmost column.  
0a26 b9			        CP      C               ; have we passed ?  
0a27 20 11		        JR      NZ,L0A3A        ; to PO-BACK-3 if not and store new position.  
0a29			  
0a29 fd cb 01 4e	        BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?  
0a2d 20 09		        JR      NZ,L0A38        ; to PO-BACK-2 if so, as we are unable to  
0a2f			                                ; backspace from the leftmost position.  
0a2f			  
0a2f			  
0a2f 04			        INC     B               ; move up one screen line  
0a30 0e 02		        LD      C,$02           ; the rightmost column position.  
0a32 3e 18		        LD      A,$18           ; Note. This should be $19  
0a34			                                ; credit. Dr. Frank O'Hara, 1982  
0a34			  
0a34 b8			        CP      B               ; has position moved past top of screen ?  
0a35 20 03		        JR      NZ,L0A3A        ; to PO-BACK-3 if not and store new position.  
0a37			  
0a37 05			        DEC     B               ; else back to $18.  
0a38			  
0a38			;; PO-BACK-2  
0a38 0e 21		L0A38:  LD      C,$21           ; the leftmost column position.  
0a3a			  
0a3a			;; PO-BACK-3  
0a3a c3 d9 0d		L0A3A:  JP      L0DD9           ; to CL-SET and PO-STORE to save new  
0a3d			                                ; position in system variables.  
0a3d			  
0a3d			; --------------------  
0a3d			; Cursor right routine  
0a3d			; --------------------  
0a3d			; This moves the print position to the right leaving a trail in the  
0a3d			; current background colour.  
0a3d			; "However the programmer has failed to store the new print position  
0a3d			;  so CHR$ 9 will only work if the next print position is at a newly  
0a3d			;  defined place.  
0a3d			;   e.g. PRINT PAPER 2; CHR$ 9; AT 4,0;  
0a3d			;  does work but is not very helpful"  
0a3d			; - Dr. Ian Logan, Understanding Your Spectrum, 1982.  
0a3d			  
0a3d			;; PO-RIGHT  
0a3d 3a 91 5c		L0A3D:  LD      A,($5C91)       ; fetch P_FLAG value  
0a40 f5			        PUSH    AF              ; and save it on stack.  
0a41			  
0a41 fd 36 57 01	        LD      (IY+$57),$01    ; temporarily set P_FLAG 'OVER 1'.  
0a45 3e 20		        LD      A,$20           ; prepare a space.  
0a47 cd 65 0b		        CALL    L0B65           ; routine PO-CHAR to print it.  
0a4a			                                ; Note. could be PO-ABLE which would update  
0a4a			                                ; the column position.  
0a4a			  
0a4a f1			        POP     AF              ; restore the permanent flag.  
0a4b 32 91 5c		        LD      ($5C91),A       ; and restore system variable P_FLAG  
0a4e			  
0a4e c9			        RET                     ; return without updating column position  
0a4f			  
0a4f			; -----------------------  
0a4f			; Perform carriage return  
0a4f			; -----------------------  
0a4f			; A carriage return is 'printed' to screen or printer buffer.  
0a4f			  
0a4f			;; PO-ENTER  
0a4f fd cb 01 4e	L0A4F:  BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?  
0a53 c2 cd 0e		        JP      NZ,L0ECD        ; to COPY-BUFF if so, to flush buffer and reset  
0a56			                                ; the print position.  
0a56			  
0a56 0e 21		        LD      C,$21           ; the leftmost column position.  
0a58 cd 55 0c		        CALL    L0C55           ; routine PO-SCR handles any scrolling required.  
0a5b 05			        DEC     B               ; to next screen line.  
0a5c c3 d9 0d		        JP      L0DD9           ; jump forward to CL-SET to store new position.  
0a5f			  
0a5f			; -----------  
0a5f			; Print comma  
0a5f			; -----------  
0a5f			; The comma control character. The 32 column screen has two 16 character  
0a5f			; tabstops.  The routine is only reached via the control character table.  
0a5f			  
0a5f			;; PO-COMMA  
0a5f cd 03 0b		L0A5F:  CALL    L0B03           ; routine PO-FETCH - seems unnecessary.  
0a62			  
0a62 79			        LD      A,C             ; the column position. $21-$01  
0a63 3d			        DEC     A               ; move right. $20-$00  
0a64 3d			        DEC     A               ; and again   $1F-$00 or $FF if trailing  
0a65 e6 10		        AND     $10             ; will be $00 or $10.  
0a67 18 5a		        JR      L0AC3           ; forward to PO-FILL  
0a69			  
0a69			; -------------------  
0a69			; Print question mark  
0a69			; -------------------  
0a69			; This routine prints a question mark which is commonly  
0a69			; used to print an unassigned control character in range 0-31d.  
0a69			; there are a surprising number yet to be assigned.  
0a69			  
0a69			;; PO-QUEST  
0a69 3e 3f		L0A69:  LD      A,$3F           ; prepare the character '?'.  
0a6b 18 6c		        JR      L0AD9           ; forward to PO-ABLE.  
0a6d			  
0a6d			; --------------------------------  
0a6d			; Control characters with operands  
0a6d			; --------------------------------  
0a6d			; Certain control characters are followed by 1 or 2 operands.  
0a6d			; The entry points from control character table are PO-2-OPER and PO-1-OPER.  
0a6d			; The routines alter the output address of the current channel so that  
0a6d			; subsequent RST $10 instructions take the appropriate action  
0a6d			; before finally resetting the output address back to PRINT-OUT.  
0a6d			  
0a6d			;; PO-TV-2  
0a6d 11 87 0a		L0A6D:  LD      DE,L0A87        ; address: PO-CONT will be next output routine  
0a70 32 0f 5c		        LD      ($5C0F),A       ; store first operand in TVDATA-hi  
0a73 18 0b		        JR      L0A80           ; forward to PO-CHANGE >>  
0a75			  
0a75			; ---  
0a75			  
0a75			; -> This initial entry point deals with two operands - AT or TAB.  
0a75			  
0a75			;; PO-2-OPER  
0a75 11 6d 0a		L0A75:  LD      DE,L0A6D        ; address: PO-TV-2 will be next output routine  
0a78 18 03		        JR      L0A7D           ; forward to PO-TV-1  
0a7a			  
0a7a			; ---  
0a7a			  
0a7a			; -> This initial entry point deals with one operand INK to OVER.  
0a7a			  
0a7a			;; PO-1-OPER  
0a7a 11 87 0a		L0A7A:  LD      DE,L0A87        ; address: PO-CONT will be next output routine  
0a7d			  
0a7d			;; PO-TV-1  
0a7d 32 0e 5c		L0A7D:  LD      ($5C0E),A       ; store control code in TVDATA-lo  
0a80			  
0a80			;; PO-CHANGE  
0a80 2a 51 5c		L0A80:  LD      HL,($5C51)      ; use CURCHL to find current output channel.  
0a83 73			        LD      (HL),E          ; make it  
0a84 23			        INC     HL              ; the supplied  
0a85 72			        LD      (HL),D          ; address from DE.  
0a86 c9			        RET                     ; return.  
0a87			  
0a87			; ---  
0a87			  
0a87			;; PO-CONT  
0a87 11 f4 09		L0A87:  LD      DE,L09F4        ; Address: PRINT-OUT  
0a8a cd 80 0a		        CALL    L0A80           ; routine PO-CHANGE to restore normal channel.  
0a8d 2a 0e 5c		        LD      HL,($5C0E)      ; TVDATA gives control code and possible  
0a90			                                ; subsequent character  
0a90 57			        LD      D,A             ; save current character  
0a91 7d			        LD      A,L             ; the stored control code  
0a92 fe 16		        CP      $16             ; was it INK to OVER (1 operand) ?  
0a94 da 11 22		        JP      C,L2211         ; to CO-TEMP-5  
0a97			  
0a97 20 29		        JR      NZ,L0AC2        ; to PO-TAB if not 22d i.e. 23d TAB.  
0a99			  
0a99			                                ; else must have been 22d AT.  
0a99 44			        LD      B,H             ; line to H   (0-23d)  
0a9a 4a			        LD      C,D             ; column to C (0-31d)  
0a9b 3e 1f		        LD      A,$1F           ; the value 31d  
0a9d 91			        SUB     C               ; reverse the column number.  
0a9e 38 0c		        JR      C,L0AAC         ; to PO-AT-ERR if C was greater than 31d.  
0aa0			  
0aa0 c6 02		        ADD     A,$02           ; transform to system range $02-$21  
0aa2 4f			        LD      C,A             ; and place in column register.  
0aa3			  
0aa3 fd cb 01 4e	        BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?  
0aa7 20 16		        JR      NZ,L0ABF        ; to PO-AT-SET as line can be ignored.  
0aa9			  
0aa9 3e 16		        LD      A,$16           ; 22 decimal  
0aab 90			        SUB     B               ; subtract line number to reverse  
0aac			                                ; 0 - 22 becomes 22 - 0.  
0aac			  
0aac			;; PO-AT-ERR  
0aac da 9f 1e		L0AAC:  JP      C,L1E9F         ; to REPORT-B if higher than 22 decimal  
0aaf			                                ; Integer out of range.  
0aaf			  
0aaf 3c			        INC     A               ; adjust for system range $01-$17  
0ab0 47			        LD      B,A             ; place in line register  
0ab1 04			        INC     B               ; adjust to system range  $02-$18  
0ab2 fd cb 02 46	        BIT     0,(IY+$02)      ; TV_FLAG  - Lower screen in use ?  
0ab6 c2 55 0c		        JP      NZ,L0C55        ; exit to PO-SCR to test for scrolling  
0ab9			  
0ab9 fd be 31		        CP      (IY+$31)        ; Compare against DF_SZ  
0abc da 86 0c		        JP      C,L0C86         ; to REPORT-5 if too low  
0abf			                                ; Out of screen.  
0abf			  
0abf			;; PO-AT-SET  
0abf c3 d9 0d		L0ABF:  JP      L0DD9           ; print position is valid so exit via CL-SET  
0ac2			  
0ac2			; Continue here when dealing with TAB.  
0ac2			; Note. In BASIC, TAB is followed by a 16-bit number and was initially  
0ac2			; designed to work with any output device.  
0ac2			  
0ac2			;; PO-TAB  
0ac2 7c			L0AC2:  LD      A,H             ; transfer parameter to A  
0ac3			                                ; Losing current character -  
0ac3			                                ; High byte of TAB parameter.  
0ac3			  
0ac3			  
0ac3			;; PO-FILL  
0ac3 cd 03 0b		L0AC3:  CALL    L0B03           ; routine PO-FETCH, HL-addr, BC=line/column.  
0ac6			                                ; column 1 (right), $21 (left)  
0ac6 81			        ADD     A,C             ; add operand to current column  
0ac7 3d			        DEC     A               ; range 0 - 31+  
0ac8 e6 1f		        AND     $1F             ; make range 0 - 31d  
0aca c8			        RET     Z               ; return if result zero  
0acb			  
0acb 57			        LD      D,A             ; Counter to D  
0acc fd cb 01 c6	        SET     0,(IY+$01)      ; update FLAGS  - signal suppress leading space.  
0ad0			  
0ad0			;; PO-SPACE  
0ad0 3e 20		L0AD0:  LD      A,$20           ; space character.  
0ad2 cd 3b 0c		        CALL    L0C3B           ; routine PO-SAVE prints the character  
0ad5			                                ; using alternate set (normal output routine)  
0ad5 15			        DEC     D               ; decrement counter.  
0ad6 20 f8		        JR      NZ,L0AD0        ; to PO-SPACE until done  
0ad8			  
0ad8 c9			        RET                     ; return  
0ad9			  
0ad9			; ----------------------  
0ad9			; Printable character(s)  
0ad9			; ----------------------  
0ad9			; This routine prints printable characters and continues into  
0ad9			; the position store routine  
0ad9			  
0ad9			;; PO-ABLE  
0ad9 cd 24 0b		L0AD9:  CALL    L0B24           ; routine PO-ANY  
0adc			                                ; and continue into position store routine.  
0adc			  
0adc			; -------------------------------------  
0adc			; Store line, column, and pixel address  
0adc			; -------------------------------------  
0adc			; This routine updates the system variables associated with  
0adc			; The main screen, lower screen/input buffer or ZX printer.  
0adc			  
0adc			;; PO-STORE  
0adc fd cb 01 4e	L0ADC:  BIT     1,(IY+$01)      ; test FLAGS  - Is printer in use ?  
0ae0 20 1a		        JR      NZ,L0AFC        ; to PO-ST-PR if so  
0ae2			  
0ae2 fd cb 02 46	        BIT     0,(IY+$02)      ; TV_FLAG  - Lower screen in use ?  
0ae6 20 08		        JR      NZ,L0AF0        ; to PO-ST-E if so  
0ae8			  
0ae8 ed 43 88 5c	        LD      ($5C88),BC      ; S_POSN line/column upper screen  
0aec 22 84 5c		        LD      ($5C84),HL      ; DF_CC  display file address  
0aef c9			        RET                     ;  
0af0			  
0af0			; ---  
0af0			  
0af0			;; PO-ST-E  
0af0 ed 43 8a 5c	L0AF0:  LD      ($5C8A),BC      ; SPOSNL line/column lower screen  
0af4 ed 43 82 5c	        LD      ($5C82),BC      ; ECHO_E line/column input buffer  
0af8 22 86 5c		        LD      ($5C86),HL      ; DFCCL  lower screen memory address  
0afb c9			        RET                     ;  
0afc			  
0afc			; ---  
0afc			  
0afc			;; PO-ST-PR  
0afc fd 71 45		L0AFC:  LD      (IY+$45),C      ; P_POSN column position printer  
0aff 22 80 5c		        LD      ($5C80),HL      ; PR_CC  full printer buffer memory address  
0b02 c9			        RET                     ;  
0b03			  
0b03			; -------------------------  
0b03			; Fetch position parameters  
0b03			; -------------------------  
0b03			; This routine fetches the line/column and display file address  
0b03			; of the upper and lower screen or, if the printer is in use,  
0b03			; the column position and absolute memory address.  
0b03			; Note. that PR-CC-hi (23681) is used by this routine and the one above  
0b03			; and if, in accordance with the manual (that says this is unused), the  
0b03			; location has been used for other purposes, then subsequent output  
0b03			; to the printer buffer could corrupt a 256-byte section of memory.  
0b03			  
0b03			;; PO-FETCH  
0b03 fd cb 01 4e	L0B03:  BIT     1,(IY+$01)      ; test FLAGS  - Is printer in use  
0b07 20 14		        JR      NZ,L0B1D        ; to PO-F-PR if so  
0b09			  
0b09			                                ; assume upper screen  
0b09 ed 4b 88 5c	        LD      BC,($5C88)      ; S_POSN  
0b0d 2a 84 5c		        LD      HL,($5C84)      ; DF_CC display file address  
0b10 fd cb 02 46	        BIT     0,(IY+$02)      ; TV_FLAG  - Lower screen in use ?  
0b14 c8			        RET     Z               ; return if upper screen  
0b15			  
0b15			                                ; ah well, was lower screen  
0b15 ed 4b 8a 5c	        LD      BC,($5C8A)      ; SPOSNL  
0b19 2a 86 5c		        LD      HL,($5C86)      ; DFCCL  
0b1c c9			        RET                     ; return  
0b1d			  
0b1d			; ---  
0b1d			  
0b1d			;; PO-F-PR  
0b1d fd 4e 45		L0B1D:  LD      C,(IY+$45)      ; P_POSN column only  
0b20 2a 80 5c		        LD      HL,($5C80)      ; PR_CC printer buffer address  
0b23 c9			        RET                     ; return  
0b24			  
0b24			; -------------------  
0b24			; Print any character  
0b24			; -------------------  
0b24			; This routine is used to print any character in range 32d - 255d  
0b24			; It is only called from PO-ABLE which continues into PO-STORE  
0b24			  
0b24			;; PO-ANY  
0b24 fe 80		L0B24:  CP      $80             ; ASCII ?  
0b26 38 3d		        JR      C,L0B65         ; to PO-CHAR is so.  
0b28			  
0b28 fe 90		        CP      $90             ; test if a block graphic character.  
0b2a 30 26		        JR      NC,L0B52        ; to PO-T&UDG to print tokens and udg's  
0b2c			  
0b2c			; The 16 2*2 mosaic characters 128-143 decimal are formed from  
0b2c			; bits 0-3 of the character.  
0b2c			  
0b2c 47			        LD      B,A             ; save character  
0b2d cd 38 0b		        CALL    L0B38           ; routine PO-GR-1 to construct top half  
0b30			                                ; then bottom half.  
0b30 cd 03 0b		        CALL    L0B03           ; routine PO-FETCH fetches print position.  
0b33 11 92 5c		        LD      DE,$5C92        ; MEM-0 is location of 8 bytes of character  
0b36 18 47		        JR      L0B7F           ; to PR-ALL to print to screen or printer  
0b38			  
0b38			; ---  
0b38			  
0b38			;; PO-GR-1  
0b38 21 92 5c		L0B38:  LD      HL,$5C92        ; address MEM-0 - a temporary buffer in  
0b3b			                                ; systems variables which is normally used  
0b3b			                                ; by the calculator.  
0b3b cd 3e 0b		        CALL    L0B3E           ; routine PO-GR-2 to construct top half  
0b3e			                                ; and continue into routine to construct  
0b3e			                                ; bottom half.  
0b3e			  
0b3e			;; PO-GR-2  
0b3e cb 18		L0B3E:  RR      B               ; rotate bit 0/2 to carry  
0b40 9f			        SBC     A,A             ; result $00 or $FF  
0b41 e6 0f		        AND     $0F             ; mask off right hand side  
0b43 4f			        LD      C,A             ; store part in C  
0b44 cb 18		        RR      B               ; rotate bit 1/3 of original chr to carry  
0b46 9f			        SBC     A,A             ; result $00 or $FF  
0b47 e6 f0		        AND     $F0             ; mask off left hand side  
0b49 b1			        OR      C               ; combine with stored pattern  
0b4a 0e 04		        LD      C,$04           ; four bytes for top/bottom half  
0b4c			  
0b4c			;; PO-GR-3  
0b4c 77			L0B4C:  LD      (HL),A          ; store bit patterns in temporary buffer  
0b4d 23			        INC     HL              ; next address  
0b4e 0d			        DEC     C               ; jump back to  
0b4f 20 fb		        JR      NZ,L0B4C        ; to PO-GR-3 until byte is stored 4 times  
0b51			  
0b51 c9			        RET                     ; return  
0b52			  
0b52			; ---  
0b52			  
0b52			; Tokens and User defined graphics are now separated.  
0b52			  
0b52			;; PO-T&UDG  
0b52 c3 9f 3b		L0B52:  JP      L3B9F           ;Spectrum 128 patch  
0b55 00			        NOP  
0b56			  
0b56 c6 15		L0B56:  ADD     A,$15           ; add 21d to restore to 0 - 20  
0b58 c5			        PUSH    BC              ; save current print position  
0b59 ed 4b 7b 5c	        LD      BC,($5C7B)      ; fetch UDG to address bit patterns  
0b5d 18 0b		        JR      L0B6A           ; to PO-CHAR-2 - common code to lay down  
0b5f			                                ; a bit patterned character  
0b5f			  
0b5f			; ---  
0b5f			  
0b5f			;; PO-T  
0b5f cd 10 0c		L0B5F:  CALL    L0C10           ; routine PO-TOKENS prints tokens  
0b62 c3 03 0b		        JP      L0B03           ; exit via a JUMP to PO-FETCH as this routine   
0b65			                                ; must continue into PO-STORE.   
0b65			                                ; A JR instruction could be used.  
0b65			  
0b65			; This point is used to print ASCII characters  32d - 127d.  
0b65			  
0b65			;; PO-CHAR  
0b65 c5			L0B65:  PUSH    BC              ; save print position  
0b66 ed 4b 36 5c	        LD      BC,($5C36)      ; address CHARS  
0b6a			  
0b6a			; This common code is used to transfer the character bytes to memory.  
0b6a			  
0b6a			;; PO-CHAR-2  
0b6a eb			L0B6A:  EX      DE,HL           ; transfer destination address to DE  
0b6b 21 3b 5c		        LD      HL,$5C3B        ; point to FLAGS  
0b6e cb 86		        RES     0,(HL)          ; allow for leading space  
0b70 fe 20		        CP      $20             ; is it a space ?  
0b72 20 02		        JR      NZ,L0B76        ; to PO-CHAR-3 if not  
0b74			  
0b74 cb c6		        SET     0,(HL)          ; signal no leading space to FLAGS  
0b76			  
0b76			;; PO-CHAR-3  
0b76 26 00		L0B76:  LD      H,$00           ; set high byte to 0  
0b78 6f			        LD      L,A             ; character to A  
0b79			                                ; 0-21 UDG or 32-127 ASCII.  
0b79 29			        ADD     HL,HL           ; multiply  
0b7a 29			        ADD     HL,HL           ; by  
0b7b 29			        ADD     HL,HL           ; eight  
0b7c 09			        ADD     HL,BC           ; HL now points to first byte of character  
0b7d c1			        POP     BC              ; the source address CHARS or UDG  
0b7e eb			        EX      DE,HL           ; character address to DE  
0b7f			  
0b7f			; --------------------  
0b7f			; Print all characters  
0b7f			; --------------------  
0b7f			; This entry point entered from above to print ASCII and UDGs  
0b7f			; but also from earlier to print mosaic characters.  
0b7f			; HL=destination  
0b7f			; DE=character source  
0b7f			; BC=line/column  
0b7f			  
0b7f			;; PR-ALL  
0b7f 79			L0B7F:  LD      A,C             ; column to A  
0b80 3d			        DEC     A               ; move right  
0b81 3e 21		        LD      A,$21           ; pre-load with leftmost position  
0b83 20 0e		        JR      NZ,L0B93        ; but if not zero to PR-ALL-1  
0b85			  
0b85 05			        DEC     B               ; down one line  
0b86 4f			        LD      C,A             ; load C with $21  
0b87 fd cb 01 4e	        BIT     1,(IY+$01)      ; test FLAGS  - Is printer in use  
0b8b 28 06		        JR      Z,L0B93         ; to PR-ALL-1 if not  
0b8d			  
0b8d d5			        PUSH    DE              ; save source address  
0b8e cd cd 0e		        CALL    L0ECD           ; routine COPY-BUFF outputs line to printer  
0b91 d1			        POP     DE              ; restore character source address  
0b92 79			        LD      A,C             ; the new column number ($21) to C  
0b93			  
0b93			;; PR-ALL-1  
0b93 b9			L0B93:  CP      C               ; this test is really for screen - new line ?  
0b94 d5			        PUSH    DE              ; save source  
0b95			  
0b95 cc 55 0c		        CALL    Z,L0C55         ; routine PO-SCR considers scrolling  
0b98			  
0b98 d1			        POP     DE              ; restore source  
0b99 c5			        PUSH    BC              ; save line/column  
0b9a e5			        PUSH    HL              ; and destination  
0b9b 3a 91 5c		        LD      A,($5C91)       ; fetch P_FLAG to accumulator  
0b9e 06 ff		        LD      B,$FF           ; prepare OVER mask in B.  
0ba0 1f			        RRA                     ; bit 0 set if OVER 1  
0ba1 38 01		        JR      C,L0BA4         ; to PR-ALL-2  
0ba3			  
0ba3 04			        INC     B               ; set OVER mask to 0  
0ba4			  
0ba4			;; PR-ALL-2  
0ba4 1f			L0BA4:  RRA                     ; skip bit 1 of P_FLAG  
0ba5 1f			        RRA                     ; bit 2 is INVERSE  
0ba6 9f			        SBC     A,A             ; will be FF for INVERSE 1 else zero  
0ba7 4f			        LD      C,A             ; transfer INVERSE mask to C  
0ba8 3e 08		        LD      A,$08           ; prepare to count 8 bytes  
0baa a7			        AND     A               ; clear carry to signal screen  
0bab fd cb 01 4e	        BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?  
0baf 28 05		        JR      Z,L0BB6         ; to PR-ALL-3 if screen  
0bb1			  
0bb1 fd cb 30 ce	        SET     1,(IY+$30)      ; update FLAGS2  - signal printer buffer has   
0bb5			                                ; been used.  
0bb5 37			        SCF                     ; set carry flag to signal printer.  
0bb6			  
0bb6			;; PR-ALL-3  
0bb6 eb			L0BB6:  EX      DE,HL           ; now HL=source, DE=destination  
0bb7			  
0bb7			;; PR-ALL-4  
0bb7 08			L0BB7:  EX      AF,AF'          ; save printer/screen flag  
0bb8 1a			        LD      A,(DE)          ; fetch existing destination byte  
0bb9 a0			        AND     B               ; consider OVER  
0bba ae			        XOR     (HL)            ; now XOR with source  
0bbb a9			        XOR     C               ; now with INVERSE MASK  
0bbc 12			        LD      (DE),A          ; update screen/printer  
0bbd 08			        EX      AF,AF'          ; restore flag  
0bbe 38 13		        JR      C,L0BD3         ; to PR-ALL-6 - printer address update  
0bc0			  
0bc0 14			        INC     D               ; gives next pixel line down screen  
0bc1			  
0bc1			;; PR-ALL-5  
0bc1 23			L0BC1:  INC     HL              ; address next character byte  
0bc2 3d			        DEC     A               ; the byte count is decremented  
0bc3 20 f2		        JR      NZ,L0BB7        ; back to PR-ALL-4 for all 8 bytes  
0bc5			  
0bc5 eb			        EX      DE,HL           ; destination to HL  
0bc6 25			        DEC     H               ; bring back to last updated screen position  
0bc7 fd cb 01 4e	        BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?  
0bcb cc db 0b		        CALL    Z,L0BDB         ; if not, call routine PO-ATTR to update  
0bce			                                ; corresponding colour attribute.  
0bce e1			        POP     HL              ; restore original screen/printer position  
0bcf c1			        POP     BC              ; and line column  
0bd0 0d			        DEC     C               ; move column to right  
0bd1 23			        INC     HL              ; increase screen/printer position  
0bd2 c9			        RET                     ; return and continue into PO-STORE  
0bd3			                                ; within PO-ABLE  
0bd3			  
0bd3			; ---  
0bd3			  
0bd3			; This branch is used to update the printer position by 32 places  
0bd3			; Note. The high byte of the address D remains constant (which it should).  
0bd3			  
0bd3			;; PR-ALL-6  
0bd3 08			L0BD3:  EX      AF,AF'          ; save the flag  
0bd4 3e 20		        LD      A,$20           ; load A with 32 decimal  
0bd6 83			        ADD     A,E             ; add this to E  
0bd7 5f			        LD      E,A             ; and store result in E  
0bd8 08			        EX      AF,AF'          ; fetch the flag  
0bd9 18 e6		        JR      L0BC1           ; back to PR-ALL-5  
0bdb			  
0bdb			; -------------  
0bdb			; Set attribute  
0bdb			; -------------  
0bdb			; This routine is entered with the HL register holding the last screen  
0bdb			; address to be updated by PRINT or PLOT.  
0bdb			; The Spectrum screen arrangement leads to the L register holding  
0bdb			; the correct value for the attribute file and it is only necessary  
0bdb			; to manipulate H to form the correct colour attribute address.  
0bdb			  
0bdb			;; PO-ATTR  
0bdb 7c			L0BDB:  LD       A,H            ; fetch high byte $40 - $57  
0bdc 0f			        RRCA                    ; shift  
0bdd 0f			        RRCA                    ; bits 3 and 4  
0bde 0f			        RRCA                    ; to right.  
0bdf e6 03		        AND     $03             ; range is now 0 - 2  
0be1 f6 58		        OR      $58             ; form correct high byte for third of screen  
0be3 67			        LD      H,A             ; HL is now correct  
0be4 ed 5b 8f 5c	        LD      DE,($5C8F)      ; make D hold ATTR_T, E hold MASK-T  
0be8 7e			        LD      A,(HL)          ; fetch existing attribute  
0be9 ab			        XOR     E               ; apply masks  
0bea a2			        AND     D               ;  
0beb ab			        XOR     E               ;  
0bec fd cb 57 76	        BIT     6,(IY+$57)      ; test P_FLAG  - is this PAPER 9 ??  
0bf0 28 08		        JR      Z,L0BFA         ; skip to PO-ATTR-1 if not.  
0bf2			  
0bf2 e6 c7		        AND     $C7             ; set paper  
0bf4 cb 57		        BIT     2,A             ; to contrast with ink  
0bf6 20 02		        JR      NZ,L0BFA        ; skip to PO-ATTR-1  
0bf8			  
0bf8 ee 38		        XOR     $38             ;  
0bfa			  
0bfa			;; PO-ATTR-1  
0bfa fd cb 57 66	L0BFA:  BIT     4,(IY+$57)      ; test P_FLAG  - Is this INK 9 ??  
0bfe 28 08		        JR      Z,L0C08         ; skip to PO-ATTR-2 if not  
0c00			  
0c00 e6 f8		        AND     $F8             ; make ink  
0c02 cb 6f		        BIT     5,A             ; contrast with paper.  
0c04 20 02		        JR      NZ,L0C08        ; to PO-ATTR-2  
0c06			  
0c06 ee 07		        XOR     $07             ;  
0c08			  
0c08			;; PO-ATTR-2  
0c08 77			L0C08:  LD      (HL),A          ; save the new attribute.  
0c09 c9			        RET                     ; return.  
0c0a			  
0c0a			; ----------------  
0c0a			; Message printing  
0c0a			; ----------------  
0c0a			; This entry point is used to print tape, boot-up, scroll? and error messages  
0c0a			; On entry the DE register points to an initial step-over byte or  
0c0a			; the inverted end-marker of the previous entry in the table.  
0c0a			; A contains the message number, often zero to print first message.  
0c0a			; (HL has nothing important usually P_FLAG)  
0c0a			  
0c0a			;; PO-MSG  
0c0a e5			L0C0A:  PUSH    HL              ; put hi-byte zero on stack to suppress  
0c0b 26 00		        LD      H,$00           ; trailing spaces  
0c0d e3			        EX      (SP),HL         ; ld h,0; push hl would have done ?.  
0c0e 18 04		        JR      L0C14           ; forward to PO-TABLE.  
0c10			  
0c10			; ---  
0c10			  
0c10			; This entry point prints the BASIC keywords, '<>' etc. from alt set  
0c10			  
0c10			;; PO-TOKENS  
0c10 11 95 00		L0C10:  LD      DE,L0095        ; address: TKN-TABLE  
0c13 f5			        PUSH    AF              ; save the token number to control  
0c14			                                ; trailing spaces - see later *  
0c14			  
0c14			;; PO-TABLE  
0c14 cd 41 0c		L0C14:  CALL    L0C41           ; routine PO-SEARCH will set carry for  
0c17			                                ; all messages and function words.  
0c17 38 09		L0C17:  JR      C,L0C22         ; forward to PO-EACH if not a command,  
0c19			                                ; '<>' etc.  
0c19			  
0c19 3e 20		        LD      A,$20           ; prepare leading space  
0c1b fd cb 01 46	        BIT     0,(IY+$01)      ; test FLAGS  - leading space if not set  
0c1f cc 3b 0c		        CALL    Z,L0C3B         ; routine PO-SAVE to print a space  
0c22			                                ; without disturbing registers  
0c22			  
0c22			;; PO-EACH  
0c22 1a			L0C22:  LD      A,(DE)          ; fetch character  
0c23 e6 7f		        AND     $7F             ; remove any inverted bit  
0c25 cd 3b 0c		        CALL    L0C3B           ; routine PO-SAVE to print using alternate  
0c28			                                ; set of registers.  
0c28 1a			        LD      A,(DE)          ; re-fetch character.  
0c29 13			        INC     DE              ; address next  
0c2a 87			        ADD     A,A             ; was character inverted ?  
0c2b			                                ; (this also doubles character)  
0c2b 30 f5		        JR      NC,L0C22        ; back to PO-EACH if not  
0c2d			  
0c2d d1			        POP     DE              ; * re-fetch trailing space flag to D (was A)  
0c2e fe 48		        CP      $48             ; was last character '$' ($24*2)  
0c30 28 03		        JR      Z,L0C35         ; forward to PO-TR-SP to consider trailing  
0c32			                                ; space if so.  
0c32			  
0c32 fe 82		        CP      $82             ; was it < 'A' i.e. '#','>','=' from tokens  
0c34			                                ; or ' ','.' (from tape) or '?' from scroll  
0c34 d8			        RET     C               ; no trailing space  
0c35			  
0c35			;; PO-TR-SP  
0c35 7a			L0C35:  LD      A,D             ; the trailing space flag (zero if an error msg)  
0c36 fe 03		        CP      $03             ; test against RND, INKEY$ and PI  
0c38			                                ; which have no parameters and  
0c38 d8			        RET     C               ; therefore no trailing space so return.  
0c39			  
0c39 3e 20		        LD      A,$20           ; else continue and print a trailing space.  
0c3b			  
0c3b			; -------------------------  
0c3b			; Handle recursive printing  
0c3b			; -------------------------  
0c3b			; This routine which is part of PRINT-OUT allows RST $10 to be  
0c3b			; used recursively to print tokens and the spaces associated with them.  
0c3b			  
0c3b			;; PO-SAVE  
0c3b d5			L0C3B:  PUSH    DE              ; save DE as CALL-SUB doesn't.  
0c3c d9			        EXX                     ; switch in main set  
0c3d			  
0c3d d7			        RST     10H             ; PRINT-A prints using this alternate set.  
0c3e			  
0c3e d9			        EXX                     ; back to this alternate set.  
0c3f d1			        POP     DE              ; restore initial DE.  
0c40 c9			        RET                     ; return.  
0c41			  
0c41			; ------------  
0c41			; Table search  
0c41			; ------------  
0c41			; This subroutine searches a message or the token table for the  
0c41			; message number held in A. DE holds the address of the table.  
0c41			  
0c41			;; PO-SEARCH  
0c41 f5			L0C41:  PUSH    AF              ; save the message/token number  
0c42 eb			        EX      DE,HL           ; transfer DE to HL  
0c43 3c			        INC     A               ; adjust for initial step-over byte  
0c44			  
0c44			;; PO-STEP  
0c44 cb 7e		L0C44:  BIT     7,(HL)          ; is character inverted ?  
0c46 23			        INC     HL              ; address next  
0c47 28 fb		        JR      Z,L0C44         ; back to PO-STEP if not inverted.  
0c49			  
0c49 3d			        DEC     A               ; decrease counter  
0c4a 20 f8		        JR      NZ,L0C44        ; back to PO-STEP if not zero  
0c4c			  
0c4c eb			        EX      DE,HL           ; transfer address to DE  
0c4d f1			        POP     AF              ; restore message/token number  
0c4e fe 20		        CP      $20             ; return with carry set  
0c50 d8			        RET     C               ; for all messages and function tokens  
0c51			  
0c51 1a			        LD      A,(DE)          ; test first character of token  
0c52 d6 41		        SUB     $41             ; and return with carry set  
0c54 c9			        RET                     ; if it is less that 'A'  
0c55			                                ; i.e. '<>', '<=', '>='  
0c55			  
0c55			; ---------------  
0c55			; Test for scroll  
0c55			; ---------------  
0c55			; This test routine is called when printing carriage return, when considering  
0c55			; PRINT AT and from the general PRINT ALL characters routine to test if  
0c55			; scrolling is required, prompting the user if necessary.  
0c55			; This is therefore using the alternate set.  
0c55			; The B register holds the current line.  
0c55			  
0c55			;; PO-SCR  
0c55 fd cb 01 4e	L0C55:  BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?  
0c59 c0			        RET     NZ              ; return immediately if so.  
0c5a			  
0c5a 11 d9 0d		        LD      DE,L0DD9        ; set DE to address: CL-SET  
0c5d d5			        PUSH    DE              ; and push for return address.  
0c5e 78			        LD      A,B             ; transfer the line to A.  
0c5f fd cb 02 46	        BIT     0,(IY+$02)      ; test TV_FLAG  - Lower screen in use ?  
0c63 c2 02 0d		        JP      NZ,L0D02        ; jump forward to PO-SCR-4 if so.  
0c66			  
0c66 fd be 31		        CP      (IY+$31)        ; greater than DF_SZ display file size ?  
0c69 38 1b		        JR      C,L0C86         ; forward to REPORT-5 if less.  
0c6b			                                ; 'Out of screen'  
0c6b			  
0c6b c0			        RET     NZ              ; return (via CL-SET) if greater  
0c6c			  
0c6c fd cb 02 66	        BIT     4,(IY+$02)      ; test TV_FLAG  - Automatic listing ?  
0c70 28 16		        JR      Z,L0C88         ; forward to PO-SCR-2 if not.  
0c72			  
0c72 fd 5e 2d		        LD      E,(IY+$2D)      ; fetch BREG - the count of scroll lines to E.  
0c75 1d			        DEC     E               ; decrease and jump  
0c76 28 5a		        JR      Z,L0CD2         ; to PO-SCR-3 if zero and scrolling required.  
0c78			  
0c78 3e 00		        LD      A,$00           ; explicit - select channel zero.  
0c7a cd 01 16		        CALL    L1601           ; routine CHAN-OPEN opens it.  
0c7d			  
0c7d ed 7b 3f 5c	        LD      SP,($5C3F)      ; set stack pointer to LIST_SP  
0c81			  
0c81 fd cb 02 a6	        RES     4,(IY+$02)      ; reset TV_FLAG  - signal auto listing finished.  
0c85 c9			        RET                     ; return ignoring pushed value, CL-SET  
0c86			                                ; to MAIN or EDITOR without updating  
0c86			                                ; print position                         ->  
0c86			  
0c86			; ---  
0c86			  
0c86			  
0c86			;; REPORT-5  
0c86 cf			L0C86:  RST     08H             ; ERROR-1  
0c87 04			        DEFB    $04             ; Error Report: Out of screen  
0c88			  
0c88			; continue here if not an automatic listing.  
0c88			  
0c88			;; PO-SCR-2  
0c88 fd 35 52		L0C88:  DEC     (IY+$52)        ; decrease SCR_CT  
0c8b 20 45		        JR      NZ,L0CD2        ; forward to PO-SCR-3 to scroll display if  
0c8d			                                ; result not zero.  
0c8d			  
0c8d			; now produce prompt.  
0c8d			  
0c8d 3e 18		        LD      A,$18           ; reset  
0c8f 90			        SUB     B               ; the  
0c90 32 8c 5c		        LD      ($5C8C),A       ; SCR_CT scroll count  
0c93 2a 8f 5c		        LD      HL,($5C8F)      ; L=ATTR_T, H=MASK_T  
0c96 e5			        PUSH    HL              ; save on stack  
0c97 3a 91 5c		        LD      A,($5C91)       ; P_FLAG  
0c9a f5			        PUSH    AF              ; save on stack to prevent lower screen  
0c9b			                                ; attributes (BORDCR etc.) being applied.  
0c9b 3e fd		        LD      A,$FD           ; select system channel 'K'  
0c9d cd 01 16		        CALL    L1601           ; routine CHAN-OPEN opens it  
0ca0 af			        XOR     A               ; clear to address message directly  
0ca1 11 f8 0c		        LD      DE,L0CF8        ; make DE address: scrl-mssg  
0ca4 cd 0a 0c		        CALL    L0C0A           ; routine PO-MSG prints to lower screen  
0ca7 fd cb 02 ee	        SET     5,(IY+$02)      ; set TV_FLAG  - signal lower screen requires  
0cab			                                ; clearing  
0cab 21 3b 5c		        LD      HL,$5C3B        ; make HL address FLAGS  
0cae cb de		        SET     3,(HL)          ; signal 'L' mode.  
0cb0 cb ae		        RES     5,(HL)          ; signal 'no new key'.  
0cb2 d9			        EXX                     ; switch to main set.  
0cb3			                                ; as calling chr input from alternative set.  
0cb3 cd d4 15		        CALL    L15D4           ; routine WAIT-KEY waits for new key  
0cb6			                                ; Note. this is the right routine but the  
0cb6			                                ; stream in use is unsatisfactory. From the  
0cb6			                                ; choices available, it is however the best.  
0cb6			  
0cb6 d9			        EXX                     ; switch back to alternate set.  
0cb7 fe 20		        CP      $20             ; space is considered as BREAK  
0cb9 28 45		        JR      Z,L0D00         ; forward to REPORT-D if so  
0cbb			                                ; 'BREAK - CONT repeats'  
0cbb			  
0cbb fe e2		        CP      $E2             ; is character 'STOP' ?  
0cbd 28 41		        JR      Z,L0D00         ; forward to REPORT-D if so  
0cbf			  
0cbf f6 20		        OR      $20             ; convert to lower-case  
0cc1 fe 6e		        CP      $6E             ; is character 'n' ?  
0cc3 28 3b		        JR      Z,L0D00         ; forward to REPORT-D if so else scroll.  
0cc5			  
0cc5 3e fe		        LD      A,$FE           ; select system channel 'S'  
0cc7 cd 01 16		        CALL    L1601           ; routine CHAN-OPEN  
0cca f1			        POP     AF              ; restore original P_FLAG  
0ccb 32 91 5c		        LD      ($5C91),A       ; and save in P_FLAG.  
0cce e1			        POP     HL              ; restore original ATTR_T, MASK_T  
0ccf 22 8f 5c		        LD      ($5C8F),HL      ; and reset ATTR_T, MASK-T as 'scroll?' has  
0cd2			                                ; been printed.  
0cd2			  
0cd2			;; PO-SCR-3  
0cd2 cd fe 0d		L0CD2:  CALL    L0DFE           ; routine CL-SC-ALL to scroll whole display  
0cd5 fd 46 31		        LD      B,(IY+$31)      ; fetch DF_SZ to B  
0cd8 04			        INC     B               ; increase to address last line of display  
0cd9 0e 21		        LD      C,$21           ; set C to $21 (was $21 from above routine)  
0cdb c5			        PUSH    BC              ; save the line and column in BC.  
0cdc			  
0cdc cd 9b 0e		        CALL    L0E9B           ; routine CL-ADDR finds display address.  
0cdf			  
0cdf 7c			        LD      A,H             ; now find the corresponding attribute byte  
0ce0 0f			        RRCA                    ; (this code sequence is used twice  
0ce1 0f			        RRCA                    ; elsewhere and is a candidate for  
0ce2 0f			        RRCA                    ; a subroutine.)  
0ce3 e6 03		        AND     $03             ;  
0ce5 f6 58		        OR      $58             ;  
0ce7 67			        LD      H,A             ;  
0ce8			  
0ce8 11 e0 5a		        LD      DE,$5AE0        ; start of last 'line' of attribute area  
0ceb 1a			        LD      A,(DE)          ; get attribute for last line  
0cec 4e			        LD      C,(HL)          ; transfer to base line of upper part  
0ced 06 20		        LD      B,$20           ; there are thirty two bytes  
0cef eb			        EX      DE,HL           ; swap the pointers.  
0cf0			  
0cf0			;; PO-SCR-3A  
0cf0 12			L0CF0:  LD      (DE),A          ; transfer  
0cf1 71			        LD      (HL),C          ; attributes.  
0cf2 13			        INC     DE              ; address next.  
0cf3 23			        INC     HL              ; address next.  
0cf4 10 fa		        DJNZ    L0CF0           ; loop back to PO-SCR-3A for all adjacent  
0cf6			                                ; attribute lines.  
0cf6			  
0cf6 c1			        POP     BC              ; restore the line/column.  
0cf7 c9			        RET                     ; return via CL-SET (was pushed on stack).  
0cf8			  
0cf8			; ---  
0cf8			  
0cf8			; The message 'scroll?' appears here with last byte inverted.  
0cf8			  
0cf8			;; scrl-mssg  
0cf8 80			L0CF8:  DEFB    $80             ; initial step-over byte.  
0cf9 ..			        DEFM    "scroll"  
0cff bf			        DEFB    $80+'?'  
0d00			  
0d00			;; REPORT-D  
0d00 cf			L0D00:  RST     08H             ; ERROR-1  
0d01 0c			        DEFB    $0C             ; Error Report: BREAK - CONT repeats  
0d02			  
0d02			; continue here if using lower display - A holds line number.  
0d02			  
0d02			;; PO-SCR-4  
0d02 fe 02		L0D02:  CP      $02             ; is line number less than 2 ?  
0d04 38 80		        JR      C,L0C86         ; to REPORT-5 if so  
0d06			                                ; 'Out of Screen'.  
0d06			  
0d06 fd 86 31		        ADD     A,(IY+$31)      ; add DF_SZ  
0d09 d6 19		        SUB     $19             ;  
0d0b d0			        RET     NC              ; return if scrolling unnecessary  
0d0c			  
0d0c ed 44		        NEG                     ; Negate to give number of scrolls required.  
0d0e c5			        PUSH    BC              ; save line/column  
0d0f 47			        LD      B,A             ; count to B  
0d10 2a 8f 5c		        LD      HL,($5C8F)      ; fetch current ATTR_T, MASK_T to HL.  
0d13 e5			        PUSH    HL              ; and save  
0d14 2a 91 5c		        LD      HL,($5C91)      ; fetch P_FLAG  
0d17 e5			        PUSH    HL              ; and save.  
0d18			                                ; to prevent corruption by input AT  
0d18			  
0d18 cd 4d 0d		        CALL    L0D4D           ; routine TEMPS sets to BORDCR etc  
0d1b 78			        LD      A,B             ; transfer scroll number to A.  
0d1c			  
0d1c			;; PO-SCR-4A  
0d1c f5			L0D1C:  PUSH    AF              ; save scroll number.  
0d1d 21 6b 5c		        LD      HL,$5C6B        ; address DF_SZ  
0d20 46			        LD      B,(HL)          ; fetch old value  
0d21 78			        LD      A,B             ; transfer to A  
0d22 3c			        INC     A               ; and increment  
0d23 77			        LD      (HL),A          ; then put back.  
0d24 21 89 5c		        LD      HL,$5C89        ; address S_POSN_hi - line  
0d27 be			        CP      (HL)            ; compare  
0d28 38 03		        JR      C,L0D2D         ; forward to PO-SCR-4B if scrolling required  
0d2a			  
0d2a 34			        INC     (HL)            ; else increment S_POSN_hi  
0d2b 06 18		        LD      B,$18           ; set count to whole display ??  
0d2d			                                ; Note. should be $17 and the top line  
0d2d			                                ; will be scrolled into the ROM which  
0d2d			                                ; is harmless on the standard set up.  
0d2d			  
0d2d			;; PO-SCR-4B  
0d2d cd 00 0e		L0D2D:  CALL    L0E00           ; routine CL-SCROLL scrolls B lines  
0d30 f1			        POP     AF              ; restore scroll counter.  
0d31 3d			        DEC     A               ; decrease  
0d32 20 e8		        JR      NZ,L0D1C        ; back to to PO-SCR-4A until done  
0d34			  
0d34 e1			        POP     HL              ; restore original P_FLAG.  
0d35 fd 75 57		        LD      (IY+$57),L      ; and overwrite system variable P_FLAG.  
0d38			  
0d38 e1			        POP     HL              ; restore original ATTR_T/MASK_T.  
0d39 22 8f 5c		        LD      ($5C8F),HL      ; and update system variables.  
0d3c			  
0d3c ed 4b 88 5c	        LD      BC,($5C88)      ; fetch S_POSN to BC.  
0d40 fd cb 02 86	        RES     0,(IY+$02)      ; signal to TV_FLAG  - main screen in use.  
0d44 cd d9 0d		        CALL    L0DD9           ; call routine CL-SET for upper display.  
0d47			  
0d47 fd cb 02 c6	        SET     0,(IY+$02)      ; signal to TV_FLAG  - lower screen in use.  
0d4b c1			        POP     BC              ; restore line/column  
0d4c c9			        RET                     ; return via CL-SET for lower display.  
0d4d			  
0d4d			; ----------------------  
0d4d			; Temporary colour items  
0d4d			; ----------------------  
0d4d			; This subroutine is called 11 times to copy the permanent colour items  
0d4d			; to the temporary ones.  
0d4d			  
0d4d			;; TEMPS  
0d4d af			L0D4D:  XOR     A               ; clear the accumulator  
0d4e 2a 8d 5c		        LD      HL,($5C8D)      ; fetch L=ATTR_P and H=MASK_P  
0d51 fd cb 02 46	        BIT     0,(IY+$02)      ; test TV_FLAG  - is lower screen in use ?  
0d55 28 04		        JR      Z,L0D5B         ; skip to TEMPS-1 if not  
0d57			  
0d57 67			        LD      H,A             ; set H, MASK P, to 00000000.  
0d58 fd 6e 0e		        LD      L,(IY+$0E)      ; fetch BORDCR to L which is used for lower  
0d5b			                                ; screen.  
0d5b			  
0d5b			;; TEMPS-1  
0d5b 22 8f 5c		L0D5B:  LD      ($5C8F),HL      ; transfer values to ATTR_T and MASK_T  
0d5e			  
0d5e			; for the print flag the permanent values are odd bits, temporary even bits.  
0d5e			  
0d5e 21 91 5c		        LD      HL,$5C91        ; address P_FLAG.  
0d61 20 02		        JR      NZ,L0D65        ; skip to TEMPS-2 if lower screen using A=0.  
0d63			  
0d63 7e			        LD      A,(HL)          ; else pick up flag bits.  
0d64 0f			        RRCA                    ; rotate permanent bits to temporary bits.  
0d65			  
0d65			;; TEMPS-2  
0d65 ae			L0D65:  XOR     (HL)            ;  
0d66 e6 55		        AND     $55             ; BIN 01010101  
0d68 ae			        XOR     (HL)            ; permanent now as original  
0d69 77			        LD      (HL),A          ; apply permanent bits to temporary bits.  
0d6a c9			        RET                     ; and return.  
0d6b			  
0d6b			; ------------------  
0d6b			; Handle CLS command  
0d6b			; ------------------  
0d6b			; clears the display.  
0d6b			; if it's difficult to write it should be difficult to read.  
0d6b			  
0d6b			;; CLS  
0d6b cd af 0d		L0D6B:  CALL    L0DAF           ; routine CL-ALL  clears display and  
0d6e			                                ; resets attributes to permanent.  
0d6e			                                ; re-attaches it to this computer.  
0d6e			  
0d6e			; this routine called from INPUT, **  
0d6e			  
0d6e			;; CLS-LOWER  
0d6e 21 3c 5c		L0D6E:  LD      HL,$5C3C        ; address System Variable TV_FLAG.  
0d71 cb ae		        RES     5,(HL)          ; TV_FLAG - signal do not clear lower screen.  
0d73 cb c6		        SET     0,(HL)          ; TV_FLAG - signal lower screen in use.  
0d75 cd 4d 0d		        CALL    L0D4D           ; routine TEMPS picks up temporary colours.  
0d78 fd 46 31		        LD      B,(IY+$31)      ; fetch lower screen DF_SZ  
0d7b cd 44 0e		        CALL    L0E44           ; routine CL-LINE clears lower part  
0d7e			                                ; and sets permanent attributes.  
0d7e			  
0d7e 21 c0 5a		        LD      HL,$5AC0        ; fetch attribute address leftmost cell,  
0d81			                                ; second line up.  
0d81 3a 8d 5c		        LD      A,($5C8D)       ; fetch permanent attribute from ATTR_P.  
0d84 05			        DEC     B               ; decrement lower screen display file size  
0d85 18 07		        JR      L0D8E           ; forward to CLS-3 ->  
0d87			  
0d87			; ---  
0d87			  
0d87			;; CLS-1  
0d87 0e 20		L0D87:  LD      C,$20           ; set counter to 32 characters per line  
0d89			  
0d89			;; CLS-2  
0d89 2b			L0D89:  DEC     HL              ; decrease attribute address.  
0d8a 77			        LD      (HL),A          ; and place attributes in next line up.  
0d8b 0d			        DEC     C               ; decrease 32 counter.  
0d8c 20 fb		        JR      NZ,L0D89        ; loop back to CLS-2 until all 32 done.  
0d8e			  
0d8e			;; CLS-3  
0d8e 10 f7		L0D8E:  DJNZ    L0D87           ; decrease B counter and back to CLS-1  
0d90			                                ; if not zero.  
0d90			  
0d90 fd 36 31 02	        LD      (IY+$31),$02    ; set DF_SZ lower screen to 2  
0d94			  
0d94			; This entry point is called from CL-ALL below to  
0d94			; reset the system channel input and output addresses to normal.  
0d94			  
0d94			;; CL-CHAN  
0d94 3e fd		L0D94:  LD      A,$FD           ; select system channel 'K'  
0d96 cd 01 16		        CALL    L1601           ; routine CHAN-OPEN opens it.  
0d99 2a 51 5c		        LD      HL,($5C51)      ; fetch CURCHL to HL to address current channel  
0d9c 11 f4 09		        LD      DE,L09F4        ; set address to PRINT-OUT for first pass.  
0d9f a7			        AND     A               ; clear carry for first pass.  
0da0			  
0da0			;; CL-CHAN-A  
0da0 73			L0DA0:  LD      (HL),E          ; insert output address first pass.  
0da1 23			        INC     HL              ; or input address on second pass.  
0da2 72			        LD      (HL),D          ;  
0da3 23			        INC     HL              ;  
0da4 11 a8 10		        LD      DE,L10A8        ; fetch address KEY-INPUT for second pass  
0da7 3f			        CCF                     ; complement carry flag - will set on pass 1.  
0da8			  
0da8 38 f6		        JR      C,L0DA0         ; back to CL-CHAN-A if first pass else done.  
0daa			  
0daa 01 21 17		        LD      BC,$1721        ; line 23 for lower screen  
0dad 18 2a		        JR      L0DD9           ; exit via CL-SET to set column  
0daf			                                ; for lower display  
0daf			  
0daf			; ---------------------------  
0daf			; Clearing whole display area  
0daf			; ---------------------------  
0daf			; This subroutine called from CLS, AUTO-LIST and MAIN-3  
0daf			; clears 24 lines of the display and resets the relevant system variables  
0daf			; and system channels.  
0daf			  
0daf			;; CL-ALL  
0daf 21 00 00		L0DAF:  LD      HL,$0000        ; initialize plot coordinates.  
0db2 22 7d 5c		        LD      ($5C7D),HL      ; set COORDS to 0,0.  
0db5 fd cb 30 86	        RES     0,(IY+$30)      ; update FLAGS2  - signal main screen is clear.  
0db9			  
0db9 cd 94 0d		        CALL    L0D94           ; routine CL-CHAN makes channel 'K' 'normal'.  
0dbc			  
0dbc 3e fe		        LD      A,$FE           ; select system channel 'S'  
0dbe cd 01 16		        CALL    L1601           ; routine CHAN-OPEN opens it  
0dc1 cd 4d 0d		        CALL    L0D4D           ; routine TEMPS picks up permanent values.  
0dc4 06 18		        LD      B,$18           ; There are 24 lines.  
0dc6 cd 44 0e		        CALL    L0E44           ; routine CL-LINE clears 24 text lines  
0dc9			                                ; (and sets BC to $1821)  
0dc9			  
0dc9 2a 51 5c		        LD      HL,($5C51)      ; fetch CURCHL make HL address current  
0dcc			                                ; channel 'S'  
0dcc 11 f4 09		        LD      DE,L09F4        ; address: PRINT-OUT  
0dcf 73			        LD      (HL),E          ; is made  
0dd0 23			        INC     HL              ; the normal  
0dd1 72			        LD      (HL),D          ; output address.  
0dd2			  
0dd2 fd 36 52 01	        LD      (IY+$52),$01    ; set SCR_CT - scroll count is set to default.  
0dd6			                                ; Note. BC already contains $1821.  
0dd6 01 21 18		        LD      BC,$1821        ; reset column and line to 0,0  
0dd9			                                ; and continue into CL-SET, below, exiting  
0dd9			                                ; via PO-STORE (for upper screen).  
0dd9			  
0dd9			; ---------------------------  
0dd9			; Set line and column numbers  
0dd9			; ---------------------------  
0dd9			; This important subroutine is used to calculate the character output  
0dd9			; address for screens or printer based on the line/column for screens  
0dd9			; or the column for printer.  
0dd9			  
0dd9			;; CL-SET  
0dd9 21 00 5b		L0DD9:  LD      HL,$5B00        ; the base address of printer buffer  
0ddc fd cb 01 4e	        BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?  
0de0 20 12		        JR      NZ,L0DF4        ; forward to CL-SET-2 if so.  
0de2			  
0de2 78			        LD      A,B             ; transfer line to A.  
0de3 fd cb 02 46	        BIT     0,(IY+$02)      ; test TV_FLAG  - lower screen in use ?  
0de7 28 05		        JR      Z,L0DEE         ; skip to CL-SET-1 if handling upper part  
0de9			  
0de9 fd 86 31		        ADD     A,(IY+$31)      ; add DF_SZ for lower screen  
0dec d6 18		        SUB     $18             ; and adjust.  
0dee			  
0dee			;; CL-SET-1  
0dee c5			L0DEE:  PUSH    BC              ; save the line/column.  
0def 47			        LD      B,A             ; transfer line to B  
0df0			                                ; (adjusted if lower screen)  
0df0			  
0df0 cd 9b 0e		        CALL    L0E9B           ; routine CL-ADDR calculates address at left  
0df3			                                ; of screen.  
0df3 c1			        POP     BC              ; restore the line/column.  
0df4			  
0df4			;; CL-SET-2  
0df4 3e 21		L0DF4:  LD      A,$21           ; the column $1-$21 is reversed  
0df6 91			        SUB     C               ; to range $00 - $20  
0df7 5f			        LD      E,A             ; now transfer to DE  
0df8 16 00		        LD      D,$00           ; prepare for addition  
0dfa 19			        ADD     HL,DE           ; and add to base address  
0dfb c3 dc 0a		        JP      L0ADC           ; exit via PO-STORE to update relevant  
0dfe			                                ; system variables.  
0dfe			; ----------------  
0dfe			; Handle scrolling  
0dfe			; ----------------  
0dfe			; The routine CL-SC-ALL is called once from PO to scroll all the display  
0dfe			; and from the routine CL-SCROLL, once, to scroll part of the display.  
0dfe			  
0dfe			;; CL-SC-ALL  
0dfe 06 17		L0DFE:  LD      B,$17           ; scroll 23 lines, after 'scroll?'.  
0e00			  
0e00			;; CL-SCROLL  
0e00 cd 9b 0e		L0E00:  CALL    L0E9B           ; routine CL-ADDR gets screen address in HL.  
0e03 0e 08		        LD      C,$08           ; there are 8 pixel lines to scroll.  
0e05			  
0e05			;; CL-SCR-1  
0e05 c5			L0E05:  PUSH    BC              ; save counters.  
0e06 e5			        PUSH    HL              ; and initial address.  
0e07 78			        LD      A,B             ; get line count.  
0e08 e6 07		        AND     $07             ; will set zero if all third to be scrolled.  
0e0a 78			        LD      A,B             ; re-fetch the line count.  
0e0b 20 0c		        JR      NZ,L0E19        ; forward to CL-SCR-3 if partial scroll.  
0e0d			  
0e0d			; HL points to top line of third and must be copied to bottom of previous 3rd.  
0e0d			; ( so HL = $4800 or $5000 ) ( but also sometimes $4000 )  
0e0d			  
0e0d			;; CL-SCR-2  
0e0d eb			L0E0D:  EX      DE,HL           ; copy HL to DE.  
0e0e 21 e0 f8		        LD      HL,$F8E0        ; subtract $08 from H and add $E0 to L -  
0e11 19			        ADD     HL,DE           ; to make destination bottom line of previous  
0e12			                                ; third.  
0e12 eb			        EX      DE,HL           ; restore the source and destination.  
0e13 01 20 00		        LD      BC,$0020        ; thirty-two bytes are to be copied.  
0e16 3d			        DEC     A               ; decrement the line count.  
0e17 ed b0		        LDIR                    ; copy a pixel line to previous third.  
0e19			  
0e19			;; CL-SCR-3  
0e19 eb			L0E19:  EX      DE,HL           ; save source in DE.  
0e1a 21 e0 ff		        LD      HL,$FFE0        ; load the value -32.  
0e1d 19			        ADD     HL,DE           ; add to form destination in HL.  
0e1e eb			        EX      DE,HL           ; switch source and destination  
0e1f 47			        LD      B,A             ; save the count in B.  
0e20 e6 07		        AND     $07             ; mask to find count applicable to current  
0e22 0f			        RRCA                    ; third and  
0e23 0f			        RRCA                    ; multiply by  
0e24 0f			        RRCA                    ; thirty two (same as 5 RLCAs)  
0e25			  
0e25 4f			        LD      C,A             ; transfer byte count to C ($E0 at most)  
0e26 78			        LD      A,B             ; store line count to A  
0e27 06 00		        LD      B,$00           ; make B zero  
0e29 ed b0		        LDIR                    ; copy bytes (BC=0, H incremented, L=0)  
0e2b 06 07		        LD      B,$07           ; set B to 7, C is zero.  
0e2d 09			        ADD     HL,BC           ; add 7 to H to address next third.  
0e2e e6 f8		        AND     $F8             ; has last third been done ?  
0e30 20 db		        JR      NZ,L0E0D        ; back to CL-SCR-2 if not  
0e32			  
0e32 e1			        POP     HL              ; restore topmost address.  
0e33 24			        INC     H               ; next pixel line down.  
0e34 c1			        POP     BC              ; restore counts.  
0e35 0d			        DEC     C               ; reduce pixel line count.  
0e36 20 cd		        JR      NZ,L0E05        ; back to CL-SCR-1 if all eight not done.  
0e38			  
0e38 cd 88 0e		        CALL    L0E88           ; routine CL-ATTR gets address in attributes  
0e3b			                                ; from current 'ninth line', count in BC.  
0e3b 21 e0 ff		        LD      HL,$FFE0        ; set HL to the 16-bit value -32.  
0e3e 19			        ADD     HL,DE           ; and add to form destination address.  
0e3f eb			        EX      DE,HL           ; swap source and destination addresses.  
0e40 ed b0		        LDIR                    ; copy bytes scrolling the linear attributes.  
0e42 06 01		        LD      B,$01           ; continue to clear the bottom line.  
0e44			  
0e44			; ---------------------------  
0e44			; Clear text lines of display  
0e44			; ---------------------------  
0e44			; This subroutine, called from CL-ALL, CLS-LOWER and AUTO-LIST and above,  
0e44			; clears text lines at bottom of display.  
0e44			; The B register holds on entry the number of lines to be cleared 1-24.  
0e44			  
0e44			;; CL-LINE  
0e44 c5			L0E44:  PUSH    BC              ; save line count  
0e45 cd 9b 0e		        CALL    L0E9B           ; routine CL-ADDR gets top address  
0e48 0e 08		        LD      C,$08           ; there are eight screen lines to a text line.  
0e4a			  
0e4a			;; CL-LINE-1  
0e4a c5			L0E4A:  PUSH    BC              ; save pixel line count  
0e4b e5			        PUSH    HL              ; and save the address  
0e4c 78			        LD      A,B             ; transfer the line to A (1-24).  
0e4d			  
0e4d			;; CL-LINE-2  
0e4d e6 07		L0E4D:  AND     $07             ; mask 0-7 to consider thirds at a time  
0e4f 0f			        RRCA                    ; multiply  
0e50 0f			        RRCA                    ; by 32  (same as five RLCA instructions)  
0e51 0f			        RRCA                    ; now 32 - 256(0)  
0e52 4f			        LD      C,A             ; store result in C  
0e53 78			        LD      A,B             ; save line in A (1-24)  
0e54 06 00		        LD      B,$00           ; set high byte to 0, prepare for ldir.  
0e56 0d			        DEC     C               ; decrement count 31-255.  
0e57 54			        LD      D,H             ; copy HL  
0e58 5d			        LD      E,L             ; to DE.  
0e59 36 00		        LD      (HL),$00        ; blank the first byte.  
0e5b 13			        INC     DE              ; make DE point to next byte.  
0e5c ed b0		        LDIR                    ; ldir will clear lines.  
0e5e 11 01 07		        LD      DE,$0701        ; now address next third adjusting  
0e61 19			        ADD     HL,DE           ; register E to address left hand side  
0e62 3d			        DEC     A               ; decrease the line count.  
0e63 e6 f8		        AND     $F8             ; will be 16, 8 or 0  (AND $18 will do).  
0e65 47			        LD      B,A             ; transfer count to B.  
0e66 20 e5		        JR      NZ,L0E4D        ; back to CL-LINE-2 if 16 or 8 to do  
0e68			                                ; the next third.  
0e68			  
0e68 e1			        POP     HL              ; restore start address.  
0e69 24			        INC     H               ; address next line down.  
0e6a c1			        POP     BC              ; fetch counts.  
0e6b 0d			        DEC     C               ; decrement pixel line count  
0e6c 20 dc		        JR      NZ,L0E4A        ; back to CL-LINE-1 till all done.  
0e6e			  
0e6e cd 88 0e		        CALL    L0E88           ; routine CL-ATTR gets attribute address  
0e71			                                ; in DE and B * 32 in BC.  
0e71 62			        LD      H,D             ; transfer the address  
0e72 6b			        LD      L,E             ; to HL.  
0e73			  
0e73 13			        INC     DE              ; make DE point to next location.  
0e74			  
0e74 3a 8d 5c		        LD      A,($5C8D)       ; fetch ATTR_P - permanent attributes  
0e77 fd cb 02 46	        BIT     0,(IY+$02)      ; test TV_FLAG  - lower screen in use ?  
0e7b 28 03		        JR      Z,L0E80         ; skip to CL-LINE-3 if not.  
0e7d			  
0e7d 3a 48 5c		        LD      A,($5C48)       ; else lower screen uses BORDCR as attribute.  
0e80			  
0e80			;; CL-LINE-3  
0e80 77			L0E80:  LD      (HL),A          ; put attribute in first byte.  
0e81 0b			        DEC     BC              ; decrement the counter.  
0e82 ed b0		        LDIR                    ; copy bytes to set all attributes.  
0e84 c1			        POP     BC              ; restore the line $01-$24.  
0e85 0e 21		        LD      C,$21           ; make column $21. (No use is made of this)  
0e87 c9			        RET                     ; return to the calling routine.  
0e88			  
0e88			; ------------------  
0e88			; Attribute handling  
0e88			; ------------------  
0e88			; This subroutine is called from CL-LINE or CL-SCROLL with the HL register  
0e88			; pointing to the 'ninth' line and H needs to be decremented before or after  
0e88			; the division. Had it been done first then either present code or that used  
0e88			; at the start of PO-ATTR could have been used.  
0e88			; The Spectrum screen arrangement leads to the L register holding already  
0e88			; the correct value for the attribute file and it is only necessary  
0e88			; to manipulate H to form the correct colour attribute address.  
0e88			  
0e88			;; CL-ATTR  
0e88 7c			L0E88:  LD      A,H             ; fetch H to A - $48, $50, or $58.  
0e89 0f			        RRCA                    ; divide by  
0e8a 0f			        RRCA                    ; eight.  
0e8b 0f			        RRCA                    ; $09, $0A or $0B.  
0e8c 3d			        DEC     A               ; $08, $09 or $0A.  
0e8d f6 50		        OR      $50             ; $58, $59 or $5A.  
0e8f 67			        LD      H,A             ; save high byte of attributes.  
0e90			  
0e90 eb			        EX      DE,HL           ; transfer attribute address to DE  
0e91 61			        LD      H,C             ; set H to zero - from last LDIR.  
0e92 68			        LD      L,B             ; load L with the line from B.  
0e93 29			        ADD     HL,HL           ; multiply  
0e94 29			        ADD     HL,HL           ; by  
0e95 29			        ADD     HL,HL           ; thirty two  
0e96 29			        ADD     HL,HL           ; to give count of attribute  
0e97 29			        ADD     HL,HL           ; cells to end of display.  
0e98			  
0e98 44			        LD      B,H             ; transfer result  
0e99 4d			        LD      C,L             ; to register BC.  
0e9a			  
0e9a c9			        RET                     ; and return.  
0e9b			  
0e9b			; -------------------------------  
0e9b			; Handle display with line number  
0e9b			; -------------------------------  
0e9b			; This subroutine is called from four places to calculate the address  
0e9b			; of the start of a screen character line which is supplied in B.  
0e9b			  
0e9b			;; CL-ADDR  
0e9b 3e 18		L0E9B:  LD      A,$18           ; reverse the line number  
0e9d 90			        SUB     B               ; to range $00 - $17.  
0e9e 57			        LD      D,A             ; save line in D for later.  
0e9f 0f			        RRCA                    ; multiply  
0ea0 0f			        RRCA                    ; by  
0ea1 0f			        RRCA                    ; thirty-two.  
0ea2			  
0ea2 e6 e0		        AND     $E0             ; mask off low bits to make  
0ea4 6f			        LD      L,A             ; L a multiple of 32.  
0ea5			  
0ea5 7a			        LD      A,D             ; bring back the line to A.  
0ea6			  
0ea6 e6 18		        AND     $18             ; now $00, $08 or $10.  
0ea8			  
0ea8 f6 40		        OR      $40             ; add the base address of screen.  
0eaa			  
0eaa 67			        LD      H,A             ; HL now has the correct address.  
0eab c9			        RET                     ; return.  
0eac			  
0eac			; -------------------  
0eac			; Handle COPY command  
0eac			; -------------------  
0eac			; This command copies the top 176 lines to the ZX Printer  
0eac			; It is popular to call this from machine code at point  
0eac			; L0EAF with B holding 192 (and interrupts disabled) for a full-screen  
0eac			; copy. This particularly applies to 16K Spectrums as time-critical  
0eac			; machine code routines cannot be written in the first 16K of RAM as  
0eac			; it is shared with the ULA which has precedence over the Z80 chip.  
0eac			  
0eac			;; COPY  
0eac			  
0eac f3			L0EAC:  DI                      ; disable interrupts as this is time-critical.  
0ead			  
0ead 06 b0		        LD      B,$B0           ; top 176 lines.  
0eaf 21 00 40		L0EAF:  LD      HL,$4000        ; address start of the display file.  
0eb2			  
0eb2			; now enter a loop to handle each pixel line.  
0eb2			  
0eb2			;; COPY-1  
0eb2 e5			L0EB2:  PUSH    HL              ; save the screen address.  
0eb3 c5			        PUSH    BC              ; and the line counter.  
0eb4			  
0eb4 cd f4 0e		        CALL    L0EF4           ; routine COPY-LINE outputs one line.  
0eb7			  
0eb7 c1			        POP     BC              ; restore the line counter.  
0eb8 e1			        POP     HL              ; and display address.  
0eb9 24			        INC     H               ; next line down screen within 'thirds'.  
0eba 7c			        LD      A,H             ; high byte to A.  
0ebb e6 07		        AND     $07             ; result will be zero if we have left third.  
0ebd 20 0a		        JR      NZ,L0EC9        ; forward to COPY-2 if not to continue loop.  
0ebf			  
0ebf 7d			        LD      A,L             ; consider low byte first.  
0ec0 c6 20		        ADD     A,$20           ; increase by 32 - sets carry if back to zero.  
0ec2 6f			        LD      L,A             ; will be next group of 8.  
0ec3 3f			        CCF                     ; complement - carry set if more lines in  
0ec4			                                ; the previous third.  
0ec4 9f			        SBC     A,A             ; will be FF, if more, else 00.  
0ec5 e6 f8		        AND     $F8             ; will be F8 (-8) or 00.  
0ec7 84			        ADD     A,H             ; that is subtract 8, if more to do in third.  
0ec8 67			        LD      H,A             ; and reset address.  
0ec9			  
0ec9			;; COPY-2  
0ec9 10 e7		L0EC9:  DJNZ    L0EB2           ; back to COPY-1 for all lines.  
0ecb			  
0ecb 18 0d		        JR      L0EDA           ; forward to COPY-END to switch off the printer  
0ecd			                                ; motor and enable interrupts.  
0ecd			                                ; Note. Nothing else required.  
0ecd			  
0ecd			; ------------------------------  
0ecd			; Pass printer buffer to printer  
0ecd			; ------------------------------  
0ecd			; This routine is used to copy 8 text lines from the printer buffer  
0ecd			; to the ZX Printer. These text lines are mapped linearly so HL does  
0ecd			; not need to be adjusted at the end of each line.  
0ecd			  
0ecd			;; COPY-BUFF  
0ecd f3			L0ECD:  DI                      ; disable interrupts  
0ece 21 00 5b		        LD      HL,$5B00        ; the base address of the Printer Buffer.  
0ed1 06 08		        LD      B,$08           ; set count to 8 lines of 32 bytes.  
0ed3			  
0ed3			;; COPY-3  
0ed3 c5			L0ED3:  PUSH    BC              ; save counter.  
0ed4 cd f4 0e		        CALL    L0EF4           ; routine COPY-LINE outputs 32 bytes  
0ed7 c1			        POP     BC              ; restore counter.  
0ed8 10 f9		        DJNZ    L0ED3           ; loop back to COPY-3 for all 8 lines.  
0eda			                                ; then stop motor and clear buffer.  
0eda			  
0eda			; Note. the COPY command rejoins here, essentially to execute the next  
0eda			; three instructions.  
0eda			  
0eda			;; COPY-END  
0eda 3e 04		L0EDA:  LD      A,$04           ; output value 4 to port  
0edc d3 fb		        OUT     ($FB),A         ; to stop the slowed printer motor.  
0ede fb			        EI                      ; enable interrupts.  
0edf			  
0edf			; --------------------  
0edf			; Clear Printer Buffer  
0edf			; --------------------  
0edf			; This routine clears an arbitrary 256 bytes of memory.  
0edf			; Note. The routine seems designed to clear a buffer that follows the  
0edf			; system variables.  
0edf			; The routine should check a flag or HL address and simply return if COPY  
0edf			; is in use.  
0edf			; (T-ADDR-lo would work for the system but not if COPY called externally.)  
0edf			; As a consequence of this omission the buffer will needlessly  
0edf			; be cleared when COPY is used and the screen/printer position may be set to  
0edf			; the start of the buffer and the line number to 0 (B)  
0edf			; giving an 'Out of Screen' error.  
0edf			; There seems to have been an unsuccessful attempt to circumvent the use  
0edf			; of PR_CC_hi.  
0edf			  
0edf			;; CLEAR-PRB  
0edf 21 00 5b		L0EDF:  LD      HL,$5B00        ; the location of the buffer.  
0ee2 fd 75 46		        LD      (IY+$46),L      ; update PR_CC_lo - set to zero - superfluous.  
0ee5 af			        XOR     A               ; clear the accumulator.  
0ee6 47			        LD      B,A             ; set count to 256 bytes.  
0ee7			  
0ee7			;; PRB-BYTES  
0ee7 77			L0EE7:  LD      (HL),A          ; set addressed location to zero.  
0ee8 23			        INC     HL              ; address next byte - Note. not INC L.  
0ee9 10 fc		        DJNZ    L0EE7           ; back to PRB-BYTES. repeat for 256 bytes.  
0eeb			  
0eeb fd cb 30 8e	        RES     1,(IY+$30)      ; set FLAGS2 - signal printer buffer is clear.  
0eef 0e 21		        LD      C,$21           ; set the column position .  
0ef1 c3 d9 0d		        JP      L0DD9           ; exit via CL-SET and then PO-STORE.  
0ef4			  
0ef4			; -----------------  
0ef4			; Copy line routine  
0ef4			; -----------------  
0ef4			; This routine is called from COPY and COPY-BUFF to output a line of  
0ef4			; 32 bytes to the ZX Printer.  
0ef4			; Output to port $FB -  
0ef4			; bit 7 set - activate stylus.  
0ef4			; bit 7 low - deactivate stylus.  
0ef4			; bit 2 set - stops printer.  
0ef4			; bit 2 reset - starts printer  
0ef4			; bit 1 set - slows printer.  
0ef4			; bit 1 reset - normal speed.  
0ef4			  
0ef4			;; COPY-LINE  
0ef4 78			L0EF4:  LD      A,B             ; fetch the counter 1-8 or 1-176  
0ef5 fe 03		        CP      $03             ; is it 01 or 02 ?.  
0ef7 9f			        SBC     A,A             ; result is $FF if so else $00.  
0ef8 e6 02		        AND     $02             ; result is 02 now else 00.  
0efa			                                ; bit 1 set slows the printer.  
0efa d3 fb		        OUT     ($FB),A         ; slow the printer for the  
0efc			                                ; last two lines.  
0efc 57			        LD      D,A             ; save the mask to control the printer later.  
0efd			  
0efd			;; COPY-L-1  
0efd cd 54 1f		L0EFD:  CALL    L1F54           ; call BREAK-KEY to read keyboard immediately.  
0f00 38 0a		        JR      C,L0F0C         ; forward to COPY-L-2 if 'break' not pressed.  
0f02			  
0f02 3e 04		        LD      A,$04           ; else stop the  
0f04 d3 fb		        OUT     ($FB),A         ; printer motor.  
0f06 fb			        EI                      ; enable interrupts.  
0f07 cd df 0e		        CALL    L0EDF           ; call routine CLEAR-PRB.  
0f0a			                                ; Note. should not be cleared if COPY in use.  
0f0a			  
0f0a			;; REPORT-Dc  
0f0a cf			L0F0A:  RST     08H             ; ERROR-1  
0f0b 0c			        DEFB    $0C             ; Error Report: BREAK - CONT repeats  
0f0c			  
0f0c			;; COPY-L-2  
0f0c db fb		L0F0C:  IN      A,($FB)         ; test now to see if  
0f0e 87			        ADD     A,A             ; a printer is attached.  
0f0f f8			        RET     M               ; return if not - but continue with parent  
0f10			                                ; command.  
0f10			  
0f10 30 eb		        JR      NC,L0EFD        ; back to COPY-L-1 if stylus of printer not  
0f12			                                ; in position.  
0f12			  
0f12 0e 20		        LD      C,$20           ; set count to 32 bytes.  
0f14			  
0f14			;; COPY-L-3  
0f14 5e			L0F14:  LD      E,(HL)          ; fetch a byte from line.  
0f15 23			        INC     HL              ; address next location. Note. not INC L.  
0f16 06 08		        LD      B,$08           ; count the bits.  
0f18			  
0f18			;; COPY-L-4  
0f18 cb 12		L0F18:  RL      D               ; prepare mask to receive bit.  
0f1a cb 13		        RL      E               ; rotate leftmost print bit to carry  
0f1c cb 1a		        RR      D               ; and back to bit 7 of D restoring bit 1  
0f1e			  
0f1e			;; COPY-L-5  
0f1e db fb		L0F1E:  IN      A,($FB)         ; read the port.  
0f20 1f			        RRA                     ; bit 0 to carry.  
0f21 30 fb		        JR      NC,L0F1E        ; back to COPY-L-5 if stylus not in position.  
0f23			  
0f23 7a			        LD      A,D             ; transfer command bits to A.  
0f24 d3 fb		        OUT     ($FB),A         ; and output to port.  
0f26 10 f0		        DJNZ    L0F18           ; loop back to COPY-L-4 for all 8 bits.  
0f28			  
0f28 0d			        DEC     C               ; decrease the byte count.  
0f29 20 e9		        JR      NZ,L0F14        ; back to COPY-L-3 until 256 bits done.  
0f2b			  
0f2b c9			        RET                     ; return to calling routine COPY/COPY-BUFF.  
0f2c			  
0f2c			  
0f2c			; ----------------------------------  
0f2c			; Editor routine for BASIC and INPUT  
0f2c			; ----------------------------------  
0f2c			; The editor is called to prepare or edit a BASIC line.  
0f2c			; It is also called from INPUT to input a numeric or string expression.  
0f2c			; The behaviour and options are quite different in the various modes  
0f2c			; and distinguished by bit 5 of FLAGX.  
0f2c			;  
0f2c			; This is a compact and highly versatile routine.  
0f2c			  
0f2c			;; EDITOR  
0f2c 2a 3d 5c		L0F2C:  LD      HL,($5C3D)      ; fetch ERR_SP  
0f2f e5			        PUSH    HL              ; save on stack  
0f30			  
0f30			;; ED-AGAIN  
0f30 21 7f 10		L0F30:  LD      HL,L107F        ; address: ED-ERROR  
0f33 e5			        PUSH    HL              ; save address on stack and  
0f34 ed 73 3d 5c	        LD      ($5C3D),SP      ; make ERR_SP point to it.  
0f38			  
0f38			; Note. While in editing/input mode should an error occur then RST 08 will  
0f38			; update X_PTR to the location reached by CH_ADD and jump to ED-ERROR  
0f38			; where the error will be cancelled and the loop begin again from ED-AGAIN  
0f38			; above. The position of the error will be apparent when the lower screen is  
0f38			; reprinted. If no error then the re-iteration is to ED-LOOP below when  
0f38			; input is arriving from the keyboard.  
0f38			  
0f38			;; ED-LOOP  
0f38 cd d4 15		L0F38:  CALL    L15D4           ; routine WAIT-KEY gets key possibly  
0f3b			                                ; changing the mode.  
0f3b f5			        PUSH    AF              ; save key.  
0f3c 16 00		        LD      D,$00           ; and give a short click based  
0f3e fd 5e ff		        LD      E,(IY-$01)      ; on PIP value for duration.  
0f41 21 c8 00		        LD      HL,$00C8        ; and pitch.  
0f44 cd b5 03		        CALL    L03B5           ; routine BEEPER gives click - effective  
0f47			                                ; with rubber keyboard.  
0f47 f1			        POP     AF              ; get saved key value.  
0f48 21 38 0f		        LD      HL,L0F38        ; address: ED-LOOP is loaded to HL.  
0f4b e5			        PUSH    HL              ; and pushed onto stack.  
0f4c			  
0f4c			; At this point there is a looping return address on the stack, an error  
0f4c			; handler and an input stream set up to supply characters.  
0f4c			; The character that has been received can now be processed.  
0f4c			  
0f4c fe 18		        CP      $18             ; range 24 to 255 ?  
0f4e 30 31		        JR      NC,L0F81        ; forward to ADD-CHAR if so.  
0f50			  
0f50 fe 07		        CP      $07             ; lower than 7 ?  
0f52 38 2d		        JR      C,L0F81         ; forward to ADD-CHAR also.  
0f54			                                ; Note. This is a 'bug' and chr$ 6, the comma  
0f54			                                ; control character, should have had an  
0f54			                                ; entry in the ED-KEYS table.  
0f54			                                ; Steven Vickers, 1984, Pitman.  
0f54			  
0f54 fe 10		        CP      $10             ; less than 16 ?  
0f56 38 3a		        JR      C,L0F92         ; forward to ED-KEYS if editing control  
0f58			                                ; range 7 to 15 dealt with by a table  
0f58			  
0f58 01 02 00		        LD      BC,$0002        ; prepare for ink/paper etc.  
0f5b 57			        LD      D,A             ; save character in D  
0f5c fe 16		        CP      $16             ; is it ink/paper/bright etc. ?  
0f5e 38 0c		        JR      C,L0F6C         ; forward to ED-CONTR if so  
0f60			  
0f60			                                ; leaves 22d AT and 23d TAB  
0f60			                                ; which can't be entered via KEY-INPUT.  
0f60			                                ; so this code is never normally executed  
0f60			                                ; when the keyboard is used for input.  
0f60			  
0f60 03			        INC     BC              ; if it was AT/TAB - 3 locations required  
0f61 fd cb 37 7e	        BIT     7,(IY+$37)      ; test FLAGX  - Is this INPUT LINE ?  
0f65 ca 1e 10		        JP      Z,L101E         ; jump to ED-IGNORE if not, else   
0f68			  
0f68 cd d4 15		        CALL    L15D4           ; routine WAIT-KEY - input address is KEY-NEXT  
0f6b			                                ; but is reset to KEY-INPUT  
0f6b 5f			        LD      E,A             ; save first in E  
0f6c			  
0f6c			;; ED-CONTR  
0f6c cd d4 15		L0F6C:  CALL    L15D4           ; routine WAIT-KEY for control.  
0f6f			                                ; input address will be key-next.  
0f6f			  
0f6f d5			        PUSH    DE              ; saved code/parameters  
0f70 2a 5b 5c		        LD      HL,($5C5B)      ; fetch address of keyboard cursor from K_CUR  
0f73 fd cb 07 86	        RES     0,(IY+$07)      ; set MODE to 'L'  
0f77			  
0f77 cd 55 16		        CALL    L1655           ; routine MAKE-ROOM makes 2/3 spaces at cursor  
0f7a			  
0f7a c1			        POP     BC              ; restore code/parameters  
0f7b 23			        INC     HL              ; address first location  
0f7c 70			        LD      (HL),B          ; place code (ink etc.)  
0f7d 23			        INC     HL              ; address next  
0f7e 71			        LD      (HL),C          ; place possible parameter. If only one  
0f7f			                                ; then DE points to this location also.  
0f7f 18 0a		        JR      L0F8B           ; forward to ADD-CH-1  
0f81			  
0f81			; ------------------------  
0f81			; Add code to current line  
0f81			; ------------------------  
0f81			; this is the branch used to add normal non-control characters  
0f81			; with ED-LOOP as the stacked return address.  
0f81			; it is also the OUTPUT service routine for system channel 'R'.  
0f81			  
0f81			;; ADD-CHAR  
0f81 fd cb 07 86	L0F81:  RES     0,(IY+$07)      ; set MODE to 'L'  
0f85			  
0f85 2a 5b 5c		X0F85:  LD      HL,($5C5B)      ; fetch address of keyboard cursor from K_CUR  
0f88 cd 52 16		        CALL    L1652           ; routine ONE-SPACE creates one space.  
0f8b			  
0f8b			; either a continuation of above or from ED-CONTR with ED-LOOP on stack.  
0f8b			  
0f8b			;; ADD-CH-1  
0f8b 12			L0F8B:  LD      (DE),A          ; load current character to last new location.  
0f8c 13			        INC     DE              ; address next  
0f8d ed 53 5b 5c	        LD      ($5C5B),DE      ; and update K_CUR system variable.  
0f91 c9			        RET                     ; return - either a simple return  
0f92			                                ; from ADD-CHAR or to ED-LOOP on stack.  
0f92			  
0f92			; ---  
0f92			  
0f92			; a branch of the editing loop to deal with control characters  
0f92			; using a look-up table.  
0f92			  
0f92			;; ED-KEYS  
0f92 5f			L0F92:  LD      E,A             ; character to E.  
0f93 16 00		        LD      D,$00           ; prepare to add.  
0f95 21 99 0f		        LD      HL,L0FA0 - 7    ; base address of editing keys table. $0F99  
0f98 19			        ADD     HL,DE           ; add E  
0f99 5e			        LD      E,(HL)          ; fetch offset to E  
0f9a 19			        ADD     HL,DE           ; add offset for address of handling routine.  
0f9b e5			        PUSH    HL              ; push the address on machine stack.  
0f9c 2a 5b 5c		        LD      HL,($5C5B)      ; load address of cursor from K_CUR.  
0f9f c9			        RET                     ; an make an indirect jump forward to routine.  
0fa0			  
0fa0			; ------------------  
0fa0			; Editing keys table  
0fa0			; ------------------  
0fa0			; For each code in the range $07 to $0F this table contains a  
0fa0			; single offset byte to the routine that services that code.  
0fa0			; Note. for what was intended there should also have been an  
0fa0			; entry for chr$ 6 with offset to ed-symbol.  
0fa0			  
0fa0			;; ed-keys-t  
0fa0 09			L0FA0:  DEFB    L0FA9 - $  ; 07d offset $09 to Address: ED-EDIT  
0fa1 66			        DEFB    L1007 - $  ; 08d offset $66 to Address: ED-LEFT  
0fa2 6a			        DEFB    L100C - $  ; 09d offset $6A to Address: ED-RIGHT  
0fa3 50			        DEFB    L0FF3 - $  ; 10d offset $50 to Address: ED-DOWN  
0fa4 b5			        DEFB    L1059 - $  ; 11d offset $B5 to Address: ED-UP  
0fa5 70			        DEFB    L1015 - $  ; 12d offset $70 to Address: ED-DELETE  
0fa6 7e			        DEFB    L1024 - $  ; 13d offset $7E to Address: ED-ENTER  
0fa7 cf			        DEFB    L1076 - $  ; 14d offset $CF to Address: ED-SYMBOL  
0fa8 d4			        DEFB    L107C - $  ; 15d offset $D4 to Address: ED-GRAPH  
0fa9			  
0fa9			; ---------------  
0fa9			; Handle EDIT key  
0fa9			; ---------------  
0fa9			; The user has pressed SHIFT 1 to bring edit line down to bottom of screen.  
0fa9			; Alternatively the user wishes to clear the input buffer and start again.  
0fa9			; Alternatively ...  
0fa9			  
0fa9			;; ED-EDIT  
0fa9 2a 49 5c		L0FA9:  LD      HL,($5C49)      ; fetch E_PPC the last line number entered.  
0fac			                                ; Note. may not exist and may follow program.  
0fac fd cb 37 6e	        BIT     5,(IY+$37)      ; test FLAGX  - input mode ?  
0fb0 c2 97 10		        JP      NZ,L1097        ; jump forward to CLEAR-SP if not in editor.  
0fb3			  
0fb3 cd 6e 19		        CALL    L196E           ; routine LINE-ADDR to find address of line  
0fb6			                                ; or following line if it doesn't exist.  
0fb6 cd 95 16		        CALL    L1695           ; routine LINE-NO will get line number from  
0fb9			                                ; address or previous line if at end-marker.  
0fb9 7a			        LD      A,D             ; if there is no program then DE will  
0fba b3			        OR      E               ; contain zero so test for this.  
0fbb ca 97 10		        JP      Z,L1097         ; jump to to CLEAR-SP if so.  
0fbe			  
0fbe			; Note. at this point we have a validated line number, not just an  
0fbe			; approximation and it would be best to update E_PPC with the true  
0fbe			; cursor line value which would enable the line cursor to be suppressed  
0fbe			; in all situations - see shortly.  
0fbe			  
0fbe e5			        PUSH    HL              ; save address of line.  
0fbf 23			        INC     HL              ; address low byte of length.  
0fc0 4e			        LD      C,(HL)          ; transfer to C  
0fc1 23			        INC     HL              ; next to high byte  
0fc2 46			        LD      B,(HL)          ; transfer to B.  
0fc3 21 0a 00		        LD      HL,$000A        ; an overhead of ten bytes  
0fc6 09			        ADD     HL,BC           ; is added to length.  
0fc7 44			        LD      B,H             ; transfer adjusted value  
0fc8 4d			        LD      C,L             ; to BC register.  
0fc9 cd 05 1f		        CALL    L1F05           ; routine TEST-ROOM checks free memory.  
0fcc cd 97 10		        CALL    L1097           ; routine CLEAR-SP clears editing area.  
0fcf 2a 51 5c		        LD      HL,($5C51)      ; address CURCHL  
0fd2 e3			        EX      (SP),HL         ; swap with line address on stack  
0fd3 e5			        PUSH    HL              ; save line address underneath  
0fd4			  
0fd4 3e ff		        LD      A,$FF           ; select system channel 'R'  
0fd6 cd 01 16		        CALL    L1601           ; routine CHAN-OPEN opens it  
0fd9			  
0fd9 e1			        POP     HL              ; drop line address  
0fda 2b			        DEC     HL              ; make it point to first byte of line num.  
0fdb fd 35 0f		        DEC     (IY+$0F)        ; decrease E_PPC_lo to suppress line cursor.  
0fde			                                ; Note. ineffective when E_PPC is one  
0fde			                                ; greater than last line of program perhaps  
0fde			                                ; as a result of a delete.  
0fde			                                ; credit. Paul Harrison 1982.  
0fde			  
0fde cd 55 18		        CALL    L1855           ; routine OUT-LINE outputs the BASIC line  
0fe1			                                ; to the editing area.  
0fe1 fd 34 0f		        INC     (IY+$0F)        ; restore E_PPC_lo to the previous value.  
0fe4 2a 59 5c		        LD      HL,($5C59)      ; address E_LINE in editing area.  
0fe7 23			        INC     HL              ; advance  
0fe8 23			        INC     HL              ; past space  
0fe9 23			        INC     HL              ; and digit characters  
0fea 23			        INC     HL              ; of line number.  
0feb			  
0feb 22 5b 5c		        LD      ($5C5B),HL      ; update K_CUR to address start of BASIC.  
0fee e1			        POP     HL              ; restore the address of CURCHL.  
0fef cd 15 16		        CALL    L1615           ; routine CHAN-FLAG sets flags for it.  
0ff2 c9			        RET                     ; RETURN to ED-LOOP.  
0ff3			  
0ff3			; -------------------  
0ff3			; Cursor down editing  
0ff3			; -------------------  
0ff3			; The BASIC lines are displayed at the top of the screen and the user  
0ff3			; wishes to move the cursor down one line in edit mode.  
0ff3			; In input mode this key can be used as an alternative to entering STOP.  
0ff3			  
0ff3			;; ED-DOWN  
0ff3 fd cb 37 6e	L0FF3:  BIT     5,(IY+$37)      ; test FLAGX  - Input Mode ?  
0ff7 20 08		        JR      NZ,L1001        ; skip to ED-STOP if so  
0ff9			  
0ff9 21 49 5c		        LD      HL,$5C49        ; address E_PPC - 'current line'  
0ffc cd 0f 19		        CALL    L190F           ; routine LN-FETCH fetches number of next  
0fff			                                ; line or same if at end of program.  
0fff 18 6d		        JR      L106E           ; forward to ED-LIST to produce an  
1001			                                ; automatic listing.  
1001			  
1001			; ---  
1001			  
1001			;; ED-STOP  
1001 fd 36 00 10	L1001:  LD      (IY+$00),$10    ; set ERR_NR to 'STOP in INPUT' code  
1005 18 1d		        JR      L1024           ; forward to ED-ENTER to produce error.  
1007			  
1007			; -------------------  
1007			; Cursor left editing  
1007			; -------------------  
1007			; This acts on the cursor in the lower section of the screen in both  
1007			; editing and input mode.  
1007			  
1007			;; ED-LEFT  
1007 cd 31 10		L1007:  CALL    L1031           ; routine ED-EDGE moves left if possible  
100a 18 05		        JR      L1011           ; forward to ED-CUR to update K-CUR  
100c			                                ; and return to ED-LOOP.  
100c			  
100c			; --------------------  
100c			; Cursor right editing  
100c			; --------------------  
100c			; This acts on the cursor in the lower screen in both editing and input  
100c			; mode and moves it to the right.  
100c			  
100c			;; ED-RIGHT  
100c 7e			L100C:  LD      A,(HL)          ; fetch addressed character.  
100d fe 0d		        CP      $0D             ; is it carriage return ?  
100f c8			        RET     Z               ; return if so to ED-LOOP  
1010			  
1010 23			        INC     HL              ; address next character  
1011			  
1011			;; ED-CUR  
1011 22 5b 5c		L1011:  LD      ($5C5B),HL      ; update K_CUR system variable  
1014 c9			        RET                     ; return to ED-LOOP  
1015			  
1015			; --------------  
1015			; DELETE editing  
1015			; --------------  
1015			; This acts on the lower screen and deletes the character to left of  
1015			; cursor. If control characters are present these are deleted first  
1015			; leaving the naked parameter (0-7) which appears as a '?' except in the  
1015			; case of chr$ 6 which is the comma control character. It is not mandatory  
1015			; to delete these second characters.  
1015			  
1015			;; ED-DELETE  
1015 cd 31 10		L1015:  CALL    L1031           ; routine ED-EDGE moves cursor to left.  
1018 01 01 00		        LD      BC,$0001        ; of character to be deleted.  
101b c3 e8 19		        JP      L19E8           ; to RECLAIM-2 reclaim the character.  
101e			  
101e			; ------------------------------------------  
101e			; Ignore next 2 codes from key-input routine  
101e			; ------------------------------------------  
101e			; Since AT and TAB cannot be entered this point is never reached  
101e			; from the keyboard. If inputting from a tape device or network then  
101e			; the control and two following characters are ignored and processing  
101e			; continues as if a carriage return had been received.  
101e			; Here, perhaps, another Spectrum has said print #15; AT 0,0; "This is yellow"  
101e			; and this one is interpreting input #15; a$.  
101e			  
101e			;; ED-IGNORE  
101e cd d4 15		L101E:  CALL    L15D4           ; routine WAIT-KEY to ignore keystroke.  
1021 cd d4 15		        CALL    L15D4           ; routine WAIT-KEY to ignore next key.  
1024			  
1024			; -------------  
1024			; Enter/newline  
1024			; -------------  
1024			; The enter key has been pressed to have BASIC line or input accepted.  
1024			  
1024			;; ED-ENTER  
1024 e1			L1024:  POP     HL              ; discard address ED-LOOP  
1025 e1			        POP     HL              ; drop address ED-ERROR  
1026			  
1026			;; ED-END  
1026 e1			L1026:  POP     HL              ; the previous value of ERR_SP  
1027 22 3d 5c		        LD      ($5C3D),HL      ; is restored to ERR_SP system variable  
102a fd cb 00 7e	        BIT     7,(IY+$00)      ; is ERR_NR $FF (= 'OK') ?  
102e c0			        RET     NZ              ; return if so  
102f			  
102f f9			        LD      SP,HL           ; else put error routine on stack  
1030 c9			        RET                     ; and make an indirect jump to it.  
1031			  
1031			; -----------------------------  
1031			; Move cursor left when editing  
1031			; -----------------------------  
1031			; This routine moves the cursor left. The complication is that it must  
1031			; not position the cursor between control codes and their parameters.  
1031			; It is further complicated in that it deals with TAB and AT characters  
1031			; which are never present from the keyboard.  
1031			; The method is to advance from the beginning of the line each time,  
1031			; jumping one, two, or three characters as necessary saving the original  
1031			; position at each jump in DE. Once it arrives at the cursor then the next  
1031			; legitimate leftmost position is in DE.  
1031			  
1031			;; ED-EDGE  
1031 37			L1031:  SCF                     ; carry flag must be set to call the nested  
1032 cd 95 11		        CALL    L1195           ; subroutine SET-DE.  
1035			                                ; if input   then DE=WORKSP  
1035			                                ; if editing then DE=E_LINE  
1035 ed 52		        SBC     HL,DE           ; subtract address from start of line  
1037 19			        ADD     HL,DE           ; and add back.  
1038 23			        INC     HL              ; adjust for carry.  
1039 c1			        POP     BC              ; drop return address  
103a d8			        RET     C               ; return to ED-LOOP if already at left  
103b			                                ; of line.  
103b			  
103b c5			        PUSH    BC              ; resave return address - ED-LOOP.  
103c 44			        LD      B,H             ; transfer HL - cursor address  
103d 4d			        LD      C,L             ; to BC register pair.  
103e			                                ; at this point DE addresses start of line.  
103e			  
103e			;; ED-EDGE-1  
103e 62			L103E:  LD      H,D             ; transfer DE - leftmost pointer  
103f 6b			        LD      L,E             ; to HL  
1040 23			        INC     HL              ; address next leftmost character to  
1041			                                ; advance position each time.  
1041 1a			        LD      A,(DE)          ; pick up previous in A  
1042 e6 f0		        AND     $F0             ; lose the low bits  
1044 fe 10		        CP      $10             ; is it INK to TAB $10-$1F ?  
1046			                                ; that is, is it followed by a parameter ?  
1046 20 09		        JR      NZ,L1051        ; to ED-EDGE-2 if not  
1048			                                ; HL has been incremented once  
1048			  
1048 23			        INC     HL              ; address next as at least one parameter.  
1049			  
1049			; in fact since 'tab' and 'at' cannot be entered the next section seems  
1049			; superfluous.  
1049			; The test will always fail and the jump to ED-EDGE-2 will be taken.  
1049			  
1049 1a			        LD      A,(DE)          ; reload leftmost character  
104a d6 17		        SUB     $17             ; decimal 23 ('tab')  
104c ce 00		        ADC     A,$00           ; will be 0 for 'tab' and 'at'.  
104e 20 01		        JR      NZ,L1051        ; forward to ED-EDGE-2 if not  
1050			                                ; HL has been incremented twice  
1050			  
1050 23			        INC     HL              ; increment a third time for 'at'/'tab'  
1051			  
1051			;; ED-EDGE-2  
1051 a7			L1051:  AND     A               ; prepare for true subtraction  
1052 ed 42		        SBC     HL,BC           ; subtract cursor address from pointer  
1054 09			        ADD     HL,BC           ; and add back  
1055			                                ; Note when HL matches the cursor position BC,  
1055			                                ; there is no carry and the previous  
1055			                                ; position is in DE.  
1055 eb			        EX      DE,HL           ; transfer result to DE if looping again.  
1056			                                ; transfer DE to HL to be used as K-CUR  
1056			                                ; if exiting loop.  
1056 38 e6		        JR      C,L103E         ; back to ED-EDGE-1 if cursor not matched.  
1058			  
1058 c9			        RET                     ; return.  
1059			  
1059			; -----------------  
1059			; Cursor up editing  
1059			; -----------------  
1059			; The main screen displays part of the BASIC program and the user wishes  
1059			; to move up one line scrolling if necessary.  
1059			; This has no alternative use in input mode.  
1059			  
1059			;; ED-UP  
1059 fd cb 37 6e	L1059:  BIT     5,(IY+$37)      ; test FLAGX  - input mode ?  
105d c0			        RET     NZ              ; return if not in editor - to ED-LOOP.  
105e			  
105e 2a 49 5c		        LD      HL,($5C49)      ; get current line from E_PPC  
1061 cd 6e 19		        CALL    L196E           ; routine LINE-ADDR gets address  
1064 eb			        EX      DE,HL           ; and previous in DE  
1065 cd 95 16		        CALL    L1695           ; routine LINE-NO gets prev line number  
1068 21 4a 5c		        LD      HL,$5C4A        ; set HL to E_PPC_hi as next routine stores  
106b			                                ; top first.  
106b cd 1c 19		        CALL    L191C           ; routine LN-STORE loads DE value to HL  
106e			                                ; high byte first - E_PPC_lo takes E  
106e			  
106e			; this branch is also taken from ed-down.  
106e			  
106e			;; ED-LIST  
106e cd 95 17		L106E:  CALL    L1795           ; routine AUTO-LIST lists to upper screen  
1071			                                ; including adjusted current line.  
1071 3e 00		        LD      A,$00           ; select lower screen again  
1073 c3 01 16		        JP      L1601           ; exit via CHAN-OPEN to ED-LOOP  
1076			  
1076			; --------------------------------  
1076			; Use of symbol and graphics codes  
1076			; --------------------------------  
1076			; These will not be encountered with the keyboard but would be handled  
1076			; otherwise as follows.  
1076			; As noted earlier, Vickers says there should have been an entry in  
1076			; the KEYS table for chr$ 6 which also pointed here.  
1076			; If, for simplicity, two Spectrums were both using #15 as a bi-directional  
1076			; channel connected to each other:-  
1076			; then when the other Spectrum has said PRINT #15; x, y  
1076			; input #15; i ; j  would treat the comma control as a newline and the  
1076			; control would skip to input j.  
1076			; You can get round the missing chr$ 6 handler by sending multiple print  
1076			; items separated by a newline '.  
1076			  
1076			; chr$14 would have the same functionality.  
1076			  
1076			; This is chr$ 14.  
1076			;; ED-SYMBOL  
1076 fd cb 37 7e	L1076:  BIT     7,(IY+$37)      ; test FLAGX - is this INPUT LINE ?  
107a 28 a8		        JR      Z,L1024         ; back to ED-ENTER if not to treat as if  
107c			                                ; enter had been pressed.  
107c			                                ; else continue and add code to buffer.  
107c			  
107c			; Next is chr$ 15  
107c			; Note that ADD-CHAR precedes the table so we can't offset to it directly.  
107c			  
107c			;; ED-GRAPH  
107c c3 81 0f		L107C:  JP      L0F81           ; jump back to ADD-CHAR  
107f			  
107f			; --------------------  
107f			; Editor error routine  
107f			; --------------------  
107f			; If an error occurs while editing, or inputting, then ERR_SP  
107f			; points to the stack location holding address ED_ERROR.  
107f			  
107f			;; ED-ERROR  
107f fd cb 30 66	L107F:  BIT     4,(IY+$30)      ; test FLAGS2  - is K channel in use ?  
1083 28 a1		        JR      Z,L1026         ; back to ED-END if not.  
1085			  
1085			; but as long as we're editing lines or inputting from the keyboard, then  
1085			; we've run out of memory so give a short rasp.  
1085			  
1085 fd 36 00 ff	        LD      (IY+$00),$FF    ; reset ERR_NR to 'OK'.  
1089 16 00		        LD      D,$00           ; prepare for beeper.  
108b fd 5e fe		        LD      E,(IY-$02)      ; use RASP value.  
108e 21 90 1a		        LD      HL,$1A90        ; set a duration.  
1091 cd b5 03		        CALL    L03B5           ; routine BEEPER emits a warning rasp.  
1094 c3 30 0f		        JP      L0F30           ; to ED-AGAIN to re-stack address of  
1097			                                ; this routine and make ERR_SP point to it.  
1097			  
1097			; ---------------------  
1097			; Clear edit/work space  
1097			; ---------------------  
1097			; The editing area or workspace is cleared depending on context.  
1097			; This is called from ED-EDIT to clear workspace if edit key is  
1097			; used during input, to clear editing area if no program exists  
1097			; and to clear editing area prior to copying the edit line to it.  
1097			; It is also used by the error routine to clear the respective  
1097			; area depending on FLAGX.  
1097			  
1097			;; CLEAR-SP  
1097 e5			L1097:  PUSH    HL              ; preserve HL  
1098 cd 90 11		        CALL    L1190           ; routine SET-HL  
109b			                                ; if in edit   HL = WORKSP-1, DE = E_LINE  
109b			                                ; if in input  HL = STKBOT,   DE = WORKSP  
109b 2b			        DEC     HL              ; adjust  
109c cd e5 19		        CALL    L19E5           ; routine RECLAIM-1 reclaims space  
109f 22 5b 5c		        LD      ($5C5B),HL      ; set K_CUR to start of empty area  
10a2 fd 36 07 00	        LD      (IY+$07),$00    ; set MODE to 'KLC'  
10a6 e1			        POP     HL              ; restore HL.  
10a7 c9			        RET                     ; return.  
10a8			  
10a8			; ---------------------  
10a8			; Handle keyboard input  
10a8			; ---------------------  
10a8			; This is the service routine for the input stream of the keyboard  
10a8			; channel 'K'.  
10a8			  
10a8			;; KEY-INPUT  
10a8 fd cb 02 5e	L10A8:  BIT     3,(IY+$02)      ; test TV_FLAG  - has a key been pressed in  
10ac			                                ; editor ?  
10ac c4 1d 11		        CALL    NZ,L111D        ; routine ED-COPY if so to reprint the lower  
10af			                                ; screen at every keystroke.  
10af a7			        AND     A               ; clear carry - required exit condition.  
10b0 fd cb 01 6e	        BIT     5,(IY+$01)      ; test FLAGS  - has a new key been pressed ?  
10b4 c8			        RET     Z               ; return if not.  
10b5			  
10b5 3a 08 5c		        LD      A,($5C08)       ; system variable LASTK will hold last key -  
10b8			                                ; from the interrupt routine.  
10b8 fd cb 01 ae	        RES     5,(IY+$01)      ; update FLAGS  - reset the new key flag.  
10bc f5			        PUSH    AF              ; save the input character.  
10bd fd cb 02 6e	        BIT     5,(IY+$02)      ; test TV_FLAG  - clear lower screen ?  
10c1 c4 6e 0d		        CALL    NZ,L0D6E        ; routine CLS-LOWER if so.  
10c4			  
10c4 f1			        POP     AF              ; restore the character code.  
10c5 fe 20		        CP      $20             ; if space or higher then  
10c7 30 52		        JR      NC,L111B        ; forward to KEY-DONE2 and return with carry  
10c9			                                ; set to signal key-found.  
10c9			  
10c9 fe 10		        CP      $10             ; with 16d INK and higher skip  
10cb 30 2d		        JR      NC,L10FA        ; forward to KEY-CONTR.  
10cd			  
10cd fe 06		        CP      $06             ; for 6 - 15d  
10cf 30 0a		        JR      NC,L10DB        ; skip forward to KEY-M-CL to handle Modes  
10d1			                                ; and CapsLock.  
10d1			  
10d1			; that only leaves 0-5, the flash bright inverse switches.  
10d1			  
10d1 47			        LD      B,A             ; save character in B  
10d2 e6 01		        AND     $01             ; isolate the embedded parameter (0/1).  
10d4 4f			        LD      C,A             ; and store in C  
10d5 78			        LD      A,B             ; re-fetch copy (0-5)  
10d6 1f			        RRA                     ; halve it 0, 1 or 2.  
10d7 c6 12		        ADD     A,$12           ; add 18d gives 'flash', 'bright'  
10d9			                                ; and 'inverse'.  
10d9 18 2a		        JR      L1105           ; forward to KEY-DATA with the   
10db			                                ; parameter (0/1) in C.  
10db			  
10db			; ---  
10db			  
10db			; Now separate capslock 06 from modes 7-15.  
10db			  
10db			;; KEY-M-CL  
10db 20 09		L10DB:  JR      NZ,L10E6        ; forward to KEY-MODE if not 06 (capslock)  
10dd			  
10dd 21 6a 5c		        LD      HL,$5C6A        ; point to FLAGS2  
10e0 3e 08		        LD      A,$08           ; value 00000100  
10e2 ae			        XOR     (HL)            ; toggle BIT 2 of FLAGS2 the capslock bit  
10e3 77			        LD      (HL),A          ; and store result in FLAGS2 again.  
10e4 18 0e		        JR      L10F4           ; forward to KEY-FLAG to signal no-key.  
10e6			  
10e6			; ---  
10e6			  
10e6			;; KEY-MODE  
10e6 fe 0e		L10E6:  CP      $0E             ; compare with chr 14d  
10e8 d8			        RET     C               ; return with carry set "key found" for  
10e9			                                ; codes 7 - 13d leaving 14d and 15d  
10e9			                                ; which are converted to mode codes.  
10e9			  
10e9 d6 0d		        SUB     $0D             ; subtract 13d leaving 1 and 2  
10eb			                                ; 1 is 'E' mode, 2 is 'G' mode.  
10eb 21 41 5c		        LD      HL,$5C41        ; address the MODE system variable.  
10ee be			        CP      (HL)            ; compare with existing value before  
10ef 77			        LD      (HL),A          ; inserting the new value.  
10f0 20 02		        JR      NZ,L10F4        ; forward to KEY-FLAG if it has changed.  
10f2			  
10f2 36 00		        LD      (HL),$00        ; else make MODE zero - KLC mode  
10f4			                                ; Note. while in Extended/Graphics mode,  
10f4			                                ; the Extended Mode/Graphics key is pressed  
10f4			                                ; again to get out.  
10f4			  
10f4			;; KEY-FLAG  
10f4 fd cb 02 de	L10F4:  SET     3,(IY+$02)      ; update TV_FLAG  - show key state has changed  
10f8 bf			        CP      A               ; clear carry and reset zero flags -  
10f9			                                ; no actual key returned.  
10f9 c9			        RET                     ; make the return.  
10fa			  
10fa			; ---  
10fa			  
10fa			; now deal with colour controls - 16-23 ink, 24-31 paper  
10fa			  
10fa			;; KEY-CONTR  
10fa 47			L10FA:  LD      B,A             ; make a copy of character.  
10fb e6 07		        AND     $07             ; mask to leave bits 0-7  
10fd 4f			        LD      C,A             ; and store in C.  
10fe 3e 10		        LD      A,$10           ; initialize to 16d - INK.  
1100 cb 58		        BIT     3,B             ; was it paper ?  
1102 20 01		        JR      NZ,L1105        ; forward to KEY-DATA with INK 16d and  
1104			                                ; colour in C.  
1104			  
1104 3c			        INC     A               ; else change from INK to PAPER (17d) if so.  
1105			  
1105			;; KEY-DATA  
1105 fd 71 d3		L1105:  LD      (IY-$2D),C      ; put the colour (0-7)/state(0/1) in KDATA  
1108 11 0d 11		        LD      DE,L110D        ; address: KEY-NEXT will be next input stream  
110b 18 06		        JR      L1113           ; forward to KEY-CHAN to change it ...  
110d			  
110d			; ---  
110d			  
110d			; ... so that INPUT_AD directs control to here at next call to WAIT-KEY  
110d			  
110d			;; KEY-NEXT  
110d 3a 0d 5c		L110D:  LD      A,($5C0D)       ; pick up the parameter stored in KDATA.  
1110 11 a8 10		        LD      DE,L10A8        ; address: KEY-INPUT will be next input stream  
1113			                                ; continue to restore default channel and  
1113			                                ; make a return with the control code.  
1113			  
1113			;; KEY-CHAN  
1113 2a 4f 5c		L1113:  LD      HL,($5C4F)      ; address start of CHANNELS area using CHANS  
1116			                                ; system variable.  
1116			                                ; Note. One might have expected CURCHL to  
1116			                                ; have been used.  
1116 23			        INC     HL              ; step over the  
1117 23			        INC     HL              ; output address  
1118 73			        LD      (HL),E          ; and update the input  
1119 23			        INC     HL              ; routine address for  
111a 72			        LD      (HL),D          ; the next call to WAIT-KEY.  
111b			  
111b			;; KEY-DONE2  
111b 37			L111B:  SCF                     ; set carry flag to show a key has been found  
111c c9			        RET                     ; and return.  
111d			  
111d			; --------------------  
111d			; Lower screen copying  
111d			; --------------------  
111d			; This subroutine is called whenever the line in the editing area or  
111d			; input workspace is required to be printed to the lower screen.  
111d			; It is by calling this routine after any change that the cursor, for  
111d			; instance, appears to move to the left.  
111d			; Remember the edit line will contain characters and tokens  
111d			; e.g. "1000 LET a = 1" is 12 characters.  
111d			  
111d			;; ED-COPY  
111d cd 4d 0d		L111D:  CALL    L0D4D           ; routine TEMPS sets temporary attributes.  
1120 fd cb 02 9e	        RES     3,(IY+$02)      ; update TV_FLAG  - signal no change in mode  
1124 fd cb 02 ae	        RES     5,(IY+$02)      ; update TV_FLAG  - signal don't clear lower  
1128			                                ; screen.  
1128 2a 8a 5c		        LD      HL,($5C8A)      ; fetch SPOSNL  
112b e5			        PUSH    HL              ; and save on stack.  
112c			  
112c 2a 3d 5c		        LD      HL,($5C3D)      ; fetch ERR_SP  
112f e5			        PUSH    HL              ; and save also  
1130 21 67 11		        LD      HL,L1167        ; address: ED-FULL  
1133 e5			        PUSH    HL              ; is pushed as the error routine  
1134 ed 73 3d 5c	        LD      ($5C3D),SP      ; and ERR_SP made to point to it.  
1138			  
1138 2a 82 5c		        LD      HL,($5C82)      ; fetch ECHO_E  
113b e5			        PUSH    HL              ; and push also  
113c			  
113c 37			        SCF                     ; set carry flag to control SET-DE  
113d cd 95 11		        CALL    L1195           ; call routine SET-DE  
1140			                                ; if in input DE = WORKSP  
1140			                                ; if in edit  DE = E_LINE  
1140 eb			        EX      DE,HL           ; start address to HL  
1141			  
1141 cd 7d 18		        CALL    L187D           ; routine OUT-LINE2 outputs entire line up to  
1144			                                ; carriage return including initial  
1144			                                ; characterized line number when present.  
1144 eb			        EX      DE,HL           ; transfer new address to DE  
1145 cd e1 18		        CALL    L18E1           ; routine OUT-CURS considers a  
1148			                                ; terminating cursor.  
1148			  
1148 2a 8a 5c		        LD      HL,($5C8A)      ; fetch updated SPOSNL  
114b e3			        EX      (SP),HL         ; exchange with ECHO_E on stack  
114c eb			        EX      DE,HL           ; transfer ECHO_E to DE  
114d cd 4d 0d		        CALL    L0D4D           ; routine TEMPS to re-set attributes  
1150			                                ; if altered.  
1150			  
1150			; the lower screen was not cleared, at the outset, so if deleting then old  
1150			; text from a previous print may follow this line and requires blanking.  
1150			  
1150			;; ED-BLANK  
1150 3a 8b 5c		L1150:  LD      A,($5C8B)       ; fetch SPOSNL_hi is current line  
1153 92			        SUB     D               ; compare with old  
1154 38 26		        JR      C,L117C         ; forward to ED-C-DONE if no blanking  
1156			  
1156 20 06		        JR      NZ,L115E        ; forward to ED-SPACES if line has changed  
1158			  
1158 7b			        LD      A,E             ; old column to A  
1159 fd 96 50		        SUB     (IY+$50)        ; subtract new in SPOSNL_lo  
115c 30 1e		        JR      NC,L117C        ; forward to ED-C-DONE if no backfilling.  
115e			  
115e			;; ED-SPACES  
115e 3e 20		L115E:  LD      A,$20           ; prepare a space.  
1160 d5			        PUSH    DE              ; save old line/column.  
1161 cd f4 09		        CALL    L09F4           ; routine PRINT-OUT prints a space over  
1164			                                ; any text from previous print.  
1164			                                ; Note. Since the blanking only occurs when  
1164			                                ; using $09F4 to print to the lower screen,  
1164			                                ; there is no need to vector via a RST 10  
1164			                                ; and we can use this alternate set.  
1164 d1			        POP     DE              ; restore the old line column.  
1165 18 e9		        JR      L1150           ; back to ED-BLANK until all old text blanked.  
1167			  
1167			; -------  
1167			; ED-FULL  
1167			; -------  
1167			; this is the error routine addressed by ERR_SP. This is not for the out of  
1167			; memory situation as we're just printing. The pitch and duration are exactly  
1167			; the same as used by ED-ERROR from which this has been augmented. The  
1167			; situation is that the lower screen is full and a rasp is given to suggest  
1167			; that this is perhaps not the best idea you've had that day.  
1167			  
1167			;; ED-FULL  
1167 16 00		L1167:  LD      D,$00           ; prepare to moan.  
1169 fd 5e fe		        LD      E,(IY-$02)      ; fetch RASP value.  
116c 21 90 1a		        LD      HL,$1A90        ; set duration.  
116f cd b5 03		        CALL    L03B5           ; routine BEEPER.  
1172 fd 36 00 ff	        LD      (IY+$00),$FF    ; clear ERR_NR.  
1176 ed 5b 8a 5c	        LD      DE,($5C8A)      ; fetch SPOSNL.  
117a 18 02		        JR      L117E           ; forward to ED-C-END  
117c			  
117c			; -------  
117c			  
117c			; the exit point from line printing continues here.  
117c			  
117c			;; ED-C-DONE  
117c d1			L117C:  POP     DE              ; fetch new line/column.  
117d e1			        POP     HL              ; fetch the error address.  
117e			  
117e			; the error path rejoins here.  
117e			  
117e			;; ED-C-END  
117e e1			L117E:  POP     HL              ; restore the old value of ERR_SP.  
117f 22 3d 5c		        LD      ($5C3D),HL      ; update the system variable ERR_SP  
1182 c1			        POP     BC              ; old value of SPOSN_L  
1183 d5			        PUSH    DE              ; save new value  
1184 cd d9 0d		        CALL    L0DD9           ; routine CL-SET and PO-STORE  
1187			                                ; update ECHO_E and SPOSN_L from BC  
1187 e1			        POP     HL              ; restore new value  
1188 22 82 5c		        LD      ($5C82),HL      ; and update ECHO_E  
118b fd 36 26 00	        LD      (IY+$26),$00    ; make error pointer X_PTR_hi out of bounds  
118f c9			        RET                     ; return  
1190			  
1190			; -----------------------------------------------  
1190			; Point to first and last locations of work space  
1190			; -----------------------------------------------  
1190			; These two nested routines ensure that the appropriate pointers are  
1190			; selected for the editing area or workspace. The routines that call  
1190			; these routines are designed to work on either area.  
1190			  
1190			; this routine is called once  
1190			;; SET-HL  
1190 2a 61 5c		L1190:  LD      HL,($5C61)      ; fetch WORKSP to HL.  
1193 2b			        DEC     HL              ; point to last location of editing area.  
1194 a7			        AND     A               ; clear carry to limit exit points to first  
1195			                                ; or last.  
1195			  
1195			; this routine is called with carry set and exits at a conditional return.  
1195			  
1195			;; SET-DE  
1195 ed 5b 59 5c	L1195:  LD      DE,($5C59)      ; fetch E_LINE to DE  
1199 fd cb 37 6e	        BIT     5,(IY+$37)      ; test FLAGX  - Input Mode ?  
119d c8			        RET     Z               ; return now if in editing mode  
119e			  
119e ed 5b 61 5c	        LD      DE,($5C61)      ; fetch WORKSP to DE  
11a2 d8			        RET     C               ; return if carry set ( entry = set-de)  
11a3			  
11a3 2a 63 5c		        LD      HL,($5C63)      ; fetch STKBOT to HL as well  
11a6 c9			        RET                     ; and return  (entry = set-hl (in input))  
11a7			  
11a7			; -------------------------------  
11a7			; Remove floating point from line  
11a7			; -------------------------------  
11a7			; When a BASIC LINE or the INPUT BUFFER is parsed any numbers will have  
11a7			; an invisible chr 14d inserted after them and the 5-byte integer or  
11a7			; floating point form inserted after that. Similar invisible value holders  
11a7			; are also created after the numeric and string variables in a DEF FN list.  
11a7			; This routine removes these 'compiled' numbers from the edit line or  
11a7			; input workspace.  
11a7			  
11a7			;; REMOVE-FP  
11a7 7e			L11A7:  LD      A,(HL)          ; fetch character  
11a8 fe 0e		        CP      $0E             ; is it the number marker ?  
11aa 01 06 00		        LD      BC,$0006        ; prepare for six bytes  
11ad cc e8 19		        CALL    Z,L19E8         ; routine RECLAIM-2 reclaims space if $0E  
11b0 7e			        LD      A,(HL)          ; reload next (or same) character  
11b1 23			        INC     HL              ; and advance address  
11b2 fe 0d		        CP      $0D             ; end of line or input buffer ?  
11b4 20 f1		        JR      NZ,L11A7        ; back to REMOVE-FP until entire line done.  
11b6			  
11b6 c9			        RET                     ; return  
11b7			  
11b7			  
11b7			;*********************************  
11b7			;** Part 6. EXECUTIVE ROUTINES  **  
11b7			;*********************************  
11b7			  
11b7			  
11b7			; The memory.  
11b7			;  
11b7			; +---------+-----------+------------+--------------+-------------+--  
11b7			; | BASIC   |  Display  | Attributes | ZX Printer   |    System   |   
11b7			; |  ROM    |   File    |    File    |   Buffer     |  Variables  |   
11b7			; +---------+-----------+------------+--------------+-------------+--  
11b7			; ^         ^           ^            ^              ^             ^  
11b7			; $0000   $4000       $5800        $5B00          $5C00         $5CB6 = CHANS   
11b7			;  
11b7			;  
11b7			;  --+----------+---+---------+-----------+---+------------+--+---+--  
11b7			;    | Channel  |$80|  BASIC  | Variables |$80| Edit Line  |NL|$80|  
11b7			;    |   Info   |   | Program |   Area    |   | or Command |  |   |  
11b7			;  --+----------+---+---------+-----------+---+------------+--+---+--  
11b7			;    ^              ^         ^               ^                   ^  
11b7			;  CHANS           PROG      VARS           E_LINE              WORKSP  
11b7			;  
11b7			;  
11b7			;                             ---5-->         <---2---  <--3---  
11b7			;  --+-------+--+------------+-------+-------+---------+-------+-+---+------+  
11b7			;    | INPUT |NL| Temporary  | Calc. | Spare | Machine | GOSUB |?|$3E| UDGs |  
11b7			;    | data  |  | Work Space | Stack |       |  Stack  | Stack | |   |      |  
11b7			;  --+-------+--+------------+-------+-------+---------+-------+-+---+------+  
11b7			;    ^                       ^       ^       ^                   ^   ^      ^  
11b7			;  WORKSP                  STKBOT  STKEND   sp               RAMTOP UDG  P_RAMT  
11b7			;                                                                           
11b7			  
11b7			; -------------------  
11b7			; Handle NEW command  
11b7			; -------------------  
11b7			; The NEW command is about to set all RAM below RAMTOP to zero and  
11b7			; then re-initialize the system. All RAM above RAMTOP should, and will be,  
11b7			; preserved.  
11b7			; There is nowhere to store values in RAM or on the stack which becomes  
11b7			; inoperable. Similarly PUSH and CALL instructions cannot be used to  
11b7			; store values or section common code. The alternate register set is the only  
11b7			; place available to store 3 persistent 16-bit system variables.  
11b7			  
11b7			;; NEW  
11b7 f3			L11B7:  DI                      ; disable interrupts - machine stack will be  
11b8			                                ; cleared.  
11b8 3e ff		        LD      A,$FF           ; flag coming from NEW.  
11ba ed 5b b2 5c	        LD      DE,($5CB2)      ; fetch RAMTOP as top value.  
11be d9			        EXX                     ; switch in alternate set.  
11bf ed 4b b4 5c	        LD      BC,($5CB4)      ; fetch P-RAMT differs on 16K/48K machines.  
11c3 ed 5b 38 5c	        LD      DE,($5C38)      ; fetch RASP/PIP.  
11c7 2a 7b 5c		        LD      HL,($5C7B)      ; fetch UDG    differs on 16K/48K machines.  
11ca d9			        EXX                     ; switch back to main set and continue into...  
11cb			  
11cb			; ---------------------------  
11cb			; Main entry (initialization)  
11cb			; ---------------------------  
11cb			; This common code tests ram and sets it to zero re-initializing  
11cb			; all the non-zero system variables and channel information.  
11cb			; The A register tells if coming from START or NEW  
11cb			  
11cb			;; START-NEW  
11cb 47			L11CB:  LD      B,A             ; save the flag for later branching.  
11cc			  
11cc 3e 07		        LD      A,$07           ; select a white border  
11ce d3 fe		        OUT     ($FE),A         ; and set it now.  
11d0			  
11d0 3e 3f		        LD      A,$3F           ; load accumulator with last page in ROM.  
11d2 ed 47		        LD      I,A             ; set the I register - this remains constant  
11d4			                                ; and can't be in range $40 - $7F as 'snow'  
11d4			                                ; appears on the screen.  
11d4 00			        NOP                     ; these seem unnecessary.  
11d5 00			        NOP                     ;  
11d6 00			        NOP                     ;  
11d7 00			        NOP                     ;  
11d8 00			        NOP                     ;  
11d9 00			        NOP                     ;  
11da			  
11da			; ------------  
11da			; Check RAM  
11da			; ------------  
11da			; Typically a Spectrum will have 16K or 48K of Ram and this code will  
11da			; test it all till it finds an unpopulated location or, less likely, a  
11da			; faulty location. Usually it stops when it reaches the top $FFFF or  
11da			; in the case of NEW the supplied top value. The entire screen turns  
11da			; black with sometimes red stripes on black paper visible.  
11da			  
11da			;; ram-check  
11da 62			L11DA:  LD      H,D             ; transfer the top value to  
11db 6b			        LD      L,E             ; the HL register pair.  
11dc			  
11dc			;; RAM-FILL  
11dc 36 02		L11DC:  LD      (HL),$02        ; load with 2 - red ink on black paper  
11de 2b			        DEC     HL              ; next lower  
11df bc			        CP      H               ; have we reached ROM - $3F ?  
11e0 20 fa		        JR      NZ,L11DC        ; back to RAM-FILL if not.  
11e2			  
11e2			;; RAM-READ  
11e2 a7			L11E2:  AND     A               ; clear carry - prepare to subtract  
11e3 ed 52		        SBC     HL,DE           ; subtract and add back setting  
11e5 19			        ADD     HL,DE           ; carry when back at start.  
11e6 23			        INC     HL              ; and increment for next iteration.  
11e7 30 06		        JR      NC,L11EF        ; forward to RAM-DONE if we've got back to  
11e9			                                ; starting point with no errors.  
11e9			  
11e9 35			        DEC     (HL)            ; decrement to 1.  
11ea 28 03		        JR      Z,L11EF         ; forward to RAM-DONE if faulty.  
11ec			  
11ec 35			        DEC     (HL)            ; decrement to zero.  
11ed 28 f3		        JR      Z,L11E2         ; back to RAM-READ if zero flag was set.  
11ef			  
11ef			;; RAM-DONE  
11ef 2b			L11EF:  DEC     HL              ; step back to last valid location.  
11f0 d9			        EXX                     ; regardless of state, set up possibly  
11f1			                                ; stored system variables in case from NEW.  
11f1 ed 43 b4 5c	        LD      ($5CB4),BC      ; insert P-RAMT.  
11f5 ed 53 38 5c	        LD      ($5C38),DE      ; insert RASP/PIP.  
11f9 22 7b 5c		        LD      ($5C7B),HL      ; insert UDG.  
11fc d9			        EXX                     ; switch in main set.  
11fd 04			        INC     B               ; now test if we arrived here from NEW.  
11fe 28 19		        JR      Z,L1219         ; forward to RAM-SET if we did.  
1200			  
1200			; this section applies to START only.  
1200			  
1200 22 b4 5c		        LD      ($5CB4),HL      ; set P-RAMT to the highest working RAM  
1203			                                ; address.  
1203 11 af 3e		        LD      DE,$3EAF        ; address of last byte of 'U' bitmap in ROM.  
1206 01 a8 00		        LD      BC,$00A8        ; there are 21 user defined graphics.  
1209 eb			        EX      DE,HL           ; switch pointers and make the UDGs a  
120a ed b8		        LDDR                    ; copy of the standard characters A - U.  
120c eb			        EX      DE,HL           ; switch the pointer to HL.  
120d 23			        INC     HL              ; update to start of 'A' in RAM.  
120e 22 7b 5c		        LD      ($5C7B),HL      ; make UDG system variable address the first  
1211			                                ; bitmap.  
1211 2b			        DEC     HL              ; point at RAMTOP again.  
1212			  
1212 01 40 00		        LD      BC,$0040        ; set the values of  
1215 ed 43 38 5c	        LD      ($5C38),BC      ; the PIP and RASP system variables.  
1219			  
1219			; the NEW command path rejoins here.  
1219			  
1219			;; RAM-SET  
1219 22 b2 5c		L1219:  LD      ($5CB2),HL      ; set system variable RAMTOP to HL.  
121c			  
121c 21 00 3c		        LD      HL,$3C00        ; a strange place to set the pointer to the   
121f 22 36 5c		        LD      ($5C36),HL      ; character set, CHARS - as no printing yet.  
1222			  
1222 2a b2 5c		        LD      HL,($5CB2)      ; fetch RAMTOP to HL again as we've lost it.  
1225			  
1225 36 3e		        LD      (HL),$3E        ; top of user ram holds GOSUB end marker  
1227			                                ; an impossible line number - see RETURN.  
1227			                                ; no significance in the number $3E. It has  
1227			                                ; been traditional since the ZX80.  
1227			  
1227 2b			        DEC     HL              ; followed by empty byte (not important).  
1228 f9			        LD      SP,HL           ; set up the machine stack pointer.  
1229 2b			        DEC     HL              ;  
122a 2b			        DEC     HL              ;  
122b 22 3d 5c		        LD      ($5C3D),HL      ; ERR_SP is where the error pointer is  
122e			                                ; at moment empty - will take address MAIN-4  
122e			                                ; at the call preceding that address,  
122e			                                ; although interrupts and calls will make use  
122e			                                ; of this location in meantime.  
122e			  
122e ed 56		        IM      1               ; select interrupt mode 1.  
1230 fd 21 3a 5c	        LD      IY,$5C3A        ; set IY to ERR_NR. IY can reach all standard  
1234			                                ; system variables but shadow ROM system  
1234			                                ; variables will be mostly out of range.  
1234			  
1234 fb			        EI                      ; enable interrupts now that we have a stack.  
1235			  
1235 21 b6 5c		        LD      HL,$5CB6        ; the address of the channels - initially  
1238			                                ; following system variables.  
1238 22 4f 5c		        LD      ($5C4F),HL      ; set the CHANS system variable.  
123b			  
123b 11 af 15		        LD      DE,L15AF        ; address: init-chan in ROM.  
123e 01 15 00		        LD      BC,$0015        ; there are 21 bytes of initial data in ROM.  
1241 eb			        EX      DE,HL           ; swap the pointers.  
1242 ed b0		        LDIR                    ; copy the bytes to RAM.  
1244			  
1244 eb			        EX      DE,HL           ; swap pointers. HL points to program area.  
1245 2b			        DEC     HL              ; decrement address.  
1246 22 57 5c		        LD      ($5C57),HL      ; set DATADD to location before program area.  
1249 23			        INC     HL              ; increment again.  
124a			  
124a 22 53 5c		        LD      ($5C53),HL      ; set PROG the location where BASIC starts.  
124d 22 4b 5c		        LD      ($5C4B),HL      ; set VARS to same location with a  
1250 36 80		        LD      (HL),$80        ; variables end-marker.  
1252 23			        INC     HL              ; advance address.  
1253 22 59 5c		        LD      ($5C59),HL      ; set E_LINE, where the edit line  
1256			                                ; will be created.  
1256			                                ; Note. it is not strictly necessary to  
1256			                                ; execute the next fifteen bytes of code  
1256			                                ; as this will be done by the call to SET-MIN.  
1256			                                ; --  
1256 36 0d		        LD      (HL),$0D        ; initially just has a carriage return  
1258 23			        INC     HL              ; followed by  
1259 36 80		        LD      (HL),$80        ; an end-marker.  
125b 23			        INC     HL              ; address the next location.  
125c 22 61 5c		        LD      ($5C61),HL      ; set WORKSP - empty workspace.  
125f 22 63 5c		        LD      ($5C63),HL      ; set STKBOT - bottom of the empty stack.  
1262 22 65 5c		        LD      ($5C65),HL      ; set STKEND to the end of the empty stack.  
1265			                                ; --  
1265 3e 38		        LD      A,$38           ; the colour system is set to white paper,  
1267			                                ; black ink, no flash or bright.  
1267 32 8d 5c		        LD      ($5C8D),A       ; set ATTR_P permanent colour attributes.  
126a 32 8f 5c		        LD      ($5C8F),A       ; set ATTR_T temporary colour attributes.  
126d 32 48 5c		        LD      ($5C48),A       ; set BORDCR the border colour/lower screen  
1270			                                ; attributes.  
1270			  
1270 21 23 05		        LD      HL,$0523        ; The keyboard repeat and delay values  
1273 22 09 5c		        LD      ($5C09),HL      ; are loaded to REPDEL and REPPER.  
1276			  
1276 fd 35 c6		        DEC     (IY-$3A)        ; set KSTATE-0 to $FF.  
1279 fd 35 ca		        DEC     (IY-$36)        ; set KSTATE-4 to $FF.  
127c			                                ; thereby marking both available.  
127c			  
127c 21 c6 15		        LD      HL,L15C6        ; set source to ROM Address: init-strm  
127f 11 10 5c		        LD      DE,$5C10        ; set destination to system variable STRMS-FD  
1282 01 0e 00		        LD      BC,$000E        ; copy the 14 bytes of initial 7 streams data  
1285 ed b0		        LDIR                    ; from ROM to RAM.  
1287			  
1287 fd cb 01 ce	        SET     1,(IY+$01)      ; update FLAGS  - signal printer in use.  
128b cd df 0e		        CALL    L0EDF           ; call routine CLEAR-PRB to initialize system  
128e			                                ; variables associated with printer.  
128e			  
128e fd 36 31 02	        LD      (IY+$31),$02    ; set DF_SZ the lower screen display size to  
1292			                                ; two lines  
1292 cd 6b 0d		        CALL    L0D6B           ; call routine CLS to set up system  
1295			                                ; variables associated with screen and clear  
1295			                                ; the screen and set attributes.  
1295 af			        XOR     A               ; clear accumulator so that we can address  
1296 11 38 15		        LD      DE,L1539 - 1    ; the message table directly.  
1299 cd 0a 0c		        CALL    L0C0A           ; routine PO-MSG puts  
129c			                                ; '(c) 1982 Sinclair Research Ltd'  
129c			                                ; at bottom of display.  
129c fd cb 02 ee	        SET     5,(IY+$02)      ; update TV_FLAG  - signal lower screen will  
12a0			                                ; require clearing.  
12a0			  
12a0 18 07		        JR      L12A9           ; forward to MAIN-1  
12a2			  
12a2			; -------------------  
12a2			; Main execution loop  
12a2			; -------------------  
12a2			;  
12a2			;  
12a2			  
12a2			;; MAIN-EXEC  
12a2 fd 36 31 02	L12A2:  LD      (IY+$31),$02    ; set DF_SZ lower screen display file  
12a6			                                ; size to 2 lines.  
12a6 cd 95 17		        CALL    L1795           ; routine AUTO-LIST  
12a9			  
12a9			;; MAIN-1  
12a9 cd b0 16		L12A9:  CALL    L16B0           ; routine SET-MIN clears work areas.  
12ac			  
12ac			;; MAIN-2  
12ac 3e 00		L12AC:  LD      A,$00           ; select channel 'K' the keyboard  
12ae cd 01 16		        CALL    L1601           ; routine CHAN-OPEN opens it  
12b1 cd 2c 0f		        CALL    L0F2C           ; routine EDITOR is called.  
12b4			                                ; Note the above routine is where the Spectrum  
12b4			                                ; waits for user-interaction. Perhaps the  
12b4			                                ; most common input at this stage  
12b4			                                ; is LOAD "".  
12b4 cd 17 1b		        CALL    L1B17           ; routine LINE-SCAN scans the input.  
12b7 fd cb 00 7e	        BIT     7,(IY+$00)      ; test ERR_NR - will be $FF if syntax  
12bb			                                ; is correct.  
12bb 20 12		        JR      NZ,L12CF        ; forward, if correct, to MAIN-3.  
12bd			  
12bd			;   
12bd			  
12bd fd cb 30 66	        BIT     4,(IY+$30)      ; test FLAGS2 - K channel in use ?  
12c1 28 40		        JR      Z,L1303         ; forward to MAIN-4 if not.  
12c3			  
12c3			;  
12c3			  
12c3 2a 59 5c		        LD      HL,($5C59)      ; an editing error so address E_LINE.  
12c6 cd a7 11		        CALL    L11A7           ; routine REMOVE-FP removes the hidden  
12c9			                                ; floating-point forms.  
12c9 fd 36 00 ff	        LD      (IY+$00),$FF    ; system variable ERR_NR is reset to 'OK'.  
12cd 18 dd		        JR      L12AC           ; back to MAIN-2 to allow user to correct.  
12cf			  
12cf			; ---  
12cf			  
12cf			; the branch was here if syntax has passed test.  
12cf			  
12cf			;; MAIN-3  
12cf 2a 59 5c		L12CF:  LD      HL,($5C59)      ; fetch the edit line address from E_LINE.  
12d2 22 5d 5c		        LD      ($5C5D),HL      ; system variable CH_ADD is set to first  
12d5			                                ; character of edit line.  
12d5			                                ; Note. the above two instructions are a little  
12d5			                                ; inadequate.   
12d5			                                ; They are repeated with a subtle difference   
12d5			                                ; at the start of the next subroutine and are   
12d5			                                ; therefore not required above.  
12d5			  
12d5 cd fb 19		        CALL    L19FB           ; routine E-LINE-NO will fetch any line  
12d8			                                ; number to BC if this is a program line.  
12d8			  
12d8 78			        LD      A,B             ; test if the number of  
12d9 b1			        OR      C               ; the line is non-zero.  
12da c2 5d 15		        JP      NZ,L155D        ; jump forward to MAIN-ADD if so to add the   
12dd			                                ; line to the BASIC program.  
12dd			  
12dd			; Has the user just pressed the ENTER key ?  
12dd			  
12dd df			        RST     18H             ; GET-CHAR gets character addressed by CH_ADD.  
12de fe 0d		        CP      $0D             ; is it a carriage return ?  
12e0 28 c0		        JR      Z,L12A2         ; back to MAIN-EXEC if so for an automatic  
12e2			                                ; listing.  
12e2			  
12e2			; this must be a direct command.  
12e2			  
12e2 fd cb 30 46	        BIT     0,(IY+$30)      ; test FLAGS2 - clear the main screen ?  
12e6 c4 af 0d		        CALL    NZ,L0DAF        ; routine CL-ALL, if so, e.g. after listing.  
12e9 cd 6e 0d		        CALL    L0D6E           ; routine CLS-LOWER anyway.  
12ec 3e 19		        LD      A,$19           ; compute scroll count to 25 minus  
12ee fd 96 4f		        SUB     (IY+$4F)        ; value of S_POSN_hi.  
12f1 32 8c 5c		        LD      ($5C8C),A       ; update SCR_CT system variable.  
12f4 fd cb 01 fe	        SET     7,(IY+$01)      ; update FLAGS - signal running program.  
12f8 fd 36 00 ff	        LD      (IY+$00),$FF    ; set ERR_NR to 'OK'.  
12fc fd 36 0a 01	        LD      (IY+$0A),$01    ; set NSPPC to one for first statement.  
1300 cd 8a 1b		        CALL    L1B8A           ; call routine LINE-RUN to run the line.  
1303			                                ; sysvar ERR_SP therefore addresses MAIN-4  
1303			  
1303			; Examples of direct commands are RUN, CLS, LOAD "", PRINT USR 40000,  
1303			; LPRINT "A"; etc..  
1303			; If a user written machine-code program disables interrupts then it  
1303			; must enable them to pass the next step. We also jumped to here if the  
1303			; keyboard was not being used.  
1303			  
1303			;; MAIN-4  
1303 76			L1303:  HALT                    ; wait for interrupt.  
1304			  
1304 fd cb 01 ae	        RES     5,(IY+$01)      ; update FLAGS - signal no new key.  
1308 fd cb 30 4e	        BIT     1,(IY+$30)      ; test FLAGS2 - is printer buffer clear ?  
130c c4 cd 0e		        CALL    NZ,L0ECD        ; call routine COPY-BUFF if not.  
130f			                                ; Note. the programmer has neglected  
130f			                                ; to set bit 1 of FLAGS first.  
130f			  
130f 3a 3a 5c		        LD      A,($5C3A)       ; fetch ERR_NR  
1312 3c			        INC     A               ; increment to give true code.  
1313			  
1313			; Now deal with a runtime error as opposed to an editing error.  
1313			; However if the error code is now zero then the OK message will be printed.  
1313			  
1313			;; MAIN-G  
1313 f5			L1313:  PUSH    AF              ; save the error number.  
1314			  
1314 21 00 00		        LD      HL,$0000        ; prepare to clear some system variables.  
1317 fd 74 37		        LD      (IY+$37),H      ; clear all the bits of FLAGX.  
131a fd 74 26		        LD      (IY+$26),H      ; blank X_PTR_hi to suppress error marker.  
131d 22 0b 5c		        LD      ($5C0B),HL      ; blank DEFADD to signal that no defined  
1320			                                ; function is currently being evaluated.  
1320			  
1320 21 01 00		        LD      HL,$0001        ; explicit - inc hl would do.  
1323 22 16 5c		        LD      ($5C16),HL      ; ensure STRMS-00 is keyboard.  
1326			  
1326 cd b0 16		        CALL    L16B0           ; routine SET-MIN clears workspace etc.  
1329 fd cb 37 ae	        RES     5,(IY+$37)      ; update FLAGX - signal in EDIT not INPUT mode.  
132d			                                ; Note. all the bits were reset earlier.  
132d			  
132d cd 6e 0d		        CALL    L0D6E           ; call routine CLS-LOWER.  
1330 fd cb 02 ee	        SET     5,(IY+$02)      ; update TV_FLAG - signal lower screen  
1334			                                ; requires clearing.  
1334			  
1334 f1			        POP     AF              ; bring back the error number  
1335 47			        LD      B,A             ; and make a copy in B.  
1336 fe 0a		        CP      $0A             ; is it a print-ready digit ?  
1338 38 02		        JR      C,L133C         ; forward to MAIN-5 if so.  
133a			  
133a c6 07		        ADD     A,$07           ; add ASCII offset to letters.  
133c			  
133c			;; MAIN-5  
133c cd ef 15		L133C:  CALL    L15EF           ; call routine OUT-CODE to print the code.  
133f			  
133f 3e 20		        LD      A,$20           ; followed by a space.  
1341 d7			        RST     10H             ; PRINT-A  
1342			  
1342 78			        LD      A,B             ; fetch stored report code.  
1343 11 91 13		        LD      DE,L1391        ; address: rpt-mesgs.  
1346 cd 0a 0c		        CALL    L0C0A           ; call routine PO-MSG to print.  
1349			  
1349 cd 3b 3b		X1349:  CALL    L3B3B           ; Spectrum 128 patch  
134c 00			        NOP  
134d			   
134d cd 0a 0c		L134D:  CALL    L0C0A           ; routine PO-MSG prints them although it would  
1350			                                ; be more succinct to use RST $10.  
1350			  
1350 ed 4b 45 5c	        LD      BC,($5C45)      ; fetch PPC the current line number.  
1354 cd 1b 1a		        CALL    L1A1B           ; routine OUT-NUM-1 will print that  
1357 3e 3a		        LD      A,$3A           ; then a ':'.  
1359 d7			        RST     10H             ; PRINT-A  
135a			  
135a fd 4e 0d		        LD      C,(IY+$0D)      ; then SUBPPC for statement  
135d 06 00		        LD      B,$00           ; limited to 127  
135f cd 1b 1a		        CALL    L1A1B           ; routine OUT-NUM-1  
1362			  
1362 cd 97 10		        CALL    L1097           ; routine CLEAR-SP clears editing area.  
1365			                                ; which probably contained 'RUN'.  
1365 3a 3a 5c		        LD      A,($5C3A)       ; fetch ERR_NR again  
1368 3c			        INC     A               ; test for no error originally $FF.  
1369 28 1b		        JR      Z,L1386         ; forward to MAIN-9 if no error.  
136b			  
136b fe 09		        CP      $09             ; is code Report 9 STOP ?  
136d 28 04		        JR      Z,L1373         ; forward to MAIN-6 if so  
136f			  
136f fe 15		        CP      $15             ; is code Report L Break ?  
1371 20 03		        JR      NZ,L1376        ; forward to MAIN-7 if not  
1373			  
1373			; Stop or Break was encountered so consider CONTINUE.  
1373			  
1373			;; MAIN-6  
1373 fd 34 0d		L1373:  INC     (IY+$0D)        ; increment SUBPPC to next statement.  
1376			  
1376			;; MAIN-7  
1376 01 03 00		L1376:  LD      BC,$0003        ; prepare to copy 3 system variables to  
1379 11 70 5c		        LD      DE,$5C70        ; address OSPPC - statement for CONTINUE.  
137c			                                ; also updating OLDPPC line number below.  
137c			  
137c 21 44 5c		        LD      HL,$5C44        ; set source top to NSPPC next statement.  
137f cb 7e		        BIT     7,(HL)          ; did BREAK occur before the jump ?  
1381			                                ; e.g. between GO TO and next statement.  
1381 28 01		        JR      Z,L1384         ; skip forward to MAIN-8, if not, as setup  
1383			                                ; is correct.  
1383			  
1383 09			        ADD     HL,BC           ; set source to SUBPPC number of current  
1384			                                ; statement/line which will be repeated.  
1384			  
1384			;; MAIN-8  
1384 ed b8		L1384:  LDDR                    ; copy PPC to OLDPPC and SUBPPC to OSPCC  
1386			                                ; or NSPPC to OLDPPC and NEWPPC to OSPCC  
1386			  
1386			;; MAIN-9  
1386 fd 36 0a ff	L1386:  LD      (IY+$0A),$FF    ; update NSPPC - signal 'no jump'.  
138a fd cb 01 9e	        RES     3,(IY+$01)      ; update FLAGS  - signal use 'K' mode for  
138e			                                ; the first character in the editor and  
138e c3 ac 12		        JP      L12AC           ; jump back to MAIN-2.  
1391			  
1391			  
1391			; ----------------------  
1391			; Canned report messages  
1391			; ----------------------  
1391			; The Error reports with the last byte inverted. The first entry  
1391			; is a dummy entry. The last, which begins with $7F, the Spectrum  
1391			; character for copyright symbol, is placed here for convenience  
1391			; as is the preceding comma and space.  
1391			; The report line must accommodate a 4-digit line number and a 3-digit  
1391			; statement number which limits the length of the message text to twenty   
1391			; characters.  
1391			; e.g.  "B Integer out of range, 1000:127"  
1391			  
1391			;; rpt-mesgs  
1391 80			L1391:  DEFB    $80  
1392 .. cb		        DEFB    'O',$80+'K'                             ; 0  
1394 ..			        DEFM    "NEXT without FO"  
13a3 d2			        DEFB    $80+'R'                                 ; 1  
13a4 ..			        DEFM    "Variable not foun"  
13b5 e4			        DEFB    $80+'d'                                 ; 2  
13b6 ..			        DEFM    "Subscript wron"  
13c4 e7			        DEFB    $80+'g'                                 ; 3  
13c5 ..			        DEFM    "Out of memor"  
13d1 f9			        DEFB    $80+'y'                                 ; 4  
13d2 ..			        DEFM    "Out of scree"  
13de ee			        DEFB    $80+'n'                                 ; 5  
13df ..			        DEFM    "Number too bi"  
13ec e7			        DEFB    $80+'g'                                 ; 6  
13ed ..			        DEFM    "RETURN without GOSU"  
1400 c2			        DEFB    $80+'B'                                 ; 7  
1401 ..			        DEFM    "End of fil"  
140b e5			        DEFB    $80+'e'                                 ; 8  
140c ..			        DEFM    "STOP statemen"  
1419 f4			        DEFB    $80+'t'                                 ; 9  
141a ..			        DEFM    "Invalid argumen"  
1429 f4			        DEFB    $80+'t'                                 ; A  
142a ..			        DEFM    "Integer out of rang"  
143d e5			        DEFB    $80+'e'                                 ; B  
143e ..			        DEFM    "Nonsense in BASI"  
144e c3			        DEFB    $80+'C'                                 ; C  
144f ..			        DEFM    "BREAK - CONT repeat"  
1462 f3			        DEFB    $80+'s'                                 ; D  
1463 ..			        DEFM    "Out of DAT"  
146d c1			        DEFB    $80+'A'                                 ; E  
146e ..			        DEFM    "Invalid file nam"  
147e e5			        DEFB    $80+'e'                                 ; F  
147f ..			        DEFM    "No room for lin"  
148e e5			        DEFB    $80+'e'                                 ; G  
148f ..			        DEFM    "STOP in INPU"  
149b d4			        DEFB    $80+'T'                                 ; H  
149c ..			        DEFM    "FOR without NEX"  
14ab d4			        DEFB    $80+'T'                                 ; I  
14ac ..			        DEFM    "Invalid I/O devic"  
14bd e5			        DEFB    $80+'e'                                 ; J  
14be ..			        DEFM    "Invalid colou"  
14cb f2			        DEFB    $80+'r'                                 ; K  
14cc ..			        DEFM    "BREAK into progra"  
14dd ed			        DEFB    $80+'m'                                 ; L  
14de ..			        DEFM    "RAMTOP no goo"  
14eb e4			        DEFB    $80+'d'                                 ; M  
14ec ..			        DEFM    "Statement los"  
14f9 f4			        DEFB    $80+'t'                                 ; N  
14fa ..			        DEFM    "Invalid strea"  
1507 ed			        DEFB    $80+'m'                                 ; O  
1508 ..			        DEFM    "FN without DE"  
1515 c6			        DEFB    $80+'F'                                 ; P  
1516 ..			        DEFM    "Parameter erro"  
1524 f2			        DEFB    $80+'r'                                 ; Q  
1525 ..			        DEFM    "Tape loading erro"  
1536 f2			        DEFB    $80+'r'                                 ; R  
1537			;; comma-sp     
1537 .. a0		L1537:  DEFB    ',',$80+' '                             ; used in report line.  
1539			;; copyright  
1539 7f			L1539:  DEFB    $7F                                     ; copyright  
153a ..			        DEFM    " 1982 Sinclair Research Lt"  
1554 e4			        DEFB    $80+'d'  
1555			  
1555			  
1555			; -------------  
1555			; REPORT-G  
1555			; -------------  
1555			; Note ERR_SP points here during line entry which allows the  
1555			; normal 'Out of Memory' report to be augmented to the more  
1555			; precise 'No Room for line' report.  
1555			  
1555			;; REPORT-G  
1555			; No Room for line  
1555 3e 10		L1555:  LD      A,$10           ; i.e. 'G' -$30 -$07  
1557 01 00 00		        LD      BC,$0000        ; this seems unnecessary.  
155a c3 13 13		        JP      L1313           ; jump back to MAIN-G  
155d			  
155d			; -----------------------------  
155d			; Handle addition of BASIC line  
155d			; -----------------------------  
155d			; Note this is not a subroutine but a branch of the main execution loop.  
155d			; System variable ERR_SP still points to editing error handler.  
155d			; A new line is added to the BASIC program at the appropriate place.  
155d			; An existing line with same number is deleted first.  
155d			; Entering an existing line number deletes that line.  
155d			; Entering a non-existent line allows the subsequent line to be edited next.  
155d			  
155d			;; MAIN-ADD  
155d ed 43 49 5c	L155D:  LD      ($5C49),BC      ; set E_PPC to extracted line number.  
1561 2a 5d 5c		        LD      HL,($5C5D)      ; fetch CH_ADD - points to location after the  
1564			                                ; initial digits (set in E_LINE_NO).  
1564 eb			        EX      DE,HL           ; save start of BASIC in DE.  
1565			  
1565 21 55 15		        LD      HL,L1555        ; Address: REPORT-G  
1568 e5			        PUSH    HL              ; is pushed on stack and addressed by ERR_SP.  
1569			                                ; the only error that can occur is  
1569			                                ; 'Out of memory'.  
1569			  
1569 2a 61 5c		        LD      HL,($5C61)      ; fetch WORKSP - end of line.  
156c 37			        SCF                     ; prepare for true subtraction.  
156d ed 52		        SBC     HL,DE           ; find length of BASIC and  
156f e5			        PUSH    HL              ; save it on stack.  
1570 60			        LD      H,B             ; transfer line number  
1571 69			        LD      L,C             ; to HL register.  
1572 cd 6e 19		        CALL    L196E           ; routine LINE-ADDR will see if  
1575			                                ; a line with the same number exists.  
1575 20 06		        JR      NZ,L157D        ; forward if no existing line to MAIN-ADD1.  
1577			  
1577 cd b8 19		        CALL    L19B8           ; routine NEXT-ONE finds the existing line.  
157a cd e8 19		        CALL    L19E8           ; routine RECLAIM-2 reclaims it.  
157d			  
157d			;; MAIN-ADD1  
157d c1			L157D:  POP     BC              ; retrieve the length of the new line.  
157e 79			        LD      A,C             ; and test if carriage return only  
157f 3d			        DEC     A               ; i.e. one byte long.  
1580 b0			        OR      B               ; result would be zero.  
1581 28 28		        JR      Z,L15AB         ; forward to MAIN-ADD2 is so.  
1583			  
1583 c5			        PUSH    BC              ; save the length again.  
1584 03			        INC     BC              ; adjust for inclusion  
1585 03			        INC     BC              ; of line number (two bytes)  
1586 03			        INC     BC              ; and line length  
1587 03			        INC     BC              ; (two bytes).  
1588 2b			        DEC     HL              ; HL points to location before the destination  
1589			  
1589 ed 5b 53 5c	        LD      DE,($5C53)      ; fetch the address of PROG  
158d d5			        PUSH    DE              ; and save it on the stack  
158e cd 55 16		        CALL    L1655           ; routine MAKE-ROOM creates BC spaces in  
1591			                                ; program area and updates pointers.  
1591 e1			        POP     HL              ; restore old program pointer.  
1592 22 53 5c		        LD      ($5C53),HL      ; and put back in PROG as it may have been  
1595			                                ; altered by the POINTERS routine.  
1595			  
1595 c1			        POP     BC              ; retrieve BASIC length  
1596 c5			        PUSH    BC              ; and save again.  
1597			  
1597 13			        INC     DE              ; points to end of new area.  
1598 2a 61 5c		        LD      HL,($5C61)      ; set HL to WORKSP - location after edit line.  
159b 2b			        DEC     HL              ; decrement to address end marker.  
159c 2b			        DEC     HL              ; decrement to address carriage return.  
159d ed b8		        LDDR                    ; copy the BASIC line back to initial command.  
159f			  
159f 2a 49 5c		        LD      HL,($5C49)      ; fetch E_PPC - line number.  
15a2 eb			        EX      DE,HL           ; swap it to DE, HL points to last of  
15a3			                                ; four locations.  
15a3 c1			        POP     BC              ; retrieve length of line.  
15a4 70			        LD      (HL),B          ; high byte last.  
15a5 2b			        DEC     HL              ;  
15a6 71			        LD      (HL),C          ; then low byte of length.  
15a7 2b			        DEC     HL              ;  
15a8 73			        LD      (HL),E          ; then low byte of line number.  
15a9 2b			        DEC     HL              ;  
15aa 72			        LD      (HL),D          ; then high byte range $0 - $27 (1-9999).  
15ab			  
15ab			;; MAIN-ADD2  
15ab f1			L15AB:  POP     AF              ; drop the address of Report G  
15ac c3 a2 12		        JP      L12A2           ; and back to MAIN-EXEC producing a listing  
15af			                                ; and to reset ERR_SP in EDITOR.  
15af			  
15af			  
15af			; ---------------------------  
15af			; Initial channel information  
15af			; ---------------------------  
15af			; This initial channel information is copied from ROM to RAM,  
15af			; during initialization. It's new location is after the system  
15af			; variables and is addressed by the system variable CHANS  
15af			; which means that it can slide up and down in memory.  
15af			; The table is never searched and the last character which could be anything  
15af			; other than a comma provides a convenient resting place for DATADD.  
15af			  
15af			;; init-chan  
15af f4 09		L15AF:  DEFW    L09F4           ; PRINT-OUT  
15b1 a8 10		        DEFW    L10A8           ; KEY-INPUT  
15b3 4b			        DEFB    $4B             ; 'K'  
15b4 f4 09		        DEFW    L09F4           ; PRINT-OUT  
15b6 c4 15		        DEFW    L15C4           ; REPORT-J  
15b8 53			        DEFB    $53             ; 'S'  
15b9 81 0f		        DEFW    L0F81           ; ADD-CHAR  
15bb c4 15		        DEFW    L15C4           ; REPORT-J  
15bd 52			        DEFB    $52             ; 'R'  
15be f4 09		        DEFW    L09F4           ; PRINT-OUT  
15c0 c4 15		        DEFW    L15C4           ; REPORT-J  
15c2 50			        DEFB    $50             ; 'P'  
15c3			  
15c3 80			        DEFB    $80             ; End Marker  
15c4			  
15c4			;; REPORT-J  
15c4 cf			L15C4:  RST     08H             ; ERROR-1  
15c5 12			        DEFB    $12             ; Error Report: Invalid I/O device  
15c6			  
15c6			  
15c6			; -------------------  
15c6			; Initial stream data  
15c6			; -------------------  
15c6			; This is the initial stream data for the seven streams $FD - $03 that is  
15c6			; copied from ROM to the STRMS system variables area during initialization.  
15c6			; There are reserved locations there for another 12 streams.  
15c6			; Each location contains an offset to the second byte of a channel.  
15c6			; The first byte of a channel can't be used as that would result in an  
15c6			; offset of zero for some and zero is used to denote that a stream is closed.  
15c6			  
15c6			;; init-strm  
15c6 01 00		L15C6:  DEFB    $01, $00        ; stream $FD offset to channel 'K'  
15c8 06 00		        DEFB    $06, $00        ; stream $FE offset to channel 'S'  
15ca 0b 00		        DEFB    $0B, $00        ; stream $FF offset to channel 'R'  
15cc			  
15cc 01 00		        DEFB    $01, $00        ; stream $00 offset to channel 'K'  
15ce 01 00		        DEFB    $01, $00        ; stream $01 offset to channel 'K'  
15d0 06 00		        DEFB    $06, $00        ; stream $02 offset to channel 'S'  
15d2 10 00		        DEFB    $10, $00        ; stream $03 offset to channel 'P'  
15d4			  
15d4			; ----------------------------  
15d4			; Control for input subroutine  
15d4			; ----------------------------  
15d4			;  
15d4			  
15d4			;; WAIT-KEY  
15d4 fd cb 02 6e	L15D4:  BIT     5,(IY+$02)      ; test TV_FLAG - clear lower screen ?  
15d8 20 04		        JR      NZ,L15DE        ; forward to WAIT-KEY1 if so.  
15da			  
15da fd cb 02 de	        SET     3,(IY+$02)      ; update TV_FLAG - signal reprint the edit  
15de			                                ; line to the lower screen.  
15de			  
15de			;; WAIT-KEY1  
15de cd e6 15		L15DE:  CALL    L15E6           ; routine INPUT-AD is called.  
15e1 d8			        RET     C               ; return with acceptable keys.  
15e2			  
15e2 28 fa		        JR      Z,L15DE         ; back to WAIT-KEY1 if no key is pressed  
15e4			                                ; or it has been handled within INPUT-AD.  
15e4			  
15e4			; Note. When inputting from the keyboard all characters are returned with  
15e4			; above conditions so this path is never taken.  
15e4			  
15e4			;; REPORT-8  
15e4 cf			L15E4:  RST     08H             ; ERROR-1  
15e5 07			        DEFB    $07             ; Error Report: End of file  
15e6			  
15e6			; ------------------------------  
15e6			; Make HL point to input address  
15e6			; ------------------------------  
15e6			; This routine fetches the address of the input stream from the current  
15e6			; channel area using system variable CURCHL.  
15e6			  
15e6			;; INPUT-AD  
15e6 d9			L15E6:  EXX                     ; switch in alternate set.  
15e7 e5			        PUSH    HL              ; save HL register  
15e8 2a 51 5c		        LD      HL,($5C51)      ; fetch address of CURCHL - current channel.  
15eb 23			        INC     HL              ; step over output routine  
15ec 23			        INC     HL              ; to point to low byte of input routine.  
15ed 18 08		        JR      L15F7           ; forward to CALL-SUB.  
15ef			  
15ef			; -------------------  
15ef			; Main Output Routine  
15ef			; -------------------  
15ef			; The entry point OUT-CODE is called on five occasions to print  
15ef			; the ASCII equivalent of a value 0-9.  
15ef			;  
15ef			; PRINT-A-2 is a continuation of the RST 10 to print any character.  
15ef			; Both print to the current channel and the printing of control codes  
15ef			; may alter that channel to divert subsequent RST 10 instructions  
15ef			; to temporary routines. The normal channel is $09F4.  
15ef			  
15ef			;; OUT-CODE  
15ef 1e 30		L15EF:  LD      E,$30           ; add 48 decimal to give ASCII  
15f1 83			        ADD     A,E             ; character '0' to '9'.  
15f2			  
15f2			;; PRINT-A-2  
15f2 d9			L15F2:  EXX                     ; switch in alternate set  
15f3 e5			        PUSH    HL              ; save HL register  
15f4 2a 51 5c		        LD      HL,($5C51)      ; fetch CURCHL the current channel.  
15f7			  
15f7			; input-ad rejoins here also.  
15f7			  
15f7			;; CALL-SUB  
15f7 5e			L15F7:  LD      E,(HL)          ; put the low byte in E.  
15f8 23			        INC     HL              ; advance address.  
15f9 56			        LD      D,(HL)          ; put the high byte to D.  
15fa eb			        EX      DE,HL           ; transfer the stream to HL.  
15fb cd 2c 16		        CALL    L162C           ; use routine CALL-JUMP.  
15fe			                                ; in effect CALL (HL).  
15fe			  
15fe e1			        POP     HL              ; restore saved HL register.  
15ff d9			        EXX                     ; switch back to the main set and  
1600 c9			        RET                     ; return.  
1601			  
1601			; ------------  
1601			; Open channel  
1601			; ------------  
1601			; This subroutine is used by the ROM to open a channel 'K', 'S', 'R' or 'P'.  
1601			; This is either for its own use or in response to a user's request, for  
1601			; example, when '#' is encountered with output - PRINT, LIST etc.  
1601			; or with input - INPUT, INKEY$ etc.  
1601			; it is entered with a system stream $FD - $FF, or a user stream $00 - $0F  
1601			; in the accumulator.  
1601			  
1601			;; CHAN-OPEN  
1601 87			L1601:  ADD     A,A             ; double the stream ($FF will become $FE etc.)  
1602 c6 16		        ADD     A,$16           ; add the offset to stream 0 from $5C00  
1604 6f			        LD      L,A             ; result to L  
1605 26 5c		        LD      H,$5C           ; now form the address in STRMS area.  
1607 5e			        LD      E,(HL)          ; fetch low byte of CHANS offset  
1608 23			        INC     HL              ; address next  
1609 56			        LD      D,(HL)          ; fetch high byte of offset  
160a 7a			        LD      A,D             ; test that the stream is open.  
160b b3			        OR      E               ; zero if closed.  
160c 20 02		        JR      NZ,L1610        ; forward to CHAN-OP-1 if open.  
160e			  
160e			;; REPORT-Oa  
160e cf			L160E:  RST     08H             ; ERROR-1  
160f 17			        DEFB    $17             ; Error Report: Invalid stream  
1610			  
1610			; continue here if stream was open. Note that the offset is from CHANS  
1610			; to the second byte of the channel.  
1610			  
1610			;; CHAN-OP-1  
1610 1b			L1610:  DEC     DE              ; reduce offset so it points to the channel.  
1611 2a 4f 5c		        LD      HL,($5C4F)      ; fetch CHANS the location of the base of  
1614			                                ; the channel information area  
1614 19			        ADD     HL,DE           ; and add the offset to address the channel.  
1615			                                ; and continue to set flags.  
1615			  
1615			; -----------------  
1615			; Set channel flags  
1615			; -----------------  
1615			; This subroutine is used from ED-EDIT, str$ and read-in to reset the  
1615			; current channel when it has been temporarily altered.  
1615			  
1615			;; CHAN-FLAG  
1615 22 51 5c		L1615:  LD      ($5C51),HL      ; set CURCHL system variable to the  
1618			                                ; address in HL  
1618 fd cb 30 a6	        RES     4,(IY+$30)      ; update FLAGS2  - signal K channel not in use.  
161c			                                ; Note. provide a default for channel 'R'.  
161c 23			        INC     HL              ; advance past  
161d 23			        INC     HL              ; output routine.  
161e 23			        INC     HL              ; advance past  
161f 23			        INC     HL              ; input routine.  
1620 4e			        LD      C,(HL)          ; pick up the letter.  
1621 21 2d 16		        LD      HL,L162D        ; address: chn-cd-lu  
1624 cd dc 16		        CALL    L16DC           ; routine INDEXER finds offset to a  
1627			                                ; flag-setting routine.  
1627			  
1627 d0			        RET     NC              ; but if the letter wasn't found in the  
1628			                                ; table just return now. - channel 'R'.  
1628			  
1628 16 00		        LD      D,$00           ; prepare to add  
162a 5e			        LD      E,(HL)          ; offset to E  
162b 19			        ADD     HL,DE           ; add offset to location of offset to form  
162c			                                ; address of routine  
162c			  
162c			;; CALL-JUMP  
162c e9			L162C:  JP      (HL)            ; jump to the routine  
162d			  
162d			; Footnote. calling any location that holds JP (HL) is the equivalent to  
162d			; a pseudo Z80 instruction CALL (HL). The ROM uses the instruction above.  
162d			  
162d			; --------------------------  
162d			; Channel code look-up table  
162d			; --------------------------  
162d			; This table is used by the routine above to find one of the three  
162d			; flag setting routines below it.  
162d			; A zero end-marker is required as channel 'R' is not present.  
162d			  
162d			;; chn-cd-lu  
162d .. 06		L162D:  DEFB    'K', L1634-$-1  ; offset $06 to CHAN-K  
162f .. 12		        DEFB    'S', L1642-$-1  ; offset $12 to CHAN-S  
1631 .. 1b		        DEFB    'P', L164D-$-1  ; offset $1B to CHAN-P  
1633			  
1633 00			        DEFB    $00             ; end marker.  
1634			  
1634			; --------------  
1634			; Channel K flag  
1634			; --------------  
1634			; routine to set flags for lower screen/keyboard channel.  
1634			  
1634			;; CHAN-K  
1634 fd cb 02 c6	L1634:  SET     0,(IY+$02)      ; update TV_FLAG  - signal lower screen in use  
1638 fd cb 01 ae	        RES     5,(IY+$01)      ; update FLAGS    - signal no new key  
163c fd cb 30 e6	        SET     4,(IY+$30)      ; update FLAGS2   - signal K channel in use  
1640 18 04		        JR      L1646           ; forward to CHAN-S-1 for indirect exit  
1642			  
1642			; --------------  
1642			; Channel S flag  
1642			; --------------  
1642			; routine to set flags for upper screen channel.  
1642			  
1642			;; CHAN-S  
1642 fd cb 02 86	L1642:  RES     0,(IY+$02)      ; TV_FLAG  - signal main screen in use  
1646			  
1646			;; CHAN-S-1  
1646 fd cb 01 8e	L1646:  RES     1,(IY+$01)      ; update FLAGS  - signal printer not in use  
164a c3 4d 0d		        JP      L0D4D           ; jump back to TEMPS and exit via that  
164d			                                ; routine after setting temporary attributes.  
164d			; --------------  
164d			; Channel P flag  
164d			; --------------  
164d			; This routine sets a flag so that subsequent print related commands  
164d			; print to printer or update the relevant system variables.  
164d			; This status remains in force until reset by the routine above.  
164d			  
164d			;; CHAN-P  
164d fd cb 01 ce	L164D:  SET     1,(IY+$01)      ; update FLAGS  - signal printer in use  
1651 c9			        RET                     ; return  
1652			  
1652			; -----------------------  
1652			; Just one space required  
1652			; -----------------------  
1652			; This routine is called once only to create a single space  
1652			; in workspace by ADD-CHAR. It is slightly quicker than using a RST $30.  
1652			; There are several instances in the calculator where the sequence  
1652			; ld bc, 1; rst $30 could be replaced by a call to this routine but it  
1652			; only gives a saving of one byte each time.  
1652			  
1652			;; ONE-SPACE  
1652 01 01 00		L1652:  LD      BC,$0001        ; create space for a single character.  
1655			  
1655			; ---------  
1655			; Make Room  
1655			; ---------  
1655			; This entry point is used to create BC spaces in various areas such as  
1655			; program area, variables area, workspace etc..  
1655			; The entire free RAM is available to each BASIC statement.  
1655			; On entry, HL addresses where the first location is to be created.  
1655			; Afterwards, HL will point to the location before this.  
1655			  
1655			;; MAKE-ROOM  
1655 e5			L1655:  PUSH    HL              ; save the address pointer.  
1656 cd 05 1f		        CALL    L1F05           ; routine TEST-ROOM checks if room  
1659			                                ; exists and generates an error if not.  
1659 e1			        POP     HL              ; restore the address pointer.  
165a cd 64 16		        CALL    L1664           ; routine POINTERS updates the  
165d			                                ; dynamic memory location pointers.  
165d			                                ; DE now holds the old value of STKEND.  
165d 2a 65 5c		        LD      HL,($5C65)      ; fetch new STKEND the top destination.  
1660			  
1660 eb			        EX      DE,HL           ; HL now addresses the top of the area to  
1661			                                ; be moved up - old STKEND.  
1661 ed b8		        LDDR                    ; the program, variables, etc are moved up.  
1663 c9			        RET                     ; return with new area ready to be populated.  
1664			                                ; HL points to location before new area,  
1664			                                ; and DE to last of new locations.  
1664			  
1664			; -----------------------------------------------  
1664			; Adjust pointers before making or reclaiming room  
1664			; -----------------------------------------------  
1664			; This routine is called by MAKE-ROOM to adjust upwards and by RECLAIM to  
1664			; adjust downwards the pointers within dynamic memory.  
1664			; The fourteen pointers to dynamic memory, starting with VARS and ending   
1664			; with STKEND, are updated adding BC if they are higher than the position  
1664			; in HL.    
1664			; The system variables are in no particular order except that STKEND, the first  
1664			; free location after dynamic memory must be the last encountered.  
1664			  
1664			;; POINTERS  
1664 f5			L1664:  PUSH    AF              ; preserve accumulator.  
1665 e5			        PUSH    HL              ; put pos pointer on stack.  
1666 21 4b 5c		        LD      HL,$5C4B        ; address VARS the first of the  
1669 3e 0e		        LD      A,$0E           ; fourteen variables to consider.  
166b			  
166b			;; PTR-NEXT  
166b 5e			L166B:  LD      E,(HL)          ; fetch the low byte of the system variable.  
166c 23			        INC     HL              ; advance address.  
166d 56			        LD      D,(HL)          ; fetch high byte of the system variable.  
166e e3			        EX      (SP),HL         ; swap pointer on stack with the variable  
166f			                                ; pointer.  
166f a7			        AND     A               ; prepare to subtract.  
1670 ed 52		        SBC     HL,DE           ; subtract variable address  
1672 19			        ADD     HL,DE           ; and add back  
1673 e3			        EX      (SP),HL         ; swap pos with system variable pointer  
1674 30 09		        JR      NC,L167F        ; forward to PTR-DONE if var before pos  
1676			  
1676 d5			        PUSH    DE              ; save system variable address.  
1677 eb			        EX      DE,HL           ; transfer to HL  
1678 09			        ADD     HL,BC           ; add the offset  
1679 eb			        EX      DE,HL           ; back to DE  
167a 72			        LD      (HL),D          ; load high byte  
167b 2b			        DEC     HL              ; move back  
167c 73			        LD      (HL),E          ; load low byte  
167d 23			        INC     HL              ; advance to high byte  
167e d1			        POP     DE              ; restore old system variable address.  
167f			  
167f			;; PTR-DONE  
167f 23			L167F:  INC     HL              ; address next system variable.  
1680 3d			        DEC     A               ; decrease counter.  
1681 20 e8		        JR      NZ,L166B        ; back to PTR-NEXT if more.  
1683 eb			        EX      DE,HL           ; transfer old value of STKEND to HL.  
1684			                                ; Note. this has always been updated.  
1684 d1			        POP     DE              ; pop the address of the position.  
1685			  
1685 f1			        POP     AF              ; pop preserved accumulator.  
1686 a7			        AND     A               ; clear carry flag preparing to subtract.  
1687			  
1687 ed 52		        SBC     HL,DE           ; subtract position from old stkend   
1689 44			        LD      B,H             ; to give number of data bytes  
168a 4d			        LD      C,L             ; to be moved.  
168b 03			        INC     BC              ; increment as we also copy byte at old STKEND.  
168c 19			        ADD     HL,DE           ; recompute old stkend.  
168d eb			        EX      DE,HL           ; transfer to DE.  
168e c9			        RET                     ; return.  
168f			  
168f			  
168f			  
168f			; -------------------  
168f			; Collect line number  
168f			; -------------------  
168f			; This routine extracts a line number, at an address that has previously  
168f			; been found using LINE-ADDR, and it is entered at LINE-NO. If it encounters  
168f			; the program 'end-marker' then the previous line is used and if that  
168f			; should also be unacceptable then zero is used as it must be a direct  
168f			; command. The program end-marker is the variables end-marker $80, or  
168f			; if variables exist, then the first character of any variable name.  
168f			  
168f			;; LINE-ZERO  
168f 00 00		L168F:  DEFB    $00, $00        ; dummy line number used for direct commands  
1691			  
1691			  
1691			;; LINE-NO-A  
1691 eb			L1691:  EX      DE,HL           ; fetch the previous line to HL and set  
1692 11 8f 16		        LD      DE,$168F        ; DE to LINE-ZERO should HL also fail.  
1695			  
1695			; -> The Entry Point.  
1695			  
1695			;; LINE-NO  
1695 7e			L1695:  LD      A,(HL)          ; fetch the high byte - max $2F  
1696 e6 c0		        AND     $C0             ; mask off the invalid bits.  
1698 20 f7		        JR      NZ,L1691        ; to LINE-NO-A if an end-marker.  
169a			  
169a 56			        LD      D,(HL)          ; reload the high byte.  
169b 23			        INC     HL              ; advance address.  
169c 5e			        LD      E,(HL)          ; pick up the low byte.  
169d c9			        RET                     ; return from here.  
169e			  
169e			; -------------------  
169e			; Handle reserve room  
169e			; -------------------  
169e			; This is a continuation of the restart BC-SPACES  
169e			  
169e			;; RESERVE  
169e 2a 63 5c		L169E:  LD      HL,($5C63)      ; STKBOT first location of calculator stack  
16a1 2b			        DEC     HL              ; make one less than new location  
16a2 cd 55 16		        CALL    L1655           ; routine MAKE-ROOM creates the room.  
16a5 23			        INC     HL              ; address the first new location  
16a6 23			        INC     HL              ; advance to second  
16a7 c1			        POP     BC              ; restore old WORKSP  
16a8 ed 43 61 5c	        LD      ($5C61),BC      ; system variable WORKSP was perhaps  
16ac			                                ; changed by POINTERS routine.  
16ac c1			        POP     BC              ; restore count for return value.  
16ad eb			        EX      DE,HL           ; switch. DE = location after first new space  
16ae 23			        INC     HL              ; HL now location after new space  
16af c9			        RET                     ; return.  
16b0			  
16b0			; ---------------------------  
16b0			; Clear various editing areas  
16b0			; ---------------------------  
16b0			; This routine sets the editing area, workspace and calculator stack  
16b0			; to their minimum configurations as at initialization and indeed this  
16b0			; routine could have been relied on to perform that task.  
16b0			; This routine uses HL only and returns with that register holding  
16b0			; WORKSP/STKBOT/STKEND though no use is made of this. The routines also  
16b0			; reset MEM to its usual place in the systems variable area should it  
16b0			; have been relocated to a FOR-NEXT variable. The main entry point  
16b0			; SET-MIN is called at the start of the MAIN-EXEC loop and prior to  
16b0			; displaying an error.  
16b0			  
16b0			;; SET-MIN  
16b0 2a 59 5c		L16B0:  LD      HL,($5C59)      ; fetch E_LINE  
16b3 36 0d		        LD      (HL),$0D        ; insert carriage return  
16b5 22 5b 5c		        LD      ($5C5B),HL      ; make K_CUR keyboard cursor point there.  
16b8 23			        INC     HL              ; next location  
16b9 36 80		        LD      (HL),$80        ; holds end-marker $80  
16bb 23			        INC     HL              ; next location becomes  
16bc 22 61 5c		        LD      ($5C61),HL      ; start of WORKSP  
16bf			  
16bf			; This entry point is used prior to input and prior to the execution,  
16bf			; or parsing, of each statement.  
16bf			  
16bf			;; SET-WORK  
16bf 2a 61 5c		L16BF:  LD      HL,($5C61)      ; fetch WORKSP value  
16c2 22 63 5c		        LD      ($5C63),HL      ; and place in STKBOT  
16c5			  
16c5			; This entry point is used to move the stack back to its normal place  
16c5			; after temporary relocation during line entry and also from ERROR-3  
16c5			  
16c5			;; SET-STK  
16c5 2a 63 5c		L16C5:  LD      HL,($5C63)      ; fetch STKBOT value   
16c8 22 65 5c		        LD      ($5C65),HL      ; and place in STKEND.  
16cb			  
16cb e5			        PUSH    HL              ; perhaps an obsolete entry point.  
16cc 21 92 5c		        LD      HL,$5C92        ; normal location of MEM-0  
16cf 22 68 5c		        LD      ($5C68),HL      ; is restored to system variable MEM.  
16d2 e1			        POP     HL              ; saved value not required.  
16d3 c9			        RET                     ; return.  
16d4			  
16d4			; ------------------  
16d4			; Reclaim edit-line?  
16d4			; ------------------  
16d4			; This seems to be legacy code from the ZX80/ZX81 as it is   
16d4			; not used in this ROM.  
16d4			; That task, in fact, is performed here by the dual-area routine CLEAR-SP.  
16d4			; This routine is designed to deal with something that is known to be in the  
16d4			; edit buffer and not workspace.  
16d4			; On entry, HL must point to the end of the something to be deleted.  
16d4			  
16d4			;; REC-EDIT  
16d4 ed 5b 59 5c	L16D4:  LD      DE,($5C59)      ; fetch start of edit line from E_LINE.  
16d8 c3 e5 19		        JP      L19E5           ; jump forward to RECLAIM-1.  
16db			  
16db			; --------------------------  
16db			; The Table INDEXING routine  
16db			; --------------------------  
16db			; This routine is used to search two-byte hash tables for a character  
16db			; held in C, returning the address of the following offset byte.  
16db			; if it is known that the character is in the table e.g. for priorities,  
16db			; then the table requires no zero end-marker. If this is not known at the  
16db			; outset then a zero end-marker is required and carry is set to signal  
16db			; success.  
16db			  
16db			;; INDEXER-1  
16db 23			L16DB:  INC     HL              ; address the next pair of values.  
16dc			  
16dc			; -> The Entry Point.  
16dc			  
16dc			;; INDEXER  
16dc 7e			L16DC:  LD      A,(HL)          ; fetch the first byte of pair  
16dd a7			        AND     A               ; is it the end-marker ?  
16de c8			        RET     Z               ; return with carry reset if so.  
16df			  
16df b9			        CP      C               ; is it the required character ?  
16e0 23			        INC     HL              ; address next location.  
16e1 20 f8		        JR      NZ,L16DB        ; back to INDEXER-1 if no match.  
16e3			  
16e3 37			        SCF                     ; else set the carry flag.  
16e4 c9			        RET                     ; return with carry set  
16e5			  
16e5			; --------------------------------  
16e5			; The Channel and Streams Routines  
16e5			; --------------------------------  
16e5			; A channel is an input/output route to a hardware device  
16e5			; and is identified to the system by a single letter e.g. 'K' for  
16e5			; the keyboard. A channel can have an input and output route  
16e5			; associated with it in which case it is bi-directional like  
16e5			; the keyboard. Others like the upper screen 'S' are output  
16e5			; only and the input routine usually points to a report message.  
16e5			; Channels 'K' and 'S' are system channels and it would be inappropriate  
16e5			; to close the associated streams so a mechanism is provided to  
16e5			; re-attach them. When the re-attachment is no longer required, then  
16e5			; closing these streams resets them as at initialization.  
16e5			; The same also would have applied to channel 'R', the RS232 channel  
16e5			; as that is used by the system. It's input stream seems to have been  
16e5			; removed and it is not available to the user. However the channel could  
16e5			; not be removed entirely as its output routine was used by the system.  
16e5			; As a result of removing this channel, channel 'P', the printer is  
16e5			; erroneously treated as a system channel.  
16e5			; Ironically the tape streamer is not accessed through streams and  
16e5			; channels.  
16e5			; Early demonstrations of the Spectrum showed a single microdrive being  
16e5			; controlled by this ROM. Adverts also said that the network and RS232  
16e5			; were in this ROM. Channels 'M' and 'N' are user channels and have been  
16e5			; removed successfully if, as seems vaguely possible, they existed.  
16e5			  
16e5			; ---------------------  
16e5			; Handle CLOSE# command  
16e5			; ---------------------  
16e5			; This command allows streams to be closed after use.  
16e5			; Any temporary memory areas used by the stream would be reclaimed and  
16e5			; finally flags set or reset if necessary.  
16e5			  
16e5			;; CLOSE  
16e5 cd 1e 17		L16E5:  CALL    L171E           ; routine STR-DATA fetches parameter  
16e8			                                ; from calculator stack and gets the  
16e8			                                ; existing STRMS data pointer address in HL  
16e8			                                ; and stream offset from CHANS in BC.  
16e8			  
16e8			                                ; Note. this offset could be zero if the  
16e8			                                ; stream is already closed. A check for this  
16e8			                                ; should occur now and an error should be  
16e8			                                ; generated, for example,  
16e8			                                ; Report S 'Stream already closed'.  
16e8			  
16e8 cd 01 17		        CALL    L1701           ; routine CLOSE-2 would perform any actions  
16eb			                                ; peculiar to that stream without disturbing  
16eb			                                ; data pointer to STRMS entry in HL.  
16eb			  
16eb 01 00 00		        LD      BC,$0000        ; the stream is to be blanked.  
16ee 11 e2 a3		        LD      DE,$A3E2        ; the number of bytes from stream 4, $5C1E,  
16f1			                                ; to $10000  
16f1 eb			        EX      DE,HL           ; transfer offset to HL, STRMS data pointer  
16f2			                                ; to DE.  
16f2 19			        ADD     HL,DE           ; add the offset to the data pointer.    
16f3 38 07		        JR      C,L16FC         ; forward to CLOSE-1 if a non-system stream.  
16f5			                                ; i.e. higher than 3.   
16f5			  
16f5			; proceed with a negative result.  
16f5			  
16f5 01 d4 15		        LD      BC,L15C6 + 14   ; prepare the address of the byte after  
16f8			                                ; the initial stream data in ROM. ($15D4)  
16f8 09			        ADD     HL,BC           ; index into the data table with negative value.  
16f9 4e			        LD      C,(HL)          ; low byte to C  
16fa 23			        INC     HL              ; address next.  
16fb 46			        LD      B,(HL)          ; high byte to B.  
16fc			  
16fc			; and for streams 0 - 3 just enter the initial data back into the STRMS entry  
16fc			; streams 0 - 2 can't be closed as they are shared by the operating system.  
16fc			; -> for streams 4 - 15 then blank the entry.  
16fc			  
16fc			;; CLOSE-1  
16fc eb			L16FC:  EX      DE,HL           ; address of stream to HL.  
16fd 71			        LD      (HL),C          ; place zero (or low byte).  
16fe 23			        INC     HL              ; next address.  
16ff 70			        LD      (HL),B          ; place zero (or high byte).  
1700 c9			        RET                     ; return.  
1701			  
1701			; ------------------  
1701			; CLOSE-2 Subroutine  
1701			; ------------------  
1701			; There is not much point in coming here.  
1701			; The purpose was once to find the offset to a special closing routine,  
1701			; in this ROM and within 256 bytes of the close stream look up table that  
1701			; would reclaim any buffers associated with a stream. At least one has been  
1701			; removed.  
1701			  
1701			;; CLOSE-2  
1701 e5			L1701:  PUSH    HL              ; * save address of stream data pointer  
1702			                                ; in STRMS on the machine stack.  
1702 2a 4f 5c		        LD      HL,($5C4F)      ; fetch CHANS address to HL  
1705 09			        ADD     HL,BC           ; add the offset to address the second  
1706			                                ; byte of the output routine hopefully.  
1706 23			        INC     HL              ; step past  
1707 23			        INC     HL              ; the input routine.  
1708 23			        INC     HL              ; to address channel's letter  
1709 4e			        LD      C,(HL)          ; pick it up in C.  
170a			                                ; Note. but if stream is already closed we  
170a			                                ; get the value $10 (the byte preceding 'K').  
170a eb			        EX      DE,HL           ; save the pointer to the letter in DE.  
170b 21 16 17		        LD      HL,L1716        ; address: cl-str-lu in ROM.  
170e cd dc 16		        CALL    L16DC           ; routine INDEXER uses the code to get   
1711			                                ; the 8-bit offset from the current point to  
1711			                                ; the address of the closing routine in ROM.  
1711			                                ; Note. it won't find $10 there!  
1711 4e			        LD      C,(HL)          ; transfer the offset to C.  
1712 06 00		        LD      B,$00           ; prepare to add.  
1714 09			        ADD     HL,BC           ; add offset to point to the address of the  
1715			                                ; routine that closes the stream.  
1715			                                ; (and presumably removes any buffers that  
1715			                                ; are associated with it.)  
1715 e9			        JP      (HL)            ; jump to that routine.  
1716			  
1716			; --------------------------  
1716			; CLOSE stream look-up table  
1716			; --------------------------  
1716			; This table contains an entry for a letter found in the CHANS area.  
1716			; followed by an 8-bit displacement, from that byte's address in the  
1716			; table to the routine that performs any ancillary actions associated  
1716			; with closing the stream of that channel.  
1716			; The table doesn't require a zero end-marker as the letter has been  
1716			; picked up from a channel that has an open stream.  
1716			  
1716			;; cl-str-lu  
1716 .. 05		L1716:  DEFB    'K', L171C-$-1  ; offset 5 to CLOSE-STR  
1718 .. 03		        DEFB    'S', L171C-$-1  ; offset 3 to CLOSE-STR  
171a .. 01		        DEFB    'P', L171C-$-1  ; offset 1 to CLOSE-STR  
171c			  
171c			  
171c			; ------------------------  
171c			; Close Stream Subroutines  
171c			; ------------------------  
171c			; The close stream routines in fact have no ancillary actions to perform  
171c			; which is not surprising with regard to 'K' and 'S'.  
171c			  
171c			;; CLOSE-STR                      
171c e1			L171C:  POP     HL              ; * now just restore the stream data pointer  
171d c9			        RET                     ; in STRMS and return.  
171e			  
171e			; -----------  
171e			; Stream data  
171e			; -----------  
171e			; This routine finds the data entry in the STRMS area for the specified  
171e			; stream which is passed on the calculator stack. It returns with HL  
171e			; pointing to this system variable and BC holding a displacement from  
171e			; the CHANS area to the second byte of the stream's channel. If BC holds  
171e			; zero, then that signifies that the stream is closed.  
171e			  
171e			;; STR-DATA  
171e cd 94 1e		L171E:  CALL    L1E94           ; routine FIND-INT1 fetches parameter to A  
1721 fe 10		        CP      $10             ; is it less than 16d ?  
1723 38 02		        JR      C,L1727         ; skip forward to STR-DATA1 if so.  
1725			  
1725			;; REPORT-Ob  
1725 cf			L1725:  RST     08H             ; ERROR-1  
1726 17			        DEFB    $17             ; Error Report: Invalid stream  
1727			  
1727			;; STR-DATA1  
1727 c6 03		L1727:  ADD     A,$03           ; add the offset for 3 system streams.  
1729			                                ; range 00 - 15d becomes 3 - 18d.  
1729 07			        RLCA                    ; double as there are two bytes per   
172a			                                ; stream - now 06 - 36d  
172a 21 10 5c		        LD      HL,$5C10        ; address STRMS - the start of the streams  
172d			                                ; data area in system variables.  
172d 4f			        LD      C,A             ; transfer the low byte to A.  
172e 06 00		        LD      B,$00           ; prepare to add offset.  
1730 09			        ADD     HL,BC           ; add to address the data entry in STRMS.  
1731			  
1731			; the data entry itself contains an offset from CHANS to the address of the  
1731			; stream  
1731			  
1731 4e			        LD      C,(HL)          ; low byte of displacement to C.  
1732 23			        INC     HL              ; address next.  
1733 46			        LD      B,(HL)          ; high byte of displacement to B.  
1734 2b			        DEC     HL              ; step back to leave HL pointing to STRMS  
1735			                                ; data entry.  
1735 c9			        RET                     ; return with CHANS displacement in BC  
1736			                                ; and address of stream data entry in HL.  
1736			  
1736			; --------------------  
1736			; Handle OPEN# command  
1736			; --------------------  
1736			; Command syntax example: OPEN #5,"s"  
1736			; On entry the channel code entry is on the calculator stack with the next  
1736			; value containing the stream identifier. They have to swapped.  
1736			  
1736			;; OPEN  
1736 ef			L1736:  RST     28H             ;; FP-CALC    ;s,c.  
1737 01			        DEFB    $01             ;;exchange    ;c,s.  
1738 38			        DEFB    $38             ;;end-calc  
1739			  
1739 cd 1e 17		        CALL    L171E           ; routine STR-DATA fetches the stream off  
173c			                                ; the stack and returns with the CHANS  
173c			                                ; displacement in BC and HL addressing   
173c			                                ; the STRMS data entry.  
173c 78			        LD      A,B             ; test for zero which  
173d b1			        OR      C               ; indicates the stream is closed.  
173e 28 16		        JR      Z,L1756         ; skip forward to OPEN-1 if so.  
1740			  
1740			; if it is a system channel then it can re-attached.  
1740			  
1740 eb			        EX      DE,HL           ; save STRMS address in DE.  
1741 2a 4f 5c		        LD      HL,($5C4F)      ; fetch CHANS.  
1744 09			        ADD     HL,BC           ; add the offset to address the second   
1745			                                ; byte of the channel.  
1745 23			        INC     HL              ; skip over the  
1746 23			        INC     HL              ; input routine.  
1747 23			        INC     HL              ; and address the letter.  
1748 7e			        LD      A,(HL)          ; pick up the letter.  
1749 eb			        EX      DE,HL           ; save letter pointer and bring back  
174a			                                ; the STRMS pointer.  
174a			  
174a fe 4b		        CP      $4B             ; is it 'K' ?  
174c 28 08		        JR      Z,L1756         ; forward to OPEN-1 if so  
174e			  
174e fe 53		        CP      $53             ; is it 'S' ?  
1750 28 04		        JR      Z,L1756         ; forward to OPEN-1 if so  
1752			  
1752 fe 50		        CP      $50             ; is it 'P' ?  
1754 20 cf		        JR      NZ,L1725        ; back to REPORT-Ob if not.  
1756			                                ; to report 'Invalid stream'.  
1756			  
1756			; continue if one of the upper-case letters was found.  
1756			; and rejoin here from above if stream was closed.  
1756			  
1756			;; OPEN-1  
1756 cd 5d 17		L1756:  CALL    L175D           ; routine OPEN-2 opens the stream.  
1759			  
1759			; it now remains to update the STRMS variable.  
1759			  
1759 73			        LD      (HL),E          ; insert or overwrite the low byte.  
175a 23			        INC     HL              ; address high byte in STRMS.  
175b 72			        LD      (HL),D          ; insert or overwrite the high byte.  
175c c9			        RET                     ; return.  
175d			  
175d			; -----------------  
175d			; OPEN-2 Subroutine  
175d			; -----------------  
175d			; There is some point in coming here as, as well as once creating buffers,  
175d			; this routine also sets flags.  
175d			  
175d			;; OPEN-2  
175d e5			L175D:  PUSH    HL              ; * save the STRMS data entry pointer.  
175e cd f1 2b		        CALL    L2BF1           ; routine STK-FETCH now fetches the  
1761			                                ; parameters of the channel string.  
1761			                                ; start in DE, length in BC.  
1761			  
1761 78			        LD      A,B             ; test that it is not  
1762 b1			        OR      C               ; the null string.  
1763 20 02		        JR      NZ,L1767        ; skip forward to OPEN-3 with 1 character  
1765			                                ; or more!  
1765			  
1765			;; REPORT-Fb  
1765 cf			L1765:  RST     08H             ; ERROR-1  
1766 0e			        DEFB    $0E             ; Error Report: Invalid file name  
1767			  
1767			;; OPEN-3  
1767 c5			L1767:  PUSH    BC              ; save the length of the string.  
1768 1a			        LD      A,(DE)          ; pick up the first character.  
1769			                                ; Note. if the second character is used to  
1769			                                ; distinguish between a binary or text  
1769			                                ; channel then it will be simply a matter  
1769			                                ; of setting bit 7 of FLAGX.  
1769 e6 df		        AND     $DF             ; make it upper-case.  
176b 4f			        LD      C,A             ; place it in C.  
176c 21 7a 17		        LD      HL,L177A        ; address: op-str-lu is loaded.  
176f cd dc 16		        CALL    L16DC           ; routine INDEXER will search for letter.  
1772 30 f1		        JR      NC,L1765        ; back to REPORT-F if not found  
1774			                                ; 'Invalid filename'  
1774			  
1774 4e			        LD      C,(HL)          ; fetch the displacement to opening routine.  
1775 06 00		        LD      B,$00           ; prepare to add.  
1777 09			        ADD     HL,BC           ; now form address of opening routine.  
1778 c1			        POP     BC              ; restore the length of string.  
1779 e9			        JP      (HL)            ; now jump forward to the relevant routine.  
177a			  
177a			; -------------------------  
177a			; OPEN stream look-up table  
177a			; -------------------------  
177a			; The open stream look-up table consists of matched pairs.  
177a			; The channel letter is followed by an 8-bit displacement to the  
177a			; associated stream-opening routine in this ROM.  
177a			; The table requires a zero end-marker as the letter has been  
177a			; provided by the user and not the operating system.  
177a			  
177a			;; op-str-lu  
177a .. 06		L177A:  DEFB    'K', L1781-$-1  ; $06 offset to OPEN-K  
177c .. 08		        DEFB    'S', L1785-$-1  ; $08 offset to OPEN-S  
177e .. 0a		        DEFB    'P', L1789-$-1  ; $0A offset to OPEN-P  
1780			  
1780 00			        DEFB    $00             ; end-marker.  
1781			  
1781			; ----------------------------  
1781			; The Stream Opening Routines.  
1781			; ----------------------------  
1781			; These routines would have opened any buffers associated with the stream  
1781			; before jumping forward to to OPEN-END with the displacement value in E  
1781			; and perhaps a modified value in BC. The strange pathing does seem to  
1781			; provide for flexibility in this respect.  
1781			;  
1781			; There is no need to open the printer buffer as it is there already  
1781			; even if you are still saving up for a ZX Printer or have moved onto  
1781			; something bigger. In any case it would have to be created after  
1781			; the system variables but apart from that it is a simple task  
1781			; and all but one of the ROM routines can handle a buffer in that position.  
1781			; (PR-ALL-6 would require an extra 3 bytes of code).  
1781			; However it wouldn't be wise to have two streams attached to the ZX Printer  
1781			; as you can now, so one assumes that if PR_CC_hi was non-zero then  
1781			; the OPEN-P routine would have refused to attach a stream if another  
1781			; stream was attached.  
1781			  
1781			; Something of significance is being passed to these ghost routines in the  
1781			; second character. Strings 'RB', 'RT' perhaps or a drive/station number.  
1781			; The routine would have to deal with that and exit to OPEN_END with BC  
1781			; containing $0001 or more likely there would be an exit within the routine.  
1781			; Anyway doesn't matter, these routines are long gone.  
1781			  
1781			; -----------------  
1781			; OPEN-K Subroutine  
1781			; -----------------  
1781			; Open Keyboard stream.  
1781			  
1781			;; OPEN-K  
1781 1e 01		L1781:  LD      E,$01           ; 01 is offset to second byte of channel 'K'.  
1783 18 06		        JR      L178B           ; forward to OPEN-END  
1785			  
1785			; -----------------  
1785			; OPEN-S Subroutine  
1785			; -----------------  
1785			; Open Screen stream.  
1785			  
1785			;; OPEN-S  
1785 1e 06		L1785:  LD      E,$06           ; 06 is offset to 2nd byte of channel 'S'  
1787 18 02		        JR      L178B           ; to OPEN-END  
1789			  
1789			; -----------------  
1789			; OPEN-P Subroutine  
1789			; -----------------  
1789			; Open Printer stream.  
1789			  
1789			;; OPEN-P  
1789 1e 10		L1789:  LD      E,$10           ; 16d is offset to 2nd byte of channel 'P'  
178b			  
178b			;; OPEN-END  
178b 0b			L178B:  DEC     BC              ; the stored length of 'K','S','P' or  
178c			                                ; whatever is now tested. ??  
178c 78			        LD      A,B             ; test now if initial or residual length  
178d b1			        OR      C               ; is one character.  
178e 20 d5		        JR      NZ,L1765        ; to REPORT-Fb 'Invalid file name' if not.  
1790			  
1790 57			        LD      D,A             ; load D with zero to form the displacement  
1791			                                ; in the DE register.  
1791 e1			        POP     HL              ; * restore the saved STRMS pointer.  
1792 c9			        RET                     ; return to update STRMS entry thereby   
1793			                                ; signaling stream is open.  
1793			  
1793			; ----------------------------------------  
1793			; Handle CAT, ERASE, FORMAT, MOVE commands  
1793			; ----------------------------------------  
1793			; These just generate an error report as the ROM is 'incomplete'.  
1793			;  
1793			; Luckily this provides a mechanism for extending these in a shadow ROM  
1793			; but without the powerful mechanisms set up in this ROM.  
1793			; An instruction fetch on $0008 may page in a peripheral ROM,  
1793			; e.g. the Sinclair Interface 1 ROM, to handle these commands.  
1793			; However that wasn't the plan.  
1793			; Development of this ROM continued for another three months until the cost  
1793			; of replacing it and the manual became unfeasible.  
1793			; The ultimate power of channels and streams died at birth.  
1793			  
1793			;; CAT-ETC  
1793 18 90		L1793:  JR      L1725           ; to REPORT-Ob  
1795			  
1795			; -----------------  
1795			; Perform AUTO-LIST  
1795			; -----------------  
1795			; This produces an automatic listing in the upper screen.  
1795			  
1795			;; AUTO-LIST  
1795 ed 73 3f 5c	L1795:  LD      ($5C3F),SP      ; save stack pointer in LIST_SP  
1799 fd 36 02 10	        LD      (IY+$02),$10    ; update TV_FLAG set bit 3  
179d cd af 0d		        CALL    L0DAF           ; routine CL-ALL.  
17a0 fd cb 02 c6	        SET     0,(IY+$02)      ; update TV_FLAG  - signal lower screen in use  
17a4			  
17a4 fd 46 31		        LD      B,(IY+$31)      ; fetch DF_SZ to B.  
17a7 cd 44 0e		        CALL    L0E44           ; routine CL-LINE clears lower display  
17aa			                                ; preserving B.  
17aa fd cb 02 86	        RES     0,(IY+$02)      ; update TV_FLAG  - signal main screen in use  
17ae fd cb 30 c6	        SET     0,(IY+$30)      ; update FLAGS2  - signal unnecessary to  
17b2			                                ; clear main screen.  
17b2 2a 49 5c		        LD      HL,($5C49)      ; fetch E_PPC current edit line to HL.  
17b5 ed 5b 6c 5c	        LD      DE,($5C6C)      ; fetch S_TOP to DE, the current top line  
17b9			                                ; (initially zero)  
17b9 a7			        AND     A               ; prepare for true subtraction.  
17ba ed 52		        SBC     HL,DE           ; subtract and  
17bc 19			        ADD     HL,DE           ; add back.  
17bd 38 22		        JR      C,L17E1         ; to AUTO-L-2 if S_TOP higher than E_PPC  
17bf			                                ; to set S_TOP to E_PPC  
17bf			  
17bf d5			        PUSH    DE              ; save the top line number.  
17c0 cd 6e 19		        CALL    L196E           ; routine LINE-ADDR gets address of E_PPC.  
17c3 11 c0 02		        LD      DE,$02C0        ; prepare known number of characters in  
17c6			                                ; the default upper screen.  
17c6 eb			        EX      DE,HL           ; offset to HL, program address to DE.  
17c7 ed 52		        SBC     HL,DE           ; subtract high value from low to obtain  
17c9			                                ; negated result used in addition.  
17c9 e3			        EX      (SP),HL         ; swap result with top line number on stack.  
17ca cd 6e 19		        CALL    L196E           ; routine LINE-ADDR  gets address of that  
17cd			                                ; top line in HL and next line in DE.  
17cd c1			        POP     BC              ; restore the result to balance stack.  
17ce			  
17ce			;; AUTO-L-1  
17ce c5			L17CE:  PUSH    BC              ; save the result.  
17cf cd b8 19		        CALL    L19B8           ; routine NEXT-ONE gets address in HL of  
17d2			                                ; line after auto-line (in DE).  
17d2 c1			        POP     BC              ; restore result.  
17d3 09			        ADD     HL,BC           ; compute back.  
17d4 38 0e		        JR      C,L17E4         ; to AUTO-L-3 if line 'should' appear  
17d6			  
17d6 eb			        EX      DE,HL           ; address of next line to HL.  
17d7 56			        LD      D,(HL)          ; get line  
17d8 23			        INC     HL              ; number  
17d9 5e			        LD      E,(HL)          ; in DE.  
17da 2b			        DEC     HL              ; adjust back to start.  
17db ed 53 6c 5c	        LD      ($5C6C),DE      ; update S_TOP.  
17df 18 ed		        JR      L17CE           ; to AUTO-L-1 until estimate reached.  
17e1			  
17e1			; ---  
17e1			  
17e1			; the jump was to here if S_TOP was greater than E_PPC  
17e1			  
17e1			;; AUTO-L-2  
17e1 22 6c 5c		L17E1:  LD      ($5C6C),HL      ; make S_TOP the same as E_PPC.  
17e4			  
17e4			; continue here with valid starting point from above or good estimate  
17e4			; from computation  
17e4			  
17e4			;; AUTO-L-3  
17e4 2a 6c 5c		L17E4:  LD      HL,($5C6C)      ; fetch S_TOP line number to HL.  
17e7 cd 6e 19		        CALL    L196E           ; routine LINE-ADDR gets address in HL.  
17ea			                                ; address of next in DE.  
17ea 28 01		        JR      Z,L17ED         ; to AUTO-L-4 if line exists.  
17ec			  
17ec eb			        EX      DE,HL           ; else use address of next line.  
17ed			  
17ed			;; AUTO-L-4  
17ed cd 33 18		L17ED:  CALL    L1833           ; routine LIST-ALL                >>>  
17f0			  
17f0			; The return will be to here if no scrolling occurred  
17f0			  
17f0 fd cb 02 a6	        RES     4,(IY+$02)      ; update TV_FLAG  - signal no auto listing.  
17f4 c9			        RET                     ; return.  
17f5			  
17f5			; ------------  
17f5			; Handle LLIST  
17f5			; ------------  
17f5			; A short form of LIST #3. The listing goes to stream 3 - default printer.  
17f5			  
17f5			;; LLIST  
17f5 3e 03		L17F5:  LD      A,$03           ; the usual stream for ZX Printer  
17f7 18 02		        JR      L17FB           ; forward to LIST-1  
17f9			  
17f9			; -----------  
17f9			; Handle LIST  
17f9			; -----------  
17f9			; List to any stream.  
17f9			; Note. While a starting line can be specified it is  
17f9			; not possible to specify an end line.  
17f9			; Just listing a line makes it the current edit line.  
17f9			  
17f9			;; LIST  
17f9 3e 02		L17F9:  LD      A,$02           ; default is stream 2 - the upper screen.  
17fb			  
17fb			;; LIST-1  
17fb fd 36 02 00	L17FB:  LD      (IY+$02),$00    ; the TV_FLAG is initialized with bit 0 reset  
17ff			                                ; indicating upper screen in use.  
17ff cd 30 25		        CALL    L2530           ; routine SYNTAX-Z - checking syntax ?  
1802 c4 01 16		        CALL    NZ,L1601        ; routine CHAN-OPEN if in run-time.  
1805			  
1805 df			        RST     18H             ; GET-CHAR  
1806 cd 70 20		        CALL    L2070           ; routine STR-ALTER will alter if '#'.  
1809 38 14		        JR      C,L181F         ; forward to LIST-4 not a '#' .  
180b			  
180b			  
180b df			        RST     18H             ; GET-CHAR  
180c fe 3b		        CP      $3B             ; is it ';' ?  
180e 28 04		        JR      Z,L1814         ; skip to LIST-2 if so.  
1810			  
1810 fe 2c		        CP      $2C             ; is it ',' ?  
1812 20 06		        JR      NZ,L181A        ; forward to LIST-3 if neither separator.  
1814			  
1814			; we have, say,  LIST #15, and a number must follow the separator.  
1814			  
1814			;; LIST-2  
1814 e7			L1814:  RST     20H             ; NEXT-CHAR  
1815 cd 82 1c		        CALL    L1C82           ; routine EXPT-1NUM  
1818 18 08		        JR      L1822           ; forward to LIST-5  
181a			  
181a			; ---  
181a			  
181a			; the branch was here with just LIST #3 etc.  
181a			  
181a			;; LIST-3  
181a cd e6 1c		L181A:  CALL    L1CE6           ; routine USE-ZERO  
181d 18 03		        JR      L1822           ; forward to LIST-5  
181f			  
181f			; ---  
181f			  
181f			; the branch was here with LIST  
181f			  
181f			;; LIST-4  
181f cd de 1c		L181F:  CALL    L1CDE           ; routine FETCH-NUM checks if a number   
1822			                                ; follows else uses zero.  
1822			  
1822			;; LIST-5  
1822 cd ee 1b		L1822:  CALL    L1BEE           ; routine CHECK-END quits if syntax OK >>>  
1825			  
1825 cd 99 1e		        CALL    L1E99           ; routine FIND-INT2 fetches the number  
1828			                                ; from the calculator stack in run-time.  
1828 78			        LD      A,B             ; fetch high byte of line number and  
1829 e6 3f		        AND     $3F             ; make less than $40 so that NEXT-ONE  
182b			                                ; (from LINE-ADDR) doesn't lose context.  
182b			                                ; Note. this is not satisfactory and the typo  
182b			                                ; LIST 20000 will list an entirely different  
182b			                                ; section than LIST 2000. Such typos are not  
182b			                                ; available for checking if they are direct  
182b			                                ; commands.  
182b			  
182b 67			        LD      H,A             ; transfer the modified  
182c 69			        LD      L,C             ; line number to HL.  
182d 22 49 5c		        LD      ($5C49),HL      ; update E_PPC to new line number.  
1830 cd 6e 19		        CALL    L196E           ; routine LINE-ADDR gets the address of the  
1833			                                ; line.  
1833			  
1833			; This routine is called from AUTO-LIST  
1833			  
1833			;; LIST-ALL  
1833 1e 01		L1833:  LD      E,$01           ; signal current line not yet printed  
1835			  
1835			;; LIST-ALL-2  
1835 cd 55 18		L1835:  CALL    L1855           ; routine OUT-LINE outputs a BASIC line  
1838			                                ; using PRINT-OUT and makes an early return  
1838			                                ; when no more lines to print. >>>  
1838			  
1838 d7			        RST     10H             ; PRINT-A prints the carriage return (in A)  
1839			  
1839 fd cb 02 66	        BIT     4,(IY+$02)      ; test TV_FLAG  - automatic listing ?  
183d 28 f6		        JR      Z,L1835         ; back to LIST-ALL-2 if not  
183f			                                ; (loop exit is via OUT-LINE)  
183f			  
183f			; continue here if an automatic listing required.  
183f			  
183f 3a 6b 5c		        LD      A,($5C6B)       ; fetch DF_SZ lower display file size.  
1842 fd 96 4f		        SUB     (IY+$4F)        ; subtract S_POSN_hi ithe current line number.  
1845 20 ee		        JR      NZ,L1835        ; back to LIST-ALL-2 if upper screen not full.  
1847			  
1847 ab			        XOR     E               ; A contains zero, E contains one if the  
1848			                                ; current edit line has not been printed  
1848			                                ; or zero if it has (from OUT-LINE).  
1848 c8			        RET     Z               ; return if the screen is full and the line  
1849			                                ; has been printed.  
1849			  
1849			; continue with automatic listings if the screen is full and the current  
1849			; edit line is missing. OUT-LINE will scroll automatically.  
1849			  
1849 e5			        PUSH    HL              ; save the pointer address.  
184a d5			        PUSH    DE              ; save the E flag.  
184b 21 6c 5c		        LD      HL,$5C6C        ; fetch S_TOP the rough estimate.  
184e cd 0f 19		        CALL    L190F           ; routine LN-FETCH updates S_TOP with  
1851			                                ; the number of the next line.  
1851 d1			        POP     DE              ; restore the E flag.  
1852 e1			        POP     HL              ; restore the address of the next line.  
1853 18 e0		        JR      L1835           ; back to LIST-ALL-2.  
1855			  
1855			; ------------------------  
1855			; Print a whole BASIC line  
1855			; ------------------------  
1855			; This routine prints a whole BASIC line and it is called  
1855			; from LIST-ALL to output the line to current channel  
1855			; and from ED-EDIT to 'sprint' the line to the edit buffer.  
1855			  
1855			;; OUT-LINE  
1855 ed 4b 49 5c	L1855:  LD      BC,($5C49)      ; fetch E_PPC the current line which may be  
1859			                                ; unchecked and not exist.  
1859 cd 80 19		        CALL    L1980           ; routine CP-LINES finds match or line after.  
185c 16 3e		        LD      D,$3E           ; prepare cursor '>' in D.  
185e 28 05		        JR      Z,L1865         ; to OUT-LINE1 if matched or line after.  
1860			  
1860 11 00 00		        LD      DE,$0000        ; put zero in D, to suppress line cursor.  
1863 cb 13		        RL      E               ; pick up carry in E if line before current  
1865			                                ; leave E zero if same or after.  
1865			  
1865			;; OUT-LINE1  
1865 fd 73 2d		L1865:  LD      (IY+$2D),E      ; save flag in BREG which is spare.  
1868 7e			        LD      A,(HL)          ; get high byte of line number.  
1869 fe 40		        CP      $40             ; is it too high ($2F is maximum possible) ?  
186b c1			        POP     BC              ; drop the return address and  
186c d0			        RET     NC              ; make an early return if so >>>  
186d			  
186d c5			        PUSH    BC              ; save return address  
186e cd 28 1a		        CALL    L1A28           ; routine OUT-NUM-2 to print addressed number  
1871			                                ; with leading space.  
1871 23			        INC     HL              ; skip low number byte.  
1872 23			        INC     HL              ; and the two  
1873 23			        INC     HL              ; length bytes.  
1874 fd cb 01 86	        RES     0,(IY+$01)      ; update FLAGS - signal leading space required.  
1878 7a			        LD      A,D             ; fetch the cursor.  
1879 a7			        AND     A               ; test for zero.  
187a 28 05		        JR      Z,L1881         ; to OUT-LINE3 if zero.  
187c			  
187c			  
187c d7			        RST     10H             ; PRINT-A prints '>' the current line cursor.  
187d			  
187d			; this entry point is called from ED-COPY  
187d			  
187d			;; OUT-LINE2  
187d fd cb 01 c6	L187D:  SET     0,(IY+$01)      ; update FLAGS - suppress leading space.  
1881			  
1881			;; OUT-LINE3  
1881 d5			L1881:  PUSH    DE              ; save flag E for a return value.  
1882 eb			        EX      DE,HL           ; save HL address in DE.  
1883 fd cb 30 96	        RES     2,(IY+$30)      ; update FLAGS2 - signal NOT in QUOTES.  
1887			  
1887 21 3b 5c		        LD      HL,$5C3B        ; point to FLAGS.  
188a cb 96		        RES     2,(HL)          ; signal 'K' mode. (starts before keyword)  
188c fd cb 37 6e	        BIT     5,(IY+$37)      ; test FLAGX - input mode ?  
1890 28 02		        JR      Z,L1894         ; forward to OUT-LINE4 if not.  
1892			  
1892 cb d6		        SET     2,(HL)          ; signal 'L' mode. (used for input)  
1894			  
1894			;; OUT-LINE4  
1894 2a 5f 5c		L1894:  LD      HL,($5C5F)      ; fetch X_PTR - possibly the error pointer  
1897			                                ; address.  
1897 a7			        AND     A               ; clear the carry flag.  
1898 ed 52		        SBC     HL,DE           ; test if an error address has been reached.  
189a 20 05		        JR      NZ,L18A1        ; forward to OUT-LINE5 if not.  
189c			  
189c 3e 3f		        LD      A,$3F           ; load A with '?' the error marker.  
189e cd c1 18		        CALL    L18C1           ; routine OUT-FLASH to print flashing marker.  
18a1			  
18a1			;; OUT-LINE5  
18a1 cd e1 18		L18A1:  CALL    L18E1           ; routine OUT-CURS will print the cursor if  
18a4			                                ; this is the right position.  
18a4 eb			        EX      DE,HL           ; restore address pointer to HL.  
18a5 7e			        LD      A,(HL)          ; fetch the addressed character.  
18a6 cd b6 18		        CALL    L18B6           ; routine NUMBER skips a hidden floating   
18a9			                                ; point number if present.  
18a9 23			        INC     HL              ; now increment the pointer.  
18aa fe 0d		        CP      $0D             ; is character end-of-line ?  
18ac 28 06		        JR      Z,L18B4         ; to OUT-LINE6, if so, as line is finished.  
18ae			  
18ae eb			        EX      DE,HL           ; save the pointer in DE.  
18af cd 37 19		        CALL    L1937           ; routine OUT-CHAR to output character/token.  
18b2			  
18b2 18 e0		        JR      L1894           ; back to OUT-LINE4 until entire line is done.  
18b4			  
18b4			; ---  
18b4			  
18b4			;; OUT-LINE6  
18b4 d1			L18B4:  POP     DE              ; bring back the flag E, zero if current  
18b5			                                ; line printed else 1 if still to print.  
18b5 c9			        RET                     ; return with A holding $0D  
18b6			  
18b6			; -------------------------  
18b6			; Check for a number marker  
18b6			; -------------------------  
18b6			; this subroutine is called from two processes. while outputting BASIC lines  
18b6			; and while searching statements within a BASIC line.  
18b6			; during both, this routine will pass over an invisible number indicator  
18b6			; and the five bytes floating-point number that follows it.  
18b6			; Note that this causes floating point numbers to be stripped from  
18b6			; the BASIC line when it is fetched to the edit buffer by OUT_LINE.  
18b6			; the number marker also appears after the arguments of a DEF FN statement  
18b6			; and may mask old 5-byte string parameters.  
18b6			  
18b6			;; NUMBER  
18b6 fe 0e		L18B6:  CP      $0E             ; character fourteen ?  
18b8 c0			        RET     NZ              ; return if not.  
18b9			  
18b9 23			        INC     HL              ; skip the character  
18ba 23			        INC     HL              ; and five bytes  
18bb 23			        INC     HL              ; following.  
18bc 23			        INC     HL              ;  
18bd 23			        INC     HL              ;  
18be 23			        INC     HL              ;  
18bf 7e			        LD      A,(HL)          ; fetch the following character  
18c0 c9			        RET                     ; for return value.  
18c1			  
18c1			; --------------------------  
18c1			; Print a flashing character  
18c1			; --------------------------  
18c1			; This subroutine is called from OUT-LINE to print a flashing error  
18c1			; marker '?' or from the next routine to print a flashing cursor e.g. 'L'.  
18c1			; However, this only gets called from OUT-LINE when printing the edit line  
18c1			; or the input buffer to the lower screen so a direct call to $09F4 can  
18c1			; be used, even though out-line outputs to other streams.  
18c1			; In fact the alternate set is used for the whole routine.  
18c1			  
18c1			;; OUT-FLASH  
18c1 d9			L18C1:  EXX                     ; switch in alternate set  
18c2			  
18c2 2a 8f 5c		        LD      HL,($5C8F)      ; fetch L = ATTR_T, H = MASK-T  
18c5 e5			        PUSH    HL              ; save masks.  
18c6 cb bc		        RES     7,H             ; reset flash mask bit so active.   
18c8 cb fd		        SET     7,L             ; make attribute FLASH.  
18ca 22 8f 5c		        LD      ($5C8F),HL      ; resave ATTR_T and MASK-T  
18cd			  
18cd 21 91 5c		        LD      HL,$5C91        ; address P_FLAG  
18d0 56			        LD      D,(HL)          ; fetch to D  
18d1 d5			        PUSH    DE              ; and save.  
18d2 36 00		        LD      (HL),$00        ; clear inverse, over, ink/paper 9  
18d4			  
18d4 cd f4 09		        CALL    L09F4           ; routine PRINT-OUT outputs character  
18d7			                                ; without the need to vector via RST 10.  
18d7			  
18d7 e1			        POP     HL              ; pop P_FLAG to H.  
18d8 fd 74 57		        LD      (IY+$57),H      ; and restore system variable P_FLAG.  
18db e1			        POP     HL              ; restore temporary masks  
18dc 22 8f 5c		        LD      ($5C8F),HL      ; and restore system variables ATTR_T/MASK_T  
18df			  
18df d9			        EXX                     ; switch back to main set  
18e0 c9			        RET                     ; return  
18e1			  
18e1			; ----------------  
18e1			; Print the cursor  
18e1			; ----------------  
18e1			; This routine is called before any character is output while outputting  
18e1			; a BASIC line or the input buffer. This includes listing to a printer  
18e1			; or screen, copying a BASIC line to the edit buffer and printing the  
18e1			; input buffer or edit buffer to the lower screen. It is only in the  
18e1			; latter two cases that it has any relevance and in the last case it  
18e1			; performs another very important function also.  
18e1			  
18e1			;; OUT-CURS  
18e1 2a 5b 5c		L18E1:  LD      HL,($5C5B)      ; fetch K_CUR the current cursor address  
18e4 a7			        AND     A               ; prepare for true subtraction.  
18e5 ed 52		        SBC     HL,DE           ; test against pointer address in DE and  
18e7 c0			        RET     NZ              ; return if not at exact position.  
18e8			  
18e8			; the value of MODE, maintained by KEY-INPUT, is tested and if non-zero  
18e8			; then this value 'E' or 'G' will take precedence.  
18e8			  
18e8 3a 41 5c		        LD      A,($5C41)       ; fetch MODE  0='KLC', 1='E', 2='G'.  
18eb cb 07		        RLC     A               ; double the value and set flags.  
18ed 28 04		        JR      Z,L18F3         ; to OUT-C-1 if still zero ('KLC').  
18ef			  
18ef c6 43		        ADD     A,$43           ; add 'C' - will become 'E' if originally 1  
18f1			                                ; or 'G' if originally 2.  
18f1 18 16		        JR      L1909           ; forward to OUT-C-2 to print.  
18f3			  
18f3			; ---  
18f3			  
18f3			; If mode was zero then, while printing a BASIC line, bit 2 of flags has been  
18f3			; set if 'THEN' or ':' was encountered as a main character and reset otherwise.  
18f3			; This is now used to determine if the 'K' cursor is to be printed but this  
18f3			; transient state is also now transferred permanently to bit 3 of FLAGS  
18f3			; to let the interrupt routine know how to decode the next key.  
18f3			  
18f3			;; OUT-C-1  
18f3 21 3b 5c		L18F3:  LD      HL,$5C3B        ; Address FLAGS  
18f6 cb 9e		        RES     3,(HL)          ; signal 'K' mode initially.  
18f8 3e 4b		        LD      A,$4B           ; prepare letter 'K'.  
18fa cb 56		        BIT     2,(HL)          ; test FLAGS - was the  
18fc			                                ; previous main character ':' or 'THEN' ?  
18fc 28 0b		        JR      Z,L1909         ; forward to OUT-C-2 if so to print.  
18fe			  
18fe cb de		        SET     3,(HL)          ; signal 'L' mode to interrupt routine.  
1900			                                ; Note. transient bit has been made permanent.  
1900 3c			        INC     A               ; augment from 'K' to 'L'.  
1901			  
1901 fd cb 30 5e	        BIT     3,(IY+$30)      ; test FLAGS2 - consider caps lock ?  
1905			                                ; which is maintained by KEY-INPUT.  
1905 28 02		        JR      Z,L1909         ; forward to OUT-C-2 if not set to print.  
1907			  
1907 3e 43		        LD      A,$43           ; alter 'L' to 'C'.  
1909			  
1909			;; OUT-C-2  
1909 d5			L1909:  PUSH    DE              ; save address pointer but OK as OUT-FLASH  
190a			                                ; uses alternate set without RST 10.  
190a			  
190a cd c1 18		        CALL    L18C1           ; routine OUT-FLASH to print.  
190d			  
190d d1			        POP     DE              ; restore and  
190e c9			        RET                     ; return.  
190f			  
190f			; ----------------------------  
190f			; Get line number of next line  
190f			; ----------------------------  
190f			; These two subroutines are called while editing.  
190f			; This entry point is from ED-DOWN with HL addressing E_PPC  
190f			; to fetch the next line number.  
190f			; Also from AUTO-LIST with HL addressing S_TOP just to update S_TOP  
190f			; with the value of the next line number. It gets fetched but is discarded.  
190f			; These routines never get called while the editor is being used for input.  
190f			  
190f			;; LN-FETCH  
190f 5e			L190F:  LD      E,(HL)          ; fetch low byte  
1910 23			        INC     HL              ; address next  
1911 56			        LD      D,(HL)          ; fetch high byte.  
1912 e5			        PUSH    HL              ; save system variable hi pointer.  
1913 eb			        EX      DE,HL           ; line number to HL,  
1914 23			        INC     HL              ; increment as a starting point.  
1915 cd 6e 19		        CALL    L196E           ; routine LINE-ADDR gets address in HL.  
1918 cd 95 16		        CALL    L1695           ; routine LINE-NO gets line number in DE.  
191b e1			        POP     HL              ; restore system variable hi pointer.  
191c			  
191c			; This entry point is from the ED-UP with HL addressing E_PPC_hi  
191c			  
191c			;; LN-STORE  
191c fd cb 37 6e	L191C:  BIT     5,(IY+$37)      ; test FLAGX - input mode ?  
1920 c0			        RET     NZ              ; return if so.  
1921			                                ; Note. above already checked by ED-UP/ED-DOWN.  
1921			  
1921 72			        LD      (HL),D          ; save high byte of line number.  
1922 2b			        DEC     HL              ; address lower  
1923 73			        LD      (HL),E          ; save low byte of line number.  
1924 c9			        RET                     ; return.  
1925			  
1925			; -----------------------------------------  
1925			; Outputting numbers at start of BASIC line  
1925			; -----------------------------------------  
1925			; This routine entered at OUT-SP-NO is used to compute then output the first  
1925			; three digits of a 4-digit BASIC line printing a space if necessary.  
1925			; The line number, or residual part, is held in HL and the BC register  
1925			; holds a subtraction value -1000, -100 or -10.  
1925			; Note. for example line number 200 -  
1925			; space(out_char), 2(out_code), 0(out_char) final number always out-code.  
1925			  
1925			;; OUT-SP-2  
1925 7b			L1925:  LD      A,E             ; will be space if OUT-CODE not yet called.  
1926			                                ; or $FF if spaces are suppressed.  
1926			                                ; else $30 ('0').  
1926			                                ; (from the first instruction at OUT-CODE)  
1926			                                ; this guy is just too clever.  
1926 a7			        AND     A               ; test bit 7 of A.  
1927 f8			        RET     M               ; return if $FF, as leading spaces not  
1928			                                ; required. This is set when printing line  
1928			                                ; number and statement in MAIN-5.  
1928			  
1928 18 0d		        JR      L1937           ; forward to exit via OUT-CHAR.  
192a			  
192a			; ---  
192a			  
192a			; -> the single entry point.  
192a			  
192a			;; OUT-SP-NO  
192a af			L192A:  XOR     A               ; initialize digit to 0  
192b			  
192b			;; OUT-SP-1  
192b 09			L192B:  ADD     HL,BC           ; add negative number to HL.  
192c 3c			        INC     A               ; increment digit  
192d 38 fc		        JR      C,L192B         ; back to OUT-SP-1 until no carry from  
192f			                                ; the addition.  
192f			  
192f ed 42		        SBC     HL,BC           ; cancel the last addition  
1931 3d			        DEC     A               ; and decrement the digit.  
1932 28 f1		        JR      Z,L1925         ; back to OUT-SP-2 if it is zero.  
1934			  
1934 c3 ef 15		        JP      L15EF           ; jump back to exit via OUT-CODE.    ->  
1937			  
1937			  
1937			; -------------------------------------  
1937			; Outputting characters in a BASIC line  
1937			; -------------------------------------  
1937			; This subroutine ...  
1937			  
1937			;; OUT-CHAR  
1937 cd 1b 2d		L1937:  CALL    L2D1B           ; routine NUMERIC tests if it is a digit ?  
193a 30 30		        JR      NC,L196C        ; to OUT-CH-3 to print digit without  
193c			                                ; changing mode. Will be 'K' mode if digits  
193c			                                ; are at beginning of edit line.  
193c			  
193c fe 21		        CP      $21             ; less than quote character ?  
193e 38 2c		        JR      C,L196C         ; to OUT-CH-3 to output controls and space.  
1940			  
1940 fd cb 01 96	        RES     2,(IY+$01)      ; initialize FLAGS to 'K' mode and leave  
1944			                                ; unchanged if this character would precede  
1944			                                ; a keyword.  
1944			  
1944 fe cb		        CP      $CB             ; is character 'THEN' token ?  
1946 28 24		        JR      Z,L196C         ; to OUT-CH-3 to output if so.  
1948			  
1948 fe 3a		        CP      $3A             ; is it ':' ?  
194a 20 0e		        JR      NZ,L195A        ; to OUT-CH-1 if not statement separator  
194c			                                ; to change mode back to 'L'.  
194c			  
194c fd cb 37 6e	        BIT     5,(IY+$37)      ; FLAGX  - Input Mode ??  
1950 20 16		        JR      NZ,L1968        ; to OUT-CH-2 if in input as no statements.  
1952			                                ; Note. this check should seemingly be at  
1952			                                ; the start. Commands seem inappropriate in  
1952			                                ; INPUT mode and are rejected by the syntax  
1952			                                ; checker anyway.  
1952			                                ; unless INPUT LINE is being used.  
1952			  
1952 fd cb 30 56	        BIT     2,(IY+$30)      ; test FLAGS2 - is the ':' within quotes ?  
1956 28 14		        JR      Z,L196C         ; to OUT-CH-3 if ':' is outside quoted text.  
1958			  
1958 18 0e		        JR      L1968           ; to OUT-CH-2 as ':' is within quotes  
195a			  
195a			; ---  
195a			  
195a			;; OUT-CH-1  
195a fe 22		L195A:  CP      $22             ; is it quote character '"'  ?  
195c 20 0a		        JR      NZ,L1968        ; to OUT-CH-2 with others to set 'L' mode.  
195e			  
195e f5			        PUSH    AF              ; save character.  
195f 3a 6a 5c		        LD      A,($5C6A)       ; fetch FLAGS2.  
1962 ee 04		        XOR     $04             ; toggle the quotes flag.  
1964 32 6a 5c		        LD      ($5C6A),A       ; update FLAGS2  
1967 f1			        POP     AF              ; and restore character.  
1968			  
1968			;; OUT-CH-2  
1968 fd cb 01 d6	L1968:  SET     2,(IY+$01)      ; update FLAGS - signal L mode if the cursor  
196c			                                ; is next.  
196c			  
196c			;; OUT-CH-3  
196c d7			L196C:  RST     10H             ; PRINT-A vectors the character to  
196d			                                ; channel 'S', 'K', 'R' or 'P'.  
196d c9			        RET                     ; return.  
196e			  
196e			; -------------------------------------------  
196e			; Get starting address of line, or line after  
196e			; -------------------------------------------  
196e			; This routine is used often to get the address, in HL, of a BASIC line  
196e			; number supplied in HL, or failing that the address of the following line  
196e			; and the address of the previous line in DE.  
196e			  
196e			;; LINE-ADDR  
196e e5			L196E:  PUSH    HL              ; save line number in HL register  
196f 2a 53 5c		        LD      HL,($5C53)      ; fetch start of program from PROG  
1972 54			        LD      D,H             ; transfer address to  
1973 5d			        LD      E,L             ; the DE register pair.  
1974			  
1974			;; LINE-AD-1  
1974 c1			L1974:  POP     BC              ; restore the line number to BC  
1975 cd 80 19		        CALL    L1980           ; routine CP-LINES compares with that  
1978			                                ; addressed by HL  
1978 d0			        RET     NC              ; return if line has been passed or matched.  
1979			                                ; if NZ, address of previous is in DE  
1979			  
1979 c5			        PUSH    BC              ; save the current line number  
197a cd b8 19		        CALL    L19B8           ; routine NEXT-ONE finds address of next  
197d			                                ; line number in DE, previous in HL.  
197d eb			        EX      DE,HL           ; switch so next in HL  
197e 18 f4		        JR      L1974           ; back to LINE-AD-1 for another comparison  
1980			  
1980			; --------------------  
1980			; Compare line numbers  
1980			; --------------------  
1980			; This routine compares a line number supplied in BC with an addressed  
1980			; line number pointed to by HL.  
1980			  
1980			;; CP-LINES  
1980 7e			L1980:  LD      A,(HL)          ; Load the high byte of line number and  
1981 b8			        CP      B               ; compare with that of supplied line number.  
1982 c0			        RET     NZ              ; return if yet to match (carry will be set).  
1983			  
1983 23			        INC     HL              ; address low byte of  
1984 7e			        LD      A,(HL)          ; number and pick up in A.  
1985 2b			        DEC     HL              ; step back to first position.  
1986 b9			        CP      C               ; now compare.  
1987 c9			        RET                     ; zero set if exact match.  
1988			                                ; carry set if yet to match.  
1988			                                ; no carry indicates a match or  
1988			                                ; next available BASIC line or  
1988			                                ; program end marker.  
1988			  
1988			; -------------------  
1988			; Find each statement  
1988			; -------------------  
1988			; The single entry point EACH-STMT is used to  
1988			; 1) To find the D'th statement in a line.  
1988			; 2) To find a token in held E.  
1988			  
1988			;; not-used  
1988 23			L1988:  INC     HL              ;  
1989 23			        INC     HL              ;  
198a 23			        INC     HL              ;  
198b			  
198b			; -> entry point.  
198b			  
198b			;; EACH-STMT  
198b 22 5d 5c		L198B:  LD      ($5C5D),HL      ; save HL in CH_ADD  
198e 0e 00		        LD      C,$00           ; initialize quotes flag  
1990			  
1990			;; EACH-S-1  
1990 15			L1990:  DEC     D               ; decrease statement count  
1991 c8			        RET     Z               ; return if zero  
1992			  
1992			  
1992 e7			        RST     20H             ; NEXT-CHAR  
1993 bb			        CP      E               ; is it the search token ?  
1994 20 04		        JR      NZ,L199A        ; forward to EACH-S-3 if not  
1996			  
1996 a7			        AND     A               ; clear carry  
1997 c9			        RET                     ; return signalling success.  
1998			  
1998			; ---  
1998			  
1998			;; EACH-S-2  
1998 23			L1998:  INC     HL              ; next address  
1999 7e			        LD      A,(HL)          ; next character  
199a			  
199a			;; EACH-S-3  
199a cd b6 18		L199A:  CALL    L18B6           ; routine NUMBER skips if number marker  
199d 22 5d 5c		        LD      ($5C5D),HL      ; save in CH_ADD  
19a0 fe 22		        CP      $22             ; is it quotes '"' ?  
19a2 20 01		        JR      NZ,L19A5        ; to EACH-S-4 if not  
19a4			  
19a4 0d			        DEC     C               ; toggle bit 0 of C  
19a5			  
19a5			;; EACH-S-4  
19a5 fe 3a		L19A5:  CP      $3A             ; is it ':'  
19a7 28 04		        JR      Z,L19AD         ; to EACH-S-5  
19a9			  
19a9 fe cb		        CP      $CB             ; 'THEN'  
19ab 20 04		        JR      NZ,L19B1        ; to EACH-S-6  
19ad			  
19ad			;; EACH-S-5  
19ad cb 41		L19AD:  BIT     0,C             ; is it in quotes  
19af 28 df		        JR      Z,L1990         ; to EACH-S-1 if not  
19b1			  
19b1			;; EACH-S-6  
19b1 fe 0d		L19B1:  CP      $0D             ; end of line ?  
19b3 20 e3		        JR      NZ,L1998        ; to EACH-S-2  
19b5			  
19b5 15			        DEC     D               ; decrease the statement counter  
19b6			                                ; which should be zero else  
19b6			                                ; 'Statement Lost'.  
19b6 37			        SCF                     ; set carry flag - not found  
19b7 c9			        RET                     ; return  
19b8			  
19b8			; -----------------------------------------------------------------------  
19b8			; Storage of variables. For full details - see chapter 24.  
19b8			; ZX Spectrum BASIC Programming by Steven Vickers 1982.  
19b8			; It is bits 7-5 of the first character of a variable that allow  
19b8			; the six types to be distinguished. Bits 4-0 are the reduced letter.  
19b8			; So any variable name is higher that $3F and can be distinguished  
19b8			; also from the variables area end-marker $80.  
19b8			;  
19b8			; 76543210 meaning                               brief outline of format.  
19b8			; -------- ------------------------              -----------------------  
19b8			; 010      string variable.                      2 byte length + contents.  
19b8			; 110      string array.                         2 byte length + contents.  
19b8			; 100      array of numbers.                     2 byte length + contents.  
19b8			; 011      simple numeric variable.              5 bytes.  
19b8			; 101      variable length named numeric.        5 bytes.  
19b8			; 111      for-next loop variable.               18 bytes.  
19b8			; 10000000 the variables area end-marker.  
19b8			;  
19b8			; Note. any of the above seven will serve as a program end-marker.  
19b8			;  
19b8			; -----------------------------------------------------------------------  
19b8			  
19b8			; ------------  
19b8			; Get next one  
19b8			; ------------  
19b8			; This versatile routine is used to find the address of the next line  
19b8			; in the program area or the next variable in the variables area.  
19b8			; The reason one routine is made to handle two apparently unrelated tasks  
19b8			; is that it can be called indiscriminately when merging a line or a  
19b8			; variable.  
19b8			  
19b8			;; NEXT-ONE  
19b8 e5			L19B8:  PUSH    HL              ; save the pointer address.  
19b9 7e			        LD      A,(HL)          ; get first byte.  
19ba fe 40		        CP      $40             ; compare with upper limit for line numbers.  
19bc 38 17		        JR      C,L19D5         ; forward to NEXT-O-3 if within BASIC area.  
19be			  
19be			; the continuation here is for the next variable unless the supplied  
19be			; line number was erroneously over 16383. see RESTORE command.  
19be			  
19be cb 6f		        BIT     5,A             ; is it a string or an array variable ?  
19c0 28 14		        JR      Z,L19D6         ; forward to NEXT-O-4 to compute length.  
19c2			  
19c2 87			        ADD     A,A             ; test bit 6 for single-character variables.  
19c3 fa c7 19		        JP      M,L19C7         ; forward to NEXT-O-1 if so  
19c6			  
19c6 3f			        CCF                     ; clear the carry for long-named variables.  
19c7			                                ; it remains set for for-next loop variables.  
19c7			  
19c7			;; NEXT-O-1  
19c7 01 05 00		L19C7:  LD      BC,$0005        ; set BC to 5 for floating point number  
19ca 30 02		        JR      NC,L19CE        ; forward to NEXT-O-2 if not a for/next  
19cc			                                ; variable.  
19cc			  
19cc 0e 12		        LD      C,$12           ; set BC to eighteen locations.  
19ce			                                ; value, limit, step, line and statement.  
19ce			  
19ce			; now deal with long-named variables  
19ce			  
19ce			;; NEXT-O-2  
19ce 17			L19CE:  RLA                     ; test if character inverted. carry will also  
19cf			                                ; be set for single character variables  
19cf 23			        INC     HL              ; address next location.  
19d0 7e			        LD      A,(HL)          ; and load character.  
19d1 30 fb		        JR      NC,L19CE        ; back to NEXT-O-2 if not inverted bit.  
19d3			                                ; forward immediately with single character  
19d3			                                ; variable names.  
19d3			  
19d3 18 06		        JR      L19DB           ; forward to NEXT-O-5 to add length of  
19d5			                                ; floating point number(s etc.).  
19d5			  
19d5			; ---  
19d5			  
19d5			; this branch is for line numbers.  
19d5			  
19d5			;; NEXT-O-3  
19d5 23			L19D5:  INC     HL              ; increment pointer to low byte of line no.  
19d6			  
19d6			; strings and arrays rejoin here  
19d6			  
19d6			;; NEXT-O-4  
19d6 23			L19D6:  INC     HL              ; increment to address the length low byte.  
19d7 4e			        LD      C,(HL)          ; transfer to C and  
19d8 23			        INC     HL              ; point to high byte of length.  
19d9 46			        LD      B,(HL)          ; transfer that to B  
19da 23			        INC     HL              ; point to start of BASIC/variable contents.  
19db			  
19db			; the three types of numeric variables rejoin here  
19db			  
19db			;; NEXT-O-5  
19db 09			L19DB:  ADD     HL,BC           ; add the length to give address of next  
19dc			                                ; line/variable in HL.  
19dc d1			        POP     DE              ; restore previous address to DE.  
19dd			  
19dd			; ------------------  
19dd			; Difference routine  
19dd			; ------------------  
19dd			; This routine terminates the above routine and is also called from the  
19dd			; start of the next routine to calculate the length to reclaim.  
19dd			  
19dd			;; DIFFER  
19dd a7			L19DD:  AND     A               ; prepare for true subtraction.  
19de ed 52		        SBC     HL,DE           ; subtract the two pointers.  
19e0 44			        LD      B,H             ; transfer result  
19e1 4d			        LD      C,L             ; to BC register pair.  
19e2 19			        ADD     HL,DE           ; add back  
19e3 eb			        EX      DE,HL           ; and switch pointers  
19e4 c9			        RET                     ; return values are the length of area in BC,  
19e5			                                ; low pointer (previous) in HL,  
19e5			                                ; high pointer (next) in DE.  
19e5			  
19e5			; -----------------------  
19e5			; Handle reclaiming space  
19e5			; -----------------------  
19e5			;  
19e5			  
19e5			;; RECLAIM-1  
19e5 cd dd 19		L19E5:  CALL    L19DD           ; routine DIFFER immediately above  
19e8			  
19e8			;; RECLAIM-2  
19e8 c5			L19E8:  PUSH    BC              ;  
19e9			  
19e9 78			        LD      A,B             ;  
19ea 2f			        CPL                     ;  
19eb 47			        LD      B,A             ;  
19ec 79			        LD      A,C             ;  
19ed 2f			        CPL                     ;  
19ee 4f			        LD      C,A             ;  
19ef 03			        INC     BC              ;  
19f0			  
19f0 cd 64 16		        CALL    L1664           ; routine POINTERS  
19f3 eb			        EX      DE,HL           ;  
19f4 e1			        POP     HL              ;  
19f5			  
19f5 19			        ADD     HL,DE           ;  
19f6 d5			        PUSH    DE              ;  
19f7 ed b0		        LDIR                    ; copy bytes  
19f9			  
19f9 e1			        POP     HL              ;  
19fa c9			        RET                     ;  
19fb			  
19fb			; ----------------------------------------  
19fb			; Read line number of line in editing area  
19fb			; ----------------------------------------  
19fb			; This routine reads a line number in the editing area returning the number  
19fb			; in the BC register or zero if no digits exist before commands.  
19fb			; It is called from LINE-SCAN to check the syntax of the digits.  
19fb			; It is called from MAIN-3 to extract the line number in preparation for  
19fb			; inclusion of the line in the BASIC program area.  
19fb			;  
19fb			; Interestingly the calculator stack is moved from its normal place at the  
19fb			; end of dynamic memory to an adequate area within the system variables area.  
19fb			; This ensures that in a low memory situation, that valid line numbers can  
19fb			; be extracted without raising an error and that memory can be reclaimed  
19fb			; by deleting lines. If the stack was in its normal place then a situation  
19fb			; arises whereby the Spectrum becomes locked with no means of reclaiming space.  
19fb			  
19fb			;; E-LINE-NO  
19fb 2a 59 5c		L19FB:  LD      HL,($5C59)      ; load HL from system variable E_LINE.  
19fe			  
19fe 2b			        DEC     HL              ; decrease so that NEXT_CHAR can be used  
19ff			                                ; without skipping the first digit.  
19ff			  
19ff 22 5d 5c		        LD      ($5C5D),HL      ; store in the system variable CH_ADD.  
1a02			  
1a02 e7			        RST     20H             ; NEXT-CHAR skips any noise and white-space  
1a03			                                ; to point exactly at the first digit.  
1a03			  
1a03 21 92 5c		        LD      HL,$5C92        ; use MEM-0 as a temporary calculator stack  
1a06			                                ; an overhead of three locations are needed.  
1a06 22 65 5c		        LD      ($5C65),HL      ; set new STKEND.  
1a09			  
1a09 cd 3b 2d		        CALL    L2D3B           ; routine INT-TO-FP will read digits till  
1a0c			                                ; a non-digit found.  
1a0c cd a2 2d		        CALL    L2DA2           ; routine FP-TO-BC will retrieve number  
1a0f			                                ; from stack at membot.  
1a0f 38 04		        JR      C,L1A15         ; forward to E-L-1 if overflow i.e. > 65535.  
1a11			                                ; 'Nonsense in BASIC'  
1a11			  
1a11 21 f0 d8		        LD      HL,$D8F0        ; load HL with value -9999  
1a14 09			        ADD     HL,BC           ; add to line number in BC  
1a15			  
1a15			;; E-L-1  
1a15 da 8a 1c		L1A15:  JP      C,L1C8A         ; to REPORT-C 'Nonsense in BASIC' if over.  
1a18			                                ; Note. As ERR_SP points to ED_ERROR  
1a18			                                ; the report is never produced although  
1a18			                                ; the RST $08 will update X_PTR leading to  
1a18			                                ; the error marker being displayed when  
1a18			                                ; the ED_LOOP is reiterated.  
1a18			                                ; in fact, since it is immediately  
1a18			                                ; cancelled, any report will do.  
1a18			  
1a18			; a line in the range 0 - 9999 has been entered.  
1a18			  
1a18 c3 c5 16		        JP      L16C5           ; jump back to SET-STK to set the calculator   
1a1b			                                ; stack back to its normal place and exit   
1a1b			                                ; from there.  
1a1b			  
1a1b			; ---------------------------------  
1a1b			; Report and line number outputting  
1a1b			; ---------------------------------  
1a1b			; Entry point OUT-NUM-1 is used by the Error Reporting code to print  
1a1b			; the line number and later the statement number held in BC.  
1a1b			; If the statement was part of a direct command then -2 is used as a  
1a1b			; dummy line number so that zero will be printed in the report.  
1a1b			; This routine is also used to print the exponent of E-format numbers.  
1a1b			;  
1a1b			; Entry point OUT-NUM-2 is used from OUT-LINE to output the line number  
1a1b			; addressed by HL with leading spaces if necessary.  
1a1b			  
1a1b			;; OUT-NUM-1  
1a1b d5			L1A1B:  PUSH    DE              ; save the  
1a1c e5			        PUSH    HL              ; registers.  
1a1d af			        XOR     A               ; set A to zero.  
1a1e cb 78		        BIT     7,B             ; is the line number minus two ?  
1a20 20 20		        JR      NZ,L1A42        ; forward to OUT-NUM-4 if so to print zero   
1a22			                                ; for a direct command.  
1a22			  
1a22 60			        LD      H,B             ; transfer the  
1a23 69			        LD      L,C             ; number to HL.  
1a24 1e ff		        LD      E,$FF           ; signal 'no leading zeros'.  
1a26 18 08		        JR      L1A30           ; forward to continue at OUT-NUM-3  
1a28			  
1a28			; ---  
1a28			  
1a28			; from OUT-LINE - HL addresses line number.  
1a28			  
1a28			;; OUT-NUM-2  
1a28 d5			L1A28:  PUSH    DE              ; save flags  
1a29 56			        LD      D,(HL)          ; high byte to D  
1a2a 23			        INC     HL              ; address next  
1a2b 5e			        LD      E,(HL)          ; low byte to E  
1a2c e5			        PUSH    HL              ; save pointer  
1a2d eb			        EX      DE,HL           ; transfer number to HL  
1a2e 1e 20		        LD      E,$20           ; signal 'output leading spaces'  
1a30			  
1a30			;; OUT-NUM-3  
1a30 01 18 fc		L1A30:  LD      BC,$FC18        ; value -1000  
1a33 cd 2a 19		        CALL    L192A           ; routine OUT-SP-NO outputs space or number  
1a36 01 9c ff		        LD      BC,$FF9C        ; value -100  
1a39 cd 2a 19		        CALL    L192A           ; routine OUT-SP-NO  
1a3c 0e f6		        LD      C,$F6           ; value -10 ( B is still $FF )  
1a3e cd 2a 19		        CALL    L192A           ; routine OUT-SP-NO  
1a41 7d			        LD      A,L             ; remainder to A.  
1a42			  
1a42			;; OUT-NUM-4  
1a42 cd ef 15		L1A42:  CALL    L15EF           ; routine OUT-CODE for final digit.  
1a45			                                ; else report code zero wouldn't get  
1a45			                                ; printed.  
1a45 e1			        POP     HL              ; restore the  
1a46 d1			        POP     DE              ; registers and  
1a47 c9			        RET                     ; return.  
1a48			  
1a48			  
1a48			;***************************************************  
1a48			;** Part 7. BASIC LINE AND COMMAND INTERPRETATION **  
1a48			;***************************************************  
1a48			  
1a48			; ----------------  
1a48			; The offset table  
1a48			; ----------------  
1a48			; The BASIC interpreter has found a command code $CE - $FF  
1a48			; which is then reduced to range $00 - $31 and added to the base address  
1a48			; of this table to give the address of an offset which, when added to  
1a48			; the offset therein, gives the location in the following parameter table  
1a48			; where a list of class codes, separators and addresses relevant to the  
1a48			; command exists.  
1a48			  
1a48			;; offst-tbl  
1a48 b1			L1A48:  DEFB    L1AF9 - $       ; B1 offset to Address: P-DEF-FN  
1a49 cb			        DEFB    L1B14 - $       ; CB offset to Address: P-CAT  
1a4a bc			        DEFB    L1B06 - $       ; BC offset to Address: P-FORMAT  
1a4b bf			        DEFB    L1B0A - $       ; BF offset to Address: P-MOVE  
1a4c c4			        DEFB    L1B10 - $       ; C4 offset to Address: P-ERASE  
1a4d af			        DEFB    L1AFC - $       ; AF offset to Address: P-OPEN  
1a4e b4			        DEFB    L1B02 - $       ; B4 offset to Address: P-CLOSE  
1a4f 93			        DEFB    L1AE2 - $       ; 93 offset to Address: P-MERGE  
1a50 91			        DEFB    L1AE1 - $       ; 91 offset to Address: P-VERIFY  
1a51 92			        DEFB    L1AE3 - $       ; 92 offset to Address: P-BEEP  
1a52 95			        DEFB    L1AE7 - $       ; 95 offset to Address: P-CIRCLE  
1a53 98			        DEFB    L1AEB - $       ; 98 offset to Address: P-INK  
1a54 98			        DEFB    L1AEC - $       ; 98 offset to Address: P-PAPER  
1a55 98			        DEFB    L1AED - $       ; 98 offset to Address: P-FLASH  
1a56 98			        DEFB    L1AEE - $       ; 98 offset to Address: P-BRIGHT  
1a57 98			        DEFB    L1AEF - $       ; 98 offset to Address: P-INVERSE  
1a58 98			        DEFB    L1AF0 - $       ; 98 offset to Address: P-OVER  
1a59 98			        DEFB    L1AF1 - $       ; 98 offset to Address: P-OUT  
1a5a 7f			        DEFB    L1AD9 - $       ; 7F offset to Address: P-LPRINT  
1a5b 81			        DEFB    L1ADC - $       ; 81 offset to Address: P-LLIST  
1a5c 2e			        DEFB    L1A8A - $       ; 2E offset to Address: P-STOP  
1a5d 6c			        DEFB    L1AC9 - $       ; 6C offset to Address: P-READ  
1a5e 6e			        DEFB    L1ACC - $       ; 6E offset to Address: P-DATA  
1a5f 70			        DEFB    L1ACF - $       ; 70 offset to Address: P-RESTORE  
1a60 48			        DEFB    L1AA8 - $       ; 48 offset to Address: P-NEW  
1a61 94			        DEFB    L1AF5 - $       ; 94 offset to Address: P-BORDER  
1a62 56			        DEFB    L1AB8 - $       ; 56 offset to Address: P-CONT  
1a63 3f			        DEFB    L1AA2 - $       ; 3F offset to Address: P-DIM  
1a64 41			        DEFB    L1AA5 - $       ; 41 offset to Address: P-REM  
1a65 2b			        DEFB    L1A90 - $       ; 2B offset to Address: P-FOR  
1a66 17			        DEFB    L1A7D - $       ; 17 offset to Address: P-GO-TO  
1a67 1f			        DEFB    L1A86 - $       ; 1F offset to Address: P-GO-SUB  
1a68 37			        DEFB    L1A9F - $       ; 37 offset to Address: P-INPUT  
1a69 77			        DEFB    L1AE0 - $       ; 77 offset to Address: P-LOAD  
1a6a 44			        DEFB    L1AAE - $       ; 44 offset to Address: P-LIST  
1a6b 0f			        DEFB    L1A7A - $       ; 0F offset to Address: P-LET  
1a6c 59			        DEFB    L1AC5 - $       ; 59 offset to Address: P-PAUSE  
1a6d 2b			        DEFB    L1A98 - $       ; 2B offset to Address: P-NEXT  
1a6e 43			        DEFB    L1AB1 - $       ; 43 offset to Address: P-POKE  
1a6f 2d			        DEFB    L1A9C - $       ; 2D offset to Address: P-PRINT  
1a70 51			        DEFB    L1AC1 - $       ; 51 offset to Address: P-PLOT  
1a71 3a			        DEFB    L1AAB - $       ; 3A offset to Address: P-RUN  
1a72 6d			        DEFB    L1ADF - $       ; 6D offset to Address: P-SAVE  
1a73 42			        DEFB    L1AB5 - $       ; 42 offset to Address: P-RANDOM  
1a74 0d			        DEFB    L1A81 - $       ; 0D offset to Address: P-IF  
1a75 49			        DEFB    L1ABE - $       ; 49 offset to Address: P-CLS  
1a76 5c			        DEFB    L1AD2 - $       ; 5C offset to Address: P-DRAW  
1a77 44			        DEFB    L1ABB - $       ; 44 offset to Address: P-CLEAR  
1a78 15			        DEFB    L1A8D - $       ; 15 offset to Address: P-RETURN  
1a79 5d			        DEFB    L1AD6 - $       ; 5D offset to Address: P-COPY  
1a7a			  
1a7a			  
1a7a			; -------------------------------  
1a7a			; The parameter or "Syntax" table  
1a7a			; -------------------------------  
1a7a			; For each command there exists a variable list of parameters.  
1a7a			; If the character is greater than a space it is a required separator.  
1a7a			; If less, then it is a command class in the range 00 - 0B.  
1a7a			; Note that classes 00, 03 and 05 will fetch the addresses from this table.  
1a7a			; Some classes e.g. 07 and 0B have the same address in all invocations  
1a7a			; and the command is re-computed from the low-byte of the parameter address.  
1a7a			; Some e.g. 02 are only called once so a call to the command is made from  
1a7a			; within the class routine rather than holding the address within the table.  
1a7a			; Some class routines check syntax entirely and some leave this task for the  
1a7a			; command itself.  
1a7a			; Others for example CIRCLE (x,y,z) check the first part (x,y) using the  
1a7a			; class routine and the final part (,z) within the command.  
1a7a			; The last few commands appear to have been added in a rush but their syntax  
1a7a			; is rather simple e.g. MOVE "M1","M2"  
1a7a			  
1a7a			;; P-LET  
1a7a 01			L1A7A:  DEFB    $01             ; Class-01 - A variable is required.  
1a7b 3d			        DEFB    $3D             ; Separator:  '='  
1a7c 02			        DEFB    $02             ; Class-02 - An expression, numeric or string,  
1a7d			                                ; must follow.  
1a7d			  
1a7d			;; P-GO-TO  
1a7d 06			L1A7D:  DEFB    $06             ; Class-06 - A numeric expression must follow.  
1a7e 00			        DEFB    $00             ; Class-00 - No further operands.  
1a7f 67 1e		        DEFW    L1E67           ; Address: $1E67; Address: GO-TO  
1a81			  
1a81			;; P-IF  
1a81 06			L1A81:  DEFB    $06             ; Class-06 - A numeric expression must follow.  
1a82 cb			        DEFB    $CB             ; Separator:  'THEN'  
1a83 05			        DEFB    $05             ; Class-05 - Variable syntax checked  
1a84			                                ; by routine.  
1a84 f0 1c		        DEFW    L1CF0           ; Address: $1CF0; Address: IF  
1a86			  
1a86			;; P-GO-SUB  
1a86 06			L1A86:  DEFB    $06             ; Class-06 - A numeric expression must follow.  
1a87 00			        DEFB    $00             ; Class-00 - No further operands.  
1a88 ed 1e		        DEFW    L1EED           ; Address: $1EED; Address: GO-SUB  
1a8a			  
1a8a			;; P-STOP  
1a8a 00			L1A8A:  DEFB    $00             ; Class-00 - No further operands.  
1a8b ee 1c		        DEFW    L1CEE           ; Address: $1CEE; Address: STOP  
1a8d			  
1a8d			;; P-RETURN  
1a8d 00			L1A8D:  DEFB    $00             ; Class-00 - No further operands.  
1a8e 23 1f		        DEFW    L1F23           ; Address: $1F23; Address: RETURN  
1a90			  
1a90			;; P-FOR  
1a90 04			L1A90:  DEFB    $04             ; Class-04 - A single character variable must  
1a91			                                ; follow.  
1a91 3d			        DEFB    $3D             ; Separator:  '='  
1a92 06			        DEFB    $06             ; Class-06 - A numeric expression must follow.  
1a93 cc			        DEFB    $CC             ; Separator:  'TO'  
1a94 06			        DEFB    $06             ; Class-06 - A numeric expression must follow.  
1a95 05			        DEFB    $05             ; Class-05 - Variable syntax checked  
1a96			                                ; by routine.  
1a96 03 1d		        DEFW    L1D03           ; Address: $1D03; Address: FOR  
1a98			  
1a98			;; P-NEXT  
1a98 04			L1A98:  DEFB    $04             ; Class-04 - A single character variable must  
1a99			                                ; follow.  
1a99 00			        DEFB    $00             ; Class-00 - No further operands.  
1a9a ab 1d		        DEFW    L1DAB           ; Address: $1DAB; Address: NEXT  
1a9c			  
1a9c			;; P-PRINT  
1a9c 05			L1A9C:  DEFB    $05             ; Class-05 - Variable syntax checked entirely  
1a9d			                                ; by routine.  
1a9d cd 1f		        DEFW    L1FCD           ; Address: $1FCD; Address: PRINT  
1a9f			  
1a9f			;; P-INPUT  
1a9f 05			L1A9F:  DEFB    $05             ; Class-05 - Variable syntax checked entirely  
1aa0			                                ; by routine.  
1aa0 89 20		        DEFW    L2089           ; Address: $2089; Address: INPUT  
1aa2			  
1aa2			;; P-DIM  
1aa2 05			L1AA2:  DEFB    $05             ; Class-05 - Variable syntax checked entirely  
1aa3			                                ; by routine.  
1aa3 02 2c		        DEFW    L2C02           ; Address: $2C02; Address: DIM  
1aa5			  
1aa5			;; P-REM  
1aa5 05			L1AA5:  DEFB    $05             ; Class-05 - Variable syntax checked entirely  
1aa6			                                ; by routine.  
1aa6 b2 1b		        DEFW    L1BB2           ; Address: $1BB2; Address: REM  
1aa8			  
1aa8			;; P-NEW  
1aa8 00			L1AA8:  DEFB    $00             ; Class-00 - No further operands.  
1aa9 b7 11		        DEFW    L11B7           ; Address: $11B7; Address: NEW  
1aab			  
1aab			;; P-RUN  
1aab 03			L1AAB:  DEFB    $03             ; Class-03 - A numeric expression may follow  
1aac			                                ; else default to zero.  
1aac a1 1e		        DEFW    L1EA1           ; Address: $1EA1; Address: RUN  
1aae			  
1aae			;; P-LIST  
1aae 05			L1AAE:  DEFB    $05             ; Class-05 - Variable syntax checked entirely  
1aaf			                                ; by routine.  
1aaf f9 17		        DEFW    L17F9           ; Address: $17F9; Address: LIST  
1ab1			  
1ab1			;; P-POKE  
1ab1 08			L1AB1:  DEFB    $08             ; Class-08 - Two comma-separated numeric  
1ab2			                                ; expressions required.  
1ab2 00			        DEFB    $00             ; Class-00 - No further operands.  
1ab3 80 1e		        DEFW    L1E80           ; Address: $1E80; Address: POKE  
1ab5			  
1ab5			;; P-RANDOM  
1ab5 03			L1AB5:  DEFB    $03             ; Class-03 - A numeric expression may follow  
1ab6			                                ; else default to zero.  
1ab6 4f 1e		        DEFW    L1E4F           ; Address: $1E4F; Address: RANDOMIZE  
1ab8			  
1ab8			;; P-CONT  
1ab8 00			L1AB8:  DEFB    $00             ; Class-00 - No further operands.  
1ab9 5f 1e		        DEFW    L1E5F           ; Address: $1E5F; Address: CONTINUE  
1abb			  
1abb			;; P-CLEAR  
1abb 03			L1ABB:  DEFB    $03             ; Class-03 - A numeric expression may follow  
1abc			                                ; else default to zero.  
1abc ac 1e		        DEFW    L1EAC           ; Address: $1EAC; Address: CLEAR  
1abe			  
1abe			;; P-CLS  
1abe 00			L1ABE:  DEFB    $00             ; Class-00 - No further operands.  
1abf 6b 0d		        DEFW    L0D6B           ; Address: $0D6B; Address: CLS  
1ac1			  
1ac1			;; P-PLOT  
1ac1 09			L1AC1:  DEFB    $09             ; Class-09 - Two comma-separated numeric  
1ac2			                                ; expressions required with optional colour  
1ac2			                                ; items.  
1ac2 00			        DEFB    $00             ; Class-00 - No further operands.  
1ac3 dc 22		        DEFW    L22DC           ; Address: $22DC; Address: PLOT  
1ac5			  
1ac5			;; P-PAUSE  
1ac5 06			L1AC5:  DEFB    $06             ; Class-06 - A numeric expression must follow.  
1ac6 00			        DEFB    $00             ; Class-00 - No further operands.  
1ac7 3a 1f		        DEFW    L1F3A           ; Address: $1F3A; Address: PAUSE  
1ac9			  
1ac9			;; P-READ  
1ac9 05			L1AC9:  DEFB    $05             ; Class-05 - Variable syntax checked entirely  
1aca			                                ; by routine.  
1aca ed 1d		        DEFW    L1DED           ; Address: $1DED; Address: READ  
1acc			  
1acc			;; P-DATA  
1acc 05			L1ACC:  DEFB    $05             ; Class-05 - Variable syntax checked entirely  
1acd			                                ; by routine.  
1acd 27 1e		        DEFW    L1E27           ; Address: $1E27; Address: DATA  
1acf			  
1acf			;; P-RESTORE  
1acf 03			L1ACF:  DEFB    $03             ; Class-03 - A numeric expression may follow  
1ad0			                                ; else default to zero.  
1ad0 42 1e		        DEFW    L1E42           ; Address: $1E42; Address: RESTORE  
1ad2			  
1ad2			;; P-DRAW  
1ad2 09			L1AD2:  DEFB    $09             ; Class-09 - Two comma-separated numeric  
1ad3			                                ; expressions required with optional colour  
1ad3			                                ; items.  
1ad3 05			        DEFB    $05             ; Class-05 - Variable syntax checked  
1ad4			                                ; by routine.  
1ad4 82 23		        DEFW    L2382           ; Address: $2382; Address: DRAW  
1ad6			  
1ad6			;; P-COPY  
1ad6 00			L1AD6:  DEFB    $00             ; Class-00 - No further operands.  
1ad7 ac 0e		        DEFW    L0EAC           ; Address: $0EAC; Address: COPY  
1ad9			  
1ad9			;; P-LPRINT  
1ad9 05			L1AD9:  DEFB    $05             ; Class-05 - Variable syntax checked entirely  
1ada			                                ; by routine.  
1ada c9 1f		        DEFW    L1FC9           ; Address: $1FC9; Address: LPRINT  
1adc			  
1adc			;; P-LLIST  
1adc 05			L1ADC:  DEFB    $05             ; Class-05 - Variable syntax checked entirely  
1add			                                ; by routine.  
1add f5 17		        DEFW    L17F5           ; Address: $17F5; Address: LLIST  
1adf			  
1adf			;; P-SAVE  
1adf 0b			L1ADF:  DEFB    $0B             ; Class-0B - Offset address converted to tape  
1ae0			                                ; command.  
1ae0			  
1ae0			;; P-LOAD  
1ae0 0b			L1AE0:  DEFB    $0B             ; Class-0B - Offset address converted to tape  
1ae1			                                ; command.  
1ae1			  
1ae1			;; P-VERIFY  
1ae1 0b			L1AE1:  DEFB    $0B             ; Class-0B - Offset address converted to tape  
1ae2			                                ; command.  
1ae2			  
1ae2			;; P-MERGE  
1ae2 0b			L1AE2:  DEFB    $0B             ; Class-0B - Offset address converted to tape  
1ae3			                                ; command.  
1ae3			  
1ae3			;; P-BEEP  
1ae3 08			L1AE3:  DEFB    $08             ; Class-08 - Two comma-separated numeric  
1ae4			                                ; expressions required.  
1ae4 00			        DEFB    $00             ; Class-00 - No further operands.  
1ae5 f8 03		        DEFW    L03F8           ; Address: $03F8; Address: BEEP  
1ae7			  
1ae7			;; P-CIRCLE  
1ae7 09			L1AE7:  DEFB    $09             ; Class-09 - Two comma-separated numeric  
1ae8			                                ; expressions required with optional colour  
1ae8			                                ; items.  
1ae8 05			        DEFB    $05             ; Class-05 - Variable syntax checked  
1ae9			                                ; by routine.  
1ae9 20 23		        DEFW    L2320           ; Address: $2320; Address: CIRCLE  
1aeb			  
1aeb			;; P-INK  
1aeb 07			L1AEB:  DEFB    $07             ; Class-07 - Offset address is converted to  
1aec			                                ; colour code.  
1aec			  
1aec			;; P-PAPER  
1aec 07			L1AEC:  DEFB    $07             ; Class-07 - Offset address is converted to  
1aed			                                ; colour code.  
1aed			  
1aed			;; P-FLASH  
1aed 07			L1AED:  DEFB    $07             ; Class-07 - Offset address is converted to  
1aee			                                ; colour code.  
1aee			  
1aee			;; P-BRIGHT  
1aee 07			L1AEE:  DEFB    $07             ; Class-07 - Offset address is converted to  
1aef			                                ; colour code.  
1aef			  
1aef			;; P-INVERSE  
1aef 07			L1AEF:  DEFB    $07             ; Class-07 - Offset address is converted to  
1af0			                                ; colour code.  
1af0			  
1af0			;; P-OVER  
1af0 07			L1AF0:  DEFB    $07             ; Class-07 - Offset address is converted to  
1af1			                                ; colour code.  
1af1			  
1af1			;; P-OUT  
1af1 08			L1AF1:  DEFB    $08             ; Class-08 - Two comma-separated numeric  
1af2			                                ; expressions required.  
1af2 00			        DEFB    $00             ; Class-00 - No further operands.  
1af3 7a 1e		        DEFW    L1E7A           ; Address: $1E7A; Address: OUT  
1af5			  
1af5			;; P-BORDER  
1af5 06			L1AF5:  DEFB    $06             ; Class-06 - A numeric expression must follow.  
1af6 00			        DEFB    $00             ; Class-00 - No further operands.  
1af7 94 22		        DEFW    L2294           ; Address: $2294; Address: BORDER  
1af9			  
1af9			;; P-DEF-FN  
1af9 05			L1AF9:  DEFB    $05             ; Class-05 - Variable syntax checked entirely  
1afa			                                ; by routine.  
1afa 60 1f		        DEFW    L1F60           ; Address: $1F60; Address: DEF-FN  
1afc			  
1afc			;; P-OPEN  
1afc 06			L1AFC:  DEFB    $06             ; Class-06 - A numeric expression must follow.  
1afd 2c			        DEFB    $2C             ; Separator:  ','          see Footnote *  
1afe 0a			        DEFB    $0A             ; Class-0A - A string expression must follow.  
1aff 00			        DEFB    $00             ; Class-00 - No further operands.  
1b00 36 17		        DEFW    L1736           ; Address: $1736; Address: OPEN  
1b02			  
1b02			;; P-CLOSE  
1b02 06			L1B02:  DEFB    $06             ; Class-06 - A numeric expression must follow.  
1b03 00			        DEFB    $00             ; Class-00 - No further operands.  
1b04 e5 16		        DEFW    L16E5           ; Address: $16E5; Address: CLOSE  
1b06			  
1b06			;; P-FORMAT  
1b06 0a			L1B06:  DEFB    $0A             ; Class-0A - A string expression must follow.  
1b07 00			        DEFB    $00             ; Class-00 - No further operands.  
1b08 93 17		        DEFW    L1793           ; Address: $1793; Address: CAT-ETC  
1b0a			  
1b0a			;; P-MOVE  
1b0a 0a			L1B0A:  DEFB    $0A             ; Class-0A - A string expression must follow.  
1b0b 2c			        DEFB    $2C             ; Separator:  ','  
1b0c 0a			        DEFB    $0A             ; Class-0A - A string expression must follow.  
1b0d 00			        DEFB    $00             ; Class-00 - No further operands.  
1b0e 93 17		        DEFW    L1793           ; Address: $1793; Address: CAT-ETC  
1b10			  
1b10			;; P-ERASE  
1b10 0a			L1B10:  DEFB    $0A             ; Class-0A - A string expression must follow.  
1b11 00			        DEFB    $00             ; Class-00 - No further operands.  
1b12 93 17		        DEFW    L1793           ; Address: $1793; Address: CAT-ETC  
1b14			  
1b14			;; P-CAT  
1b14 00			L1B14:  DEFB    $00             ; Class-00 - No further operands.  
1b15 93 17		        DEFW    L1793           ; Address: $1793; Address: CAT-ETC  
1b17			  
1b17			; * Note that a comma is required as a separator with the OPEN command  
1b17			; but the Interface 1 programmers relaxed this allowing ';' as an  
1b17			; alternative for their channels creating a confusing mixture of  
1b17			; allowable syntax as it is this ROM which opens or re-opens the  
1b17			; normal channels.  
1b17			  
1b17			; -------------------------------  
1b17			; Main parser (BASIC interpreter)  
1b17			; -------------------------------  
1b17			; This routine is called once from MAIN-2 when the BASIC line is to  
1b17			; be entered or re-entered into the Program area and the syntax  
1b17			; requires checking.  
1b17			  
1b17			;; LINE-SCAN  
1b17 fd cb 01 be	L1B17:  RES     7,(IY+$01)      ; update FLAGS - signal checking syntax  
1b1b cd fb 19		        CALL    L19FB           ; routine E-LINE-NO              >>  
1b1e			                                ; fetches the line number if in range.  
1b1e			  
1b1e af			        XOR     A               ; clear the accumulator.  
1b1f 32 47 5c		        LD      ($5C47),A       ; set statement number SUBPPC to zero.  
1b22 3d			        DEC     A               ; set accumulator to $FF.  
1b23 32 3a 5c		        LD      ($5C3A),A       ; set ERR_NR to 'OK' - 1.  
1b26 18 01		        JR      L1B29           ; forward to continue at STMT-L-1.  
1b28			  
1b28			; --------------  
1b28			; Statement loop  
1b28			; --------------  
1b28			;  
1b28			;  
1b28			  
1b28			;; STMT-LOOP  
1b28 e7			L1B28:  RST     20H             ; NEXT-CHAR  
1b29			  
1b29			; -> the entry point from above or LINE-RUN  
1b29			;; STMT-L-1  
1b29 cd bf 16		L1B29:  CALL    L16BF           ; routine SET-WORK clears workspace etc.  
1b2c			  
1b2c fd 34 0d		        INC     (IY+$0D)        ; increment statement number SUBPPC  
1b2f fa 8a 1c		        JP      M,L1C8A         ; to REPORT-C to raise  
1b32			                                ; 'Nonsense in BASIC' if over 127.  
1b32			  
1b32 df			        RST     18H             ; GET-CHAR  
1b33			  
1b33 06 00		        LD      B,$00           ; set B to zero for later indexing.  
1b35			                                ; early so any other reason ???  
1b35			  
1b35 fe 0d		        CP      $0D             ; is character carriage return ?  
1b37			                                ; i.e. an empty statement.  
1b37 28 7a		        JR      Z,L1BB3         ; forward to LINE-END if so.  
1b39			  
1b39 fe 3a		        CP      $3A             ; is it statement end marker ':' ?  
1b3b			                                ; i.e. another type of empty statement.  
1b3b 28 eb		        JR      Z,L1B28         ; back to STMT-LOOP if so.  
1b3d			  
1b3d 21 76 1b		        LD      HL,L1B76        ; address: STMT-RET  
1b40 e5			        PUSH    HL              ; is now pushed as a return address  
1b41 4f			        LD      C,A             ; transfer the current character to C.  
1b42			  
1b42			; advance CH_ADD to a position after command and test if it is a command.  
1b42			  
1b42 e7			        RST     20H             ; NEXT-CHAR to advance pointer  
1b43 79			        LD      A,C             ; restore current character  
1b44 d6 ce		        SUB     $CE             ; subtract 'DEF FN' - first command  
1b46 da 8a 1c		        JP      C,L1C8A         ; jump to REPORT-C if less than a command  
1b49			                                ; raising   
1b49			                                ; 'Nonsense in BASIC'  
1b49			  
1b49 4f			        LD      C,A             ; put the valid command code back in C.  
1b4a			                                ; register B is zero.  
1b4a 21 48 1a		        LD      HL,L1A48        ; address: offst-tbl  
1b4d 09			        ADD     HL,BC           ; index into table with one of 50 commands.  
1b4e 4e			        LD      C,(HL)          ; pick up displacement to syntax table entry.  
1b4f 09			        ADD     HL,BC           ; add to address the relevant entry.  
1b50 18 03		        JR      L1B55           ; forward to continue at GET-PARAM  
1b52			  
1b52			; ----------------------  
1b52			; The main scanning loop  
1b52			; ----------------------  
1b52			; not documented properly  
1b52			;  
1b52			  
1b52			;; SCAN-LOOP  
1b52 2a 74 5c		L1B52:  LD      HL,($5C74)      ; fetch temporary address from T_ADDR  
1b55			                                ; during subsequent loops.  
1b55			  
1b55			; -> the initial entry point with HL addressing start of syntax table entry.  
1b55			  
1b55			;; GET-PARAM  
1b55 7e			L1B55:  LD      A,(HL)          ; pick up the parameter.  
1b56 23			        INC     HL              ; address next one.  
1b57 22 74 5c		        LD      ($5C74),HL      ; save pointer in system variable T_ADDR  
1b5a			  
1b5a 01 52 1b		        LD      BC,L1B52        ; address: SCAN-LOOP  
1b5d c5			        PUSH    BC              ; is now pushed on stack as looping address.  
1b5e 4f			        LD      C,A             ; store parameter in C.  
1b5f fe 20		        CP      $20             ; is it greater than ' '  ?  
1b61 30 0c		        JR      NC,L1B6F        ; forward to SEPARATOR to check that correct  
1b63			                                ; separator appears in statement if so.  
1b63			  
1b63 21 01 1c		        LD      HL,L1C01        ; address: class-tbl.  
1b66 06 00		        LD      B,$00           ; prepare to index into the class table.  
1b68 09			        ADD     HL,BC           ; index to find displacement to routine.  
1b69 4e			        LD      C,(HL)          ; displacement to BC  
1b6a 09			        ADD     HL,BC           ; add to address the CLASS routine.  
1b6b e5			        PUSH    HL              ; push the address on the stack.  
1b6c			  
1b6c df			        RST     18H             ; GET-CHAR - HL points to place in statement.  
1b6d			  
1b6d 05			        DEC     B               ; reset the zero flag - the initial state  
1b6e			                                ; for all class routines.  
1b6e			  
1b6e c9			        RET                     ; and make an indirect jump to routine  
1b6f			                                ; and then SCAN-LOOP (also on stack).  
1b6f			  
1b6f			; Note. one of the class routines will eventually drop the return address  
1b6f			; off the stack breaking out of the above seemingly endless loop.  
1b6f			  
1b6f			; ----------------  
1b6f			; Verify separator  
1b6f			; ----------------  
1b6f			; This routine is called once to verify that the mandatory separator  
1b6f			; present in the parameter table is also present in the correct  
1b6f			; location following the command. For example, the 'THEN' token after  
1b6f			; the 'IF' token and expression.  
1b6f			  
1b6f			;; SEPARATOR  
1b6f df			L1B6F:  RST     18H             ; GET-CHAR  
1b70 b9			        CP      C               ; does it match the character in C ?  
1b71 c2 8a 1c		        JP      NZ,L1C8A        ; jump forward to REPORT-C if not  
1b74			                                ; 'Nonsense in BASIC'.  
1b74			  
1b74 e7			        RST     20H             ; NEXT-CHAR advance to next character  
1b75 c9			        RET                     ; return.  
1b76			  
1b76			; ------------------------------  
1b76			; Come here after interpretation  
1b76			; ------------------------------  
1b76			;  
1b76			;  
1b76			  
1b76			;; STMT-RET  
1b76 cd 54 1f		L1B76:  CALL    L1F54           ; routine BREAK-KEY is tested after every  
1b79			                                ; statement.  
1b79 38 02		        JR      C,L1B7D         ; step forward to STMT-R-1 if not pressed.  
1b7b			  
1b7b			;; REPORT-L  
1b7b cf			L1B7B:  RST     08H             ; ERROR-1  
1b7c 14			        DEFB    $14             ; Error Report: BREAK into program  
1b7d			  
1b7d			;; STMT-R-1  
1b7d cd 4d 3b		L1B7D:  CALL    L3B4D           ; Spectrum 128 patch  
1b80 00			        NOP  
1b81			  
1b81 20 71		L1B81:  JR      NZ,L1BF4        ; forward to STMT-NEXT if a program line.  
1b83			  
1b83 2a 42 5c		        LD      HL,($5C42)      ; fetch line number from NEWPPC  
1b86 cb 7c		        BIT     7,H             ; will be set if minus two - direct command(s)  
1b88 28 14		        JR      Z,L1B9E         ; forward to LINE-NEW if a jump is to be  
1b8a			                                ; made to a new program line/statement.  
1b8a			  
1b8a			; --------------------  
1b8a			; Run a direct command  
1b8a			; --------------------  
1b8a			; A direct command is to be run or, if continuing from above,  
1b8a			; the next statement of a direct command is to be considered.  
1b8a			  
1b8a			;; LINE-RUN  
1b8a 21 fe ff		L1B8A:  LD      HL,$FFFE        ; The dummy value minus two  
1b8d 22 45 5c		        LD      ($5C45),HL      ; is set/reset as line number in PPC.  
1b90 2a 61 5c		        LD      HL,($5C61)      ; point to end of line + 1 - WORKSP.  
1b93 2b			        DEC     HL              ; now point to $80 end-marker.  
1b94 ed 5b 59 5c	        LD      DE,($5C59)      ; address the start of line E_LINE.  
1b98 1b			        DEC     DE              ; now location before - for GET-CHAR.  
1b99 3a 44 5c		        LD      A,($5C44)       ; load statement to A from NSPPC.  
1b9c 18 33		        JR      L1BD1           ; forward to NEXT-LINE.  
1b9e			  
1b9e			; ------------------------------  
1b9e			; Find start address of new line  
1b9e			; ------------------------------  
1b9e			; The branch was to here if a jump is to made to a new line number  
1b9e			; and statement.  
1b9e			; That is the previous statement was a GO TO, GO SUB, RUN, RETURN, NEXT etc..  
1b9e			  
1b9e			;; LINE-NEW  
1b9e cd 6e 19		L1B9E:  CALL    L196E           ; routine LINE-ADDR gets address of line  
1ba1			                                ; returning zero flag set if line found.  
1ba1 3a 44 5c		        LD      A,($5C44)       ; fetch new statement from NSPPC  
1ba4 28 19		        JR      Z,L1BBF         ; forward to LINE-USE if line matched.  
1ba6			  
1ba6			; continue as must be a direct command.  
1ba6			  
1ba6 a7			        AND     A               ; test statement which should be zero  
1ba7 20 43		        JR      NZ,L1BEC        ; forward to REPORT-N if not.  
1ba9			                                ; 'Statement lost'  
1ba9			  
1ba9			;   
1ba9			  
1ba9 47			        LD      B,A             ; save statement in B. ?  
1baa 7e			        LD      A,(HL)          ; fetch high byte of line number.  
1bab e6 c0		        AND     $C0             ; test if using direct command  
1bad			                                ; a program line is less than $3F  
1bad 78			        LD      A,B             ; retrieve statement.  
1bae			                                ; (we can assume it is zero).  
1bae 28 0f		        JR      Z,L1BBF         ; forward to LINE-USE if was a program line  
1bb0			  
1bb0			; Alternatively a direct statement has finished correctly.  
1bb0			  
1bb0			;; REPORT-0  
1bb0 cf			L1BB0:  RST     08H             ; ERROR-1  
1bb1 ff			        DEFB    $FF             ; Error Report: OK  
1bb2			  
1bb2			; ------------------  
1bb2			; Handle REM command  
1bb2			; ------------------  
1bb2			; The REM command routine.  
1bb2			; The return address STMT-RET is dropped and the rest of line ignored.  
1bb2			  
1bb2			;; REM  
1bb2 c1			L1BB2:  POP     BC              ; drop return address STMT-RET and  
1bb3			                                ; continue ignoring rest of line.  
1bb3			  
1bb3			; ------------  
1bb3			; End of line?  
1bb3			; ------------  
1bb3			;  
1bb3			;  
1bb3			  
1bb3			;; LINE-END  
1bb3 cd 30 25		L1BB3:  CALL    L2530           ; routine SYNTAX-Z  (UNSTACK-Z?)  
1bb6 c8			        RET     Z               ; return if checking syntax.  
1bb7			  
1bb7 2a 55 5c		        LD      HL,($5C55)      ; fetch NXTLIN to HL.  
1bba 3e c0		        LD      A,$C0           ; test against the  
1bbc a6			        AND     (HL)            ; system limit $3F.  
1bbd c0			        RET     NZ              ; return if more as must be  
1bbe			                                ; end of program.  
1bbe			                                ; (or direct command)  
1bbe			  
1bbe af			        XOR     A               ; set statement to zero.  
1bbf			  
1bbf			; and continue to set up the next following line and then consider this new one.  
1bbf			  
1bbf			; ---------------------  
1bbf			; General line checking  
1bbf			; ---------------------  
1bbf			; The branch was here from LINE-NEW if BASIC is branching.  
1bbf			; or a continuation from above if dealing with a new sequential line.  
1bbf			; First make statement zero number one leaving others unaffected.  
1bbf			  
1bbf			;; LINE-USE  
1bbf fe 01		L1BBF:  CP      $01             ; will set carry if zero.  
1bc1 ce 00		        ADC     A,$00           ; add in any carry.  
1bc3			  
1bc3 56			        LD      D,(HL)          ; high byte of line number to D.  
1bc4 23			        INC     HL              ; advance pointer.  
1bc5 5e			        LD      E,(HL)          ; low byte of line number to E.  
1bc6 ed 53 45 5c	        LD      ($5C45),DE      ; set system variable PPC.  
1bca			  
1bca 23			        INC     HL              ; advance pointer.  
1bcb 5e			        LD      E,(HL)          ; low byte of line length to E.  
1bcc 23			        INC     HL              ; advance pointer.  
1bcd 56			        LD      D,(HL)          ; high byte of line length to D.  
1bce			  
1bce eb			        EX      DE,HL           ; swap pointer to DE before  
1bcf 19			        ADD     HL,DE           ; adding to address the end of line.  
1bd0 23			        INC     HL              ; advance to start of next line.  
1bd1			  
1bd1			; -----------------------------  
1bd1			; Update NEXT LINE but consider  
1bd1			; previous line or edit line.  
1bd1			; -----------------------------  
1bd1			; The pointer will be the next line if continuing from above or to  
1bd1			; edit line end-marker ($80) if from LINE-RUN.  
1bd1			  
1bd1			;; NEXT-LINE  
1bd1 22 55 5c		L1BD1:  LD      ($5C55),HL      ; store pointer in system variable NXTLIN  
1bd4			  
1bd4 eb			        EX      DE,HL           ; bring back pointer to previous or edit line  
1bd5 22 5d 5c		        LD      ($5C5D),HL      ; and update CH_ADD with character address.  
1bd8			  
1bd8 57			        LD      D,A             ; store statement in D.  
1bd9 1e 00		        LD      E,$00           ; set E to zero to suppress token searching  
1bdb			                                ; if EACH-STMT is to be called.  
1bdb fd 36 0a ff	        LD      (IY+$0A),$FF    ; set statement NSPPC to $FF signalling  
1bdf			                                ; no jump to be made.  
1bdf 15			        DEC     D               ; decrement and test statement  
1be0 fd 72 0d		        LD      (IY+$0D),D      ; set SUBPPC to decremented statement number.  
1be3 ca 28 1b		        JP      Z,L1B28         ; to STMT-LOOP if result zero as statement is  
1be6			                                ; at start of line and address is known.  
1be6			  
1be6 14			        INC     D               ; else restore statement.  
1be7 cd 8b 19		        CALL    L198B           ; routine EACH-STMT finds the D'th statement  
1bea			                                ; address as E does not contain a token.  
1bea 28 08		        JR      Z,L1BF4         ; forward to STMT-NEXT if address found.  
1bec			  
1bec			;; REPORT-N  
1bec cf			L1BEC:  RST     08H             ; ERROR-1  
1bed 16			        DEFB    $16             ; Error Report: Statement lost  
1bee			  
1bee			; -----------------  
1bee			; End of statement?  
1bee			; -----------------  
1bee			; This combination of routines is called from 20 places when  
1bee			; the end of a statement should have been reached and all preceding  
1bee			; syntax is in order.  
1bee			  
1bee			;; CHECK-END  
1bee cd 30 25		L1BEE:  CALL    L2530           ; routine SYNTAX-Z  
1bf1 c0			        RET     NZ              ; return immediately in runtime  
1bf2			  
1bf2 c1			        POP     BC              ; drop address of calling routine.  
1bf3 c1			        POP     BC              ; drop address STMT-RET.  
1bf4			                                ; and continue to find next statement.  
1bf4			  
1bf4			; --------------------  
1bf4			; Go to next statement  
1bf4			; --------------------  
1bf4			; Acceptable characters at this point are carriage return and ':'.  
1bf4			; If so go to next statement which in the first case will be on next line.  
1bf4			  
1bf4			;; STMT-NEXT  
1bf4 cd 5d 3b		L1BF4:  CALL    L3B5D           ; Spectrum 128 patch  
1bf7			  
1bf7 28 ba		L1BF7:  JR      Z,L1BB3         ; back to LINE-END if so.  
1bf9			  
1bf9 fe 3a		        CP      $3A             ; is it ':' ?  
1bfb ca 28 1b		        JP      Z,L1B28         ; jump back to STMT-LOOP to consider  
1bfe			                                ; further statements  
1bfe			  
1bfe c3 8a 1c		        JP      L1C8A           ; jump to REPORT-C with any other character  
1c01			                                ; 'Nonsense in BASIC'.  
1c01			  
1c01			; Note. the two-byte sequence 'rst 08; defb $0b' could replace the above jp.  
1c01			  
1c01			; -------------------  
1c01			; Command class table  
1c01			; -------------------  
1c01			;  
1c01			  
1c01			;; class-tbl  
1c01 0f			L1C01:  DEFB    L1C10 - $       ; 0F offset to Address: CLASS-00  
1c02 1d			        DEFB    L1C1F - $       ; 1D offset to Address: CLASS-01  
1c03 4b			        DEFB    L1C4E - $       ; 4B offset to Address: CLASS-02  
1c04 09			        DEFB    L1C0D - $       ; 09 offset to Address: CLASS-03  
1c05 67			        DEFB    L1C6C - $       ; 67 offset to Address: CLASS-04  
1c06 0b			        DEFB    L1C11 - $       ; 0B offset to Address: CLASS-05  
1c07 7b			        DEFB    L1C82 - $       ; 7B offset to Address: CLASS-06  
1c08 8e			        DEFB    L1C96 - $       ; 8E offset to Address: CLASS-07  
1c09 71			        DEFB    L1C7A - $       ; 71 offset to Address: CLASS-08  
1c0a b4			        DEFB    L1CBE - $       ; B4 offset to Address: CLASS-09  
1c0b 81			        DEFB    L1C8C - $       ; 81 offset to Address: CLASS-0A  
1c0c cf			        DEFB    L1CDB - $       ; CF offset to Address: CLASS-0B  
1c0d			  
1c0d			  
1c0d			; --------------------------------  
1c0d			; Command classes---00, 03, and 05  
1c0d			; --------------------------------  
1c0d			; class-03 e.g RUN or RUN 200   ;  optional operand  
1c0d			; class-00 e.g CONTINUE         ;  no operand  
1c0d			; class-05 e.g PRINT            ;  variable syntax checked by routine  
1c0d			  
1c0d			;; CLASS-03  
1c0d cd de 1c		L1C0D:  CALL    L1CDE           ; routine FETCH-NUM  
1c10			  
1c10			;; CLASS-00  
1c10			  
1c10 bf			L1C10:  CP      A               ; reset zero flag.  
1c11			  
1c11			; if entering here then all class routines are entered with zero reset.  
1c11			  
1c11			;; CLASS-05  
1c11 c1			L1C11:  POP     BC              ; drop address SCAN-LOOP.  
1c12 cc ee 1b		        CALL    Z,L1BEE         ; if zero set then call routine CHECK-END >>>  
1c15			                                ; as should be no further characters.  
1c15			  
1c15 eb			        EX      DE,HL           ; save HL to DE.  
1c16 2a 74 5c		        LD      HL,($5C74)      ; fetch T_ADDR  
1c19 4e			        LD      C,(HL)          ; fetch low byte of routine  
1c1a 23			        INC     HL              ; address next.  
1c1b 46			        LD      B,(HL)          ; fetch high byte of routine.  
1c1c eb			        EX      DE,HL           ; restore HL from DE  
1c1d c5			        PUSH    BC              ; push the address  
1c1e c9			        RET                     ; and make an indirect jump to the command.  
1c1f			  
1c1f			; --------------------------------  
1c1f			; Command classes---01, 02, and 04  
1c1f			; --------------------------------  
1c1f			; class-01  e.g LET A = 2*3     ; a variable is reqd  
1c1f			  
1c1f			; This class routine is also called from INPUT and READ to find the  
1c1f			; destination variable for an assignment.  
1c1f			  
1c1f			;; CLASS-01  
1c1f cd b2 28		L1C1F:  CALL    L28B2           ; routine LOOK-VARS returns carry set if not  
1c22			                                ; found in runtime.  
1c22			  
1c22			; ----------------------  
1c22			; Variable in assignment  
1c22			; ----------------------  
1c22			;  
1c22			;  
1c22			  
1c22			;; VAR-A-1  
1c22 fd 36 37 00	L1C22:  LD      (IY+$37),$00    ; set FLAGX to zero  
1c26 30 08		        JR      NC,L1C30        ; forward to VAR-A-2 if found or checking  
1c28			                                ; syntax.  
1c28			  
1c28 fd cb 37 ce	        SET     1,(IY+$37)      ; FLAGX  - Signal a new variable  
1c2c 20 18		        JR      NZ,L1C46        ; to VAR-A-3 if not assigning to an array  
1c2e			                                ; e.g. LET a$(3,3) = "X"  
1c2e			  
1c2e			;; REPORT-2  
1c2e cf			L1C2E:  RST     08H             ; ERROR-1  
1c2f 01			        DEFB    $01             ; Error Report: Variable not found  
1c30			  
1c30			;; VAR-A-2  
1c30 cc 96 29		L1C30:  CALL    Z,L2996         ; routine STK-VAR considers a subscript/slice  
1c33 fd cb 01 76	        BIT     6,(IY+$01)      ; test FLAGS  - Numeric or string result ?  
1c37 20 0d		        JR      NZ,L1C46        ; to VAR-A-3 if numeric  
1c39			  
1c39 af			        XOR     A               ; default to array/slice - to be retained.  
1c3a cd 30 25		        CALL    L2530           ; routine SYNTAX-Z  
1c3d c4 f1 2b		        CALL    NZ,L2BF1        ; routine STK-FETCH is called in runtime  
1c40			                                ; may overwrite A with 1.  
1c40 21 71 5c		        LD      HL,$5C71        ; address system variable FLAGX  
1c43 b6			        OR      (HL)            ; set bit 0 if simple variable to be reclaimed  
1c44 77			        LD      (HL),A          ; update FLAGX  
1c45 eb			        EX      DE,HL           ; start of string/subscript to DE  
1c46			  
1c46			;; VAR-A-3  
1c46 ed 43 72 5c	L1C46:  LD      ($5C72),BC      ; update STRLEN  
1c4a 22 4d 5c		        LD      ($5C4D),HL      ; and DEST of assigned string.  
1c4d c9			        RET                     ; return.  
1c4e			  
1c4e			; -------------------------------------------------  
1c4e			; class-02 e.g. LET a = 1 + 1   ; an expression must follow  
1c4e			  
1c4e			;; CLASS-02  
1c4e c1			L1C4E:  POP     BC              ; drop return address SCAN-LOOP  
1c4f cd 56 1c		        CALL    L1C56           ; routine VAL-FET-1 is called to check  
1c52			                                ; expression and assign result in runtime  
1c52 cd ee 1b		        CALL    L1BEE           ; routine CHECK-END checks nothing else  
1c55			                                ; is present in statement.  
1c55 c9			        RET                     ; Return  
1c56			  
1c56			; -------------  
1c56			; Fetch a value  
1c56			; -------------  
1c56			;  
1c56			;  
1c56			  
1c56			;; VAL-FET-1  
1c56 3a 3b 5c		L1C56:  LD      A,($5C3B)       ; initial FLAGS to A  
1c59			  
1c59			;; VAL-FET-2  
1c59 f5			L1C59:  PUSH    AF              ; save A briefly  
1c5a cd fb 24		        CALL    L24FB           ; routine SCANNING evaluates expression.  
1c5d f1			        POP     AF              ; restore A  
1c5e fd 56 01		        LD      D,(IY+$01)      ; post-SCANNING FLAGS to D  
1c61 aa			        XOR     D               ; xor the two sets of flags  
1c62 e6 40		        AND     $40             ; pick up bit 6 of xored FLAGS should be zero  
1c64 20 24		        JR      NZ,L1C8A        ; forward to REPORT-C if not zero  
1c66			                                ; 'Nonsense in BASIC' - results don't agree.  
1c66			  
1c66 cb 7a		        BIT     7,D             ; test FLAGS - is syntax being checked ?  
1c68 c2 ff 2a		        JP      NZ,L2AFF        ; jump forward to LET to make the assignment  
1c6b			                                ; in runtime.  
1c6b			  
1c6b c9			        RET                     ; but return from here if checking syntax.  
1c6c			  
1c6c			; ------------------  
1c6c			; Command class---04  
1c6c			; ------------------  
1c6c			; class-04 e.g. FOR i            ; a single character variable must follow  
1c6c			  
1c6c			;; CLASS-04  
1c6c cd b2 28		L1C6C:  CALL    L28B2           ; routine LOOK-VARS  
1c6f f5			        PUSH    AF              ; preserve flags.  
1c70 79			        LD      A,C             ; fetch type - should be 011xxxxx  
1c71 f6 9f		        OR      $9F             ; combine with 10011111.  
1c73 3c			        INC     A               ; test if now $FF by incrementing.  
1c74 20 14		        JR      NZ,L1C8A        ; forward to REPORT-C if result not zero.  
1c76			  
1c76 f1			        POP     AF              ; else restore flags.  
1c77 18 a9		        JR      L1C22           ; back to VAR-A-1  
1c79			  
1c79			  
1c79			; --------------------------------  
1c79			; Expect numeric/string expression  
1c79			; --------------------------------  
1c79			; This routine is used to get the two coordinates of STRING$, ATTR and POINT.  
1c79			; It is also called from PRINT-ITEM to get the two numeric expressions that  
1c79			; follow the AT ( in PRINT AT, INPUT AT).  
1c79			  
1c79			;; NEXT-2NUM  
1c79 e7			L1C79:  RST     20H             ; NEXT-CHAR advance past 'AT' or '('.  
1c7a			  
1c7a			; --------  
1c7a			; class-08 e.g POKE 65535,2     ; two numeric expressions separated by comma  
1c7a			;; CLASS-08  
1c7a			;; EXPT-2NUM  
1c7a cd 82 1c		L1C7A:  CALL    L1C82           ; routine EXPT-1NUM is called for first  
1c7d			                                ; numeric expression  
1c7d fe 2c		        CP      $2C             ; is character ',' ?  
1c7f 20 09		        JR      NZ,L1C8A        ; to REPORT-C if not required separator.  
1c81			                                ; 'Nonsense in BASIC'.  
1c81			  
1c81 e7			        RST     20H             ; NEXT-CHAR  
1c82			  
1c82			; ->  
1c82			;  class-06  e.g. GOTO a*1000   ; a numeric expression must follow  
1c82			;; CLASS-06  
1c82			;; EXPT-1NUM  
1c82 cd fb 24		L1C82:  CALL    L24FB           ; routine SCANNING  
1c85 fd cb 01 76	        BIT     6,(IY+$01)      ; test FLAGS  - Numeric or string result ?  
1c89 c0			        RET     NZ              ; return if result is numeric.  
1c8a			  
1c8a			;; REPORT-C  
1c8a cf			L1C8A:  RST     08H             ; ERROR-1  
1c8b 0b			        DEFB    $0B             ; Error Report: Nonsense in BASIC  
1c8c			  
1c8c			; ---------------------------------------------------------------  
1c8c			; class-0A e.g. ERASE "????"    ; a string expression must follow.  
1c8c			;                               ; these only occur in unimplemented commands  
1c8c			;                               ; although the routine expt-exp is called  
1c8c			;                               ; from SAVE-ETC  
1c8c			  
1c8c			;; CLASS-0A  
1c8c			;; EXPT-EXP  
1c8c cd fb 24		L1C8C:  CALL    L24FB           ; routine SCANNING  
1c8f fd cb 01 76	        BIT     6,(IY+$01)      ; test FLAGS  - Numeric or string result ?  
1c93 c8			        RET     Z               ; return if string result.  
1c94			  
1c94 18 f4		        JR      L1C8A           ; back to REPORT-C if numeric.  
1c96			  
1c96			; ---------------------  
1c96			; Set permanent colours  
1c96			; class 07  
1c96			; ---------------------  
1c96			; class-07 e.g PAPER 6          ; a single class for a collection of  
1c96			;                               ; similar commands. Clever.  
1c96			;  
1c96			; Note. these commands should ensure that current channel is 'S'  
1c96			  
1c96			;; CLASS-07  
1c96 fd cb 01 7e	L1C96:  BIT     7,(IY+$01)      ; test FLAGS - checking syntax only ?  
1c9a fd cb 02 86	        RES     0,(IY+$02)      ; update TV_FLAG - signal main screen in use  
1c9e c4 4d 0d		        CALL    NZ,L0D4D        ; routine TEMPS is called in runtime.  
1ca1 f1			        POP     AF              ; drop return address SCAN-LOOP  
1ca2 3a 74 5c		        LD      A,($5C74)       ; T_ADDR_lo to accumulator.  
1ca5			                                ; points to '$07' entry + 1  
1ca5			                                ; e.g. for INK points to $EC now  
1ca5			  
1ca5			; Note if you move alter the syntax table next line may have to be altered.  
1ca5			  
1ca5			; Note. For ZASM assembler replace following expression with SUB $13.  
1ca5			  
1ca5			L1CA5:  ;SUB     L1AEB-$D8 % 256 ; convert $EB to $D8 ('INK') etc.  
1ca5 d6 13		        SUB $13                  ; ( is SUB $13 in standard ROM )  
1ca7			  
1ca7 cd fc 21		        CALL    L21FC           ; routine CO-TEMP-4  
1caa cd ee 1b		        CALL    L1BEE           ; routine CHECK-END check that nothing else  
1cad			                                ; in statement.  
1cad			  
1cad			; return here in runtime.  
1cad			  
1cad 2a 8f 5c		        LD      HL,($5C8F)      ; pick up ATTR_T and MASK_T  
1cb0 22 8d 5c		        LD      ($5C8D),HL      ; and store in ATTR_P and MASK_P  
1cb3 21 91 5c		        LD      HL,$5C91        ; point to P_FLAG.  
1cb6 7e			        LD      A,(HL)          ; pick up in A  
1cb7 07			        RLCA                    ; rotate to left  
1cb8 ae			        XOR     (HL)            ; combine with HL  
1cb9 e6 aa		        AND     $AA             ; 10101010  
1cbb ae			        XOR     (HL)            ; only permanent bits affected  
1cbc 77			        LD      (HL),A          ; reload into P_FLAG.  
1cbd c9			        RET                     ; return.  
1cbe			  
1cbe			; ------------------  
1cbe			; Command class---09  
1cbe			; ------------------  
1cbe			; e.g. PLOT PAPER 0; 128,88     ; two coordinates preceded by optional  
1cbe			;                               ; embedded colour items.  
1cbe			;  
1cbe			; Note. this command should ensure that current channel is actually 'S'.  
1cbe			  
1cbe			;; CLASS-09  
1cbe cd 30 25		L1CBE:  CALL    L2530           ; routine SYNTAX-Z  
1cc1 28 13		        JR      Z,L1CD6         ; forward to CL-09-1 if checking syntax.  
1cc3			  
1cc3 fd cb 02 86	        RES     0,(IY+$02)      ; update TV_FLAG - signal main screen in use  
1cc7 cd 4d 0d		        CALL    L0D4D           ; routine TEMPS is called.  
1cca 21 90 5c		        LD      HL,$5C90        ; point to MASK_T  
1ccd 7e			        LD      A,(HL)          ; fetch mask to accumulator.  
1cce f6 f8		        OR      $F8             ; or with 11111000 paper/bright/flash 8  
1cd0 77			        LD      (HL),A          ; mask back to MASK_T system variable.  
1cd1 fd cb 57 b6	        RES     6,(IY+$57)      ; reset P_FLAG  - signal NOT PAPER 9 ?  
1cd5			  
1cd5 df			        RST     18H             ; GET-CHAR  
1cd6			  
1cd6			;; CL-09-1  
1cd6 cd e2 21		L1CD6:  CALL    L21E2           ; routine CO-TEMP-2 deals with any embedded  
1cd9			                                ; colour items.  
1cd9 18 9f		        JR      L1C7A           ; exit via EXPT-2NUM to check for x,y.  
1cdb			  
1cdb			; Note. if either of the numeric expressions contain STR$ then the flag setting   
1cdb			; above will be undone when the channel flags are reset during STR$.  
1cdb			; e.g.   
1cdb			; 10 BORDER 3 : PLOT VAL STR$ 128, VAL STR$ 100  
1cdb			; credit John Elliott.  
1cdb			  
1cdb			; ------------------  
1cdb			; Command class---0B  
1cdb			; ------------------  
1cdb			; Again a single class for four commands.  
1cdb			; This command just jumps back to SAVE-ETC to handle the four tape commands.  
1cdb			; The routine itself works out which command has called it by examining the  
1cdb			; address in T_ADDR_lo. Note therefore that the syntax table has to be  
1cdb			; located where these and other sequential command addresses are not split  
1cdb			; over a page boundary.  
1cdb			  
1cdb			;; CLASS-0B  
1cdb c3 05 06		L1CDB:  JP      L0605           ; jump way back to SAVE-ETC  
1cde			  
1cde			; --------------  
1cde			; Fetch a number  
1cde			; --------------  
1cde			; This routine is called from CLASS-03 when a command may be followed by  
1cde			; an optional numeric expression e.g. RUN. If the end of statement has  
1cde			; been reached then zero is used as the default.  
1cde			; Also called from LIST-4.  
1cde			  
1cde			;; FETCH-NUM  
1cde fe 0d		L1CDE:  CP      $0D             ; is character a carriage return ?  
1ce0 28 04		        JR      Z,L1CE6         ; forward to USE-ZERO if so  
1ce2			  
1ce2 fe 3a		        CP      $3A             ; is it ':' ?  
1ce4 20 9c		        JR      NZ,L1C82        ; forward to EXPT-1NUM if not.  
1ce6			                                ; else continue and use zero.  
1ce6			  
1ce6			; ----------------  
1ce6			; Use zero routine  
1ce6			; ----------------  
1ce6			; This routine is called four times to place the value zero on the  
1ce6			; calculator stack as a default value in runtime.  
1ce6			  
1ce6			;; USE-ZERO  
1ce6 cd 30 25		L1CE6:  CALL    L2530           ; routine SYNTAX-Z  (UNSTACK-Z?)  
1ce9 c8			        RET     Z               ;  
1cea			  
1cea ef			        RST     28H             ;; FP-CALC  
1ceb a0			        DEFB    $A0             ;;stk-zero       ;0.  
1cec 38			        DEFB    $38             ;;end-calc  
1ced			  
1ced c9			        RET                     ; return.  
1cee			  
1cee			; -------------------  
1cee			; Handle STOP command  
1cee			; -------------------  
1cee			; Command Syntax: STOP  
1cee			; One of the shortest and least used commands. As with 'OK' not an error.  
1cee			  
1cee			;; REPORT-9  
1cee			;; STOP  
1cee cf			L1CEE:  RST     08H             ; ERROR-1  
1cef 08			        DEFB    $08             ; Error Report: STOP statement  
1cf0			  
1cf0			; -----------------  
1cf0			; Handle IF command  
1cf0			; -----------------  
1cf0			; e.g. IF score>100 THEN PRINT "You Win"  
1cf0			; The parser has already checked the expression the result of which is on  
1cf0			; the calculator stack. The presence of the 'THEN' separator has also been  
1cf0			; checked and CH-ADD points to the command after THEN.  
1cf0			;  
1cf0			  
1cf0			;; IF  
1cf0 c1			L1CF0:  POP     BC              ; drop return address - STMT-RET  
1cf1 cd 30 25		        CALL    L2530           ; routine SYNTAX-Z  
1cf4 28 0a		        JR      Z,L1D00         ; forward to IF-1 if checking syntax  
1cf6			                                ; to check syntax of PRINT "You Win"  
1cf6			  
1cf6			  
1cf6 ef			        RST     28H             ;; FP-CALC    score>100 (1=TRUE 0=FALSE)  
1cf7 02			        DEFB    $02             ;;delete      .  
1cf8 38			        DEFB    $38             ;;end-calc  
1cf9			  
1cf9 eb			        EX      DE,HL           ; make HL point to deleted value  
1cfa cd e9 34		        CALL    L34E9           ; routine TEST-ZERO  
1cfd da b3 1b		        JP      C,L1BB3         ; jump to LINE-END if FALSE (0)  
1d00			  
1d00			;; IF-1  
1d00 c3 29 1b		L1D00:  JP      L1B29           ; to STMT-L-1, if true (1) to execute command  
1d03			                                ; after 'THEN' token.  
1d03			  
1d03			; ------------------  
1d03			; Handle FOR command  
1d03			; ------------------  
1d03			; e.g. FOR i = 0 TO 1 STEP 0.1  
1d03			; Using the syntax tables, the parser has already checked for a start and  
1d03			; limit value and also for the intervening separator.  
1d03			; the two values v,l are on the calculator stack.  
1d03			; CLASS-04 has also checked the variable and the name is in STRLEN_lo.  
1d03			; The routine begins by checking for an optional STEP.  
1d03			  
1d03			;; FOR  
1d03 fe cd		L1D03:  CP      $CD             ; is there a 'STEP' ?  
1d05 20 09		        JR      NZ,L1D10        ; to F-USE-1 if not to use 1 as default.  
1d07			  
1d07 e7			        RST     20H             ; NEXT-CHAR  
1d08 cd 82 1c		        CALL    L1C82           ; routine EXPT-1NUM  
1d0b cd ee 1b		        CALL    L1BEE           ; routine CHECK-END  
1d0e 18 06		        JR      L1D16           ; to F-REORDER  
1d10			  
1d10			; ---  
1d10			  
1d10			;; F-USE-1  
1d10 cd ee 1b		L1D10:  CALL    L1BEE           ; routine CHECK-END  
1d13			  
1d13 ef			        RST     28H             ;; FP-CALC      v,l.  
1d14 a1			        DEFB    $A1             ;;stk-one       v,l,1=s.  
1d15 38			        DEFB    $38             ;;end-calc  
1d16			  
1d16			  
1d16			;; F-REORDER  
1d16 ef			L1D16:  RST     28H             ;; FP-CALC       v,l,s.  
1d17 c0			        DEFB    $C0             ;;st-mem-0       v,l,s.  
1d18 02			        DEFB    $02             ;;delete         v,l.  
1d19 01			        DEFB    $01             ;;exchange       l,v.  
1d1a e0			        DEFB    $E0             ;;get-mem-0      l,v,s.  
1d1b 01			        DEFB    $01             ;;exchange       l,s,v.  
1d1c 38			        DEFB    $38             ;;end-calc  
1d1d			  
1d1d cd ff 2a		        CALL    L2AFF           ; routine LET assigns the initial value v to  
1d20			                                ; the variable altering type if necessary.  
1d20 22 68 5c		        LD      ($5C68),HL      ; The system variable MEM is made to point to  
1d23			                                ; the variable instead of its normal  
1d23			                                ; location MEMBOT  
1d23 2b			        DEC     HL              ; point to single-character name  
1d24 7e			        LD      A,(HL)          ; fetch name  
1d25 cb fe		        SET     7,(HL)          ; set bit 7 at location  
1d27 01 06 00		        LD      BC,$0006        ; add six to HL  
1d2a 09			        ADD     HL,BC           ; to address where limit should be.  
1d2b 07			        RLCA                    ; test bit 7 of original name.  
1d2c 38 06		        JR      C,L1D34         ; forward to F-L-S if already a FOR/NEXT  
1d2e			                                ; variable  
1d2e			  
1d2e 0e 0d		        LD      C,$0D           ; otherwise an additional 13 bytes are needed.  
1d30			                                ; 5 for each value, two for line number and  
1d30			                                ; 1 byte for looping statement.  
1d30 cd 55 16		        CALL    L1655           ; routine MAKE-ROOM creates them.  
1d33 23			        INC     HL              ; make HL address limit.  
1d34			  
1d34			;; F-L-S  
1d34 e5			L1D34:  PUSH    HL              ; save position.  
1d35			  
1d35 ef			        RST     28H             ;; FP-CALC         l,s.  
1d36 02			        DEFB    $02             ;;delete           l.  
1d37 02			        DEFB    $02             ;;delete           .  
1d38 38			        DEFB    $38             ;;end-calc  
1d39			                                ; DE points to STKEND, l.  
1d39			  
1d39 e1			        POP     HL              ; restore variable position  
1d3a eb			        EX      DE,HL           ; swap pointers  
1d3b 0e 0a		        LD      C,$0A           ; ten bytes to move  
1d3d ed b0		        LDIR                    ; Copy 'deleted' values to variable.  
1d3f 2a 45 5c		        LD      HL,($5C45)      ; Load with current line number from PPC  
1d42 eb			        EX      DE,HL           ; exchange pointers.  
1d43 73			        LD      (HL),E          ; save the looping line  
1d44 23			        INC     HL              ; in the next  
1d45 72			        LD      (HL),D          ; two locations.  
1d46 fd 56 0d		        LD      D,(IY+$0D)      ; fetch statement from SUBPPC system variable.  
1d49 14			        INC     D               ; increment statement.  
1d4a 23			        INC     HL              ; and pointer  
1d4b 72			        LD      (HL),D          ; and store the looping statement.  
1d4c			                                ;  
1d4c cd da 1d		        CALL    L1DDA           ; routine NEXT-LOOP considers an initial  
1d4f d0			        RET     NC              ; iteration. Return to STMT-RET if a loop is  
1d50			                                ; possible to execute next statement.  
1d50			  
1d50			; no loop is possible so execution continues after the matching 'NEXT'  
1d50			  
1d50 fd 46 38		        LD      B,(IY+$38)      ; get single-character name from STRLEN_lo  
1d53 2a 45 5c		        LD      HL,($5C45)      ; get the current line from PPC  
1d56 22 42 5c		        LD      ($5C42),HL      ; and store it in NEWPPC  
1d59 3a 47 5c		        LD      A,($5C47)       ; fetch current statement from SUBPPC  
1d5c ed 44		        NEG                     ; Negate as counter decrements from zero  
1d5e			                                ; initially and we are in the middle of a  
1d5e			                                ; line.  
1d5e 57			        LD      D,A             ; Store result in D.  
1d5f 2a 5d 5c		        LD      HL,($5C5D)      ; get current address from CH_ADD  
1d62 1e f3		        LD      E,$F3           ; search will be for token 'NEXT'  
1d64			  
1d64			;; F-LOOP  
1d64 c5			L1D64:  PUSH    BC              ; save variable name.  
1d65 ed 4b 55 5c	        LD      BC,($5C55)      ; fetch NXTLIN  
1d69 cd 86 1d		        CALL    L1D86           ; routine LOOK-PROG searches for 'NEXT' token.  
1d6c ed 43 55 5c	        LD      ($5C55),BC      ; update NXTLIN  
1d70 c1			        POP     BC              ; and fetch the letter  
1d71 38 11		        JR      C,L1D84         ; forward to REPORT-I if the end of program  
1d73			                                ; was reached by LOOK-PROG.  
1d73			                                ; 'FOR without NEXT'  
1d73			  
1d73 e7			        RST     20H             ; NEXT-CHAR fetches character after NEXT  
1d74 f6 20		        OR      $20             ; ensure it is upper-case.  
1d76 b8			        CP      B               ; compare with FOR variable name  
1d77 28 03		        JR      Z,L1D7C         ; forward to F-FOUND if it matches.  
1d79			  
1d79			; but if no match i.e. nested FOR/NEXT loops then continue search.  
1d79			  
1d79 e7			        RST     20H             ; NEXT-CHAR  
1d7a 18 e8		        JR      L1D64           ; back to F-LOOP  
1d7c			  
1d7c			; ---  
1d7c			  
1d7c			  
1d7c			;; F-FOUND  
1d7c e7			L1D7C:  RST     20H             ; NEXT-CHAR  
1d7d 3e 01		        LD      A,$01           ; subtract the negated counter from 1  
1d7f 92			        SUB     D               ; to give the statement after the NEXT  
1d80 32 44 5c		        LD      ($5C44),A       ; set system variable NSPPC  
1d83 c9			        RET                     ; return to STMT-RET to branch to new  
1d84			                                ; line and statement. ->  
1d84			; ---  
1d84			  
1d84			;; REPORT-I  
1d84 cf			L1D84:  RST     08H             ; ERROR-1  
1d85 11			        DEFB    $11             ; Error Report: FOR without NEXT  
1d86			  
1d86			; ---------  
1d86			; LOOK-PROG  
1d86			; ---------  
1d86			; Find DATA, DEF FN or NEXT.  
1d86			; This routine searches the program area for one of the above three keywords.  
1d86			; On entry, HL points to start of search area.  
1d86			; The token is in E, and D holds a statement count, decremented from zero.  
1d86			  
1d86			;; LOOK-PROG  
1d86 7e			L1D86:  LD      A,(HL)          ; fetch current character  
1d87 fe 3a		        CP      $3A             ; is it ':' a statement separator ?  
1d89 28 18		        JR      Z,L1DA3         ; forward to LOOK-P-2 if so.  
1d8b			  
1d8b			; The starting point was PROG - 1 or the end of a line.  
1d8b			  
1d8b			;; LOOK-P-1  
1d8b 23			L1D8B:  INC     HL              ; increment pointer to address  
1d8c 7e			        LD      A,(HL)          ; the high byte of line number  
1d8d e6 c0		        AND     $C0             ; test for program end marker $80 or a  
1d8f			                                ; variable  
1d8f 37			        SCF                     ; Set Carry Flag  
1d90 c0			        RET     NZ              ; return with carry set if at end  
1d91			                                ; of program.           ->  
1d91			  
1d91 46			        LD      B,(HL)          ; high byte of line number to B  
1d92 23			        INC     HL              ;  
1d93 4e			        LD      C,(HL)          ; low byte to C.  
1d94 ed 43 42 5c	        LD      ($5C42),BC      ; set system variable NEWPPC.  
1d98 23			        INC     HL              ;  
1d99 4e			        LD      C,(HL)          ; low byte of line length to C.  
1d9a 23			        INC     HL              ;  
1d9b 46			        LD      B,(HL)          ; high byte to B.  
1d9c e5			        PUSH    HL              ; save address  
1d9d 09			        ADD     HL,BC           ; add length to position.  
1d9e 44			        LD      B,H             ; and save result  
1d9f 4d			        LD      C,L             ; in BC.  
1da0 e1			        POP     HL              ; restore address.  
1da1 16 00		        LD      D,$00           ; initialize statement counter to zero.  
1da3			  
1da3			;; LOOK-P-2  
1da3 c5			L1DA3:  PUSH    BC              ; save address of next line  
1da4 cd 8b 19		        CALL    L198B           ; routine EACH-STMT searches current line.  
1da7 c1			        POP     BC              ; restore address.  
1da8 d0			        RET     NC              ; return if match was found. ->  
1da9			  
1da9 18 e0		        JR      L1D8B           ; back to LOOK-P-1 for next line.  
1dab			  
1dab			; -------------------  
1dab			; Handle NEXT command  
1dab			; -------------------  
1dab			; e.g. NEXT i  
1dab			; The parameter tables have already evaluated the presence of a variable  
1dab			  
1dab			;; NEXT  
1dab fd cb 37 4e	L1DAB:  BIT     1,(IY+$37)      ; test FLAGX - handling a new variable ?  
1daf c2 2e 1c		        JP      NZ,L1C2E        ; jump back to REPORT-2 if so  
1db2			                                ; 'Variable not found'  
1db2			  
1db2			; now test if found variable is a simple variable uninitialized by a FOR.  
1db2			  
1db2 2a 4d 5c		        LD      HL,($5C4D)      ; load address of variable from DEST  
1db5 cb 7e		        BIT     7,(HL)          ; is it correct type ?  
1db7 28 1f		        JR      Z,L1DD8         ; forward to REPORT-1 if not  
1db9			                                ; 'NEXT without FOR'  
1db9			  
1db9 23			        INC     HL              ; step past variable name  
1dba 22 68 5c		        LD      ($5C68),HL      ; and set MEM to point to three 5-byte values  
1dbd			                                ; value, limit, step.  
1dbd			  
1dbd ef			        RST     28H             ;; FP-CALC     add step and re-store  
1dbe e0			        DEFB    $E0             ;;get-mem-0    v.  
1dbf e2			        DEFB    $E2             ;;get-mem-2    v,s.  
1dc0 0f			        DEFB    $0F             ;;addition     v+s.  
1dc1 c0			        DEFB    $C0             ;;st-mem-0     v+s.  
1dc2 02			        DEFB    $02             ;;delete       .  
1dc3 38			        DEFB    $38             ;;end-calc  
1dc4			  
1dc4 cd da 1d		        CALL    L1DDA           ; routine NEXT-LOOP tests against limit.  
1dc7 d8			        RET     C               ; return if no more iterations possible.  
1dc8			  
1dc8 2a 68 5c		        LD      HL,($5C68)      ; find start of variable contents from MEM.  
1dcb 11 0f 00		        LD      DE,$000F        ; add 3*5 to  
1dce 19			        ADD     HL,DE           ; address the looping line number  
1dcf 5e			        LD      E,(HL)          ; low byte to E  
1dd0 23			        INC     HL              ;  
1dd1 56			        LD      D,(HL)          ; high byte to D  
1dd2 23			        INC     HL              ; address looping statement  
1dd3 66			        LD      H,(HL)          ; and store in H  
1dd4 eb			        EX      DE,HL           ; swap registers  
1dd5 c3 73 1e		        JP      L1E73           ; exit via GO-TO-2 to execute another loop.  
1dd8			  
1dd8			; ---  
1dd8			  
1dd8			;; REPORT-1  
1dd8 cf			L1DD8:  RST     08H             ; ERROR-1  
1dd9 00			        DEFB    $00             ; Error Report: NEXT without FOR  
1dda			  
1dda			  
1dda			; -----------------  
1dda			; Perform NEXT loop  
1dda			; -----------------  
1dda			; This routine is called from the FOR command to test for an initial  
1dda			; iteration and from the NEXT command to test for all subsequent iterations.  
1dda			; the system variable MEM addresses the variable's contents which, in the  
1dda			; latter case, have had the step, possibly negative, added to the value.  
1dda			  
1dda			;; NEXT-LOOP  
1dda ef			L1DDA:  RST     28H             ;; FP-CALC  
1ddb e1			        DEFB    $E1             ;;get-mem-1        l.  
1ddc e0			        DEFB    $E0             ;;get-mem-0        l,v.  
1ddd e2			        DEFB    $E2             ;;get-mem-2        l,v,s.  
1dde 36			        DEFB    $36             ;;less-0           l,v,(1/0) negative step ?  
1ddf 00			        DEFB    $00             ;;jump-true        l,v.(1/0)  
1de0			  
1de0 02			        DEFB    $02             ;;to L1DE2, NEXT-1 if step negative  
1de1			  
1de1 01			        DEFB    $01             ;;exchange         v,l.  
1de2			  
1de2			;; NEXT-1  
1de2 03			L1DE2:  DEFB    $03             ;;subtract         l-v OR v-l.  
1de3 37			        DEFB    $37             ;;greater-0        (1/0)  
1de4 00			        DEFB    $00             ;;jump-true        .  
1de5			  
1de5 04			        DEFB    $04             ;;to L1DE9, NEXT-2 if no more iterations.  
1de6			  
1de6 38			        DEFB    $38             ;;end-calc         .  
1de7			  
1de7 a7			        AND     A               ; clear carry flag signalling another loop.  
1de8 c9			        RET                     ; return  
1de9			  
1de9			; ---  
1de9			  
1de9			;; NEXT-2  
1de9 38			L1DE9:  DEFB    $38             ;;end-calc         .  
1dea			  
1dea 37			        SCF                     ; set carry flag signalling looping exhausted.  
1deb c9			        RET                     ; return  
1dec			  
1dec			  
1dec			; -------------------  
1dec			; Handle READ command  
1dec			; -------------------  
1dec			; e.g. READ a, b$, c$(1000 TO 3000)  
1dec			; A list of comma-separated variables is assigned from a list of  
1dec			; comma-separated expressions.  
1dec			; As it moves along the first list, the character address CH_ADD is stored  
1dec			; in X_PTR while CH_ADD is used to read the second list.  
1dec			  
1dec			;; READ-3  
1dec e7			L1DEC:  RST     20H             ; NEXT-CHAR  
1ded			  
1ded			; -> Entry point.  
1ded			;; READ  
1ded cd 1f 1c		L1DED:  CALL    L1C1F           ; routine CLASS-01 checks variable.  
1df0 cd 30 25		        CALL    L2530           ; routine SYNTAX-Z  
1df3 28 29		        JR      Z,L1E1E         ; forward to READ-2 if checking syntax  
1df5			  
1df5			  
1df5 df			        RST     18H             ; GET-CHAR  
1df6 22 5f 5c		        LD      ($5C5F),HL      ; save character position in X_PTR.  
1df9 2a 57 5c		        LD      HL,($5C57)      ; load HL with Data Address DATADD, which is  
1dfc			                                ; the start of the program or the address  
1dfc			                                ; after the last expression that was read or  
1dfc			                                ; the address of the line number of the   
1dfc			                                ; last RESTORE command.  
1dfc 7e			        LD      A,(HL)          ; fetch character  
1dfd fe 2c		        CP      $2C             ; is it a comma ?  
1dff 28 09		        JR      Z,L1E0A         ; forward to READ-1 if so.  
1e01			  
1e01			; else all data in this statement has been read so look for next DATA token  
1e01			  
1e01 1e e4		        LD      E,$E4           ; token 'DATA'  
1e03 cd 86 1d		        CALL    L1D86           ; routine LOOK-PROG  
1e06 30 02		        JR      NC,L1E0A        ; forward to READ-1 if DATA found  
1e08			  
1e08			; else report the error.  
1e08			  
1e08			;; REPORT-E  
1e08 cf			L1E08:  RST     08H             ; ERROR-1  
1e09 0d			        DEFB    $0D             ; Error Report: Out of DATA  
1e0a			  
1e0a			;; READ-1  
1e0a cd 77 00		L1E0A:  CALL    L0077           ; routine TEMP-PTR1 advances updating CH_ADD  
1e0d			                                ; with new DATADD position.  
1e0d cd 56 1c		        CALL    L1C56           ; routine VAL-FET-1 assigns value to variable  
1e10			                                ; checking type match and adjusting CH_ADD.  
1e10			  
1e10 df			        RST     18H             ; GET-CHAR fetches adjusted character position  
1e11 22 57 5c		        LD      ($5C57),HL      ; store back in DATADD  
1e14 2a 5f 5c		        LD      HL,($5C5F)      ; fetch X_PTR  the original READ CH_ADD  
1e17 fd 36 26 00	        LD      (IY+$26),$00    ; now nullify X_PTR_hi  
1e1b cd 78 00		        CALL    L0078           ; routine TEMP-PTR2 restores READ CH_ADD  
1e1e			  
1e1e			;; READ-2  
1e1e df			L1E1E:  RST     18H             ; GET-CHAR  
1e1f fe 2c		        CP      $2C             ; is it ',' indicating more variables to read ?  
1e21 28 c9		        JR      Z,L1DEC         ; back to READ-3 if so  
1e23			  
1e23 cd ee 1b		        CALL    L1BEE           ; routine CHECK-END  
1e26 c9			        RET                     ; return from here in runtime to STMT-RET.  
1e27			  
1e27			; -------------------  
1e27			; Handle DATA command  
1e27			; -------------------  
1e27			; In runtime this 'command' is passed by but the syntax is checked when such  
1e27			; a statement is found while parsing a line.  
1e27			; e.g. DATA 1, 2, "text", score-1, a$(location, room, object), FN r(49),  
1e27			;         wages - tax, TRUE, The meaning of life  
1e27			  
1e27			;; DATA  
1e27 cd 30 25		L1E27:  CALL    L2530           ; routine SYNTAX-Z to check status  
1e2a 20 0b		        JR      NZ,L1E37        ; forward to DATA-2 if in runtime  
1e2c			  
1e2c			;; DATA-1  
1e2c cd fb 24		L1E2C:  CALL    L24FB           ; routine SCANNING to check syntax of  
1e2f			                                ; expression  
1e2f fe 2c		        CP      $2C             ; is it a comma ?  
1e31 c4 ee 1b		        CALL    NZ,L1BEE        ; routine CHECK-END checks that statement  
1e34			                                ; is complete. Will make an early exit if  
1e34			                                ; so. >>>  
1e34 e7			        RST     20H             ; NEXT-CHAR  
1e35 18 f5		        JR      L1E2C           ; back to DATA-1  
1e37			  
1e37			; ---  
1e37			  
1e37			;; DATA-2  
1e37 3e e4		L1E37:  LD      A,$E4           ; set token to 'DATA' and continue into  
1e39			                                ; the the PASS-BY routine.  
1e39			  
1e39			  
1e39			; ----------------------------------  
1e39			; Check statement for DATA or DEF FN  
1e39			; ----------------------------------  
1e39			; This routine is used to backtrack to a command token and then  
1e39			; forward to the next statement in runtime.  
1e39			  
1e39			;; PASS-BY  
1e39 47			L1E39:  LD      B,A             ; Give BC enough space to find token.  
1e3a ed b9		        CPDR                    ; Compare decrement and repeat. (Only use).  
1e3c			                                ; Work backwards till keyword is found which  
1e3c			                                ; is start of statement before any quotes.  
1e3c			                                ; HL points to location before keyword.  
1e3c 11 00 02		        LD      DE,$0200        ; count 1+1 statements, dummy value in E to  
1e3f			                                ; inhibit searching for a token.  
1e3f c3 8b 19		        JP      L198B           ; to EACH-STMT to find next statement  
1e42			  
1e42			; -----------------------------------------------------------------------  
1e42			; A General Note on Invalid Line Numbers.  
1e42			; =======================================  
1e42			; One of the revolutionary concepts of Sinclair BASIC was that it supported  
1e42			; virtual line numbers. That is the destination of a GO TO, RESTORE etc. need  
1e42			; not exist. It could be a point before or after an actual line number.  
1e42			; Zero suffices for a before but the after should logically be infinity.  
1e42			; Since the maximum actual line limit is 9999 then the system limit, 16383  
1e42			; when variables kick in, would serve fine as a virtual end point.  
1e42			; However, ironically, only the LOAD command gets it right. It will not  
1e42			; autostart a program that has been saved with a line higher than 16383.  
1e42			; All the other commands deal with the limit unsatisfactorily.  
1e42			; LIST, RUN, GO TO, GO SUB and RESTORE have problems and the latter may  
1e42			; crash the machine when supplied with an inappropriate virtual line number.  
1e42			; This is puzzling as very careful consideration must have been given to  
1e42			; this point when the new variable types were allocated their masks and also  
1e42			; when the routine NEXT-ONE was successfully re-written to reflect this.  
1e42			; An enigma.  
1e42			; -------------------------------------------------------------------------  
1e42			  
1e42			; ----------------------  
1e42			; Handle RESTORE command  
1e42			; ----------------------  
1e42			; The restore command sets the system variable for the data address to  
1e42			; point to the location before the supplied line number or first line  
1e42			; thereafter.  
1e42			; This alters the position where subsequent READ commands look for data.  
1e42			; Note. If supplied with inappropriate high numbers the system may crash  
1e42			; in the LINE-ADDR routine as it will pass the program/variables end-marker  
1e42			; and then lose control of what it is looking for - variable or line number.  
1e42			; - observation, Steven Vickers, 1984, Pitman.  
1e42			  
1e42			;; RESTORE  
1e42 cd 99 1e		L1E42:  CALL    L1E99           ; routine FIND-INT2 puts integer in BC.  
1e45			                                ; Note. B should be checked against limit $3F  
1e45			                                ; and an error generated if higher.  
1e45			  
1e45			; this entry point is used from RUN command with BC holding zero  
1e45			  
1e45			;; REST-RUN  
1e45 60			L1E45:  LD      H,B             ; transfer the line  
1e46 69			        LD      L,C             ; number to the HL register.  
1e47 cd 6e 19		        CALL    L196E           ; routine LINE-ADDR to fetch the address.  
1e4a 2b			        DEC     HL              ; point to the location before the line.  
1e4b 22 57 5c		        LD      ($5C57),HL      ; update system variable DATADD.  
1e4e c9			        RET                     ; return to STMT-RET (or RUN)  
1e4f			  
1e4f			; ------------------------  
1e4f			; Handle RANDOMIZE command  
1e4f			; ------------------------  
1e4f			; This command sets the SEED for the RND function to a fixed value.  
1e4f			; With the parameter zero, a random start point is used depending on  
1e4f			; how long the computer has been switched on.  
1e4f			  
1e4f			;; RANDOMIZE  
1e4f cd 99 1e		L1E4F:  CALL    L1E99           ; routine FIND-INT2 puts parameter in BC.  
1e52 78			        LD      A,B             ; test this  
1e53 b1			        OR      C               ; for zero.  
1e54 20 04		        JR      NZ,L1E5A        ; forward to RAND-1 if not zero.  
1e56			  
1e56 ed 4b 78 5c	        LD      BC,($5C78)      ; use the lower two bytes at FRAMES1.  
1e5a			  
1e5a			;; RAND-1  
1e5a ed 43 76 5c	L1E5A:  LD      ($5C76),BC      ; place in SEED system variable.  
1e5e c9			        RET                     ; return to STMT-RET  
1e5f			  
1e5f			; -----------------------  
1e5f			; Handle CONTINUE command  
1e5f			; -----------------------  
1e5f			; The CONTINUE command transfers the OLD (but incremented) values of  
1e5f			; line number and statement to the equivalent "NEW VALUE" system variables  
1e5f			; by using the last part of GO TO and exits indirectly to STMT-RET.  
1e5f			  
1e5f			;; CONTINUE  
1e5f 2a 6e 5c		L1E5F:  LD      HL,($5C6E)      ; fetch OLDPPC line number.  
1e62 fd 56 36		        LD      D,(IY+$36)      ; fetch OSPPC statement.  
1e65 18 0c		        JR      L1E73           ; forward to GO-TO-2  
1e67			  
1e67			; --------------------  
1e67			; Handle GO TO command  
1e67			; --------------------  
1e67			; The GO TO command routine is also called by GO SUB and RUN routines  
1e67			; to evaluate the parameters of both commands.  
1e67			; It updates the system variables used to fetch the next line/statement.  
1e67			; It is at STMT-RET that the actual change in control takes place.  
1e67			; Unlike some BASICs the line number need not exist.  
1e67			; Note. the high byte of the line number is incorrectly compared with $F0  
1e67			; instead of $3F. This leads to commands with operands greater than 32767  
1e67			; being considered as having been run from the editing area and the  
1e67			; error report 'Statement Lost' is given instead of 'OK'.  
1e67			; - Steven Vickers, 1984.  
1e67			  
1e67			;; GO-TO  
1e67 cd 99 1e		L1E67:  CALL    L1E99           ; routine FIND-INT2 puts operand in BC  
1e6a 60			        LD      H,B             ; transfer line  
1e6b 69			        LD      L,C             ; number to HL.  
1e6c 16 00		        LD      D,$00           ; set statement to 0 - first.  
1e6e 7c			        LD      A,H             ; compare high byte only  
1e6f fe f0		        CP      $F0             ; to $F0 i.e. 61439 in full.  
1e71 30 2c		        JR      NC,L1E9F        ; forward to REPORT-B if above.  
1e73			  
1e73			; This call entry point is used to update the system variables e.g. by RETURN.  
1e73			  
1e73			;; GO-TO-2  
1e73 22 42 5c		L1E73:  LD      ($5C42),HL      ; save line number in NEWPPC  
1e76 fd 72 0a		        LD      (IY+$0A),D      ; and statement in NSPPC  
1e79 c9			        RET                     ; to STMT-RET (or GO-SUB command)  
1e7a			  
1e7a			; ------------------  
1e7a			; Handle OUT command  
1e7a			; ------------------  
1e7a			; Syntax has been checked and the two comma-separated values are on the  
1e7a			; calculator stack.  
1e7a			  
1e7a			;; OUT  
1e7a cd 85 1e		L1E7A:  CALL    L1E85           ; routine TWO-PARAM fetches values  
1e7d			                                ; to BC and A.  
1e7d ed 79		        OUT     (C),A           ; perform the operation.  
1e7f c9			        RET                     ; return to STMT-RET.  
1e80			  
1e80			; -------------------  
1e80			; Handle POKE command  
1e80			; -------------------  
1e80			; This routine alters a single byte in the 64K address space.  
1e80			; Happily no check is made as to whether ROM or RAM is addressed.  
1e80			; Sinclair BASIC requires no poking of system variables.  
1e80			  
1e80			;; POKE  
1e80 cd 85 1e		L1E80:  CALL    L1E85           ; routine TWO-PARAM fetches values  
1e83			                                ; to BC and A.  
1e83 02			        LD      (BC),A          ; load memory location with A.  
1e84 c9			        RET                     ; return to STMT-RET.  
1e85			  
1e85			; ------------------------------------  
1e85			; Fetch two  parameters from calculator stack  
1e85			; ------------------------------------  
1e85			; This routine fetches a byte and word from the calculator stack  
1e85			; producing an error if either is out of range.  
1e85			  
1e85			;; TWO-PARAM  
1e85 cd d5 2d		L1E85:  CALL    L2DD5           ; routine FP-TO-A  
1e88 38 15		        JR      C,L1E9F         ; forward to REPORT-B if overflow occurred  
1e8a			  
1e8a 28 02		        JR      Z,L1E8E         ; forward to TWO-P-1 if positive  
1e8c			  
1e8c ed 44		        NEG                     ; negative numbers are made positive  
1e8e			  
1e8e			;; TWO-P-1  
1e8e f5			L1E8E:  PUSH    AF              ; save the value  
1e8f cd 99 1e		        CALL    L1E99           ; routine FIND-INT2 gets integer to BC  
1e92 f1			        POP     AF              ; restore the value  
1e93 c9			        RET                     ; return  
1e94			  
1e94			; -------------  
1e94			; Find integers  
1e94			; -------------  
1e94			; The first of these routines fetches a 8-bit integer (range 0-255) from the  
1e94			; calculator stack to the accumulator and is used for colours, streams,  
1e94			; durations and coordinates.  
1e94			; The second routine fetches 16-bit integers to the BC register pair   
1e94			; and is used to fetch command and function arguments involving line numbers  
1e94			; or memory addresses and also array subscripts and tab arguments.  
1e94			; ->  
1e94			  
1e94			;; FIND-INT1  
1e94 cd d5 2d		L1E94:  CALL    L2DD5           ; routine FP-TO-A  
1e97 18 03		        JR      L1E9C           ; forward to FIND-I-1 for common exit routine.  
1e99			  
1e99			; ---  
1e99			  
1e99			; ->  
1e99			  
1e99			;; FIND-INT2  
1e99 cd a2 2d		L1E99:  CALL    L2DA2           ; routine FP-TO-BC  
1e9c			  
1e9c			;; FIND-I-1  
1e9c 38 01		L1E9C:  JR      C,L1E9F         ; to REPORT-Bb with overflow.  
1e9e			  
1e9e c8			        RET     Z               ; return if positive.  
1e9f			  
1e9f			  
1e9f			;; REPORT-Bb  
1e9f cf			L1E9F:  RST     08H             ; ERROR-1  
1ea0 0a			        DEFB    $0A             ; Error Report: Integer out of range  
1ea1			  
1ea1			; ------------------  
1ea1			; Handle RUN command  
1ea1			; ------------------  
1ea1			; This command runs a program starting at an optional line.  
1ea1			; It performs a 'RESTORE 0' then CLEAR  
1ea1			  
1ea1			;; RUN  
1ea1 cd 67 1e		L1EA1:  CALL    L1E67           ; routine GO-TO puts line number in  
1ea4			                                ; system variables.  
1ea4 01 00 00		        LD      BC,$0000        ; prepare to set DATADD to first line.  
1ea7 cd 45 1e		        CALL    L1E45           ; routine REST-RUN does the 'restore'.  
1eaa			                                ; Note BC still holds zero.  
1eaa 18 03		        JR      L1EAF           ; forward to CLEAR-RUN to clear variables  
1eac			                                ; without disturbing RAMTOP and  
1eac			                                ; exit indirectly to STMT-RET  
1eac			  
1eac			; --------------------  
1eac			; Handle CLEAR command  
1eac			; --------------------  
1eac			; This command reclaims the space used by the variables.  
1eac			; It also clears the screen and the GO SUB stack.  
1eac			; With an integer expression, it sets the uppermost memory  
1eac			; address within the BASIC system.  
1eac			; "Contrary to the manual, CLEAR doesn't execute a RESTORE" -  
1eac			; Steven Vickers, Pitman Pocket Guide to the Spectrum, 1984.  
1eac			  
1eac			;; CLEAR  
1eac cd 99 1e		L1EAC:  CALL    L1E99           ; routine FIND-INT2 fetches to BC.  
1eaf			  
1eaf			;; CLEAR-RUN  
1eaf 78			L1EAF:  LD      A,B             ; test for  
1eb0 b1			        OR      C               ; zero.  
1eb1 20 04		        JR      NZ,L1EB7        ; skip to CLEAR-1 if not zero.  
1eb3			  
1eb3 ed 4b b2 5c	        LD      BC,($5CB2)      ; use the existing value of RAMTOP if zero.  
1eb7			  
1eb7			;; CLEAR-1  
1eb7 c5			L1EB7:  PUSH    BC              ; save ramtop value.  
1eb8			  
1eb8 ed 5b 4b 5c	        LD      DE,($5C4B)      ; fetch VARS  
1ebc 2a 59 5c		        LD      HL,($5C59)      ; fetch E_LINE  
1ebf 2b			        DEC     HL              ; adjust to point at variables end-marker.  
1ec0 cd e5 19		        CALL    L19E5           ; routine RECLAIM-1 reclaims the space used by  
1ec3			                                ; the variables.  
1ec3 cd 6b 0d		        CALL    L0D6B           ; routine CLS to clear screen.  
1ec6 2a 65 5c		        LD      HL,($5C65)      ; fetch STKEND the start of free memory.  
1ec9 11 32 00		        LD      DE,$0032        ; allow for another 50 bytes.  
1ecc 19			        ADD     HL,DE           ; add the overhead to HL.  
1ecd			  
1ecd d1			        POP     DE              ; restore the ramtop value.  
1ece ed 52		        SBC     HL,DE           ; if HL is greater than the value then jump  
1ed0 30 08		        JR      NC,L1EDA        ; forward to REPORT-M  
1ed2			                                ; 'RAMTOP no good'  
1ed2			  
1ed2 2a b4 5c		        LD      HL,($5CB4)      ; now P-RAMT ($7FFF on 16K RAM machine)  
1ed5 a7			        AND     A               ; exact this time.  
1ed6 ed 52		        SBC     HL,DE           ; new ramtop must be lower or the same.  
1ed8 30 02		        JR      NC,L1EDC        ; skip to CLEAR-2 if in actual RAM.  
1eda			  
1eda			;; REPORT-M  
1eda cf			L1EDA:  RST     08H             ; ERROR-1  
1edb 15			        DEFB    $15             ; Error Report: RAMTOP no good  
1edc			  
1edc			;; CLEAR-2  
1edc eb			L1EDC:  EX      DE,HL           ; transfer ramtop value to HL.  
1edd 22 b2 5c		        LD      ($5CB2),HL      ; update system variable RAMTOP.  
1ee0 d1			        POP     DE              ; pop the return address STMT-RET.  
1ee1 c1			        POP     BC              ; pop the Error Address.  
1ee2 36 3e		        LD      (HL),$3E        ; now put the GO SUB end-marker at RAMTOP.  
1ee4 2b			        DEC     HL              ; leave a location beneath it.  
1ee5 f9			        LD      SP,HL           ; initialize the machine stack pointer.  
1ee6 c5			        PUSH    BC              ; push the error address.  
1ee7 ed 73 3d 5c	        LD      ($5C3D),SP      ; make ERR_SP point to location.  
1eeb eb			        EX      DE,HL           ; put STMT-RET in HL.  
1eec e9			        JP      (HL)            ; and go there directly.  
1eed			  
1eed			; ---------------------  
1eed			; Handle GO SUB command  
1eed			; ---------------------  
1eed			; The GO SUB command diverts BASIC control to a new line number  
1eed			; in a very similar manner to GO TO but  
1eed			; the current line number and current statement + 1  
1eed			; are placed on the GO SUB stack as a RETURN point.  
1eed			  
1eed			;; GO-SUB  
1eed d1			L1EED:  POP     DE              ; drop the address STMT-RET  
1eee fd 66 0d		        LD      H,(IY+$0D)      ; fetch statement from SUBPPC and  
1ef1 24			        INC     H               ; increment it  
1ef2 e3			        EX      (SP),HL         ; swap - error address to HL,  
1ef3			                                ; H (statement) at top of stack,  
1ef3			                                ; L (unimportant) beneath.  
1ef3 33			        INC     SP              ; adjust to overwrite unimportant byte  
1ef4 ed 4b 45 5c	        LD      BC,($5C45)      ; fetch the current line number from PPC  
1ef8 c5			        PUSH    BC              ; and PUSH onto GO SUB stack.  
1ef9			                                ; the empty machine-stack can be rebuilt  
1ef9 e5			        PUSH    HL              ; push the error address.  
1efa ed 73 3d 5c	        LD      ($5C3D),SP      ; make system variable ERR_SP point to it.  
1efe d5			        PUSH    DE              ; push the address STMT-RET.  
1eff cd 67 1e		        CALL    L1E67           ; call routine GO-TO to update the system  
1f02			                                ; variables NEWPPC and NSPPC.  
1f02			                                ; then make an indirect exit to STMT-RET via  
1f02 01 14 00		        LD      BC,$0014        ; a 20-byte overhead memory check.  
1f05			  
1f05			; ----------------------  
1f05			; Check available memory  
1f05			; ----------------------  
1f05			; This routine is used on many occasions when extending a dynamic area  
1f05			; upwards or the GO SUB stack downwards.  
1f05			  
1f05			;; TEST-ROOM  
1f05 2a 65 5c		L1F05:  LD      HL,($5C65)      ; fetch STKEND  
1f08 09			        ADD     HL,BC           ; add the supplied test value  
1f09 38 0a		        JR      C,L1F15         ; forward to REPORT-4 if over $FFFF  
1f0b			  
1f0b eb			        EX      DE,HL           ; was less so transfer to DE  
1f0c 21 50 00		        LD      HL,$0050        ; test against another 80 bytes  
1f0f 19			        ADD     HL,DE           ; anyway  
1f10 38 03		        JR      C,L1F15         ; forward to REPORT-4 if this passes $FFFF  
1f12			  
1f12 ed 72		        SBC     HL,SP           ; if less than the machine stack pointer  
1f14 d8			        RET     C               ; then return - OK.  
1f15			  
1f15			;; REPORT-4  
1f15 2e 03		L1F15:  LD      L,$03           ; prepare 'Out of Memory'   
1f17 c3 55 00		        JP      L0055           ; jump back to ERROR-3 at $0055  
1f1a			                                ; Note. this error can't be trapped at $0008  
1f1a			  
1f1a			; ------------------------------  
1f1a			; THE 'FREE MEMORY' USER ROUTINE  
1f1a			; ------------------------------  
1f1a			; This routine is not used by the ROM but allows users to evaluate  
1f1a			; approximate free memory with PRINT 65536 - USR 7962.  
1f1a			  
1f1a			;; free-mem  
1f1a 01 00 00		L1F1A:  LD      BC,$0000        ; allow no overhead.  
1f1d			  
1f1d cd 05 1f		        CALL    L1F05           ; routine TEST-ROOM.  
1f20			  
1f20 44			        LD      B,H             ; transfer the result  
1f21 4d			        LD      C,L             ; to the BC register.  
1f22 c9			        RET                     ; the USR function returns value of BC.  
1f23			  
1f23			; --------------------  
1f23			; THE 'RETURN' COMMAND  
1f23			; --------------------  
1f23			; As with any command, there are two values on the machine stack at the time   
1f23			; it is invoked.  The machine stack is below the GOSUB stack.  Both grow   
1f23			; downwards, the machine stack by two bytes, the GOSUB stack by 3 bytes.   
1f23			; The highest location is a statement byte followed by a two-byte line number.  
1f23			  
1f23			;; RETURN  
1f23 c1			L1F23:  POP     BC              ; drop the address STMT-RET.  
1f24 e1			        POP     HL              ; now the error address.  
1f25 d1			        POP     DE              ; now a possible BASIC return line.  
1f26 7a			        LD      A,D             ; the high byte $00 - $27 is   
1f27 fe 3e		        CP      $3E             ; compared with the traditional end-marker $3E.  
1f29 28 0b		        JR      Z,L1F36         ; forward to REPORT-7 with a match.  
1f2b			                                ; 'RETURN without GOSUB'  
1f2b			  
1f2b			; It was not the end-marker so a single statement byte remains at the base of   
1f2b			; the calculator stack. It can't be popped off.  
1f2b			  
1f2b 3b			        DEC     SP              ; adjust stack pointer to create room for two   
1f2c			                                ; bytes.  
1f2c e3			        EX      (SP),HL         ; statement to H, error address to base of  
1f2d			                                ; new machine stack.  
1f2d eb			        EX      DE,HL           ; statement to D,  BASIC line number to HL.  
1f2e ed 73 3d 5c	        LD      ($5C3D),SP      ; adjust ERR_SP to point to new stack pointer  
1f32 c5			        PUSH    BC              ; now re-stack the address STMT-RET  
1f33 c3 73 1e		        JP      L1E73           ; to GO-TO-2 to update statement and line  
1f36			                                ; system variables and exit indirectly to the  
1f36			                                ; address just pushed on stack.  
1f36			  
1f36			; ---  
1f36			  
1f36			;; REPORT-7  
1f36 d5			L1F36:  PUSH    DE              ; replace the end-marker.  
1f37 e5			        PUSH    HL              ; now restore the error address  
1f38			                                ; as will be required in a few clock cycles.  
1f38			  
1f38 cf			        RST     08H             ; ERROR-1  
1f39 06			        DEFB    $06             ; Error Report: RETURN without GOSUB  
1f3a			  
1f3a			; --------------------  
1f3a			; Handle PAUSE command  
1f3a			; --------------------  
1f3a			; The pause command takes as its parameter the number of interrupts  
1f3a			; for which to wait. PAUSE 50 pauses for about a second.  
1f3a			; PAUSE 0 pauses indefinitely.  
1f3a			; Both forms can be finished by pressing a key.  
1f3a			  
1f3a			;; PAUSE  
1f3a cd 99 1e		L1F3A:  CALL    L1E99           ; routine FIND-INT2 puts value in BC  
1f3d			  
1f3d			;; PAUSE-1  
1f3d 76			L1F3D:  HALT                    ; wait for interrupt.  
1f3e 0b			        DEC     BC              ; decrease counter.  
1f3f 78			        LD      A,B             ; test if  
1f40 b1			        OR      C               ; result is zero.  
1f41 28 0c		        JR      Z,L1F4F         ; forward to PAUSE-END if so.  
1f43			  
1f43 78			        LD      A,B             ; test if  
1f44 a1			        AND     C               ; now $FFFF  
1f45 3c			        INC     A               ; that is, initially zero.  
1f46 20 01		        JR      NZ,L1F49        ; skip forward to PAUSE-2 if not.  
1f48			  
1f48 03			        INC     BC              ; restore counter to zero.  
1f49			  
1f49			;; PAUSE-2  
1f49 fd cb 01 6e	L1F49:  BIT     5,(IY+$01)      ; test FLAGS - has a new key been pressed ?  
1f4d 28 ee		        JR      Z,L1F3D         ; back to PAUSE-1 if not.  
1f4f			  
1f4f			;; PAUSE-END  
1f4f fd cb 01 ae	L1F4F:  RES     5,(IY+$01)      ; update FLAGS - signal no new key  
1f53 c9			        RET                     ; and return.  
1f54			  
1f54			; -------------------  
1f54			; Check for BREAK key  
1f54			; -------------------  
1f54			; This routine is called from COPY-LINE, when interrupts are disabled,  
1f54			; to test if BREAK (SHIFT - SPACE) is being pressed.  
1f54			; It is also called at STMT-RET after every statement.  
1f54			  
1f54			;; BREAK-KEY  
1f54 3e 7f		L1F54:  LD      A,$7F           ; Input address: $7FFE  
1f56 db fe		        IN      A,($FE)         ; read lower right keys  
1f58 1f			        RRA                     ; rotate bit 0 - SPACE  
1f59 d8			        RET     C               ; return if not reset  
1f5a			  
1f5a 3e fe		        LD      A,$FE           ; Input address: $FEFE  
1f5c db fe		        IN      A,($FE)         ; read lower left keys  
1f5e 1f			        RRA                     ; rotate bit 0 - SHIFT  
1f5f c9			        RET                     ; carry will be set if not pressed.  
1f60			                                ; return with no carry if both keys  
1f60			                                ; pressed.  
1f60			  
1f60			; ---------------------  
1f60			; Handle DEF FN command  
1f60			; ---------------------  
1f60			; e.g DEF FN r$(a$,a) = a$(a TO )  
1f60			; this 'command' is ignored in runtime but has its syntax checked  
1f60			; during line-entry.  
1f60			  
1f60			;; DEF-FN  
1f60 cd 30 25		L1F60:  CALL    L2530           ; routine SYNTAX-Z  
1f63 28 05		        JR      Z,L1F6A         ; forward to DEF-FN-1 if parsing  
1f65			  
1f65 3e ce		        LD      A,$CE           ; else load A with 'DEF FN' and  
1f67 c3 39 1e		        JP      L1E39           ; jump back to PASS-BY  
1f6a			  
1f6a			; ---  
1f6a			  
1f6a			; continue here if checking syntax.  
1f6a			  
1f6a			;; DEF-FN-1  
1f6a fd cb 01 f6	L1F6A:  SET      6,(IY+$01)     ; set FLAGS  - Assume numeric result  
1f6e cd 8d 2c		        CALL    L2C8D           ; call routine ALPHA  
1f71 30 16		        JR      NC,L1F89        ; if not then to DEF-FN-4 to jump to  
1f73			                                ; 'Nonsense in BASIC'  
1f73			  
1f73			  
1f73 e7			        RST     20H             ; NEXT-CHAR  
1f74 fe 24		        CP      $24             ; is it '$' ?  
1f76 20 05		        JR      NZ,L1F7D        ; to DEF-FN-2 if not as numeric.  
1f78			  
1f78 fd cb 01 b6	        RES     6,(IY+$01)      ; set FLAGS  - Signal string result  
1f7c			  
1f7c e7			        RST     20H             ; get NEXT-CHAR  
1f7d			  
1f7d			;; DEF-FN-2  
1f7d fe 28		L1F7D:  CP      $28             ; is it '(' ?  
1f7f 20 3c		        JR      NZ,L1FBD        ; to DEF-FN-7 'Nonsense in BASIC'  
1f81			  
1f81			  
1f81 e7			        RST     20H             ; NEXT-CHAR  
1f82 fe 29		        CP      $29             ; is it ')' ?  
1f84 28 20		        JR      Z,L1FA6         ; to DEF-FN-6 if null argument  
1f86			  
1f86			;; DEF-FN-3  
1f86 cd 8d 2c		L1F86:  CALL    L2C8D           ; routine ALPHA checks that it is the expected  
1f89			                                ; alphabetic character.  
1f89			  
1f89			;; DEF-FN-4  
1f89 d2 8a 1c		L1F89:  JP      NC,L1C8A        ; to REPORT-C  if not  
1f8c			                                ; 'Nonsense in BASIC'.  
1f8c			  
1f8c eb			        EX      DE,HL           ; save pointer in DE  
1f8d			  
1f8d e7			        RST     20H             ; NEXT-CHAR re-initializes HL from CH_ADD  
1f8e			                                ; and advances.  
1f8e fe 24		        CP      $24             ; '$' ? is it a string argument.  
1f90 20 02		        JR      NZ,L1F94        ; forward to DEF-FN-5 if not.  
1f92			  
1f92 eb			        EX      DE,HL           ; save pointer to '$' in DE  
1f93			  
1f93 e7			        RST     20H             ; NEXT-CHAR re-initializes HL and advances  
1f94			  
1f94			;; DEF-FN-5  
1f94 eb			L1F94:  EX      DE,HL           ; bring back pointer.  
1f95 01 06 00		        LD      BC,$0006        ; the function requires six hidden bytes for  
1f98			                                ; each parameter passed.  
1f98			                                ; The first byte will be $0E  
1f98			                                ; then 5-byte numeric value  
1f98			                                ; or 5-byte string pointer.  
1f98			  
1f98 cd 55 16		        CALL    L1655           ; routine MAKE-ROOM creates space in program  
1f9b			                                ; area.  
1f9b			  
1f9b 23			        INC     HL              ; adjust HL (set by LDDR)  
1f9c 23			        INC     HL              ; to point to first location.  
1f9d 36 0e		        LD      (HL),$0E        ; insert the 'hidden' marker.  
1f9f			  
1f9f			; Note. these invisible storage locations hold nothing meaningful for the  
1f9f			; moment. They will be used every time the corresponding function is  
1f9f			; evaluated in runtime.  
1f9f			; Now consider the following character fetched earlier.  
1f9f			  
1f9f fe 2c		        CP      $2C             ; is it ',' ? (more than one parameter)  
1fa1 20 03		        JR      NZ,L1FA6        ; to DEF-FN-6 if not  
1fa3			  
1fa3			  
1fa3 e7			        RST     20H             ; else NEXT-CHAR  
1fa4 18 e0		        JR      L1F86           ; and back to DEF-FN-3  
1fa6			  
1fa6			; ---  
1fa6			  
1fa6			;; DEF-FN-6  
1fa6 fe 29		L1FA6:  CP      $29             ; should close with a ')'  
1fa8 20 13		        JR      NZ,L1FBD        ; to DEF-FN-7 if not  
1faa			                                ; 'Nonsense in BASIC'  
1faa			  
1faa			  
1faa e7			        RST     20H             ; get NEXT-CHAR  
1fab fe 3d		        CP      $3D             ; is it '=' ?  
1fad 20 0e		        JR      NZ,L1FBD        ; to DEF-FN-7 if not 'Nonsense...'  
1faf			  
1faf			  
1faf e7			        RST     20H             ; address NEXT-CHAR  
1fb0 3a 3b 5c		        LD      A,($5C3B)       ; get FLAGS which has been set above  
1fb3 f5			        PUSH    AF              ; and preserve  
1fb4			  
1fb4 cd fb 24		        CALL    L24FB           ; routine SCANNING checks syntax of expression  
1fb7			                                ; and also sets flags.  
1fb7			  
1fb7 f1			        POP     AF              ; restore previous flags  
1fb8 fd ae 01		        XOR     (IY+$01)        ; xor with FLAGS - bit 6 should be same   
1fbb			                                ; therefore will be reset.  
1fbb e6 40		        AND     $40             ; isolate bit 6.  
1fbd			  
1fbd			;; DEF-FN-7  
1fbd c2 8a 1c		L1FBD:  JP      NZ,L1C8A        ; jump back to REPORT-C if the expected result   
1fc0			                                ; is not the same type.  
1fc0			                                ; 'Nonsense in BASIC'  
1fc0			  
1fc0 cd ee 1b		        CALL    L1BEE           ; routine CHECK-END will return early if  
1fc3			                                ; at end of statement and move onto next  
1fc3			                                ; else produce error report. >>>  
1fc3			  
1fc3			                                ; There will be no return to here.  
1fc3			  
1fc3			; -------------------------------  
1fc3			; Returning early from subroutine  
1fc3			; -------------------------------  
1fc3			; All routines are capable of being run in two modes - syntax checking mode  
1fc3			; and runtime mode.  This routine is called often to allow a routine to return   
1fc3			; early if checking syntax.  
1fc3			  
1fc3			;; UNSTACK-Z  
1fc3 cd 30 25		L1FC3:  CALL    L2530           ; routine SYNTAX-Z sets zero flag if syntax  
1fc6			                                ; is being checked.  
1fc6			  
1fc6 e1			        POP     HL              ; drop the return address.  
1fc7 c8			        RET      Z              ; return to previous call in chain if checking  
1fc8			                                ; syntax.  
1fc8			  
1fc8 e9			        JP      (HL)            ; jump to return address as BASIC program is  
1fc9			                                ; actually running.  
1fc9			  
1fc9			; ---------------------  
1fc9			; Handle LPRINT command  
1fc9			; ---------------------  
1fc9			; A simple form of 'PRINT #3' although it can output to 16 streams.  
1fc9			; Probably for compatibility with other BASICs particularly ZX81 BASIC.  
1fc9			; An extra UDG might have been better.  
1fc9			  
1fc9			;; LPRINT  
1fc9 3e 03		L1FC9:  LD      A,$03           ; the printer channel  
1fcb 18 02		        JR      L1FCF           ; forward to PRINT-1  
1fcd			  
1fcd			; ---------------------  
1fcd			; Handle PRINT commands  
1fcd			; ---------------------  
1fcd			; The Spectrum's main stream output command.  
1fcd			; The default stream is stream 2 which is normally the upper screen  
1fcd			; of the computer. However the stream can be altered in range 0 - 15.  
1fcd			  
1fcd			;; PRINT  
1fcd 3e 02		L1FCD:  LD      A,$02           ; the stream for the upper screen.  
1fcf			  
1fcf			; The LPRINT command joins here.  
1fcf			  
1fcf			;; PRINT-1  
1fcf cd 30 25		L1FCF:  CALL    L2530           ; routine SYNTAX-Z checks if program running  
1fd2 c4 01 16		        CALL    NZ,L1601        ; routine CHAN-OPEN if so  
1fd5 cd 4d 0d		        CALL    L0D4D           ; routine TEMPS sets temporary colours.  
1fd8 cd df 1f		        CALL    L1FDF           ; routine PRINT-2 - the actual item  
1fdb cd ee 1b		        CALL    L1BEE           ; routine CHECK-END gives error if not at end  
1fde			                                ; of statement  
1fde c9			        RET                     ; and return >>>  
1fdf			  
1fdf			; ------------------------------------  
1fdf			; this subroutine is called from above  
1fdf			; and also from INPUT.  
1fdf			  
1fdf			;; PRINT-2  
1fdf df			L1FDF:  RST     18H             ; GET-CHAR gets printable character  
1fe0 cd 45 20		        CALL    L2045           ; routine PR-END-Z checks if more printing  
1fe3 28 0d		        JR      Z,L1FF2         ; to PRINT-4 if not     e.g. just 'PRINT :'  
1fe5			  
1fe5			; This tight loop deals with combinations of positional controls and  
1fe5			; print items. An early return can be made from within the loop  
1fe5			; if the end of a print sequence is reached.  
1fe5			  
1fe5			;; PRINT-3  
1fe5 cd 4e 20		L1FE5:  CALL    L204E           ; routine PR-POSN-1 returns zero if more  
1fe8			                                ; but returns early at this point if  
1fe8			                                ; at end of statement!  
1fe8			                                ;   
1fe8 28 fb		        JR      Z,L1FE5         ; to PRINT-3 if consecutive positioners  
1fea			  
1fea cd fc 1f		        CALL    L1FFC           ; routine PR-ITEM-1 deals with strings etc.  
1fed cd 4e 20		        CALL    L204E           ; routine PR-POSN-1 for more position codes  
1ff0 28 f3		        JR      Z,L1FE5         ; loop back to PRINT-3 if so  
1ff2			  
1ff2			;; PRINT-4  
1ff2 fe 29		L1FF2:  CP      $29             ; return now if this is ')' from input-item.  
1ff4			                                ; (see INPUT.)  
1ff4 c8			        RET     Z               ; or continue and print carriage return in  
1ff5			                                ; runtime  
1ff5			  
1ff5			; ---------------------  
1ff5			; Print carriage return  
1ff5			; ---------------------  
1ff5			; This routine which continues from above prints a carriage return  
1ff5			; in run-time. It is also called once from PRINT-POSN.  
1ff5			  
1ff5			;; PRINT-CR  
1ff5 cd c3 1f		L1FF5:  CALL    L1FC3           ; routine UNSTACK-Z  
1ff8			  
1ff8 3e 0d		        LD      A,$0D           ; prepare a carriage return  
1ffa			  
1ffa d7			        RST     10H             ; PRINT-A  
1ffb c9			        RET                     ; return  
1ffc			  
1ffc			  
1ffc			; -----------  
1ffc			; Print items  
1ffc			; -----------  
1ffc			; This routine deals with print items as in  
1ffc			; PRINT AT 10,0;"The value of A is ";a  
1ffc			; It returns once a single item has been dealt with as it is part  
1ffc			; of a tight loop that considers sequences of positional and print items  
1ffc			  
1ffc			;; PR-ITEM-1  
1ffc df			L1FFC:  RST     18H             ; GET-CHAR  
1ffd fe ac		        CP      $AC             ; is character 'AT' ?  
1fff 20 0d		        JR      NZ,L200E        ; forward to PR-ITEM-2 if not.  
2001			  
2001 cd 79 1c		        CALL    L1C79           ; routine NEXT-2NUM  check for two comma   
2004			                                ; separated numbers placing them on the   
2004			                                ; calculator stack in runtime.   
2004 cd c3 1f		        CALL    L1FC3           ; routine UNSTACK-Z quits if checking syntax.  
2007			  
2007 cd 07 23		        CALL    L2307           ; routine STK-TO-BC get the numbers in B and C.  
200a 3e 16		        LD      A,$16           ; prepare the 'at' control.  
200c 18 10		        JR      L201E           ; forward to PR-AT-TAB to print the sequence.  
200e			  
200e			; ---  
200e			  
200e			;; PR-ITEM-2  
200e fe ad		L200E:  CP      $AD             ; is character 'TAB' ?  
2010 20 12		        JR      NZ,L2024        ; to PR-ITEM-3 if not  
2012			  
2012			  
2012 e7			        RST     20H             ; NEXT-CHAR to address next character  
2013 cd 82 1c		        CALL    L1C82           ; routine EXPT-1NUM  
2016 cd c3 1f		        CALL    L1FC3           ; routine UNSTACK-Z quits if checking syntax.  
2019			  
2019 cd 99 1e		        CALL    L1E99           ; routine FIND-INT2 puts integer in BC.  
201c 3e 17		        LD      A,$17           ; prepare the 'tab' control.  
201e			  
201e			;; PR-AT-TAB  
201e d7			L201E:  RST     10H             ; PRINT-A outputs the control  
201f			  
201f 79			        LD      A,C             ; first value to A  
2020 d7			        RST     10H             ; PRINT-A outputs it.  
2021			  
2021 78			        LD      A,B             ; second value  
2022 d7			        RST     10H             ; PRINT-A  
2023			  
2023 c9			        RET                     ; return - item finished >>>  
2024			  
2024			; ---  
2024			  
2024			; Now consider paper 2; #2; a$  
2024			  
2024			;; PR-ITEM-3  
2024 cd f2 21		L2024:  CALL    L21F2           ; routine CO-TEMP-3 will print any colour  
2027 d0			        RET     NC              ; items - return if success.  
2028			  
2028 cd 70 20		        CALL    L2070           ; routine STR-ALTER considers new stream  
202b d0			        RET     NC              ; return if altered.  
202c			  
202c cd fb 24		        CALL    L24FB           ; routine SCANNING now to evaluate expression  
202f cd c3 1f		        CALL    L1FC3           ; routine UNSTACK-Z if not runtime.  
2032			  
2032 fd cb 01 76	        BIT     6,(IY+$01)      ; test FLAGS  - Numeric or string result ?  
2036 cc f1 2b		        CALL    Z,L2BF1         ; routine STK-FETCH if string.  
2039			                                ; note no flags affected.  
2039 c2 e3 2d		        JP      NZ,L2DE3        ; to PRINT-FP to print if numeric >>>  
203c			  
203c			; It was a string expression - start in DE, length in BC  
203c			; Now enter a loop to print it  
203c			  
203c			;; PR-STRING  
203c 78			L203C:  LD      A,B             ; this tests if the  
203d b1			        OR      C               ; length is zero and sets flag accordingly.  
203e 0b			        DEC     BC              ; this doesn't but decrements counter.  
203f c8			        RET     Z               ; return if zero.  
2040			  
2040 1a			        LD      A,(DE)          ; fetch character.  
2041 13			        INC     DE              ; address next location.  
2042			  
2042 d7			        RST     10H             ; PRINT-A.  
2043			  
2043 18 f7		        JR      L203C           ; loop back to PR-STRING.  
2045			  
2045			; ---------------  
2045			; End of printing  
2045			; ---------------  
2045			; This subroutine returns zero if no further printing is required  
2045			; in the current statement.  
2045			; The first terminator is found in  escaped input items only,  
2045			; the others in print_items.  
2045			  
2045			;; PR-END-Z  
2045 fe 29		L2045:  CP      $29             ; is character a ')' ?  
2047 c8			        RET     Z               ; return if so -        e.g. INPUT (p$); a$  
2048			  
2048			;; PR-ST-END  
2048 fe 0d		L2048:  CP      $0D             ; is it a carriage return ?  
204a c8			        RET     Z               ; return also -         e.g. PRINT a  
204b			  
204b fe 3a		        CP      $3A             ; is character a ':' ?  
204d c9			        RET                     ; return - zero flag will be set if so.  
204e			                                ;                       e.g. PRINT a :  
204e			  
204e			; --------------  
204e			; Print position  
204e			; --------------  
204e			; This routine considers a single positional character ';', ',', '''  
204e			  
204e			;; PR-POSN-1  
204e df			L204E:  RST     18H             ; GET-CHAR  
204f fe 3b		        CP      $3B             ; is it ';' ?               
2051			                                ; i.e. print from last position.  
2051 28 14		        JR      Z,L2067         ; forward to PR-POSN-3 if so.  
2053			                                ; i.e. do nothing.  
2053			  
2053 fe 2c		        CP      $2C             ; is it ',' ?  
2055			                                ; i.e. print at next tabstop.  
2055 20 0a		        JR      NZ,L2061        ; forward to PR-POSN-2 if anything else.  
2057			  
2057 cd 30 25		        CALL    L2530           ; routine SYNTAX-Z  
205a 28 0b		        JR      Z,L2067         ; forward to PR-POSN-3 if checking syntax.  
205c			  
205c 3e 06		        LD      A,$06           ; prepare the 'comma' control character.  
205e			  
205e d7			        RST     10H             ; PRINT-A  outputs to current channel in  
205f			                                ; run-time.  
205f			  
205f 18 06		        JR      L2067           ; skip to PR-POSN-3.  
2061			  
2061			; ---  
2061			  
2061			; check for newline.  
2061			  
2061			;; PR-POSN-2  
2061 fe 27		L2061:  CP      $27             ; is character a "'" ? (newline)  
2063 c0			        RET     NZ              ; return if no match              >>>  
2064			  
2064 cd f5 1f		        CALL    L1FF5           ; routine PRINT-CR outputs a carriage return  
2067			                                ; in runtime only.  
2067			  
2067			;; PR-POSN-3  
2067 e7			L2067:  RST     20H             ; NEXT-CHAR to A.  
2068 cd 45 20		        CALL    L2045           ; routine PR-END-Z checks if at end.  
206b 20 01		        JR      NZ,L206E        ; to PR-POSN-4 if not.  
206d			  
206d c1			        POP     BC              ; drop return address if at end.  
206e			  
206e			;; PR-POSN-4  
206e bf			L206E:  CP      A               ; reset the zero flag.  
206f c9			        RET                     ; and return to loop or quit.  
2070			  
2070			; ------------  
2070			; Alter stream  
2070			; ------------  
2070			; This routine is called from PRINT ITEMS above, and also LIST as in  
2070			; LIST #15  
2070			  
2070			;; STR-ALTER  
2070 fe 23		L2070:  CP      $23             ; is character '#' ?  
2072 37			        SCF                     ; set carry flag.  
2073 c0			        RET     NZ              ; return if no match.  
2074			  
2074			  
2074 e7			        RST      20H            ; NEXT-CHAR  
2075 cd 82 1c		        CALL    L1C82           ; routine EXPT-1NUM gets stream number  
2078 a7			        AND     A               ; prepare to exit early with carry reset  
2079 cd c3 1f		        CALL    L1FC3           ; routine UNSTACK-Z exits early if parsing  
207c cd 94 1e		        CALL    L1E94           ; routine FIND-INT1 gets number off stack  
207f fe 10		        CP      $10             ; must be range 0 - 15 decimal.  
2081 d2 0e 16		        JP      NC,L160E        ; jump back to REPORT-Oa if not  
2084			                                ; 'Invalid stream'.  
2084			  
2084 cd 01 16		        CALL    L1601           ; routine CHAN-OPEN  
2087 a7			        AND     A               ; clear carry - signal item dealt with.  
2088 c9			        RET                     ; return  
2089			  
2089			; --------------------  
2089			; Handle INPUT command  
2089			; --------------------  
2089			; This command  
2089			;  
2089			  
2089			;; INPUT  
2089 cd 30 25		L2089:  CALL    L2530           ; routine SYNTAX-Z to check if in runtime.  
208c 28 08		        JR      Z,L2096         ; forward to INPUT-1 if checking syntax.  
208e			  
208e 3e 01		        LD      A,$01           ; select channel 'K' the keyboard for input.  
2090 cd 01 16		        CALL    L1601           ; routine CHAN-OPEN opens it.  
2093 cd 6e 0d		        CALL    L0D6E           ; routine CLS-LOWER clears the lower screen  
2096			                                ; and sets DF_SZ to two.  
2096			  
2096			;; INPUT-1  
2096 fd 36 02 01	L2096:  LD      (IY+$02),$01    ; update TV_FLAG - signal lower screen in use  
209a			                                ; ensuring that the correct set of system   
209a			                                ; variables are updated and that the border   
209a			                                ; colour is used.  
209a			  
209a cd c1 20		        CALL    L20C1           ; routine IN-ITEM-1 to handle the input.  
209d			  
209d cd ee 1b		        CALL    L1BEE           ; routine CHECK-END will make an early exit  
20a0			                                ; if checking syntax. >>>  
20a0			  
20a0			; keyboard input has been made and it remains to adjust the upper  
20a0			; screen in case the lower two lines have been extended upwards.  
20a0			  
20a0 ed 4b 88 5c	        LD      BC,($5C88)      ; fetch S_POSN current line/column of  
20a4			                                ; the upper screen.  
20a4 3a 6b 5c		        LD      A,($5C6B)       ; fetch DF_SZ the display file size of  
20a7			                                ; the lower screen.  
20a7 b8			        CP      B               ; test that lower screen does not overlap  
20a8 38 03		        JR      C,L20AD         ; forward to INPUT-2 if not.  
20aa			  
20aa			; the two screens overlap so adjust upper screen.  
20aa			  
20aa 0e 21		        LD      C,$21           ; set column of upper screen to leftmost.  
20ac 47			        LD      B,A             ; and line to one above lower screen.  
20ad			                                ; continue forward to update upper screen  
20ad			                                ; print position.  
20ad			  
20ad			;; INPUT-2  
20ad ed 43 88 5c	L20AD:  LD      ($5C88),BC      ; set S_POSN update upper screen line/column.  
20b1 3e 19		        LD      A,$19           ; subtract from twenty five  
20b3 90			        SUB     B               ; the new line number.  
20b4 32 8c 5c		        LD      ($5C8C),A       ; and place result in SCR_CT - scroll count.  
20b7 fd cb 02 86	        RES     0,(IY+$02)      ; update TV_FLAG - signal main screen in use.  
20bb cd d9 0d		        CALL    L0DD9           ; routine CL-SET sets the print position  
20be			                                ; system variables for the upper screen.  
20be c3 6e 0d		        JP      L0D6E           ; jump back to CLS-LOWER and make  
20c1			                                ; an indirect exit >>.  
20c1			  
20c1			; ---------------------  
20c1			; INPUT ITEM subroutine  
20c1			; ---------------------  
20c1			; This subroutine deals with the input items and print items.  
20c1			; from  the current input channel.  
20c1			; It is only called from the above INPUT routine but was obviously  
20c1			; once called from somewhere else in another context.  
20c1			  
20c1			;; IN-ITEM-1  
20c1 cd 4e 20		L20C1:  CALL    L204E           ; routine PR-POSN-1 deals with a single  
20c4			                                ; position item at each call.  
20c4 28 fb		        JR      Z,L20C1         ; back to IN-ITEM-1 until no more in a  
20c6			                                ; sequence.  
20c6			  
20c6 fe 28		        CP      $28             ; is character '(' ?  
20c8 20 0e		        JR      NZ,L20D8        ; forward to IN-ITEM-2 if not.  
20ca			  
20ca			; any variables within braces will be treated as part, or all, of the prompt  
20ca			; instead of being used as destination variables.  
20ca			  
20ca e7			        RST     20H             ; NEXT-CHAR  
20cb cd df 1f		        CALL    L1FDF           ; routine PRINT-2 to output the dynamic  
20ce			                                ; prompt.  
20ce			  
20ce df			        RST     18H             ; GET-CHAR  
20cf fe 29		        CP      $29             ; is character a matching ')' ?  
20d1 c2 8a 1c		        JP      NZ,L1C8A        ; jump back to REPORT-C if not.  
20d4			                                ; 'Nonsense in BASIC'.  
20d4			  
20d4 e7			        RST     20H             ; NEXT-CHAR  
20d5 c3 b2 21		        JP      L21B2           ; forward to IN-NEXT-2  
20d8			  
20d8			; ---  
20d8			  
20d8			;; IN-ITEM-2  
20d8 fe ca		L20D8:  CP      $CA             ; is the character the token 'LINE' ?  
20da 20 11		        JR      NZ,L20ED        ; forward to IN-ITEM-3 if not.  
20dc			  
20dc e7			        RST     20H             ; NEXT-CHAR - variable must come next.  
20dd cd 1f 1c		        CALL    L1C1F           ; routine CLASS-01 returns destination  
20e0			                                ; address of variable to be assigned.  
20e0			                                ; or generates an error if no variable  
20e0			                                ; at this position.  
20e0			  
20e0 fd cb 37 fe	        SET     7,(IY+$37)      ; update FLAGX  - signal handling INPUT LINE  
20e4 fd cb 01 76	        BIT     6,(IY+$01)      ; test FLAGS  - numeric or string result ?  
20e8 c2 8a 1c		        JP      NZ,L1C8A        ; jump back to REPORT-C if not string  
20eb			                                ; 'Nonsense in BASIC'.  
20eb			  
20eb 18 0d		        JR      L20FA           ; forward to IN-PROMPT to set up workspace.  
20ed			  
20ed			; ---  
20ed			  
20ed			; the jump was here for other variables.  
20ed			  
20ed			;; IN-ITEM-3  
20ed cd 8d 2c		L20ED:  CALL     L2C8D          ; routine ALPHA checks if character is  
20f0			                                ; a suitable variable name.  
20f0 d2 af 21		        JP      NC,L21AF        ; forward to IN-NEXT-1 if not  
20f3			  
20f3 cd 1f 1c		        CALL    L1C1F           ; routine CLASS-01 returns destination  
20f6			                                ; address of variable to be assigned.  
20f6 fd cb 37 be	        RES     7,(IY+$37)      ; update FLAGX  - signal not INPUT LINE.  
20fa			  
20fa			;; IN-PROMPT  
20fa cd 30 25		L20FA:  CALL    L2530           ; routine SYNTAX-Z  
20fd ca b2 21		        JP      Z,L21B2         ; forward to IN-NEXT-2 if checking syntax.  
2100			  
2100 cd bf 16		        CALL    L16BF           ; routine SET-WORK clears workspace.  
2103 21 71 5c		        LD      HL,$5C71        ; point to system variable FLAGX  
2106 cb b6		        RES     6,(HL)          ; signal string result.  
2108 cb ee		        SET     5,(HL)          ; signal in Input Mode for editor.  
210a 01 01 00		        LD      BC,$0001        ; initialize space required to one for  
210d			                                ; the carriage return.  
210d cb 7e		        BIT     7,(HL)          ; test FLAGX - INPUT LINE in use ?  
210f 20 0b		        JR      NZ,L211C        ; forward to IN-PR-2 if so as that is  
2111			                                ; all the space that is required.  
2111			  
2111 3a 3b 5c		        LD      A,($5C3B)       ; load accumulator from FLAGS  
2114 e6 40		        AND     $40             ; mask to test BIT 6 of FLAGS and clear  
2116			                                ; the other bits in A.  
2116			                                ; numeric result expected ?  
2116 20 02		        JR      NZ,L211A        ; forward to IN-PR-1 if so  
2118			  
2118 0e 03		        LD      C,$03           ; increase space to three bytes for the  
211a			                                ; pair of surrounding quotes.  
211a			  
211a			;; IN-PR-1  
211a b6			L211A:  OR      (HL)            ; if numeric result, set bit 6 of FLAGX.  
211b 77			        LD      (HL),A          ; and update system variable  
211c			  
211c			;; IN-PR-2  
211c f7			L211C:  RST     30H             ; BC-SPACES opens 1 or 3 bytes in workspace  
211d 36 0d		        LD      (HL),$0D        ; insert carriage return at last new location.  
211f 79			        LD      A,C             ; fetch the length, one or three.  
2120 0f			        RRCA                    ; lose bit 0.  
2121 0f			        RRCA                    ; test if quotes required.  
2122 30 05		        JR      NC,L2129        ; forward to IN-PR-3 if not.  
2124			  
2124 3e 22		        LD      A,$22           ; load the '"' character  
2126 12			        LD      (DE),A          ; place quote in first new location at DE.  
2127 2b			        DEC     HL              ; decrease HL - from carriage return.  
2128 77			        LD      (HL),A          ; and place a quote in second location.  
2129			  
2129			;; IN-PR-3  
2129 22 5b 5c		L2129:  LD      ($5C5B),HL      ; set keyboard cursor K_CUR to HL  
212c fd cb 37 7e	        BIT     7,(IY+$37)      ; test FLAGX  - is this INPUT LINE ??  
2130 20 2c		        JR      NZ,L215E        ; forward to IN-VAR-3 if so as input will  
2132			                                ; be accepted without checking its syntax.  
2132			  
2132 2a 5d 5c		        LD      HL,($5C5D)      ; fetch CH_ADD  
2135 e5			        PUSH    HL              ; and save on stack.  
2136 2a 3d 5c		        LD      HL,($5C3D)      ; fetch ERR_SP  
2139 e5			        PUSH    HL              ; and save on stack  
213a			  
213a			;; IN-VAR-1  
213a 21 3a 21		L213A:  LD      HL,L213A        ; address: IN-VAR-1 - this address  
213d e5			        PUSH    HL              ; is saved on stack to handle errors.  
213e fd cb 30 66	        BIT     4,(IY+$30)      ; test FLAGS2  - is K channel in use ?  
2142 28 04		        JR      Z,L2148         ; forward to IN-VAR-2 if not using the  
2144			                                ; keyboard for input. (??)  
2144			  
2144 ed 73 3d 5c	        LD      ($5C3D),SP      ; set ERR_SP to point to IN-VAR-1 on stack.  
2148			  
2148			;; IN-VAR-2  
2148 2a 61 5c		L2148:  LD      HL,($5C61)      ; set HL to WORKSP - start of workspace.  
214b cd a7 11		        CALL    L11A7           ; routine REMOVE-FP removes floating point  
214e			                                ; forms when looping in error condition.  
214e fd 36 00 ff	        LD      (IY+$00),$FF    ; set ERR_NR to 'OK' cancelling the error.  
2152			                                ; but X_PTR causes flashing error marker  
2152			                                ; to be displayed at each call to the editor.  
2152 cd 2c 0f		        CALL    L0F2C           ; routine EDITOR allows input to be entered  
2155			                                ; or corrected if this is second time around.  
2155			  
2155			; if we pass to next then there are no system errors  
2155			  
2155 fd cb 01 be	        RES     7,(IY+$01)      ; update FLAGS  - signal checking syntax  
2159 cd b9 21		        CALL    L21B9           ; routine IN-ASSIGN checks syntax using  
215c			                                ; the VAL-FET-2 and powerful SCANNING routines.  
215c			                                ; any syntax error and its back to IN-VAR-1.  
215c			                                ; but with the flashing error marker showing  
215c			                                ; where the error is.  
215c			                                ; Note. the syntax of string input has to be  
215c			                                ; checked as the user may have removed the  
215c			                                ; bounding quotes or escaped them as with  
215c			                                ; "hat" + "stand" for example.  
215c			; proceed if syntax passed.  
215c			  
215c 18 03		        JR      L2161           ; jump forward to IN-VAR-4  
215e			  
215e			; ---  
215e			  
215e			; the jump was to here when using INPUT LINE.  
215e			  
215e			;; IN-VAR-3  
215e cd 2c 0f		L215E:  CALL    L0F2C           ; routine EDITOR is called for input  
2161			  
2161			; when ENTER received rejoin other route but with no syntax check.  
2161			  
2161			; INPUT and INPUT LINE converge here.  
2161			  
2161			;; IN-VAR-4  
2161 fd 36 22 00	L2161:  LD      (IY+$22),$00    ; set K_CUR_hi to a low value so that the cursor  
2165			                                ; no longer appears in the input line.  
2165			  
2165 cd d6 21		        CALL    L21D6           ; routine IN-CHAN-K tests if the keyboard  
2168			                                ; is being used for input.  
2168 20 0a		        JR      NZ,L2174        ; forward to IN-VAR-5 if using another input   
216a			                                ; channel.  
216a			  
216a			; continue here if using the keyboard.  
216a			  
216a cd 1d 11		        CALL    L111D           ; routine ED-COPY overprints the edit line  
216d			                                ; to the lower screen. The only visible  
216d			                                ; affect is that the cursor disappears.  
216d			                                ; if you're inputting more than one item in  
216d			                                ; a statement then that becomes apparent.  
216d			  
216d ed 4b 82 5c	        LD      BC,($5C82)      ; fetch line and column from ECHO_E  
2171 cd d9 0d		        CALL    L0DD9           ; routine CL-SET sets S-POSNL to those  
2174			                                ; values.  
2174			  
2174			; if using another input channel rejoin here.  
2174			  
2174			;; IN-VAR-5  
2174 21 71 5c		L2174:  LD      HL,$5C71        ; point HL to FLAGX  
2177 cb ae		        RES     5,(HL)          ; signal not in input mode  
2179 cb 7e		        BIT     7,(HL)          ; is this INPUT LINE ?  
217b cb be		        RES     7,(HL)          ; cancel the bit anyway.  
217d 20 1c		        JR      NZ,L219B        ; forward to IN-VAR-6 if INPUT LINE.  
217f			  
217f e1			        POP     HL              ; drop the looping address  
2180 e1			        POP     HL              ; drop the the address of previous  
2181			                                ; error handler.  
2181 22 3d 5c		        LD      ($5C3D),HL      ; set ERR_SP to point to it.  
2184 e1			        POP     HL              ; drop original CH_ADD which points to  
2185			                                ; INPUT command in BASIC line.  
2185 22 5f 5c		        LD      ($5C5F),HL      ; save in X_PTR while input is assigned.  
2188 fd cb 01 fe	        SET     7,(IY+$01)      ; update FLAGS - Signal running program  
218c cd b9 21		        CALL    L21B9           ; routine IN-ASSIGN is called again  
218f			                                ; this time the variable will be assigned  
218f			                                ; the input value without error.  
218f			                                ; Note. the previous example now  
218f			                                ; becomes "hatstand"  
218f			  
218f 2a 5f 5c		        LD      HL,($5C5F)      ; fetch stored CH_ADD value from X_PTR.  
2192 fd 36 26 00	        LD      (IY+$26),$00    ; set X_PTR_hi so that iy is no longer relevant.  
2196 22 5d 5c		        LD      ($5C5D),HL      ; put restored value back in CH_ADD  
2199 18 17		        JR      L21B2           ; forward to IN-NEXT-2 to see if anything  
219b			                                ; more in the INPUT list.  
219b			  
219b			; ---  
219b			  
219b			; the jump was to here with INPUT LINE only  
219b			  
219b			;; IN-VAR-6  
219b 2a 63 5c		L219B:  LD      HL,($5C63)      ; STKBOT points to the end of the input.  
219e ed 5b 61 5c	        LD      DE,($5C61)      ; WORKSP points to the beginning.  
21a2 37			        SCF                     ; prepare for true subtraction.  
21a3 ed 52		        SBC     HL,DE           ; subtract to get length  
21a5 44			        LD      B,H             ; transfer it to  
21a6 4d			        LD      C,L             ; the BC register pair.  
21a7 cd b2 2a		        CALL    L2AB2           ; routine STK-STO-$ stores parameters on  
21aa			                                ; the calculator stack.  
21aa cd ff 2a		        CALL    L2AFF           ; routine LET assigns it to destination.  
21ad 18 03		        JR      L21B2           ; forward to IN-NEXT-2 as print items  
21af			                                ; not allowed with INPUT LINE.  
21af			                                ; Note. that "hat" + "stand" will, for  
21af			                                ; example, be unchanged as also would  
21af			                                ; 'PRINT "Iris was here"'.  
21af			  
21af			; ---  
21af			  
21af			; the jump was to here when ALPHA found more items while looking for  
21af			; a variable name.  
21af			  
21af			;; IN-NEXT-1  
21af cd fc 1f		L21AF:  CALL    L1FFC           ; routine PR-ITEM-1 considers further items.  
21b2			  
21b2			;; IN-NEXT-2  
21b2 cd 4e 20		L21B2:  CALL    L204E           ; routine PR-POSN-1 handles a position item.  
21b5 ca c1 20		        JP      Z,L20C1         ; jump back to IN-ITEM-1 if the zero flag  
21b8			                                ; indicates more items are present.  
21b8			  
21b8 c9			        RET                     ; return.  
21b9			  
21b9			; ---------------------------  
21b9			; INPUT ASSIGNMENT Subroutine  
21b9			; ---------------------------  
21b9			; This subroutine is called twice from the INPUT command when normal  
21b9			; keyboard input is assigned. On the first occasion syntax is checked  
21b9			; using SCANNING. The final call with the syntax flag reset is to make  
21b9			; the assignment.  
21b9			  
21b9			;; IN-ASSIGN  
21b9 2a 61 5c		L21B9:  LD      HL,($5C61)      ; fetch WORKSP start of input  
21bc 22 5d 5c		        LD      ($5C5D),HL      ; set CH_ADD to first character  
21bf			  
21bf df			        RST     18H             ; GET-CHAR ignoring leading white-space.  
21c0 fe e2		        CP      $E2             ; is it 'STOP'  
21c2 28 0c		        JR      Z,L21D0         ; forward to IN-STOP if so.  
21c4			  
21c4 3a 71 5c		        LD      A,($5C71)       ; load accumulator from FLAGX  
21c7 cd 59 1c		        CALL    L1C59           ; routine VAL-FET-2 makes assignment  
21ca			                                ; or goes through the motions if checking  
21ca			                                ; syntax. SCANNING is used.  
21ca			  
21ca df			        RST     18H             ; GET-CHAR  
21cb fe 0d		        CP      $0D             ; is it carriage return ?  
21cd c8			        RET     Z               ; return if so  
21ce			                                ; either syntax is OK  
21ce			                                ; or assignment has been made.  
21ce			  
21ce			; if another character was found then raise an error.  
21ce			; User doesn't see report but the flashing error marker  
21ce			; appears in the lower screen.  
21ce			  
21ce			;; REPORT-Cb  
21ce cf			L21CE:  RST     08H             ; ERROR-1  
21cf 0b			        DEFB    $0B             ; Error Report: Nonsense in BASIC  
21d0			  
21d0			;; IN-STOP  
21d0 cd 30 25		L21D0:  CALL    L2530           ; routine SYNTAX-Z (UNSTACK-Z?)  
21d3 c8			        RET     Z               ; return if checking syntax  
21d4			                                ; as user wouldn't see error report.  
21d4			                                ; but generate visible error report  
21d4			                                ; on second invocation.  
21d4			  
21d4			;; REPORT-H  
21d4 cf			L21D4:  RST     08H             ; ERROR-1  
21d5 10			        DEFB    $10             ; Error Report: STOP in INPUT  
21d6			  
21d6			; ------------------  
21d6			; Test for channel K  
21d6			; ------------------  
21d6			; This subroutine is called once from the keyboard  
21d6			; INPUT command to check if the input routine in  
21d6			; use is the one for the keyboard.  
21d6			  
21d6			;; IN-CHAN-K  
21d6 2a 51 5c		L21D6:  LD      HL,($5C51)      ; fetch address of current channel CURCHL  
21d9 23			        INC     HL              ;  
21da 23			        INC     HL              ; advance past  
21db 23			        INC     HL              ; input and  
21dc 23			        INC     HL              ; output streams  
21dd 7e			        LD      A,(HL)          ; fetch the channel identifier.  
21de fe 4b		        CP      $4B             ; test for 'K'  
21e0 c9			        RET                     ; return with zero set if keyboard is use.  
21e1			  
21e1			; --------------------  
21e1			; Colour Item Routines  
21e1			; --------------------  
21e1			;  
21e1			; These routines have 3 entry points -  
21e1			; 1) CO-TEMP-2 to handle a series of embedded Graphic colour items.  
21e1			; 2) CO-TEMP-3 to handle a single embedded print colour item.  
21e1			; 3) CO TEMP-4 to handle a colour command such as FLASH 1  
21e1			;  
21e1			; "Due to a bug, if you bring in a peripheral channel and later use a colour  
21e1			;  statement, colour controls will be sent to it by mistake." - Steven Vickers  
21e1			;  Pitman Pocket Guide, 1984.  
21e1			;  
21e1			; To be fair, this only applies if the last channel was other than 'K', 'S'  
21e1			; or 'P', which are all that are supported by this ROM, but if that last  
21e1			; channel was a microdrive file, network channel etc. then  
21e1			; PAPER 6; CLS will not turn the screen yellow and  
21e1			; CIRCLE INK 2; 128,88,50 will not draw a red circle.  
21e1			;  
21e1			; This bug does not apply to embedded PRINT items as it is quite permissible  
21e1			; to mix stream altering commands and colour items.  
21e1			; The fix therefore would be to ensure that CLASS-07 and CLASS-09 make  
21e1			; channel 'S' the current channel when not checking syntax.  
21e1			; -----------------------------------------------------------------  
21e1			  
21e1			;; CO-TEMP-1  
21e1 e7			L21E1:  RST     20H             ; NEXT-CHAR  
21e2			  
21e2			; -> Entry point from CLASS-09. Embedded Graphic colour items.  
21e2			; e.g. PLOT INK 2; PAPER 8; 128,88  
21e2			; Loops till all colour items output, finally addressing the coordinates.  
21e2			  
21e2			;; CO-TEMP-2  
21e2 cd f2 21		L21E2:  CALL    L21F2           ; routine CO-TEMP-3 to output colour control.  
21e5 d8			        RET     C               ; return if nothing more to output. ->  
21e6			  
21e6			  
21e6 df			        RST     18H             ; GET-CHAR  
21e7 fe 2c		        CP      $2C             ; is it ',' separator ?  
21e9 28 f6		        JR      Z,L21E1         ; back if so to CO-TEMP-1  
21eb			  
21eb fe 3b		        CP      $3B             ; is it ';' separator ?  
21ed 28 f2		        JR      Z,L21E1         ; back to CO-TEMP-1 for more.  
21ef			  
21ef c3 8a 1c		        JP      L1C8A           ; to REPORT-C (REPORT-Cb is within range)  
21f2			                                ; 'Nonsense in BASIC'  
21f2			  
21f2			; -------------------  
21f2			; CO-TEMP-3  
21f2			; -------------------  
21f2			; -> this routine evaluates and outputs a colour control and parameter.  
21f2			; It is called from above and also from PR-ITEM-3 to handle a single embedded  
21f2			; print item e.g. PRINT PAPER 6; "Hi". In the latter case, the looping for  
21f2			; multiple items is within the PR-ITEM routine.  
21f2			; It is quite permissible to send these to any stream.  
21f2			  
21f2			;; CO-TEMP-3  
21f2 fe d9		L21F2:  CP      $D9             ; is it 'INK' ?  
21f4 d8			        RET     C               ; return if less.  
21f5			  
21f5 fe df		        CP      $DF             ; compare with 'OUT'  
21f7 3f			        CCF                     ; Complement Carry Flag  
21f8 d8			        RET     C               ; return if greater than 'OVER', $DE.  
21f9			  
21f9 f5			        PUSH    AF              ; save the colour token.  
21fa			  
21fa e7			        RST     20H             ; address NEXT-CHAR  
21fb f1			        POP     AF              ; restore token and continue.  
21fc			  
21fc			; -> this entry point used by CLASS-07. e.g. the command PAPER 6.  
21fc			  
21fc			;; CO-TEMP-4  
21fc d6 c9		L21FC:  SUB     $C9             ; reduce to control character $10 (INK)  
21fe			                                ; thru $15 (OVER).  
21fe f5			        PUSH    AF              ; save control.  
21ff cd 82 1c		        CALL    L1C82           ; routine EXPT-1NUM stacks addressed  
2202			                                ; parameter on calculator stack.  
2202 f1			        POP     AF              ; restore control.  
2203 a7			        AND     A               ; clear carry  
2204			  
2204 cd c3 1f		        CALL    L1FC3           ; routine UNSTACK-Z returns if checking syntax.  
2207			  
2207 f5			        PUSH    AF              ; save again  
2208 cd 94 1e		        CALL    L1E94           ; routine FIND-INT1 fetches parameter to A.  
220b 57			        LD      D,A             ; transfer now to D  
220c f1			        POP     AF              ; restore control.  
220d			  
220d d7			        RST     10H             ; PRINT-A outputs the control to current  
220e			                                ; channel.  
220e 7a			        LD      A,D             ; transfer parameter to A.  
220f			  
220f d7			        RST     10H             ; PRINT-A outputs parameter.  
2210 c9			        RET                     ; return. ->  
2211			  
2211			; -------------------------------------------------------------------------  
2211			;  
2211			;         {fl}{br}{   paper   }{  ink    }    The temporary colour attributes  
2211			;          ___ ___ ___ ___ ___ ___ ___ ___    system variable.  
2211			; ATTR_T  |   |   |   |   |   |   |   |   |  
2211			;         |   |   |   |   |   |   |   |   |  
2211			; 23695   |___|___|___|___|___|___|___|___|  
2211			;           7   6   5   4   3   2   1   0  
2211			;  
2211			;  
2211			;         {fl}{br}{   paper   }{  ink    }    The temporary mask used for  
2211			;          ___ ___ ___ ___ ___ ___ ___ ___    transparent colours. Any bit  
2211			; MASK_T  |   |   |   |   |   |   |   |   |   that is 1 shows that the  
2211			;         |   |   |   |   |   |   |   |   |   corresponding attribute is  
2211			; 23696   |___|___|___|___|___|___|___|___|   taken not from ATTR-T but from  
2211			;           7   6   5   4   3   2   1   0     what is already on the screen.  
2211			;  
2211			;  
2211			;         {paper9 }{ ink9 }{ inv1 }{ over1}   The print flags. Even bits are  
2211			;          ___ ___ ___ ___ ___ ___ ___ ___    temporary flags. The odd bits  
2211			; P_FLAG  |   |   |   |   |   |   |   |   |   are the permanent flags.  
2211			;         | p | t | p | t | p | t | p | t |  
2211			; 23697   |___|___|___|___|___|___|___|___|  
2211			;           7   6   5   4   3   2   1   0  
2211			;  
2211			; -----------------------------------------------------------------------  
2211			  
2211			; ------------------------------------  
2211			;  The colour system variable handler.  
2211			; ------------------------------------  
2211			; This is an exit branch from PO-1-OPER, PO-2-OPER  
2211			; A holds control $10 (INK) to $15 (OVER)  
2211			; D holds parameter 0-9 for ink/paper 0,1 or 8 for bright/flash,  
2211			; 0 or 1 for over/inverse.  
2211			  
2211			;; CO-TEMP-5  
2211 d6 11		L2211:  SUB     $11             ; reduce range $FF-$04  
2213 ce 00		        ADC     A,$00           ; add in carry if INK  
2215 28 1d		        JR      Z,L2234         ; forward to CO-TEMP-7 with INK and PAPER.  
2217			  
2217 d6 02		        SUB     $02             ; reduce range $FF-$02  
2219 ce 00		        ADC     A,$00           ; add carry if FLASH  
221b 28 56		        JR      Z,L2273         ; forward to CO-TEMP-C with FLASH and BRIGHT.  
221d			  
221d fe 01		        CP      $01             ; is it 'INVERSE' ?  
221f 7a			        LD      A,D             ; fetch parameter for INVERSE/OVER  
2220 06 01		        LD      B,$01           ; prepare OVER mask setting bit 0.  
2222 20 04		        JR      NZ,L2228        ; forward to CO-TEMP-6 if OVER  
2224			  
2224 07			        RLCA                    ; shift bit 0  
2225 07			        RLCA                    ; to bit 2  
2226 06 04		        LD      B,$04           ; set bit 2 of mask for inverse.  
2228			  
2228			;; CO-TEMP-6  
2228 4f			L2228:  LD      C,A             ; save the A  
2229 7a			        LD      A,D             ; re-fetch parameter  
222a fe 02		        CP      $02             ; is it less than 2  
222c 30 16		        JR      NC,L2244        ; to REPORT-K if not 0 or 1.  
222e			                                ; 'Invalid colour'.  
222e			  
222e 79			        LD      A,C             ; restore A  
222f 21 91 5c		        LD      HL,$5C91        ; address system variable P_FLAG  
2232 18 38		        JR      L226C           ; forward to exit via routine CO-CHANGE  
2234			  
2234			; ---  
2234			  
2234			; the branch was here with INK/PAPER and carry set for INK.  
2234			  
2234			;; CO-TEMP-7  
2234 7a			L2234:  LD      A,D             ; fetch parameter  
2235 06 07		        LD      B,$07           ; set ink mask 00000111  
2237 38 05		        JR      C,L223E         ; forward to CO-TEMP-8 with INK  
2239			  
2239 07			        RLCA                    ; shift bits 0-2  
223a 07			        RLCA                    ; to  
223b 07			        RLCA                    ; bits 3-5  
223c 06 38		        LD      B,$38           ; set paper mask 00111000  
223e			  
223e			; both paper and ink rejoin here  
223e			  
223e			;; CO-TEMP-8  
223e 4f			L223E:  LD      C,A             ; value to C  
223f 7a			        LD      A,D             ; fetch parameter  
2240 fe 0a		        CP      $0A             ; is it less than 10d ?  
2242 38 02		        JR      C,L2246         ; forward to CO-TEMP-9 if so.  
2244			  
2244			; ink 10 etc. is not allowed.  
2244			  
2244			;; REPORT-K  
2244 cf			L2244:  RST     08H             ; ERROR-1  
2245 13			        DEFB    $13             ; Error Report: Invalid colour  
2246			  
2246			;; CO-TEMP-9  
2246 21 8f 5c		L2246:  LD      HL,$5C8F        ; address system variable ATTR_T initially.  
2249 fe 08		        CP      $08             ; compare with 8  
224b 38 0b		        JR      C,L2258         ; forward to CO-TEMP-B with 0-7.  
224d			  
224d 7e			        LD      A,(HL)          ; fetch temporary attribute as no change.  
224e 28 07		        JR      Z,L2257         ; forward to CO-TEMP-A with INK/PAPER 8  
2250			  
2250			; it is either ink 9 or paper 9 (contrasting)  
2250			  
2250 b0			        OR      B               ; or with mask to make white  
2251 2f			        CPL                     ; make black and change other to dark  
2252 e6 24		        AND     $24             ; 00100100  
2254 28 01		        JR      Z,L2257         ; forward to CO-TEMP-A if black and  
2256			                                ; originally light.  
2256			  
2256 78			        LD      A,B             ; else just use the mask (white)  
2257			  
2257			;; CO-TEMP-A  
2257 4f			L2257:  LD      C,A             ; save A in C  
2258			  
2258			;; CO-TEMP-B  
2258 79			L2258:  LD      A,C             ; load colour to A  
2259 cd 6c 22		        CALL    L226C           ; routine CO-CHANGE addressing ATTR-T  
225c			  
225c 3e 07		        LD      A,$07           ; put 7 in accumulator  
225e ba			        CP      D               ; compare with parameter  
225f 9f			        SBC     A,A             ; $00 if 0-7, $FF if 8  
2260 cd 6c 22		        CALL    L226C           ; routine CO-CHANGE addressing MASK-T  
2263			                                ; mask returned in A.  
2263			  
2263			; now consider P-FLAG.  
2263			  
2263 07			        RLCA                    ; 01110000 or 00001110  
2264 07			        RLCA                    ; 11100000 or 00011100  
2265 e6 50		        AND     $50             ; 01000000 or 00010000  (AND 01010000)  
2267 47			        LD      B,A             ; transfer to mask  
2268 3e 08		        LD      A,$08           ; load A with 8  
226a ba			        CP      D               ; compare with parameter  
226b 9f			        SBC     A,A             ; $FF if was 9,  $00 if 0-8  
226c			                                ; continue while addressing P-FLAG  
226c			                                ; setting bit 4 if ink 9  
226c			                                ; setting bit 6 if paper 9  
226c			  
226c			; -----------------------  
226c			; Handle change of colour  
226c			; -----------------------  
226c			; This routine addresses a system variable ATTR_T, MASK_T or P-FLAG in HL.  
226c			; colour value in A, mask in B.  
226c			  
226c			;; CO-CHANGE  
226c ae			L226C:  XOR     (HL)            ; impress bits specified  
226d a0			        AND     B               ; by mask  
226e ae			        XOR     (HL)            ; on system variable.  
226f 77			        LD      (HL),A          ; update system variable.  
2270 23			        INC     HL              ; address next location.  
2271 78			        LD      A,B             ; put current value of mask in A  
2272 c9			        RET                     ; return.  
2273			  
2273			; ---  
2273			  
2273			; the branch was here with flash and bright  
2273			  
2273			;; CO-TEMP-C  
2273 9f			L2273:  SBC     A,A             ; set zero flag for bright.  
2274 7a			        LD      A,D             ; fetch original parameter 0,1 or 8  
2275 0f			        RRCA                    ; rotate bit 0 to bit 7  
2276 06 80		        LD      B,$80           ; mask for flash 10000000  
2278 20 03		        JR      NZ,L227D        ; forward to CO-TEMP-D if flash  
227a			  
227a 0f			        RRCA                    ; rotate bit 7 to bit 6  
227b 06 40		        LD      B,$40           ; mask for bright 01000000  
227d			  
227d			;; CO-TEMP-D  
227d 4f			L227D:  LD      C,A             ; store value in C  
227e 7a			        LD      A,D             ; fetch parameter  
227f fe 08		        CP      $08             ; compare with 8  
2281 28 04		        JR      Z,L2287         ; forward to CO-TEMP-E if 8  
2283			  
2283 fe 02		        CP      $02             ; test if 0 or 1  
2285 30 bd		        JR      NC,L2244        ; back to REPORT-K if not  
2287			                                ; 'Invalid colour'  
2287			  
2287			;; CO-TEMP-E  
2287 79			L2287:  LD      A,C             ; value to A  
2288 21 8f 5c		        LD      HL,$5C8F        ; address ATTR_T  
228b cd 6c 22		        CALL    L226C           ; routine CO-CHANGE addressing ATTR_T  
228e 79			        LD      A,C             ; fetch value  
228f 0f			        RRCA                    ; for flash8/bright8 complete  
2290 0f			        RRCA                    ; rotations to put set bit in  
2291 0f			        RRCA                    ; bit 7 (flash) bit 6 (bright)  
2292 18 d8		        JR      L226C           ; back to CO-CHANGE addressing MASK_T  
2294			                                ; and indirect return.  
2294			  
2294			; ---------------------  
2294			; Handle BORDER command  
2294			; ---------------------  
2294			; Command syntax example: BORDER 7  
2294			; This command routine sets the border to one of the eight colours.  
2294			; The colours used for the lower screen are based on this.  
2294			  
2294			;; BORDER  
2294 cd 94 1e		L2294:  CALL    L1E94           ; routine FIND-INT1  
2297 fe 08		        CP      $08             ; must be in range 0 (black) to 7 (white)  
2299 30 a9		        JR      NC,L2244        ; back to REPORT-K if not  
229b			                                ; 'Invalid colour'.  
229b			  
229b d3 fe		        OUT     ($FE),A         ; outputting to port effects an immediate  
229d			                                ; change.  
229d 07			        RLCA                    ; shift the colour to  
229e 07			        RLCA                    ; the paper bits setting the  
229f 07			        RLCA                    ; ink colour black.  
22a0 cb 6f		        BIT     5,A             ; is the number light coloured ?  
22a2			                                ; i.e. in the range green to white.  
22a2 20 02		        JR      NZ,L22A6        ; skip to BORDER-1 if so  
22a4			  
22a4 ee 07		        XOR     $07             ; make the ink white.  
22a6			  
22a6			;; BORDER-1  
22a6 32 48 5c		L22A6:  LD      ($5C48),A       ; update BORDCR with new paper/ink  
22a9 c9			        RET                     ; return.  
22aa			  
22aa			; -----------------  
22aa			; Get pixel address  
22aa			; -----------------  
22aa			;  
22aa			;  
22aa			  
22aa			;; PIXEL-ADD  
22aa 3e af		L22AA:  LD      A,$AF           ; load with 175 decimal.  
22ac 90			        SUB     B               ; subtract the y value.  
22ad da f9 24		        JP      C,L24F9         ; jump forward to REPORT-Bc if greater.  
22b0			                                ; 'Integer out of range'  
22b0			  
22b0			; the high byte is derived from Y only.  
22b0			; the first 3 bits are always 010  
22b0			; the next 2 bits denote in which third of the screen the byte is.  
22b0			; the last 3 bits denote in which of the 8 scan lines within a third  
22b0			; the byte is located. There are 24 discrete values.  
22b0			  
22b0			  
22b0 47			        LD      B,A             ; the line number from top of screen to B.  
22b1 a7			        AND     A               ; clear carry (already clear)  
22b2 1f			        RRA                     ;                     0xxxxxxx  
22b3 37			        SCF                     ; set carry flag  
22b4 1f			        RRA                     ;                     10xxxxxx  
22b5 a7			        AND     A               ; clear carry flag  
22b6 1f			        RRA                     ;                     010xxxxx  
22b7			  
22b7 a8			        XOR     B               ;  
22b8 e6 f8		        AND     $F8             ; keep the top 5 bits 11111000  
22ba a8			        XOR     B               ;                     010xxbbb  
22bb 67			        LD      H,A             ; transfer high byte to H.  
22bc			  
22bc			; the low byte is derived from both X and Y.  
22bc			  
22bc 79			        LD      A,C             ; the x value 0-255.  
22bd 07			        RLCA                    ;  
22be 07			        RLCA                    ;  
22bf 07			        RLCA                    ;  
22c0 a8			        XOR     B               ; the y value  
22c1 e6 c7		        AND     $C7             ; apply mask             11000111  
22c3 a8			        XOR     B               ; restore unmasked bits  xxyyyxxx  
22c4 07			        RLCA                    ; rotate to              xyyyxxxx  
22c5 07			        RLCA                    ; required position.     yyyxxxxx  
22c6 6f			        LD      L,A             ; low byte to L.  
22c7			  
22c7			; finally form the pixel position in A.  
22c7			  
22c7 79			        LD      A,C             ; x value to A  
22c8 e6 07		        AND     $07             ; mod 8  
22ca c9			        RET                     ; return  
22cb			  
22cb			; ----------------  
22cb			; Point Subroutine  
22cb			; ----------------  
22cb			; The point subroutine is called from s-point via the scanning functions  
22cb			; table.  
22cb			  
22cb			;; POINT-SUB  
22cb cd 07 23		L22CB:  CALL    L2307           ; routine STK-TO-BC  
22ce cd aa 22		        CALL    L22AA           ; routine PIXEL-ADD finds address of pixel.  
22d1 47			        LD      B,A             ; pixel position to B, 0-7.  
22d2 04			        INC     B               ; increment to give rotation count 1-8.  
22d3 7e			        LD      A,(HL)          ; fetch byte from screen.  
22d4			  
22d4			;; POINT-LP  
22d4 07			L22D4:  RLCA                    ; rotate and loop back  
22d5 10 fd		        DJNZ    L22D4           ; to POINT-LP until pixel at right.  
22d7			  
22d7 e6 01		        AND      $01            ; test to give zero or one.  
22d9 c3 28 2d		        JP      L2D28           ; jump forward to STACK-A to save result.  
22dc			  
22dc			; -------------------  
22dc			; Handle PLOT command  
22dc			; -------------------  
22dc			; Command Syntax example: PLOT 128,88  
22dc			;  
22dc			  
22dc			;; PLOT  
22dc cd 07 23		L22DC:  CALL    L2307           ; routine STK-TO-BC  
22df cd e5 22		        CALL    L22E5           ; routine PLOT-SUB  
22e2 c3 4d 0d		        JP      L0D4D           ; to TEMPS  
22e5			  
22e5			; -------------------  
22e5			; The Plot subroutine  
22e5			; -------------------  
22e5			; A screen byte holds 8 pixels so it is necessary to rotate a mask  
22e5			; into the correct position to leave the other 7 pixels unaffected.  
22e5			; However all 64 pixels in the character cell take any embedded colour  
22e5			; items.  
22e5			; A pixel can be reset (inverse 1), toggled (over 1), or set ( with inverse  
22e5			; and over switches off). With both switches on, the byte is simply put  
22e5			; back on the screen though the colours may change.  
22e5			  
22e5			;; PLOT-SUB  
22e5 ed 43 7d 5c	L22E5:  LD      ($5C7D),BC      ; store new x/y values in COORDS  
22e9 cd aa 22		        CALL    L22AA           ; routine PIXEL-ADD gets address in HL,  
22ec			                                ; count from left 0-7 in B.  
22ec 47			        LD      B,A             ; transfer count to B.  
22ed 04			        INC     B               ; increase 1-8.  
22ee 3e fe		        LD      A,$FE           ; 11111110 in A.  
22f0			  
22f0			;; PLOT-LOOP  
22f0 0f			L22F0:  RRCA                    ; rotate mask.  
22f1 10 fd		        DJNZ    L22F0           ; to PLOT-LOOP until B circular rotations.  
22f3			  
22f3 47			        LD      B,A             ; load mask to B  
22f4 7e			        LD      A,(HL)          ; fetch screen byte to A  
22f5			  
22f5 fd 4e 57		        LD      C,(IY+$57)      ; P_FLAG to C  
22f8 cb 41		        BIT     0,C             ; is it to be OVER 1 ?  
22fa 20 01		        JR      NZ,L22FD        ; forward to PL-TST-IN if so.  
22fc			  
22fc			; was over 0  
22fc			  
22fc a0			        AND     B               ; combine with mask to blank pixel.  
22fd			  
22fd			;; PL-TST-IN  
22fd cb 51		L22FD:  BIT     2,C             ; is it inverse 1 ?  
22ff 20 02		        JR      NZ,L2303        ; to PLOT-END if so.  
2301			  
2301 a8			        XOR     B               ; switch the pixel  
2302 2f			        CPL                     ; restore other 7 bits  
2303			  
2303			;; PLOT-END  
2303 77			L2303:  LD      (HL),A          ; load byte to the screen.  
2304 c3 db 0b		        JP      L0BDB           ; exit to PO-ATTR to set colours for cell.  
2307			  
2307			; ------------------------------  
2307			; Put two numbers in BC register  
2307			; ------------------------------  
2307			;  
2307			;  
2307			  
2307			;; STK-TO-BC  
2307 cd 14 23		L2307:  CALL    L2314           ; routine STK-TO-A  
230a 47			        LD      B,A             ;  
230b c5			        PUSH    BC              ;  
230c cd 14 23		        CALL    L2314           ; routine STK-TO-A  
230f 59			        LD      E,C             ;  
2310 c1			        POP     BC              ;  
2311 51			        LD      D,C             ;  
2312 4f			        LD      C,A             ;  
2313 c9			        RET                     ;  
2314			  
2314			; -----------------------  
2314			; Put stack in A register  
2314			; -----------------------  
2314			; This routine puts the last value on the calculator stack into the accumulator  
2314			; deleting the last value.  
2314			  
2314			;; STK-TO-A  
2314 cd d5 2d		L2314:  CALL    L2DD5           ; routine FP-TO-A compresses last value into  
2317			                                ; accumulator. e.g. PI would become 3.   
2317			                                ; zero flag set if positive.  
2317 da f9 24		        JP      C,L24F9         ; jump forward to REPORT-Bc if >= 255.5.  
231a			  
231a 0e 01		        LD      C,$01           ; prepare a positive sign byte.  
231c c8			        RET     Z               ; return if FP-TO-BC indicated positive.  
231d			  
231d 0e ff		        LD      C,$FF           ; prepare negative sign byte and  
231f c9			        RET                     ; return.  
2320			  
2320			  
2320			; ---------------------  
2320			; Handle CIRCLE command  
2320			; ---------------------  
2320			;  
2320			; syntax has been partly checked using the class for draw command.  
2320			  
2320			;; CIRCLE  
2320 df			L2320:  RST     18H             ; GET-CHAR  
2321 fe 2c		        CP      $2C             ; is it required comma ?  
2323 c2 8a 1c		        JP      NZ,L1C8A        ; jump to REPORT-C if not  
2326			  
2326			  
2326 e7			        RST     20H             ; NEXT-CHAR  
2327 cd 82 1c		        CALL    L1C82           ; routine EXPT-1NUM fetches radius  
232a cd ee 1b		        CALL    L1BEE           ; routine CHECK-END will return here if  
232d			                                ; nothing follows command.  
232d			  
232d ef			        RST     28H             ;; FP-CALC  
232e 2a			        DEFB    $2A             ;;abs           ; make radius positive  
232f 3d			        DEFB    $3D             ;;re-stack      ; in full floating point form  
2330 38			        DEFB    $38             ;;end-calc  
2331			  
2331 7e			        LD      A,(HL)          ; fetch first floating point byte  
2332 fe 81		        CP      $81             ; compare to one  
2334 30 05		        JR      NC,L233B        ; forward to C-R-GRE-1 if circle radius  
2336			                                ; is greater than one.  
2336			  
2336			  
2336 ef			        RST     28H             ;; FP-CALC  
2337 02			        DEFB    $02             ;;delete        ; delete the radius from stack.  
2338 38			        DEFB    $38             ;;end-calc  
2339			  
2339 18 a1		        JR      L22DC           ; to PLOT to just plot x,y.  
233b			  
233b			; ---  
233b			  
233b			  
233b			;; C-R-GRE-1  
233b ef			L233B:  RST     28H             ;; FP-CALC      ; x, y, r  
233c a3			        DEFB    $A3             ;;stk-pi/2      ; x, y, r, pi/2.  
233d 38			        DEFB    $38             ;;end-calc  
233e			  
233e 36 83		        LD      (HL),$83        ;               ; x, y, r, 2*PI  
2340			  
2340 ef			        RST     28H             ;; FP-CALC  
2341 c5			        DEFB    $C5             ;;st-mem-5      ; store 2*PI in mem-5  
2342 02			        DEFB    $02             ;;delete        ; x, y, z.  
2343 38			        DEFB    $38             ;;end-calc  
2344			  
2344 cd 7d 24		        CALL    L247D           ; routine CD-PRMS1  
2347 c5			        PUSH    BC              ;  
2348			  
2348 ef			        RST     28H             ;; FP-CALC  
2349 31			        DEFB    $31             ;;duplicate  
234a e1			        DEFB    $E1             ;;get-mem-1  
234b 04			        DEFB    $04             ;;multiply  
234c 38			        DEFB    $38             ;;end-calc  
234d			  
234d 7e			        LD      A,(HL)          ;  
234e fe 80		        CP      $80             ;  
2350 30 08		        JR      NC,L235A        ; to C-ARC-GE1  
2352			  
2352			  
2352 ef			        RST     28H             ;; FP-CALC  
2353 02			        DEFB    $02             ;;delete  
2354 02			        DEFB    $02             ;;delete  
2355 38			        DEFB    $38             ;;end-calc  
2356			  
2356 c1			        POP     BC              ;  
2357 c3 dc 22		        JP      L22DC           ; JUMP to PLOT  
235a			  
235a			; ---  
235a			  
235a			  
235a			;; C-ARC-GE1  
235a ef			L235A:  RST     28H             ;; FP-CALC  
235b c2			        DEFB    $C2             ;;st-mem-2  
235c 01			        DEFB    $01             ;;exchange  
235d c0			        DEFB    $C0             ;;st-mem-0  
235e 02			        DEFB    $02             ;;delete  
235f 03			        DEFB    $03             ;;subtract  
2360 01			        DEFB    $01             ;;exchange  
2361 e0			        DEFB    $E0             ;;get-mem-0  
2362 0f			        DEFB    $0F             ;;addition  
2363 c0			        DEFB    $C0             ;;st-mem-0  
2364 01			        DEFB    $01             ;;exchange  
2365 31			        DEFB    $31             ;;duplicate  
2366 e0			        DEFB    $E0             ;;get-mem-0  
2367 01			        DEFB    $01             ;;exchange  
2368 31			        DEFB    $31             ;;duplicate  
2369 e0			        DEFB    $E0             ;;get-mem-0  
236a a0			        DEFB    $A0             ;;stk-zero  
236b c1			        DEFB    $C1             ;;st-mem-1  
236c 02			        DEFB    $02             ;;delete  
236d 38			        DEFB    $38             ;;end-calc  
236e			  
236e fd 34 62		        INC     (IY+$62)        ; MEM-2-1st  
2371 cd 94 1e		        CALL     L1E94          ; routine FIND-INT1  
2374 6f			        LD      L,A             ;  
2375 e5			        PUSH    HL              ;  
2376 cd 94 1e		        CALL    L1E94           ; routine FIND-INT1  
2379 e1			        POP     HL              ;  
237a 67			        LD      H,A             ;  
237b 22 7d 5c		        LD      ($5C7D),HL      ; COORDS  
237e c1			        POP     BC              ;  
237f c3 20 24		        JP      L2420           ; to DRW-STEPS  
2382			  
2382			  
2382			; -------------------  
2382			; Handle DRAW command  
2382			; -------------------  
2382			;  
2382			;  
2382			  
2382			;; DRAW  
2382 df			L2382:  RST     18H             ; GET-CHAR  
2383 fe 2c		        CP      $2C             ;  
2385 28 06		        JR      Z,L238D         ; to DR-3-PRMS  
2387			  
2387 cd ee 1b		        CALL    L1BEE           ; routine CHECK-END  
238a c3 77 24		        JP      L2477           ; to LINE-DRAW  
238d			  
238d			; ---  
238d			  
238d			;; DR-3-PRMS  
238d e7			L238D:  RST     20H             ; NEXT-CHAR  
238e cd 82 1c		        CALL    L1C82           ; routine EXPT-1NUM  
2391 cd ee 1b		        CALL    L1BEE           ; routine CHECK-END  
2394			  
2394 ef			        RST     28H             ;; FP-CALC  
2395 c5			        DEFB    $C5             ;;st-mem-5  
2396 a2			        DEFB    $A2             ;;stk-half  
2397 04			        DEFB    $04             ;;multiply  
2398 1f			        DEFB    $1F             ;;sin  
2399 31			        DEFB    $31             ;;duplicate  
239a 30			        DEFB    $30             ;;not  
239b 30			        DEFB    $30             ;;not  
239c 00			        DEFB    $00             ;;jump-true  
239d			  
239d 06			        DEFB    $06             ;;to L23A3, DR-SIN-NZ  
239e			  
239e 02			        DEFB    $02             ;;delete  
239f 38			        DEFB    $38             ;;end-calc  
23a0			  
23a0 c3 77 24		        JP      L2477           ; to LINE-DRAW  
23a3			  
23a3			; ---  
23a3			  
23a3			;; DR-SIN-NZ  
23a3 c0			L23A3:  DEFB    $C0             ;;st-mem-0  
23a4 02			        DEFB    $02             ;;delete  
23a5 c1			        DEFB    $C1             ;;st-mem-1  
23a6 02			        DEFB    $02             ;;delete  
23a7 31			        DEFB    $31             ;;duplicate  
23a8 2a			        DEFB    $2A             ;;abs  
23a9 e1			        DEFB    $E1             ;;get-mem-1  
23aa 01			        DEFB    $01             ;;exchange  
23ab e1			        DEFB    $E1             ;;get-mem-1  
23ac 2a			        DEFB    $2A             ;;abs  
23ad 0f			        DEFB    $0F             ;;addition  
23ae e0			        DEFB    $E0             ;;get-mem-0  
23af 05			        DEFB    $05             ;;division  
23b0 2a			        DEFB    $2A             ;;abs  
23b1 e0			        DEFB    $E0             ;;get-mem-0  
23b2 01			        DEFB    $01             ;;exchange  
23b3 3d			        DEFB    $3D             ;;re-stack  
23b4 38			        DEFB    $38             ;;end-calc  
23b5			  
23b5 7e			        LD      A,(HL)          ;  
23b6 fe 81		        CP      $81             ;  
23b8 30 07		        JR      NC,L23C1        ; to DR-PRMS  
23ba			  
23ba			  
23ba ef			        RST     28H             ;; FP-CALC  
23bb 02			        DEFB    $02             ;;delete  
23bc 02			        DEFB    $02             ;;delete  
23bd 38			        DEFB    $38             ;;end-calc  
23be			  
23be c3 77 24		        JP      L2477           ; to LINE-DRAW  
23c1			  
23c1			; ---  
23c1			  
23c1			;; DR-PRMS  
23c1 cd 7d 24		L23C1:  CALL    L247D           ; routine CD-PRMS1  
23c4 c5			        PUSH    BC              ;  
23c5			  
23c5 ef			        RST     28H             ;; FP-CALC  
23c6 02			        DEFB    $02             ;;delete  
23c7 e1			        DEFB    $E1             ;;get-mem-1  
23c8 01			        DEFB    $01             ;;exchange  
23c9 05			        DEFB    $05             ;;division  
23ca c1			        DEFB    $C1             ;;st-mem-1  
23cb 02			        DEFB    $02             ;;delete  
23cc 01			        DEFB    $01             ;;exchange  
23cd 31			        DEFB    $31             ;;duplicate  
23ce e1			        DEFB    $E1             ;;get-mem-1  
23cf 04			        DEFB    $04             ;;multiply  
23d0 c2			        DEFB    $C2             ;;st-mem-2  
23d1 02			        DEFB    $02             ;;delete  
23d2 01			        DEFB    $01             ;;exchange  
23d3 31			        DEFB    $31             ;;duplicate  
23d4 e1			        DEFB    $E1             ;;get-mem-1  
23d5 04			        DEFB    $04             ;;multiply  
23d6 e2			        DEFB    $E2             ;;get-mem-2  
23d7 e5			        DEFB    $E5             ;;get-mem-5  
23d8 e0			        DEFB    $E0             ;;get-mem-0  
23d9 03			        DEFB    $03             ;;subtract  
23da a2			        DEFB    $A2             ;;stk-half  
23db 04			        DEFB    $04             ;;multiply  
23dc 31			        DEFB    $31             ;;duplicate  
23dd 1f			        DEFB    $1F             ;;sin  
23de c5			        DEFB    $C5             ;;st-mem-5  
23df 02			        DEFB    $02             ;;delete  
23e0 20			        DEFB    $20             ;;cos  
23e1 c0			        DEFB    $C0             ;;st-mem-0  
23e2 02			        DEFB    $02             ;;delete  
23e3 c2			        DEFB    $C2             ;;st-mem-2  
23e4 02			        DEFB    $02             ;;delete  
23e5 c1			        DEFB    $C1             ;;st-mem-1  
23e6 e5			        DEFB    $E5             ;;get-mem-5  
23e7 04			        DEFB    $04             ;;multiply  
23e8 e0			        DEFB    $E0             ;;get-mem-0  
23e9 e2			        DEFB    $E2             ;;get-mem-2  
23ea 04			        DEFB    $04             ;;multiply  
23eb 0f			        DEFB    $0F             ;;addition  
23ec e1			        DEFB    $E1             ;;get-mem-1  
23ed 01			        DEFB    $01             ;;exchange  
23ee c1			        DEFB    $C1             ;;st-mem-1  
23ef 02			        DEFB    $02             ;;delete  
23f0 e0			        DEFB    $E0             ;;get-mem-0  
23f1 04			        DEFB    $04             ;;multiply  
23f2 e2			        DEFB    $E2             ;;get-mem-2  
23f3 e5			        DEFB    $E5             ;;get-mem-5  
23f4 04			        DEFB    $04             ;;multiply  
23f5 03			        DEFB    $03             ;;subtract  
23f6 c2			        DEFB    $C2             ;;st-mem-2  
23f7 2a			        DEFB    $2A             ;;abs  
23f8 e1			        DEFB    $E1             ;;get-mem-1  
23f9 2a			        DEFB    $2A             ;;abs  
23fa 0f			        DEFB    $0F             ;;addition  
23fb 02			        DEFB    $02             ;;delete  
23fc 38			        DEFB    $38             ;;end-calc  
23fd			  
23fd 1a			        LD      A,(DE)          ;  
23fe fe 81		        CP       $81            ;  
2400 c1			        POP     BC              ;  
2401 da 77 24		        JP      C,L2477         ; to LINE-DRAW  
2404			  
2404 c5			        PUSH    BC              ;  
2405			  
2405 ef			        RST     28H             ;; FP-CALC  
2406 01			        DEFB    $01             ;;exchange  
2407 38			        DEFB    $38             ;;end-calc  
2408			  
2408 3a 7d 5c		        LD      A,($5C7D)       ; COORDS-x  
240b cd 28 2d		        CALL    L2D28           ; routine STACK-A  
240e			  
240e ef			        RST     28H             ;; FP-CALC  
240f c0			        DEFB    $C0             ;;st-mem-0  
2410 0f			        DEFB    $0F             ;;addition  
2411 01			        DEFB    $01             ;;exchange  
2412 38			        DEFB    $38             ;;end-calc  
2413			  
2413 3a 7e 5c		        LD      A,($5C7E)       ; COORDS-y  
2416 cd 28 2d		        CALL    L2D28           ; routine STACK-A  
2419			  
2419 ef			        RST     28H             ;; FP-CALC  
241a c5			        DEFB    $C5             ;;st-mem-5  
241b 0f			        DEFB    $0F             ;;addition  
241c e0			        DEFB    $E0             ;;get-mem-0  
241d e5			        DEFB    $E5             ;;get-mem-5  
241e 38			        DEFB    $38             ;;end-calc  
241f			  
241f c1			        POP     BC              ;  
2420			  
2420			;; DRW-STEPS  
2420 05			L2420:  DEC     B               ;  
2421 28 3c		        JR      Z,L245F         ; to ARC-END  
2423			  
2423 18 14		        JR      L2439           ; to ARC-START  
2425			  
2425			; ---  
2425			  
2425			  
2425			;; ARC-LOOP  
2425 ef			L2425:  RST     28H             ;; FP-CALC  
2426 e1			        DEFB    $E1             ;;get-mem-1  
2427 31			        DEFB    $31             ;;duplicate  
2428 e3			        DEFB    $E3             ;;get-mem-3  
2429 04			        DEFB    $04             ;;multiply  
242a e2			        DEFB    $E2             ;;get-mem-2  
242b e4			        DEFB    $E4             ;;get-mem-4  
242c 04			        DEFB    $04             ;;multiply  
242d 03			        DEFB    $03             ;;subtract  
242e c1			        DEFB    $C1             ;;st-mem-1  
242f 02			        DEFB    $02             ;;delete  
2430 e4			        DEFB    $E4             ;;get-mem-4  
2431 04			        DEFB    $04             ;;multiply  
2432 e2			        DEFB    $E2             ;;get-mem-2  
2433 e3			        DEFB    $E3             ;;get-mem-3  
2434 04			        DEFB    $04             ;;multiply  
2435 0f			        DEFB    $0F             ;;addition  
2436 c2			        DEFB    $C2             ;;st-mem-2  
2437 02			        DEFB    $02             ;;delete  
2438 38			        DEFB    $38             ;;end-calc  
2439			  
2439			;; ARC-START  
2439 c5			L2439:  PUSH    BC              ;  
243a			  
243a ef			        RST     28H             ;; FP-CALC  
243b c0			        DEFB    $C0             ;;st-mem-0  
243c 02			        DEFB    $02             ;;delete  
243d e1			        DEFB    $E1             ;;get-mem-1  
243e 0f			        DEFB    $0F             ;;addition  
243f 31			        DEFB    $31             ;;duplicate  
2440 38			        DEFB    $38             ;;end-calc  
2441			  
2441 3a 7d 5c		        LD      A,($5C7D)       ; COORDS-x  
2444 cd 28 2d		        CALL    L2D28           ; routine STACK-A  
2447			  
2447 ef			        RST     28H             ;; FP-CALC  
2448 03			        DEFB    $03             ;;subtract  
2449 e0			        DEFB    $E0             ;;get-mem-0  
244a e2			        DEFB    $E2             ;;get-mem-2  
244b 0f			        DEFB    $0F             ;;addition  
244c c0			        DEFB    $C0             ;;st-mem-0  
244d 01			        DEFB    $01             ;;exchange  
244e e0			        DEFB    $E0             ;;get-mem-0  
244f 38			        DEFB    $38             ;;end-calc  
2450			  
2450 3a 7e 5c		        LD      A,($5C7E)       ; COORDS-y  
2453 cd 28 2d		        CALL    L2D28           ; routine STACK-A  
2456			  
2456 ef			        RST     28H             ;; FP-CALC  
2457 03			        DEFB    $03             ;;subtract  
2458 38			        DEFB    $38             ;;end-calc  
2459			  
2459 cd b7 24		        CALL    L24B7           ; routine DRAW-LINE  
245c c1			        POP     BC              ;  
245d 10 c6		        DJNZ    L2425           ; to ARC-LOOP  
245f			  
245f			  
245f			;; ARC-END  
245f ef			L245F:  RST     28H             ;; FP-CALC  
2460 02			        DEFB    $02             ;;delete  
2461 02			        DEFB    $02             ;;delete  
2462 01			        DEFB    $01             ;;exchange  
2463 38			        DEFB    $38             ;;end-calc  
2464			  
2464 3a 7d 5c		        LD      A,($5C7D)       ; COORDS-x  
2467 cd 28 2d		        CALL    L2D28           ; routine STACK-A  
246a			  
246a ef			        RST     28H             ;; FP-CALC  
246b 03			        DEFB    $03             ;;subtract  
246c 01			        DEFB    $01             ;;exchange  
246d 38			        DEFB    $38             ;;end-calc  
246e			  
246e 3a 7e 5c		        LD      A,($5C7E)       ; COORDS-y  
2471 cd 28 2d		        CALL    L2D28           ; routine STACK-A  
2474			  
2474 ef			        RST     28H             ;; FP-CALC  
2475 03			        DEFB    $03             ;;subtract  
2476 38			        DEFB    $38             ;;end-calc  
2477			  
2477			;; LINE-DRAW  
2477 cd b7 24		L2477:  CALL    L24B7           ; routine DRAW-LINE  
247a c3 4d 0d		        JP      L0D4D           ; to TEMPS  
247d			  
247d			  
247d			; ------------------  
247d			; Initial parameters  
247d			; ------------------  
247d			;  
247d			;  
247d			  
247d			;; CD-PRMS1  
247d ef			L247D:  RST     28H             ;; FP-CALC  
247e 31			        DEFB    $31             ;;duplicate  
247f 28			        DEFB    $28             ;;sqr  
2480 34			        DEFB    $34             ;;stk-data  
2481 32			        DEFB    $32             ;;Exponent: $82, Bytes: 1  
2482 00			        DEFB    $00             ;;(+00,+00,+00)  
2483 01			        DEFB    $01             ;;exchange  
2484 05			        DEFB    $05             ;;division  
2485 e5			        DEFB    $E5             ;;get-mem-5  
2486 01			        DEFB    $01             ;;exchange  
2487 05			        DEFB    $05             ;;division  
2488 2a			        DEFB    $2A             ;;abs  
2489 38			        DEFB    $38             ;;end-calc  
248a			  
248a cd d5 2d		        CALL    L2DD5           ; routine FP-TO-A  
248d 38 06		        JR      C,L2495         ; to USE-252  
248f			  
248f e6 fc		        AND     $FC             ;  
2491 c6 04		        ADD     A,$04           ;  
2493 30 02		        JR      NC,L2497        ; to DRAW-SAVE  
2495			  
2495			;; USE-252  
2495 3e fc		L2495:  LD      A,$FC           ;  
2497			  
2497			;; DRAW-SAVE  
2497 f5			L2497:  PUSH    AF              ;  
2498 cd 28 2d		        CALL    L2D28           ; routine STACK-A  
249b			  
249b ef			        RST     28H             ;; FP-CALC  
249c e5			        DEFB    $E5             ;;get-mem-5  
249d 01			        DEFB    $01             ;;exchange  
249e 05			        DEFB    $05             ;;division  
249f 31			        DEFB    $31             ;;duplicate  
24a0 1f			        DEFB    $1F             ;;sin  
24a1 c4			        DEFB    $C4             ;;st-mem-4  
24a2 02			        DEFB    $02             ;;delete  
24a3 31			        DEFB    $31             ;;duplicate  
24a4 a2			        DEFB    $A2             ;;stk-half  
24a5 04			        DEFB    $04             ;;multiply  
24a6 1f			        DEFB    $1F             ;;sin  
24a7 c1			        DEFB    $C1             ;;st-mem-1  
24a8 01			        DEFB    $01             ;;exchange  
24a9 c0			        DEFB    $C0             ;;st-mem-0  
24aa 02			        DEFB    $02             ;;delete  
24ab 31			        DEFB    $31             ;;duplicate  
24ac 04			        DEFB    $04             ;;multiply  
24ad 31			        DEFB    $31             ;;duplicate  
24ae 0f			        DEFB    $0F             ;;addition  
24af a1			        DEFB    $A1             ;;stk-one  
24b0 03			        DEFB    $03             ;;subtract  
24b1 1b			        DEFB    $1B             ;;negate  
24b2 c3			        DEFB    $C3             ;;st-mem-3  
24b3 02			        DEFB    $02             ;;delete  
24b4 38			        DEFB    $38             ;;end-calc  
24b5			  
24b5 c1			        POP     BC              ;  
24b6 c9			        RET                     ;  
24b7			  
24b7			; ------------  
24b7			; Line drawing  
24b7			; ------------  
24b7			;  
24b7			;  
24b7			  
24b7			;; DRAW-LINE  
24b7 cd 07 23		L24B7:  CALL    L2307           ; routine STK-TO-BC  
24ba 79			        LD      A,C             ;  
24bb b8			        CP      B               ;  
24bc 30 06		        JR      NC,L24C4        ; to DL-X-GE-Y  
24be			  
24be 69			        LD      L,C             ;  
24bf d5			        PUSH    DE              ;  
24c0 af			        XOR     A               ;  
24c1 5f			        LD      E,A             ;  
24c2 18 07		        JR      L24CB           ; to DL-LARGER  
24c4			  
24c4			; ---  
24c4			  
24c4			;; DL-X-GE-Y  
24c4 b1			L24C4:  OR      C               ;  
24c5 c8			        RET     Z               ;  
24c6			  
24c6 68			        LD      L,B             ;  
24c7 41			        LD      B,C             ;  
24c8 d5			        PUSH    DE              ;  
24c9 16 00		        LD      D,$00           ;  
24cb			  
24cb			;; DL-LARGER  
24cb 60			L24CB:  LD      H,B             ;  
24cc 78			        LD      A,B             ;  
24cd 1f			        RRA                     ;  
24ce			  
24ce			;; D-L-LOOP  
24ce 85			L24CE:  ADD     A,L             ;  
24cf 38 03		        JR      C,L24D4         ; to D-L-DIAG  
24d1			  
24d1 bc			        CP      H               ;  
24d2 38 07		        JR      C,L24DB         ; to D-L-HR-VT  
24d4			  
24d4			;; D-L-DIAG  
24d4 94			L24D4:  SUB     H               ;  
24d5 4f			        LD      C,A             ;  
24d6 d9			        EXX                     ;  
24d7 c1			        POP     BC              ;  
24d8 c5			        PUSH    BC              ;  
24d9 18 04		        JR      L24DF           ; to D-L-STEP  
24db			  
24db			; ---  
24db			  
24db			;; D-L-HR-VT  
24db 4f			L24DB:  LD      C,A             ;  
24dc d5			        PUSH    DE              ;  
24dd d9			        EXX                     ;  
24de c1			        POP     BC              ;  
24df			  
24df			;; D-L-STEP  
24df 2a 7d 5c		L24DF:  LD      HL,($5C7D)      ; COORDS  
24e2 78			        LD      A,B             ;  
24e3 84			        ADD     A,H             ;  
24e4 47			        LD      B,A             ;  
24e5 79			        LD      A,C             ;  
24e6 3c			        INC     A               ;  
24e7 85			        ADD     A,L             ;  
24e8 38 0d		        JR      C,L24F7         ; to D-L-RANGE  
24ea			  
24ea 28 0d		        JR      Z,L24F9         ; to REPORT-Bc  
24ec			  
24ec			;; D-L-PLOT  
24ec 3d			L24EC:  DEC     A               ;  
24ed 4f			        LD      C,A             ;  
24ee cd e5 22		        CALL    L22E5           ; routine PLOT-SUB  
24f1 d9			        EXX                     ;  
24f2 79			        LD      A,C             ;  
24f3 10 d9		        DJNZ    L24CE           ; to D-L-LOOP  
24f5			  
24f5 d1			        POP     DE              ;  
24f6 c9			        RET                     ;  
24f7			  
24f7			; ---  
24f7			  
24f7			;; D-L-RANGE  
24f7 28 f3		L24F7:  JR      Z,L24EC         ; to D-L-PLOT  
24f9			  
24f9			  
24f9			;; REPORT-Bc  
24f9 cf			L24F9:  RST     08H             ; ERROR-1  
24fa 0a			        DEFB    $0A             ; Error Report: Integer out of range  
24fb			  
24fb			  
24fb			  
24fb			;***********************************  
24fb			;** Part 8. EXPRESSION EVALUATION **  
24fb			;***********************************  
24fb			;  
24fb			; It is a this stage of the ROM that the Spectrum ceases altogether to be  
24fb			; just a colourful novelty. One remarkable feature is that in all previous  
24fb			; commands when the Spectrum is expecting a number or a string then an  
24fb			; expression of the same type can be substituted ad infinitum.  
24fb			; This is the routine that evaluates that expression.  
24fb			; This is what causes 2 + 2 to give the answer 4.  
24fb			; That is quite easy to understand. However you don't have to make it much  
24fb			; more complex to start a remarkable juggling act.  
24fb			; e.g. PRINT 2 * (VAL "2+2" + TAN 3)  
24fb			; In fact, provided there is enough free RAM, the Spectrum can evaluate  
24fb			; an expression of unlimited complexity.  
24fb			; Apart from a couple of minor glitches, which you can now correct, the  
24fb			; system is remarkably robust.  
24fb			  
24fb			  
24fb			; ---------------------------------  
24fb			; Scan expression or sub-expression  
24fb			; ---------------------------------  
24fb			;  
24fb			;  
24fb			  
24fb			;; SCANNING  
24fb df			L24FB:  RST     18H             ; GET-CHAR  
24fc 06 00		        LD      B,$00           ; priority marker zero is pushed on stack  
24fe			                                ; to signify end of expression when it is  
24fe			                                ; popped off again.  
24fe c5			        PUSH    BC              ; put in on stack.  
24ff			                                ; and proceed to consider the first character  
24ff			                                ; of the expression.  
24ff			  
24ff			;; S-LOOP-1  
24ff 4f			L24FF:  LD      C,A             ; store the character while a look up is done.  
2500 21 96 25		        LD      HL,L2596        ; Address: scan-func  
2503 cd dc 16		        CALL    L16DC           ; routine INDEXER is called to see if it is  
2506			                                ; part of a limited range '+', '(', 'ATTR' etc.  
2506			  
2506 79			        LD      A,C             ; fetch the character back  
2507 d2 84 26		        JP      NC,L2684        ; jump forward to S-ALPHNUM if not in primary  
250a			                                ; operators and functions to consider in the  
250a			                                ; first instance a digit or a variable and  
250a			                                ; then anything else.                >>>  
250a			  
250a 06 00		        LD      B,$00           ; but here if it was found in table so  
250c 4e			        LD      C,(HL)          ; fetch offset from table and make B zero.  
250d 09			        ADD     HL,BC           ; add the offset to position found  
250e e9			        JP      (HL)            ; and jump to the routine e.g. S-BIN  
250f			                                ; making an indirect exit from there.  
250f			  
250f			; -------------------------------------------------------------------------  
250f			; The four service subroutines for routines in the scannings function table  
250f			; -------------------------------------------------------------------------  
250f			  
250f			; PRINT """Hooray!"" he cried."  
250f			  
250f			;; S-QUOTE-S  
250f cd 74 00		L250F:  CALL    L0074           ; routine CH-ADD+1 points to next character  
2512			                                ; and fetches that character.  
2512 03			        INC     BC              ; increase length counter.  
2513 fe 0d		        CP      $0D             ; is it carriage return ?  
2515			                                ; inside a quote.  
2515 ca 8a 1c		        JP      Z,L1C8A         ; jump back to REPORT-C if so.  
2518			                                ; 'Nonsense in BASIC'.  
2518			  
2518 fe 22		        CP      $22             ; is it a quote '"' ?  
251a 20 f3		        JR      NZ,L250F        ; back to S-QUOTE-S if not for more.  
251c			  
251c cd 74 00		        CALL    L0074           ; routine CH-ADD+1  
251f fe 22		        CP      $22             ; compare with possible adjacent quote  
2521 c9			        RET                     ; return. with zero set if two together.  
2522			  
2522			; ---  
2522			  
2522			; This subroutine is used to get two coordinate expressions for the three  
2522			; functions SCREEN$, ATTR and POINT that have two fixed parameters and  
2522			; therefore require surrounding braces.  
2522			  
2522			;; S-2-COORD  
2522 e7			L2522:  RST     20H             ; NEXT-CHAR  
2523 fe 28		        CP      $28             ; is it the opening '(' ?  
2525 20 06		        JR      NZ,L252D        ; forward to S-RPORT-C if not  
2527			                                ; 'Nonsense in BASIC'.  
2527			  
2527 cd 79 1c		        CALL    L1C79           ; routine NEXT-2NUM gets two comma-separated  
252a			                                ; numeric expressions. Note. this could cause  
252a			                                ; many more recursive calls to SCANNING but  
252a			                                ; the parent function will be evaluated fully  
252a			                                ; before rejoining the main juggling act.  
252a			  
252a df			        RST     18H             ; GET-CHAR  
252b fe 29		        CP      $29             ; is it the closing ')' ?  
252d			  
252d			;; S-RPORT-C  
252d c2 8a 1c		L252D:  JP      NZ,L1C8A        ; jump back to REPORT-C if not.  
2530			                                ; 'Nonsense in BASIC'.  
2530			  
2530			; ------------  
2530			; Check syntax  
2530			; ------------  
2530			; This routine is called on a number of occasions to check if syntax is being  
2530			; checked or if the program is being run. To test the flag inline would use  
2530			; four bytes of code, but a call instruction only uses 3 bytes of code.  
2530			  
2530			;; SYNTAX-Z  
2530 fd cb 01 7e	L2530:  BIT     7,(IY+$01)      ; test FLAGS  - checking syntax only ?  
2534 c9			        RET                     ; return.  
2535			  
2535			; ----------------  
2535			; Scanning SCREEN$  
2535			; ----------------  
2535			; This function returns the code of a bit-mapped character at screen  
2535			; position at line C, column B. It is unable to detect the mosaic characters  
2535			; which are not bit-mapped but detects the ASCII 32 - 127 range.  
2535			; The bit-mapped UDGs are ignored which is curious as it requires only a  
2535			; few extra bytes of code. As usual, anything to do with CHARS is weird.  
2535			; If no match is found a null string is returned.  
2535			; No actual check on ranges is performed - that's up to the BASIC programmer.  
2535			; No real harm can come from SCREEN$(255,255) although the BASIC manual  
2535			; says that invalid values will be trapped.  
2535			; Interestingly, in the Pitman pocket guide, 1984, Vickers says that the  
2535			; range checking will be performed.   
2535			  
2535			;; S-SCRN$-S  
2535 cd 07 23		L2535:  CALL    L2307           ; routine STK-TO-BC.  
2538 2a 36 5c		        LD      HL,($5C36)      ; fetch address of CHARS.  
253b 11 00 01		        LD      DE,$0100        ; fetch offset to chr$ 32  
253e 19			        ADD     HL,DE           ; and find start of bitmaps.  
253f			                                ; Note. not inc h. ??  
253f 79			        LD      A,C             ; transfer line to A.  
2540 0f			        RRCA                    ; multiply  
2541 0f			        RRCA                    ; by  
2542 0f			        RRCA                    ; thirty-two.  
2543 e6 e0		        AND     $E0             ; and with 11100000  
2545 a8			        XOR     B               ; combine with column $00 - $1F  
2546 5f			        LD      E,A             ; to give the low byte of top line  
2547 79			        LD      A,C             ; column to A range 00000000 to 00011111  
2548 e6 18		        AND     $18             ; and with 00011000  
254a ee 40		        XOR     $40             ; xor with 01000000 (high byte screen start)  
254c 57			        LD      D,A             ; register DE now holds start address of cell.  
254d 06 60		        LD      B,$60           ; there are 96 characters in ASCII set.  
254f			  
254f			;; S-SCRN-LP  
254f c5			L254F:  PUSH    BC              ; save count  
2550 d5			        PUSH    DE              ; save screen start address  
2551 e5			        PUSH    HL              ; save bitmap start  
2552 1a			        LD      A,(DE)          ; first byte of screen to A  
2553 ae			        XOR     (HL)            ; xor with corresponding character byte  
2554 28 04		        JR      Z,L255A         ; forward to S-SC-MTCH if they match  
2556			                                ; if inverse result would be $FF  
2556			                                ; if any other then mismatch  
2556			  
2556 3c			        INC     A               ; set to $00 if inverse  
2557 20 1a		        JR      NZ,L2573        ; forward to S-SCR-NXT if a mismatch  
2559			  
2559 3d			        DEC     A               ; restore $FF  
255a			  
255a			; a match has been found so seven more to test.  
255a			  
255a			;; S-SC-MTCH  
255a 4f			L255A:  LD      C,A             ; load C with inverse mask $00 or $FF  
255b 06 07		        LD      B,$07           ; count seven more bytes  
255d			  
255d			;; S-SC-ROWS  
255d 14			L255D:  INC     D               ; increment screen address.  
255e 23			        INC     HL              ; increment bitmap address.  
255f 1a			        LD      A,(DE)          ; byte to A  
2560 ae			        XOR     (HL)            ; will give $00 or $FF (inverse)  
2561 a9			        XOR     C               ; xor with inverse mask  
2562 20 0f		        JR      NZ,L2573        ; forward to S-SCR-NXT if no match.  
2564			  
2564 10 f7		        DJNZ    L255D           ; back to S-SC-ROWS until all eight matched.  
2566			  
2566			; continue if a match of all eight bytes was found  
2566			  
2566 c1			        POP     BC              ; discard the  
2567 c1			        POP     BC              ; saved  
2568 c1			        POP     BC              ; pointers  
2569 3e 80		        LD      A,$80           ; the endpoint of character set  
256b 90			        SUB     B               ; subtract the counter  
256c			                                ; to give the code 32-127  
256c 01 01 00		        LD      BC,$0001        ; make one space in workspace.  
256f			  
256f f7			        RST     30H             ; BC-SPACES creates the space sliding  
2570			                                ; the calculator stack upwards.  
2570 12			        LD      (DE),A          ; start is addressed by DE, so insert code  
2571 18 0a		        JR      L257D           ; forward to S-SCR-STO  
2573			  
2573			; ---  
2573			  
2573			; the jump was here if no match and more bitmaps to test.  
2573			  
2573			;; S-SCR-NXT  
2573 e1			L2573:  POP     HL              ; restore the last bitmap start  
2574 11 08 00		        LD      DE,$0008        ; and prepare to add 8.  
2577 19			        ADD     HL,DE           ; now addresses next character bitmap.  
2578 d1			        POP     DE              ; restore screen address  
2579 c1			        POP     BC              ; and character counter in B  
257a 10 d3		        DJNZ    L254F           ; back to S-SCRN-LP if more characters.  
257c			  
257c 48			        LD      C,B             ; B is now zero, so BC now zero.  
257d			  
257d			;; S-SCR-STO  
257d c3 b2 2a		L257D:  JP      L2AB2           ; to STK-STO-$ to store the string in  
2580			                                ; workspace or a string with zero length.  
2580			                                ; (value of DE doesn't matter in last case)  
2580			  
2580			; Note. this exit seems correct but the general-purpose routine S-STRING  
2580			; that calls this one will also stack any of its string results so this  
2580			; leads to a double storing of the result in this case.  
2580			; The instruction at L257D should just be a RET.  
2580			; credit Stephen Kelly and others, 1982.  
2580			  
2580			; -------------  
2580			; Scanning ATTR  
2580			; -------------  
2580			; This function subroutine returns the attributes of a screen location -  
2580			; a numeric result.  
2580			; Again it's up to the BASIC programmer to supply valid values of line/column.  
2580			  
2580			;; S-ATTR-S  
2580 cd 07 23		L2580:  CALL    L2307           ; routine STK-TO-BC fetches line to C,  
2583			                                ; and column to B.  
2583 79			        LD      A,C             ; line to A $00 - $17   (max 00010111)  
2584 0f			        RRCA                    ; rotate  
2585 0f			        RRCA                    ; bits  
2586 0f			        RRCA                    ; left.  
2587 4f			        LD      C,A             ; store in C as an intermediate value.  
2588			  
2588 e6 e0		        AND     $E0             ; pick up bits 11100000 ( was 00011100 )  
258a a8			        XOR     B               ; combine with column $00 - $1F  
258b 6f			        LD      L,A             ; low byte now correct.  
258c			  
258c 79			        LD      A,C             ; bring back intermediate result from C  
258d e6 03		        AND     $03             ; mask to give correct third of  
258f			                                ; screen $00 - $02  
258f ee 58		        XOR     $58             ; combine with base address.  
2591 67			        LD      H,A             ; high byte correct.  
2592 7e			        LD      A,(HL)          ; pick up the colour attribute.  
2593 c3 28 2d		        JP      L2D28           ; forward to STACK-A to store result  
2596			                                ; and make an indirect exit.  
2596			  
2596			; -----------------------  
2596			; Scanning function table  
2596			; -----------------------  
2596			; This table is used by INDEXER routine to find the offsets to  
2596			; four operators and eight functions. e.g. $A8 is the token 'FN'.  
2596			; This table is used in the first instance for the first character of an  
2596			; expression or by a recursive call to SCANNING for the first character of  
2596			; any sub-expression. It eliminates functions that have no argument or  
2596			; functions that can have more than one argument and therefore require  
2596			; braces. By eliminating and dealing with these now it can later take a  
2596			; simplistic approach to all other functions and assume that they have  
2596			; one argument.  
2596			; Similarly by eliminating BIN and '.' now it is later able to assume that  
2596			; all numbers begin with a digit and that the presence of a number or  
2596			; variable can be detected by a call to ALPHANUM.  
2596			; By default all expressions are positive and the spurious '+' is eliminated  
2596			; now as in print +2. This should not be confused with the operator '+'.  
2596			; Note. this does allow a degree of nonsense to be accepted as in  
2596			; PRINT +"3 is the greatest.".  
2596			; An acquired programming skill is the ability to include brackets where  
2596			; they are not necessary.  
2596			; A bracket at the start of a sub-expression may be spurious or necessary  
2596			; to denote that the contained expression is to be evaluated as an entity.  
2596			; In either case this is dealt with by recursive calls to SCANNING.  
2596			; An expression that begins with a quote requires special treatment.  
2596			  
2596			;; scan-func  
2596 22 1c		L2596:  DEFB    $22, L25B3-$-1  ; $1C offset to S-QUOTE  
2598 .. 4f		        DEFB    '(', L25E8-$-1  ; $4F offset to S-BRACKET  
259a .. f2		        DEFB    '.', L268D-$-1  ; $F2 offset to S-DECIMAL  
259c .. 12		        DEFB    '+', L25AF-$-1  ; $12 offset to S-U-PLUS  
259e			  
259e a8 56		        DEFB    $A8, L25F5-$-1  ; $56 offset to S-FN  
25a0 a5 57		        DEFB    $A5, L25F8-$-1  ; $57 offset to S-RND  
25a2 a7 84		        DEFB    $A7, L2627-$-1  ; $84 offset to S-PI  
25a4 a6 8f		        DEFB    $A6, L2634-$-1  ; $8F offset to S-INKEY$  
25a6 c4 e6		        DEFB    $C4, L268D-$-1  ; $E6 offset to S-BIN  
25a8 aa bf		        DEFB    $AA, L2668-$-1  ; $BF offset to S-SCREEN$  
25aa ab c7		        DEFB    $AB, L2672-$-1  ; $C7 offset to S-ATTR  
25ac a9 ce		        DEFB    $A9, L267B-$-1  ; $CE offset to S-POINT  
25ae			  
25ae 00			        DEFB    $00             ; zero end marker  
25af			  
25af			; --------------------------  
25af			; Scanning function routines  
25af			; --------------------------  
25af			; These are the 11 subroutines accessed by the above table.  
25af			; S-BIN and S-DECIMAL are the same  
25af			; The 1-byte offset limits their location to within 255 bytes of their  
25af			; entry in the table.  
25af			  
25af			; ->  
25af			;; S-U-PLUS  
25af e7			L25AF:  RST     20H             ; NEXT-CHAR just ignore  
25b0 c3 ff 24		        JP      L24FF           ; to S-LOOP-1  
25b3			  
25b3			; ---  
25b3			  
25b3			; ->  
25b3			;; S-QUOTE  
25b3 df			L25B3:  RST     18H             ; GET-CHAR  
25b4 23			        INC     HL              ; address next character (first in quotes)  
25b5 e5			        PUSH    HL              ; save start of quoted text.  
25b6 01 00 00		        LD      BC,$0000        ; initialize length of string to zero.  
25b9 cd 0f 25		        CALL    L250F           ; routine S-QUOTE-S  
25bc 20 1b		        JR      NZ,L25D9        ; forward to S-Q-PRMS if  
25be			  
25be			;; S-Q-AGAIN  
25be cd 0f 25		L25BE:  CALL    L250F           ; routine S-QUOTE-S copies string until a  
25c1			                                ; quote is encountered  
25c1 28 fb		        JR      Z,L25BE         ; back to S-Q-AGAIN if two quotes WERE  
25c3			                                ; together.  
25c3			  
25c3			; but if just an isolated quote then that terminates the string.  
25c3			  
25c3 cd 30 25		        CALL    L2530           ; routine SYNTAX-Z  
25c6 28 11		        JR      Z,L25D9         ; forward to S-Q-PRMS if checking syntax.  
25c8			  
25c8			  
25c8 f7			        RST     30H             ; BC-SPACES creates the space for true  
25c9			                                ; copy of string in workspace.  
25c9 e1			        POP     HL              ; re-fetch start of quoted text.  
25ca d5			        PUSH    DE              ; save start in workspace.  
25cb			  
25cb			;; S-Q-COPY  
25cb 7e			L25CB:  LD      A,(HL)          ; fetch a character from source.  
25cc 23			        INC     HL              ; advance source address.  
25cd 12			        LD      (DE),A          ; place in destination.  
25ce 13			        INC     DE              ; advance destination address.  
25cf fe 22		        CP      $22             ; was it a '"' just copied ?  
25d1 20 f8		        JR      NZ,L25CB        ; back to S-Q-COPY to copy more if not  
25d3			  
25d3 7e			        LD      A,(HL)          ; fetch adjacent character from source.  
25d4 23			        INC     HL              ; advance source address.  
25d5 fe 22		        CP      $22             ; is this '"' ? - i.e. two quotes together ?  
25d7 28 f2		        JR      Z,L25CB         ; to S-Q-COPY if so including just one of the  
25d9			                                ; pair of quotes.  
25d9			  
25d9			; proceed when terminating quote encountered.  
25d9			  
25d9			;; S-Q-PRMS  
25d9 0b			L25D9:  DEC     BC              ; decrease count by 1.  
25da d1			        POP     DE              ; restore start of string in workspace.  
25db			  
25db			;; S-STRING  
25db 21 3b 5c		L25DB:  LD      HL,$5C3B        ; Address FLAGS system variable.  
25de cb b6		        RES     6,(HL)          ; signal string result.  
25e0 cb 7e		        BIT     7,(HL)          ; is syntax being checked.  
25e2 c4 b2 2a		        CALL    NZ,L2AB2        ; routine STK-STO-$ is called in runtime.  
25e5 c3 12 27		        JP      L2712           ; jump forward to S-CONT-2          ===>  
25e8			  
25e8			; ---  
25e8			  
25e8			; ->  
25e8			;; S-BRACKET  
25e8 e7			L25E8:  RST     20H             ; NEXT-CHAR  
25e9 cd fb 24		        CALL    L24FB           ; routine SCANNING is called recursively.  
25ec fe 29		        CP      $29             ; is it the closing ')' ?  
25ee c2 8a 1c		        JP      NZ,L1C8A        ; jump back to REPORT-C if not  
25f1			                                ; 'Nonsense in BASIC'  
25f1			  
25f1 e7			        RST     20H             ; NEXT-CHAR  
25f2 c3 12 27		        JP      L2712           ; jump forward to S-CONT-2          ===>  
25f5			  
25f5			; ---  
25f5			  
25f5			; ->  
25f5			;; S-FN  
25f5 c3 bd 27		L25F5:  JP      L27BD           ; jump forward to S-FN-SBRN.  
25f8			  
25f8			; ---  
25f8			  
25f8			; ->  
25f8			;; S-RND  
25f8 cd 30 25		L25F8:  CALL    L2530           ; routine SYNTAX-Z  
25fb 28 28		        JR      Z,L2625         ; forward to S-RND-END if checking syntax.  
25fd			  
25fd ed 4b 76 5c	        LD      BC,($5C76)      ; fetch system variable SEED  
2601 cd 2b 2d		        CALL    L2D2B           ; routine STACK-BC places on calculator stack  
2604			  
2604 ef			        RST     28H             ;; FP-CALC           ;s.  
2605 a1			        DEFB    $A1             ;;stk-one            ;s,1.  
2606 0f			        DEFB    $0F             ;;addition           ;s+1.  
2607 34			        DEFB    $34             ;;stk-data           ;  
2608 37			        DEFB    $37             ;;Exponent: $87,  
2609			                                ;;Bytes: 1  
2609 16			        DEFB    $16             ;;(+00,+00,+00)      ;s+1,75.  
260a 04			        DEFB    $04             ;;multiply           ;(s+1)*75 = v  
260b 34			        DEFB    $34             ;;stk-data           ;v.  
260c 80			        DEFB    $80             ;;Bytes: 3  
260d 41			        DEFB    $41             ;;Exponent $91  
260e 00 00 80		        DEFB    $00,$00,$80     ;;(+00)              ;v,65537.  
2611 32			        DEFB    $32             ;;n-mod-m            ;remainder, result.  
2612 02			        DEFB    $02             ;;delete             ;remainder.  
2613 a1			        DEFB    $A1             ;;stk-one            ;remainder, 1.  
2614 03			        DEFB    $03             ;;subtract           ;remainder - 1. = rnd  
2615 31			        DEFB    $31             ;;duplicate          ;rnd,rnd.  
2616 38			        DEFB    $38             ;;end-calc  
2617			  
2617 cd a2 2d		        CALL    L2DA2           ; routine FP-TO-BC  
261a ed 43 76 5c	        LD      ($5C76),BC      ; store in SEED for next starting point.  
261e 7e			        LD      A,(HL)          ; fetch exponent  
261f a7			        AND     A               ; is it zero ?  
2620 28 03		        JR      Z,L2625         ; forward if so to S-RND-END  
2622			  
2622 d6 10		        SUB     $10             ; reduce exponent by 2^16  
2624 77			        LD      (HL),A          ; place back  
2625			  
2625			;; S-RND-END  
2625 18 09		L2625:  JR      L2630           ; forward to S-PI-END  
2627			  
2627			; ---  
2627			  
2627			; the number PI 3.14159...  
2627			  
2627			; ->  
2627			;; S-PI  
2627 cd 30 25		L2627:  CALL    L2530           ; routine SYNTAX-Z  
262a 28 04		        JR      Z,L2630         ; to S-PI-END if checking syntax.  
262c			  
262c ef			        RST     28H             ;; FP-CALC  
262d a3			        DEFB    $A3             ;;stk-pi/2                          pi/2.  
262e 38			        DEFB    $38             ;;end-calc  
262f			  
262f 34			        INC     (HL)            ; increment the exponent leaving pi  
2630			                                ; on the calculator stack.  
2630			  
2630			;; S-PI-END  
2630 e7			L2630:  RST     20H             ; NEXT-CHAR  
2631 c3 c3 26		        JP      L26C3           ; jump forward to S-NUMERIC  
2634			  
2634			; ---  
2634			  
2634			; ->  
2634			;; S-INKEY$  
2634 01 5a 10		L2634:  LD      BC,$105A        ; priority $10, operation code $1A ('read-in')  
2637			                                ; +$40 for string result, numeric operand.  
2637			                                ; set this up now in case we need to use the  
2637			                                ; calculator.  
2637 e7			        RST     20H             ; NEXT-CHAR  
2638 fe 23		        CP      $23             ; '#' ?  
263a ca 0d 27		        JP      Z,L270D         ; to S-PUSH-PO if so to use the calculator  
263d			                                ; single operation  
263d			                                ; to read from network/RS232 etc. .  
263d			  
263d			; else read a key from the keyboard.  
263d			  
263d 21 3b 5c		        LD      HL,$5C3B        ; fetch FLAGS  
2640 cb b6		        RES     6,(HL)          ; signal string result.  
2642 cb 7e		        BIT     7,(HL)          ; checking syntax ?  
2644 28 1f		        JR      Z,L2665         ; forward to S-INK$-EN if so  
2646			  
2646 c3 6c 3b		        JP      L3B6C           ; Spectrum 128 patch  
2649			  
2649 0e 00		L2649:  LD      C,$00           ; the length of an empty string  
264b 20 13		        JR      NZ,L2660        ; to S-IK$-STK to store empty string if  
264d			                                ; no key returned.  
264d			  
264d cd 1e 03		        CALL    L031E           ; routine K-TEST get main code in A  
2650 30 0e		        JR      NC,L2660        ; to S-IK$-STK to stack null string if  
2652			                                ; invalid  
2652			  
2652 15			        DEC     D               ; D is expected to be FLAGS so set bit 3 $FF  
2653			                                ; 'L' Mode so no keywords.  
2653 5f			        LD      E,A             ; main key to A  
2654			                                ; C is MODE 0 'KLC' from above still.  
2654 cd 33 03		        CALL    L0333           ; routine K-DECODE  
2657 f5			L2657:  PUSH    AF              ; save the code  
2658 01 01 00		        LD      BC,$0001        ; make room for one character  
265b			  
265b f7			        RST     30H             ; BC-SPACES  
265c f1			        POP     AF              ; bring the code back  
265d 12			        LD      (DE),A          ; put the key in workspace  
265e 0e 01		        LD      C,$01           ; set C length to one  
2660			  
2660			;; S-IK$-STK  
2660 06 00		L2660:  LD      B,$00           ; set high byte of length to zero  
2662 cd b2 2a		        CALL    L2AB2           ; routine STK-STO-$  
2665			  
2665			;; S-INK$-EN  
2665 c3 12 27		L2665:  JP      L2712           ; to S-CONT-2            ===>  
2668			  
2668			; ---  
2668			  
2668			; ->  
2668			;; S-SCREEN$  
2668 cd 22 25		L2668:  CALL    L2522           ; routine S-2-COORD  
266b c4 35 25		        CALL    NZ,L2535        ; routine S-SCRN$-S  
266e			  
266e e7			        RST     20H             ; NEXT-CHAR  
266f c3 db 25		        JP      L25DB           ; forward to S-STRING to stack result  
2672			  
2672			; ---  
2672			  
2672			; ->  
2672			;; S-ATTR  
2672 cd 22 25		L2672:  CALL    L2522           ; routine S-2-COORD  
2675 c4 80 25		        CALL    NZ,L2580        ; routine S-ATTR-S  
2678			  
2678 e7			        RST     20H             ; NEXT-CHAR  
2679 18 48		        JR      L26C3           ; forward to S-NUMERIC  
267b			  
267b			; ---  
267b			  
267b			; ->  
267b			;; S-POINT  
267b cd 22 25		L267B:  CALL    L2522           ; routine S-2-COORD  
267e c4 cb 22		        CALL    NZ,L22CB        ; routine POINT-SUB  
2681			  
2681 e7			        RST     20H             ; NEXT-CHAR  
2682 18 3f		        JR      L26C3           ; forward to S-NUMERIC  
2684			  
2684			; -----------------------------  
2684			  
2684			; ==> The branch was here if not in table.  
2684			  
2684			;; S-ALPHNUM  
2684 cd 88 2c		L2684:  CALL    L2C88           ; routine ALPHANUM checks if variable or  
2687			                                ; a digit.  
2687 30 56		        JR      NC,L26DF        ; forward to S-NEGATE if not to consider  
2689			                                ; a '-' character then functions.  
2689			  
2689 fe 41		        CP      $41             ; compare 'A'  
268b 30 3c		        JR      NC,L26C9        ; forward to S-LETTER if alpha       ->  
268d			                                ; else must have been numeric so continue  
268d			                                ; into that routine.  
268d			  
268d			; This important routine is called during runtime and from LINE-SCAN  
268d			; when a BASIC line is checked for syntax. It is this routine that  
268d			; inserts, during syntax checking, the invisible floating point numbers  
268d			; after the numeric expression. During runtime it just picks these  
268d			; numbers up. It also handles BIN format numbers.  
268d			  
268d			; ->  
268d			;; S-BIN  
268d			;; S-DECIMAL  
268d cd 30 25		L268D:  CALL    L2530           ; routine SYNTAX-Z  
2690 20 23		        JR      NZ,L26B5        ; to S-STK-DEC in runtime  
2692			  
2692			; this route is taken when checking syntax.  
2692			  
2692 cd 9b 2c		        CALL    L2C9B           ; routine DEC-TO-FP to evaluate number  
2695			  
2695 df			        RST     18H             ; GET-CHAR to fetch HL  
2696 01 06 00		        LD      BC,$0006        ; six locations required  
2699 cd 55 16		        CALL    L1655           ; routine MAKE-ROOM  
269c 23			        INC     HL              ; to first new location  
269d 36 0e		        LD      (HL),$0E        ; insert number marker  
269f 23			        INC     HL              ; address next  
26a0 eb			        EX      DE,HL           ; make DE destination.  
26a1 2a 65 5c		        LD      HL,($5C65)      ; STKEND points to end of stack.  
26a4 0e 05		        LD      C,$05           ; result is five locations lower  
26a6 a7			        AND     A               ; prepare for true subtraction  
26a7 ed 42		        SBC     HL,BC           ; point to start of value.  
26a9 22 65 5c		        LD      ($5C65),HL      ; update STKEND as we are taking number.  
26ac ed b0		        LDIR                    ; Copy five bytes to program location  
26ae eb			        EX      DE,HL           ; transfer pointer to HL  
26af 2b			        DEC     HL              ; adjust  
26b0 cd 77 00		        CALL    L0077           ; routine TEMP-PTR1 sets CH-ADD  
26b3 18 0e		        JR      L26C3           ; to S-NUMERIC to record nature of result  
26b5			  
26b5			; ---  
26b5			  
26b5			; branch here in runtime.  
26b5			  
26b5			;; S-STK-DEC  
26b5 df			L26B5:  RST     18H             ; GET-CHAR positions HL at digit.  
26b6			  
26b6			;; S-SD-SKIP  
26b6 23			L26B6:  INC     HL              ; advance pointer  
26b7 7e			        LD      A,(HL)          ; until we find  
26b8 fe 0e		        CP      $0E             ; chr 14d - the number indicator  
26ba 20 fa		        JR      NZ,L26B6        ; to S-SD-SKIP until a match  
26bc			                                ; it has to be here.  
26bc			  
26bc 23			        INC     HL              ; point to first byte of number  
26bd cd b4 33		        CALL    L33B4           ; routine STACK-NUM stacks it  
26c0 22 5d 5c		        LD      ($5C5D),HL      ; update system variable CH_ADD  
26c3			  
26c3			;; S-NUMERIC  
26c3 fd cb 01 f6	L26C3:  SET     6,(IY+$01)      ; update FLAGS  - Signal numeric result  
26c7 18 14		        JR      L26DD           ; forward to S-CONT-1               ===>  
26c9			                                ; actually S-CONT-2 is destination but why  
26c9			                                ; waste a byte on a jump when a JR will do.  
26c9			                                ; actually a JR L2712 can be used. Rats.  
26c9			  
26c9			; end of functions accessed from scanning functions table.  
26c9			  
26c9			; --------------------------  
26c9			; Scanning variable routines  
26c9			; --------------------------  
26c9			;  
26c9			;  
26c9			  
26c9			;; S-LETTER  
26c9 cd b2 28		L26C9:  CALL    L28B2           ; routine LOOK-VARS  
26cc da 2e 1c		        JP      C,L1C2E         ; jump back to REPORT-2 if not found  
26cf			                                ; 'Variable not found'  
26cf			                                ; but a variable is always 'found' if syntax  
26cf			                                ; is being checked.  
26cf			  
26cf cc 96 29		        CALL    Z,L2996         ; routine STK-VAR considers a subscript/slice  
26d2 3a 3b 5c		        LD      A,($5C3B)       ; fetch FLAGS value  
26d5 fe c0		        CP      $C0             ; compare 11000000  
26d7 38 04		        JR      C,L26DD         ; step forward to S-CONT-1 if string  ===>  
26d9			  
26d9 23			        INC     HL              ; advance pointer  
26da cd b4 33		        CALL    L33B4           ; routine STACK-NUM  
26dd			  
26dd			;; S-CONT-1  
26dd 18 33		L26DD:  JR      L2712           ; forward to S-CONT-2                 ===>  
26df			  
26df			; ----------------------------------------  
26df			; -> the scanning branch was here if not alphanumeric.  
26df			; All the remaining functions will be evaluated by a single call to the  
26df			; calculator. The correct priority for the operation has to be placed in  
26df			; the B register and the operation code, calculator literal in the C register.  
26df			; the operation code has bit 7 set if result is numeric and bit 6 is  
26df			; set if operand is numeric. so  
26df			; $C0 = numeric result, numeric operand.            e.g. 'sin'  
26df			; $80 = numeric result, string operand.             e.g. 'code'  
26df			; $40 = string result, numeric operand.             e.g. 'str$'  
26df			; $00 = string result, string operand.              e.g. 'val$'  
26df			  
26df			;; S-NEGATE  
26df 01 db 09		L26DF:  LD      BC,$09DB        ; prepare priority 09, operation code $C0 +   
26e2			                                ; 'negate' ($1B) - bits 6 and 7 set for numeric  
26e2			                                ; result and numeric operand.  
26e2			  
26e2 fe 2d		        CP      $2D             ; is it '-' ?  
26e4 28 27		        JR      Z,L270D         ; forward if so to S-PUSH-PO  
26e6			  
26e6 01 18 10		        LD      BC,$1018        ; prepare priority $10, operation code 'val$' -  
26e9			                                ; bits 6 and 7 reset for string result and  
26e9			                                ; string operand.  
26e9			          
26e9 fe ae		        CP      $AE             ; is it 'VAL$' ?  
26eb 28 20		        JR      Z,L270D         ; forward if so to S-PUSH-PO  
26ed			  
26ed d6 af		        SUB     $AF             ; subtract token 'CODE' value to reduce  
26ef			                                ; functions 'CODE' to 'NOT' although the  
26ef			                                ; upper range is, as yet, unchecked.  
26ef			                                ; valid range would be $00 - $14.  
26ef			  
26ef da 8a 1c		        JP      C,L1C8A         ; jump back to REPORT-C with anything else  
26f2			                                ; 'Nonsense in BASIC'  
26f2			  
26f2 01 f0 04		        LD      BC,$04F0        ; prepare priority $04, operation $C0 +   
26f5			                                ; 'not' ($30)  
26f5			  
26f5 fe 14		        CP      $14             ; is it 'NOT'  
26f7 28 14		        JR      Z,L270D         ; forward to S-PUSH-PO if so  
26f9			  
26f9 d2 8a 1c		        JP      NC,L1C8A        ; to REPORT-C if higher  
26fc			                                ; 'Nonsense in BASIC'  
26fc			  
26fc 06 10		        LD      B,$10           ; priority $10 for all the rest  
26fe c6 dc		        ADD     A,$DC           ; make range $DC - $EF  
2700			                                ; $C0 + 'code'($1C) thru 'chr$' ($2F)  
2700			  
2700 4f			        LD      C,A             ; transfer 'function' to C  
2701 fe df		        CP      $DF             ; is it 'sin' ?  
2703 30 02		        JR      NC,L2707        ; forward to S-NO-TO-$  with 'sin' through  
2705			                                ; 'chr$' as operand is numeric.  
2705			  
2705			; all the rest 'cos' through 'chr$' give a numeric result except 'str$'  
2705			; and 'chr$'.  
2705			  
2705 cb b1		        RES     6,C             ; signal string operand for 'code', 'val' and  
2707			                                ; 'len'.  
2707			  
2707			;; S-NO-TO-$  
2707 fe ee		L2707:  CP      $EE             ; compare 'str$'  
2709 38 02		        JR      C,L270D         ; forward to S-PUSH-PO if lower as result  
270b			                                ; is numeric.  
270b			  
270b cb b9		        RES     7,C             ; reset bit 7 of op code for 'str$', 'chr$'  
270d			                                ; as result is string.  
270d			  
270d			; >> This is where they were all headed for.  
270d			  
270d			;; S-PUSH-PO  
270d c5			L270D:  PUSH    BC              ; push the priority and calculator operation  
270e			                                ; code.  
270e			  
270e e7			        RST     20H             ; NEXT-CHAR  
270f c3 ff 24		        JP      L24FF           ; jump back to S-LOOP-1 to go round the loop  
2712			                                ; again with the next character.  
2712			  
2712			; --------------------------------  
2712			  
2712			; ===>  there were many branches forward to here  
2712			  
2712			;; S-CONT-2  
2712 df			L2712:  RST     18H             ; GET-CHAR  
2713			  
2713			;; S-CONT-3  
2713 fe 28		L2713:  CP      $28             ; is it '(' ?  
2715 20 0c		        JR      NZ,L2723        ; forward to S-OPERTR if not    >  
2717			  
2717 fd cb 01 76	        BIT     6,(IY+$01)      ; test FLAGS - numeric or string result ?  
271b 20 17		        JR      NZ,L2734        ; forward to S-LOOP if numeric to evaluate  >  
271d			  
271d			; if a string preceded '(' then slice it.  
271d			  
271d cd 52 2a		        CALL    L2A52           ; routine SLICING  
2720			  
2720 e7			        RST     20H             ; NEXT-CHAR  
2721 18 f0		        JR      L2713           ; back to S-CONT-3  
2723			  
2723			; ---------------------------  
2723			  
2723			; the branch was here when possibility of an operator '(' has been excluded.  
2723			  
2723			;; S-OPERTR  
2723 06 00		L2723:  LD      B,$00           ; prepare to add  
2725 4f			        LD      C,A             ; possible operator to C  
2726 21 95 27		        LD      HL,L2795        ; Address: $2795 - tbl-of-ops  
2729 cd dc 16		        CALL    L16DC           ; routine INDEXER  
272c 30 06		        JR      NC,L2734        ; forward to S-LOOP if not in table  
272e			  
272e			; but if found in table the priority has to be looked up.  
272e			  
272e 4e			        LD      C,(HL)          ; operation code to C ( B is still zero )  
272f 21 ed 26		        LD      HL,L27B0 - $C3  ; $26ED is base of table  
2732 09			        ADD     HL,BC           ; index into table.  
2733 46			        LD      B,(HL)          ; priority to B.  
2734			  
2734			; ------------------  
2734			; Scanning main loop  
2734			; ------------------  
2734			; the juggling act  
2734			  
2734			;; S-LOOP  
2734 d1			L2734:  POP     DE              ; fetch last priority and operation  
2735 7a			        LD      A,D             ; priority to A  
2736 b8			        CP      B               ; compare with this one  
2737 38 3a		        JR      C,L2773         ; forward to S-TIGHTER to execute the  
2739			                                ; last operation before this one as it has  
2739			                                ; higher priority.  
2739			  
2739			; the last priority was greater or equal this one.  
2739			  
2739 a7			        AND     A               ; if it is zero then so is this  
273a ca 18 00		        JP      Z,L0018         ; jump to exit via get-char pointing at  
273d			                                ; next character.  
273d			                                ; This may be the character after the  
273d			                                ; expression or, if exiting a recursive call,  
273d			                                ; the next part of the expression to be  
273d			                                ; evaluated.  
273d			  
273d c5			        PUSH    BC              ; save current priority/operation  
273e			                                ; as it has lower precedence than the one  
273e			                                ; now in DE.  
273e			  
273e			; the 'USR' function is special in that it is overloaded to give two types  
273e			; of result.  
273e			  
273e 21 3b 5c		        LD      HL,$5C3B        ; address FLAGS  
2741 7b			        LD      A,E             ; new operation to A register  
2742 fe ed		        CP      $ED             ; is it $C0 + 'usr-no' ($2D)  ?  
2744 20 06		        JR      NZ,L274C        ; forward to S-STK-LST if not  
2746			  
2746 cb 76		        BIT     6,(HL)          ; string result expected ?  
2748			                                ; (from the lower priority operand we've  
2748			                                ; just pushed on stack )  
2748 20 02		        JR      NZ,L274C        ; forward to S-STK-LST if numeric  
274a			                                ; as operand bits match.  
274a			  
274a 1e 99		        LD      E,$99           ; reset bit 6 and substitute $19 'usr-$'  
274c			                                ; for string operand.  
274c			  
274c			;; S-STK-LST  
274c d5			L274C:  PUSH    DE              ; now stack this priority/operation  
274d cd 30 25		        CALL    L2530           ; routine SYNTAX-Z  
2750 28 09		        JR      Z,L275B         ; forward to S-SYNTEST if checking syntax.  
2752			  
2752 7b			        LD      A,E             ; fetch the operation code  
2753 e6 3f		        AND     $3F             ; mask off the result/operand bits to leave  
2755			                                ; a calculator literal.  
2755 47			        LD      B,A             ; transfer to B register  
2756			  
2756			; now use the calculator to perform the single operation - operand is on  
2756			; the calculator stack.  
2756			; Note. although the calculator is performing a single operation most  
2756			; functions e.g. TAN are written using other functions and literals and  
2756			; these in turn are written using further strings of calculator literals so  
2756			; another level of magical recursion joins the juggling act for a while  
2756			; as the calculator too is calling itself.  
2756			  
2756 ef			        RST     28H             ;; FP-CALC  
2757 3b			        DEFB    $3B             ;;fp-calc-2  
2758 38			L2758:  DEFB    $38             ;;end-calc  
2759			  
2759 18 09		        JR      L2764           ; forward to S-RUNTEST  
275b			  
275b			; ---  
275b			  
275b			; the branch was here if checking syntax only.   
275b			  
275b			;; S-SYNTEST  
275b 7b			L275B:  LD      A,E             ; fetch the operation code to accumulator  
275c fd ae 01		        XOR     (IY+$01)        ; compare with bits of FLAGS  
275f e6 40		        AND     $40             ; bit 6 will be zero now if operand  
2761			                                ; matched expected result.  
2761			  
2761			;; S-RPORT-C2  
2761 c2 8a 1c		L2761:  JP      NZ,L1C8A        ; to REPORT-C if mismatch  
2764			                                ; 'Nonsense in BASIC'  
2764			                                ; else continue to set flags for next  
2764			  
2764			; the branch is to here in runtime after a successful operation.  
2764			  
2764			;; S-RUNTEST  
2764 d1			L2764:  POP     DE              ; fetch the last operation from stack  
2765 21 3b 5c		        LD      HL,$5C3B        ; address FLAGS  
2768 cb f6		        SET     6,(HL)          ; set default to numeric result in FLAGS  
276a cb 7b		        BIT     7,E             ; test the operational result  
276c 20 02		        JR      NZ,L2770        ; forward to S-LOOPEND if numeric  
276e			  
276e cb b6		        RES     6,(HL)          ; reset bit 6 of FLAGS to show string result.  
2770			  
2770			;; S-LOOPEND  
2770 c1			L2770:  POP     BC              ; fetch the previous priority/operation  
2771 18 c1		        JR      L2734           ; back to S-LOOP to perform these  
2773			  
2773			; ---  
2773			  
2773			; the branch was here when a stacked priority/operator had higher priority  
2773			; than the current one.  
2773			  
2773			;; S-TIGHTER  
2773 d5			L2773:  PUSH    DE              ; save high priority op on stack again  
2774 79			        LD      A,C             ; fetch lower priority operation code  
2775 fd cb 01 76	        BIT     6,(IY+$01)      ; test FLAGS - Numeric or string result ?  
2779 20 15		        JR      NZ,L2790        ; forward to S-NEXT if numeric result  
277b			  
277b			; if this is lower priority yet has string then must be a comparison.  
277b			; Since these can only be evaluated in context and were defaulted to  
277b			; numeric in operator look up they must be changed to string equivalents.  
277b			  
277b e6 3f		        AND     $3F             ; mask to give true calculator literal  
277d c6 08		        ADD     A,$08           ; augment numeric literals to string  
277f			                                ; equivalents.  
277f			                                ; 'no-&-no'  => 'str-&-no'  
277f			                                ; 'no-l-eql' => 'str-l-eql'  
277f			                                ; 'no-gr-eq' => 'str-gr-eq'  
277f			                                ; 'nos-neql' => 'strs-neql'  
277f			                                ; 'no-grtr'  => 'str-grtr'  
277f			                                ; 'no-less'  => 'str-less'  
277f			                                ; 'nos-eql'  => 'strs-eql'  
277f			                                ; 'addition' => 'strs-add'  
277f 4f			        LD      C,A             ; put modified comparison operator back  
2780 fe 10		        CP      $10             ; is it now 'str-&-no' ?  
2782 20 04		        JR      NZ,L2788        ; forward to S-NOT-AND  if not.  
2784			  
2784 cb f1		        SET     6,C             ; set numeric operand bit  
2786 18 08		        JR      L2790           ; forward to S-NEXT  
2788			  
2788			; ---  
2788			  
2788			;; S-NOT-AND  
2788 38 d7		L2788:  JR      C,L2761         ; back to S-RPORT-C2 if less  
278a			                                ; 'Nonsense in BASIC'.  
278a			                                ; e.g. a$ * b$  
278a			  
278a fe 17		        CP      $17             ; is it 'strs-add' ?  
278c 28 02		        JR      Z,L2790         ; forward to to S-NEXT if so  
278e			                                ; (bit 6 and 7 are reset)  
278e			  
278e cb f9		        SET     7,C             ; set numeric (Boolean) result for all others  
2790			  
2790			;; S-NEXT  
2790 c5			L2790:  PUSH    BC              ; now save this priority/operation on stack  
2791			  
2791 e7			        RST     20H             ; NEXT-CHAR  
2792 c3 ff 24		        JP      L24FF           ; jump back to S-LOOP-1  
2795			  
2795			; ------------------  
2795			; Table of operators  
2795			; ------------------  
2795			; This table is used to look up the calculator literals associated with  
2795			; the operator character. The thirteen calculator operations $03 - $0F  
2795			; have bits 6 and 7 set to signify a numeric result.  
2795			; Some of these codes and bits may be altered later if the context suggests  
2795			; a string comparison or operation.  
2795			; that is '+', '=', '>', '<', '<=', '>=' or '<>'.  
2795			  
2795			;; tbl-of-ops  
2795 .. cf		L2795:  DEFB    '+', $CF        ;        $C0 + 'addition'  
2797 .. c3		        DEFB    '-', $C3        ;        $C0 + 'subtract'  
2799 .. c4		        DEFB    '*', $C4        ;        $C0 + 'multiply'  
279b .. c5		        DEFB    '/', $C5        ;        $C0 + 'division'  
279d .. c6		        DEFB    '^', $C6        ;        $C0 + 'to-power'  
279f .. ce		        DEFB    '=', $CE        ;        $C0 + 'nos-eql'  
27a1 .. cc		        DEFB    '>', $CC        ;        $C0 + 'no-grtr'  
27a3 .. cd		        DEFB    '<', $CD        ;        $C0 + 'no-less'  
27a5			  
27a5 c7 c9		        DEFB    $C7, $C9        ; '<='   $C0 + 'no-l-eql'  
27a7 c8 ca		        DEFB    $C8, $CA        ; '>='   $C0 + 'no-gr-eql'  
27a9 c9 cb		        DEFB    $C9, $CB        ; '<>'   $C0 + 'nos-neql'  
27ab c5 c7		        DEFB    $C5, $C7        ; 'OR'   $C0 + 'or'  
27ad c6 c8		        DEFB    $C6, $C8        ; 'AND'  $C0 + 'no-&-no'  
27af			  
27af 00			        DEFB    $00             ; zero end-marker.  
27b0			  
27b0			  
27b0			; -------------------  
27b0			; Table of priorities  
27b0			; -------------------  
27b0			; This table is indexed with the operation code obtained from the above  
27b0			; table $C3 - $CF to obtain the priority for the respective operation.  
27b0			  
27b0			;; tbl-priors  
27b0 06			L27B0:  DEFB    $06             ; '-'   opcode $C3  
27b1 08			        DEFB    $08             ; '*'   opcode $C4  
27b2 08			        DEFB    $08             ; '/'   opcode $C5  
27b3 0a			        DEFB    $0A             ; '^'   opcode $C6  
27b4 02			        DEFB    $02             ; 'OR'  opcode $C7  
27b5 03			        DEFB    $03             ; 'AND' opcode $C8  
27b6 05			        DEFB    $05             ; '<='  opcode $C9  
27b7 05			        DEFB    $05             ; '>='  opcode $CA  
27b8 05			        DEFB    $05             ; '<>'  opcode $CB  
27b9 05			        DEFB    $05             ; '>'   opcode $CC  
27ba 05			        DEFB    $05             ; '<'   opcode $CD  
27bb 05			        DEFB    $05             ; '='   opcode $CE  
27bc 06			        DEFB    $06             ; '+'   opcode $CF  
27bd			  
27bd			; ----------------------  
27bd			; Scanning function (FN)  
27bd			; ----------------------  
27bd			; This routine deals with user-defined functions.  
27bd			; The definition can be anywhere in the program area but these are best  
27bd			; placed near the start of the program as we shall see.  
27bd			; The evaluation process is quite complex as the Spectrum has to parse two  
27bd			; statements at the same time. Syntax of both has been checked previously  
27bd			; and hidden locations have been created immediately after each argument  
27bd			; of the DEF FN statement. Each of the arguments of the FN function is  
27bd			; evaluated by SCANNING and placed in the hidden locations. Then the  
27bd			; expression to the right of the DEF FN '=' is evaluated by SCANNING and for  
27bd			; any variables encountered, a search is made in the DEF FN variable list  
27bd			; in the program area before searching in the normal variables area.  
27bd			;  
27bd			; Recursion is not allowed: i.e. the definition of a function should not use  
27bd			; the same function, either directly or indirectly ( through another function).  
27bd			; You'll normally get error 4, ('Out of memory'), although sometimes the sytem  
27bd			; will crash. - Vickers, Pitman 1984.  
27bd			;  
27bd			; As the definition is just an expression, there would seem to be no means  
27bd			; of breaking out of such recursion.  
27bd			; However, by the clever use of string expressions and VAL, such recursion is  
27bd			; possible.  
27bd			; e.g. DEF FN a(n) = VAL "n+FN a(n-1)+0" ((n<1) * 10 + 1 TO )  
27bd			; will evaluate the full 11-character expression for all values where n is  
27bd			; greater than zero but just the 11th character, "0", when n drops to zero  
27bd			; thereby ending the recursion producing the correct result.  
27bd			; Recursive string functions are possible using VAL$ instead of VAL and the  
27bd			; null string as the final addend.  
27bd			; - from a turn of the century newsgroup discussion initiated by Mike Wynne.  
27bd			  
27bd			;; S-FN-SBRN  
27bd cd 30 25		L27BD:  CALL    L2530           ; routine SYNTAX-Z  
27c0 20 35		        JR      NZ,L27F7        ; forward to SF-RUN in runtime  
27c2			  
27c2			  
27c2 e7			        RST     20H             ; NEXT-CHAR  
27c3 cd 8d 2c		        CALL    L2C8D           ; routine ALPHA check for letters A-Z a-z  
27c6 d2 8a 1c		        JP      NC,L1C8A        ; jump back to REPORT-C if not  
27c9			                                ; 'Nonsense in BASIC'  
27c9			  
27c9			  
27c9 e7			        RST     20H             ; NEXT-CHAR  
27ca fe 24		        CP      $24             ; is it '$' ?  
27cc f5			        PUSH    AF              ; save character and flags  
27cd 20 01		        JR      NZ,L27D0        ; forward to SF-BRKT-1 with numeric function  
27cf			  
27cf			  
27cf e7			        RST     20H             ; NEXT-CHAR  
27d0			  
27d0			;; SF-BRKT-1  
27d0 fe 28		L27D0:  CP      $28             ; is '(' ?  
27d2 20 12		        JR      NZ,L27E6        ; forward to SF-RPRT-C if not  
27d4			                                ; 'Nonsense in BASIC'  
27d4			  
27d4			  
27d4 e7			        RST     20H             ; NEXT-CHAR  
27d5 fe 29		        CP      $29             ; is it ')' ?  
27d7 28 10		        JR      Z,L27E9         ; forward to SF-FLAG-6 if no arguments.  
27d9			  
27d9			;; SF-ARGMTS  
27d9 cd fb 24		L27D9:  CALL    L24FB           ; routine SCANNING checks each argument  
27dc			                                ; which may be an expression.  
27dc			  
27dc df			        RST     18H             ; GET-CHAR  
27dd fe 2c		        CP      $2C             ; is it a ',' ?  
27df 20 03		        JR      NZ,L27E4        ; forward if not to SF-BRKT-2 to test bracket  
27e1			  
27e1			  
27e1 e7			        RST     20H             ; NEXT-CHAR if a comma was found  
27e2 18 f5		        JR      L27D9           ; back to SF-ARGMTS to parse all arguments.  
27e4			  
27e4			; ---  
27e4			  
27e4			;; SF-BRKT-2  
27e4 fe 29		L27E4:  CP      $29             ; is character the closing ')' ?  
27e6			  
27e6			;; SF-RPRT-C  
27e6 c2 8a 1c		L27E6:  JP      NZ,L1C8A        ; jump to REPORT-C  
27e9			                                ; 'Nonsense in BASIC'  
27e9			  
27e9			; at this point any optional arguments have had their syntax checked.  
27e9			  
27e9			;; SF-FLAG-6  
27e9 e7			L27E9:  RST     20H             ; NEXT-CHAR  
27ea 21 3b 5c		        LD      HL,$5C3B        ; address system variable FLAGS  
27ed cb b6		        RES     6,(HL)          ; signal string result  
27ef f1			        POP     AF              ; restore test against '$'.  
27f0 28 02		        JR      Z,L27F4         ; forward to SF-SYN-EN if string function.  
27f2			  
27f2 cb f6		        SET     6,(HL)          ; signal numeric result  
27f4			  
27f4			;; SF-SYN-EN  
27f4 c3 12 27		L27F4:  JP      L2712           ; jump back to S-CONT-2 to continue scanning.  
27f7			  
27f7			; ---  
27f7			  
27f7			; the branch was here in runtime.  
27f7			  
27f7			;; SF-RUN  
27f7 e7			L27F7:  RST     20H             ; NEXT-CHAR fetches name  
27f8 e6 df		        AND     $DF             ; AND 11101111 - reset bit 5 - upper-case.  
27fa 47			        LD      B,A             ; save in B  
27fb			  
27fb e7			        RST     20H             ; NEXT-CHAR  
27fc d6 24		        SUB     $24             ; subtract '$'  
27fe 4f			        LD      C,A             ; save result in C  
27ff 20 01		        JR      NZ,L2802        ; forward if not '$' to SF-ARGMT1  
2801			  
2801 e7			        RST     20H             ; NEXT-CHAR advances to bracket  
2802			  
2802			;; SF-ARGMT1  
2802 e7			L2802:  RST     20H             ; NEXT-CHAR advances to start of argument  
2803 e5			        PUSH    HL              ; save address  
2804 2a 53 5c		        LD      HL,($5C53)      ; fetch start of program area from PROG  
2807 2b			        DEC     HL              ; the search starting point is the previous  
2808			                                ; location.  
2808			  
2808			;; SF-FND-DF  
2808 11 ce 00		L2808:  LD      DE,$00CE        ; search is for token 'DEF FN' in E,  
280b			                                ; statement count in D.  
280b c5			        PUSH    BC              ; save C the string test, and B the letter.  
280c cd 86 1d		        CALL    L1D86           ; routine LOOK-PROG will search for token.  
280f c1			        POP     BC              ; restore BC.  
2810 30 02		        JR      NC,L2814        ; forward to SF-CP-DEF if a match was found.  
2812			  
2812			  
2812			;; REPORT-P  
2812 cf			L2812:  RST     08H             ; ERROR-1  
2813 18			        DEFB    $18             ; Error Report: FN without DEF  
2814			  
2814			;; SF-CP-DEF  
2814 e5			L2814:  PUSH    HL              ; save address of DEF FN  
2815 cd ab 28		        CALL    L28AB           ; routine FN-SKPOVR skips over white-space etc.  
2818			                                ; without disturbing CH-ADD.  
2818 e6 df		        AND     $DF             ; make fetched character upper-case.  
281a b8			        CP      B               ; compare with FN name  
281b 20 08		        JR      NZ,L2825        ; forward to SF-NOT-FD if no match.  
281d			  
281d			; the letters match so test the type.  
281d			  
281d cd ab 28		        CALL    L28AB           ; routine FN-SKPOVR skips white-space  
2820 d6 24		        SUB     $24             ; subtract '$' from fetched character  
2822 b9			        CP      C               ; compare with saved result of same operation  
2823			                                ; on FN name.  
2823 28 0c		        JR      Z,L2831         ; forward to SF-VALUES with a match.  
2825			  
2825			; the letters matched but one was string and the other numeric.  
2825			  
2825			;; SF-NOT-FD  
2825 e1			L2825:  POP     HL              ; restore search point.  
2826 2b			        DEC     HL              ; make location before  
2827 11 00 02		        LD      DE,$0200        ; the search is to be for the end of the  
282a			                                ; current definition - 2 statements forward.  
282a c5			        PUSH    BC              ; save the letter/type  
282b cd 8b 19		        CALL    L198B           ; routine EACH-STMT steps past rejected  
282e			                                ; definition.  
282e c1			        POP     BC              ; restore letter/type  
282f 18 d7		        JR      L2808           ; back to SF-FND-DF to continue search  
2831			  
2831			; ---  
2831			  
2831			; Success!  
2831			; the branch was here with matching letter and numeric/string type.  
2831			  
2831			;; SF-VALUES  
2831 a7			L2831:  AND     A               ; test A ( will be zero if string '$' - '$' )  
2832			  
2832 cc ab 28		        CALL    Z,L28AB         ; routine FN-SKPOVR advances HL past '$'.  
2835			  
2835 d1			        POP     DE              ; discard pointer to 'DEF FN'.  
2836 d1			        POP     DE              ; restore pointer to first FN argument.  
2837 ed 53 5d 5c	        LD      ($5C5D),DE      ; save in CH_ADD  
283b			  
283b cd ab 28		        CALL    L28AB           ; routine FN-SKPOVR advances HL past '('  
283e e5			        PUSH    HL              ; save start address in DEF FN  ***  
283f fe 29		        CP      $29             ; is character a ')' ?  
2841 28 42		        JR      Z,L2885         ; forward to SF-R-BR-2 if no arguments.  
2843			  
2843			;; SF-ARG-LP  
2843 23			L2843:  INC     HL              ; point to next character.  
2844 7e			        LD      A,(HL)          ; fetch it.  
2845 fe 0e		        CP      $0E             ; is it the number marker  
2847 16 40		        LD      D,$40           ; signal numeric in D.  
2849 28 07		        JR      Z,L2852         ; forward to SF-ARG-VL if numeric.  
284b			  
284b 2b			        DEC     HL              ; back to letter  
284c cd ab 28		        CALL    L28AB           ; routine FN-SKPOVR skips any white-space  
284f 23			        INC     HL              ; advance past the expected '$' to   
2850			                                ; the 'hidden' marker.  
2850 16 00		        LD      D,$00           ; signal string.  
2852			  
2852			;; SF-ARG-VL  
2852 23			L2852:  INC     HL              ; now address first of 5-byte location.  
2853 e5			        PUSH    HL              ; save address in DEF FN statement  
2854 d5			        PUSH    DE              ; save D - result type  
2855			  
2855 cd fb 24		        CALL    L24FB           ; routine SCANNING evaluates expression in  
2858			                                ; the FN statement setting FLAGS and leaving  
2858			                                ; result as last value on calculator stack.  
2858			  
2858 f1			        POP     AF              ; restore saved result type to A  
2859			  
2859 fd ae 01		        XOR     (IY+$01)        ; xor with FLAGS  
285c e6 40		        AND     $40             ; and with 01000000 to test bit 6  
285e 20 2b		        JR      NZ,L288B        ; forward to REPORT-Q if type mismatch.  
2860			                                ; 'Parameter error'  
2860			  
2860 e1			        POP     HL              ; pop the start address in DEF FN statement  
2861 eb			        EX      DE,HL           ; transfer to DE ?? pop straight into de ?  
2862			  
2862 2a 65 5c		        LD      HL,($5C65)      ; set HL to STKEND location after value  
2865 01 05 00		        LD      BC,$0005        ; five bytes to move  
2868 ed 42		        SBC     HL,BC           ; decrease HL by 5 to point to start.  
286a 22 65 5c		        LD      ($5C65),HL      ; set STKEND 'removing' value from stack.  
286d			  
286d ed b0		        LDIR                    ; copy value into DEF FN statement  
286f eb			        EX      DE,HL           ; set HL to location after value in DEF FN  
2870 2b			        DEC     HL              ; step back one  
2871 cd ab 28		        CALL    L28AB           ; routine FN-SKPOVR gets next valid character  
2874 fe 29		        CP      $29             ; is it ')' end of arguments ?  
2876 28 0d		        JR      Z,L2885         ; forward to SF-R-BR-2 if so.  
2878			  
2878			; a comma separator has been encountered in the DEF FN argument list.  
2878			  
2878 e5			        PUSH    HL              ; save position in DEF FN statement  
2879			  
2879 df			        RST     18H             ; GET-CHAR from FN statement  
287a fe 2c		        CP      $2C             ; is it ',' ?  
287c 20 0d		        JR      NZ,L288B        ; forward to REPORT-Q if not  
287e			                                ; 'Parameter error'  
287e			  
287e e7			        RST     20H             ; NEXT-CHAR in FN statement advances to next  
287f			                                ; argument.  
287f			  
287f e1			        POP     HL              ; restore DEF FN pointer  
2880 cd ab 28		        CALL    L28AB           ; routine FN-SKPOVR advances to corresponding  
2883			                                ; argument.  
2883			  
2883 18 be		        JR      L2843           ; back to SF-ARG-LP looping until all  
2885			                                ; arguments are passed into the DEF FN  
2885			                                ; hidden locations.  
2885			  
2885			; ---  
2885			  
2885			; the branch was here when all arguments passed.  
2885			  
2885			;; SF-R-BR-2  
2885 e5			L2885:  PUSH    HL              ; save location of ')' in DEF FN  
2886			  
2886 df			        RST     18H             ; GET-CHAR gets next character in FN  
2887 fe 29		        CP      $29             ; is it a ')' also ?  
2889 28 02		        JR      Z,L288D         ; forward to SF-VALUE if so.  
288b			  
288b			  
288b			;; REPORT-Q  
288b cf			L288B:  RST     08H             ; ERROR-1  
288c 19			        DEFB    $19             ; Error Report: Parameter error  
288d			  
288d			;; SF-VALUE  
288d d1			L288D:  POP     DE              ; location of ')' in DEF FN to DE.  
288e eb			        EX      DE,HL           ; now to HL, FN ')' pointer to DE.  
288f 22 5d 5c		        LD      ($5C5D),HL      ; initialize CH_ADD to this value.  
2892			  
2892			; At this point the start of the DEF FN argument list is on the machine stack.  
2892			; We also have to consider that this defined function may form part of the  
2892			; definition of another defined function (though not itself).  
2892			; As this defined function may be part of a hierarchy of defined functions  
2892			; currently being evaluated by recursive calls to SCANNING, then we have to  
2892			; preserve the original value of DEFADD and not assume that it is zero.  
2892			  
2892 2a 0b 5c		        LD      HL,($5C0B)      ; get original DEFADD address  
2895 e3			        EX      (SP),HL         ; swap with DEF FN address on stack ***  
2896 22 0b 5c		        LD      ($5C0B),HL      ; set DEFADD to point to this argument list  
2899			                                ; during scanning.  
2899			  
2899 d5			        PUSH    DE              ; save FN ')' pointer.  
289a			  
289a e7			        RST     20H             ; NEXT-CHAR advances past ')' in define  
289b			  
289b e7			        RST     20H             ; NEXT-CHAR advances past '=' to expression  
289c			  
289c cd fb 24		        CALL    L24FB           ; routine SCANNING evaluates but searches  
289f			                                ; initially for variables at DEFADD  
289f			  
289f e1			        POP     HL              ; pop the FN ')' pointer  
28a0 22 5d 5c		        LD      ($5C5D),HL      ; set CH_ADD to this  
28a3 e1			        POP     HL              ; pop the original DEFADD value  
28a4 22 0b 5c		        LD      ($5C0B),HL      ; and re-insert into DEFADD system variable.  
28a7			  
28a7 e7			        RST     20H             ; NEXT-CHAR advances to character after ')'  
28a8 c3 12 27		        JP      L2712           ; to S-CONT-2 - to continue current  
28ab			                                ; invocation of scanning  
28ab			  
28ab			; --------------------  
28ab			; Used to parse DEF FN  
28ab			; --------------------  
28ab			; e.g. DEF FN     s $ ( x )     =  b     $ (  TO  x  ) : REM exaggerated  
28ab			;  
28ab			; This routine is used 10 times to advance along a DEF FN statement  
28ab			; skipping spaces and colour control codes. It is similar to NEXT-CHAR  
28ab			; which is, at the same time, used to skip along the corresponding FN function  
28ab			; except the latter has to deal with AT and TAB characters in string  
28ab			; expressions. These cannot occur in a program area so this routine is  
28ab			; simpler as both colour controls and their parameters are less than space.  
28ab			  
28ab			;; FN-SKPOVR  
28ab 23			L28AB:  INC     HL              ; increase pointer  
28ac 7e			        LD      A,(HL)          ; fetch addressed character  
28ad fe 21		        CP      $21             ; compare with space + 1  
28af 38 fa		        JR      C,L28AB         ; back to FN-SKPOVR if less  
28b1			  
28b1 c9			        RET                     ; return pointing to a valid character.  
28b2			  
28b2			; ---------  
28b2			; LOOK-VARS  
28b2			; ---------  
28b2			;  
28b2			;  
28b2			  
28b2			;; LOOK-VARS  
28b2 fd cb 01 f6	L28B2:  SET     6,(IY+$01)      ; update FLAGS - presume numeric result  
28b6			  
28b6 df			        RST     18H             ; GET-CHAR  
28b7 cd 8d 2c		        CALL    L2C8D           ; routine ALPHA tests for A-Za-z  
28ba d2 8a 1c		        JP      NC,L1C8A        ; jump to REPORT-C if not.  
28bd			                                ; 'Nonsense in BASIC'  
28bd			  
28bd e5			        PUSH    HL              ; save pointer to first letter       ^1  
28be e6 1f		        AND     $1F             ; mask lower bits, 1 - 26 decimal     000xxxxx  
28c0 4f			        LD      C,A             ; store in C.  
28c1			  
28c1 e7			        RST     20H             ; NEXT-CHAR  
28c2 e5			        PUSH    HL              ; save pointer to second character   ^2  
28c3 fe 28		        CP      $28             ; is it '(' - an array ?  
28c5 28 28		        JR      Z,L28EF         ; forward to V-RUN/SYN if so.  
28c7			  
28c7 cb f1		        SET     6,C             ; set 6 signaling string if solitary  010  
28c9 fe 24		        CP      $24             ; is character a '$' ?  
28cb 28 11		        JR      Z,L28DE         ; forward to V-STR-VAR  
28cd			  
28cd cb e9		        SET     5,C             ; signal numeric                       011  
28cf cd 88 2c		        CALL    L2C88           ; routine ALPHANUM sets carry if second  
28d2			                                ; character is alphanumeric.  
28d2 30 0f		        JR      NC,L28E3        ; forward to V-TEST-FN if just one character  
28d4			  
28d4			; it is more than one character but re-test current character so that 6 reset  
28d4			; Note. this is a rare lack of elegance. Bit 6 could be reset once before  
28d4			; entering the loop. Another puzzle is that this loop renders the similar  
28d4			; loop at V-PASS redundant.  
28d4			  
28d4			;; V-CHAR  
28d4 cd 88 2c		L28D4:  CALL    L2C88           ; routine ALPHANUM  
28d7 30 16		        JR      NC,L28EF        ; to V-RUN/SYN when no more  
28d9			  
28d9 cb b1		        RES     6,C             ; make long named type                 001  
28db			  
28db e7			        RST     20H             ; NEXT-CHAR  
28dc 18 f6		        JR      L28D4           ; loop back to V-CHAR  
28de			  
28de			; ---  
28de			  
28de			  
28de			;; V-STR-VAR  
28de e7			L28DE:  RST     20H             ; NEXT-CHAR advances past '$'  
28df fd cb 01 b6	        RES     6,(IY+$01)      ; update FLAGS - signal string result.  
28e3			  
28e3			;; V-TEST-FN  
28e3 3a 0c 5c		L28E3:  LD      A,($5C0C)       ; load A with DEFADD_hi  
28e6 a7			        AND     A               ; and test for zero.  
28e7 28 06		        JR      Z,L28EF         ; forward to V-RUN/SYN if a defined function  
28e9			                                ; is not being evaluated.  
28e9			  
28e9			; Note.  
28e9			  
28e9 cd 30 25		        CALL    L2530           ; routine SYNTAX-Z  
28ec c2 51 29		        JP      NZ,L2951        ; JUMP to STK-F-ARG in runtime and then  
28ef			                                ; back to this point if no variable found.  
28ef			  
28ef			;; V-RUN/SYN  
28ef 41			L28EF:  LD      B,C             ; save flags in B  
28f0 cd 30 25		        CALL    L2530           ; routine SYNTAX-Z  
28f3 20 08		        JR      NZ,L28FD        ; to V-RUN to look for the variable in runtime  
28f5			  
28f5			; if checking syntax the letter is not returned  
28f5			  
28f5 79			        LD      A,C             ; copy letter/flags to A  
28f6 e6 e0		        AND     $E0             ; and with 11100000 to get rid of the letter  
28f8 cb ff		        SET     7,A             ; use spare bit to signal checking syntax.  
28fa 4f			        LD      C,A             ; and transfer to C.  
28fb 18 37		        JR      L2934           ; forward to V-SYNTAX  
28fd			  
28fd			; ---  
28fd			  
28fd			; but in runtime search for the variable.  
28fd			  
28fd			;; V-RUN  
28fd 2a 4b 5c		L28FD:  LD      HL,($5C4B)      ; set HL to start of variables from VARS  
2900			  
2900			;; V-EACH  
2900 7e			L2900:  LD      A,(HL)          ; get first character  
2901 e6 7f		        AND     $7F             ; and with 01111111  
2903			                                ; ignoring bit 7 which distinguishes  
2903			                                ; arrays or for/next variables.  
2903			  
2903 28 2d		        JR      Z,L2932         ; to V-80-BYTE if zero as must be 10000000  
2905			                                ; the variables end-marker.  
2905			  
2905 b9			        CP      C               ; compare with supplied value.  
2906 20 22		        JR      NZ,L292A        ; forward to V-NEXT if no match.  
2908			  
2908 17			        RLA                     ; destructively test  
2909 87			        ADD     A,A             ; bits 5 and 6 of A  
290a			                                ; jumping if bit 5 reset or 6 set  
290a			  
290a f2 3f 29		        JP      P,L293F         ; to V-FOUND-2  strings and arrays  
290d			  
290d 38 30		        JR      C,L293F         ; to V-FOUND-2  simple and for next  
290f			  
290f			; leaving long name variables.  
290f			  
290f d1			        POP     DE              ; pop pointer to 2nd. char  
2910 d5			        PUSH    DE              ; save it again  
2911 e5			        PUSH    HL              ; save variable first character pointer  
2912			  
2912			;; V-MATCHES  
2912 23			L2912:  INC     HL              ; address next character in vars area  
2913			  
2913			;; V-SPACES  
2913 1a			L2913:  LD      A,(DE)          ; pick up letter from prog area  
2914 13			        INC     DE              ; and advance address  
2915 fe 20		        CP      $20             ; is it a space  
2917 28 fa		        JR      Z,L2913         ; back to V-SPACES until non-space  
2919			  
2919 f6 20		        OR      $20             ; convert to range 1 - 26.  
291b be			        CP      (HL)            ; compare with addressed variables character  
291c 28 f4		        JR      Z,L2912         ; loop back to V-MATCHES if a match on an  
291e			                                ; intermediate letter.  
291e			  
291e f6 80		        OR      $80             ; now set bit 7 as last character of long  
2920			                                ; names are inverted.  
2920 be			        CP      (HL)            ; compare again  
2921 20 06		        JR      NZ,L2929        ; forward to V-GET-PTR if no match  
2923			  
2923			; but if they match check that this is also last letter in prog area  
2923			  
2923 1a			        LD      A,(DE)          ; fetch next character  
2924 cd 88 2c		        CALL    L2C88           ; routine ALPHANUM sets carry if not alphanum  
2927 30 15		        JR      NC,L293E        ; forward to V-FOUND-1 with a full match.  
2929			  
2929			;; V-GET-PTR  
2929 e1			L2929:  POP     HL              ; pop saved pointer to char 1  
292a			  
292a			;; V-NEXT  
292a c5			L292A:  PUSH    BC              ; save flags  
292b cd b8 19		        CALL    L19B8           ; routine NEXT-ONE gets next variable in DE  
292e eb			        EX      DE,HL           ; transfer to HL.  
292f c1			        POP     BC              ; restore the flags  
2930 18 ce		        JR      L2900           ; loop back to V-EACH  
2932			                                ; to compare each variable  
2932			  
2932			; ---  
2932			  
2932			;; V-80-BYTE  
2932 cb f8		L2932:  SET     7,B             ; will signal not found  
2934			  
2934			; the branch was here when checking syntax  
2934			  
2934			;; V-SYNTAX  
2934 d1			L2934:  POP     DE              ; discard the pointer to 2nd. character  v2  
2935			                                ; in BASIC line/workspace.  
2935			  
2935 df			        RST     18H             ; GET-CHAR gets character after variable name.  
2936 fe 28		        CP      $28             ; is it '(' ?  
2938 28 09		        JR      Z,L2943         ; forward to V-PASS  
293a			                                ; Note. could go straight to V-END ?  
293a			  
293a cb e8		        SET     5,B             ; signal not an array  
293c 18 0d		        JR      L294B           ; forward to V-END  
293e			  
293e			; ---------------------------  
293e			  
293e			; the jump was here when a long name matched and HL pointing to last character  
293e			; in variables area.  
293e			  
293e			;; V-FOUND-1  
293e d1			L293E:  POP     DE              ; discard pointer to first var letter  
293f			  
293f			; the jump was here with all other matches HL points to first var char.  
293f			  
293f			;; V-FOUND-2  
293f d1			L293F:  POP     DE              ; discard pointer to 2nd prog char       v2  
2940 d1			        POP     DE              ; drop pointer to 1st prog char          v1  
2941 e5			        PUSH    HL              ; save pointer to last char in vars  
2942			  
2942 df			        RST     18H             ; GET-CHAR  
2943			  
2943			;; V-PASS  
2943 cd 88 2c		L2943:  CALL    L2C88           ; routine ALPHANUM  
2946 30 03		        JR      NC,L294B        ; forward to V-END if not  
2948			  
2948			; but it never will be as we advanced past long-named variables earlier.  
2948			  
2948 e7			        RST     20H             ; NEXT-CHAR  
2949 18 f8		        JR      L2943           ; back to V-PASS  
294b			  
294b			; ---  
294b			  
294b			;; V-END  
294b e1			L294B:  POP     HL              ; pop the pointer to first character in  
294c			                                ; BASIC line/workspace.  
294c cb 10		        RL      B               ; rotate the B register left  
294e			                                ; bit 7 to carry  
294e cb 70		        BIT     6,B             ; test the array indicator bit.  
2950 c9			        RET                     ; return  
2951			  
2951			; -----------------------  
2951			; Stack function argument  
2951			; -----------------------  
2951			; This branch is taken from LOOK-VARS when a defined function is currently  
2951			; being evaluated.  
2951			; Scanning is evaluating the expression after the '=' and the variable  
2951			; found could be in the argument list to the left of the '=' or in the  
2951			; normal place after the program. Preference will be given to the former.  
2951			; The variable name to be matched is in C.  
2951			  
2951			;; STK-F-ARG  
2951 2a 0b 5c		L2951:  LD      HL,($5C0B)      ; set HL to DEFADD  
2954 7e			        LD      A,(HL)          ; load the first character  
2955 fe 29		        CP      $29             ; is it ')' ?  
2957 ca ef 28		        JP      Z,L28EF         ; JUMP back to V-RUN/SYN, if so, as there are  
295a			                                ; no arguments.  
295a			  
295a			; but proceed to search argument list of defined function first if not empty.  
295a			  
295a			;; SFA-LOOP  
295a 7e			L295A:  LD      A,(HL)          ; fetch character again.  
295b f6 60		        OR      $60             ; or with 01100000 presume a simple variable.  
295d 47			        LD      B,A             ; save result in B.  
295e 23			        INC     HL              ; address next location.  
295f 7e			        LD      A,(HL)          ; pick up byte.  
2960 fe 0e		        CP      $0E             ; is it the number marker ?  
2962 28 07		        JR      Z,L296B         ; forward to SFA-CP-VR if so.  
2964			  
2964			; it was a string. White-space may be present but syntax has been checked.  
2964			  
2964 2b			        DEC     HL              ; point back to letter.  
2965 cd ab 28		        CALL    L28AB           ; routine FN-SKPOVR skips to the '$'  
2968 23			        INC     HL              ; now address the hidden marker.  
2969 cb a8		        RES     5,B             ; signal a string variable.  
296b			  
296b			;; SFA-CP-VR  
296b 78			L296B:  LD      A,B             ; transfer found variable letter to A.  
296c b9			        CP      C               ; compare with expected.  
296d 28 12		        JR      Z,L2981         ; forward to SFA-MATCH with a match.  
296f			  
296f 23			        INC     HL              ; step  
2970 23			        INC     HL              ; past  
2971 23			        INC     HL              ; the  
2972 23			        INC     HL              ; five  
2973 23			        INC     HL              ; bytes.  
2974			  
2974 cd ab 28		        CALL    L28AB           ; routine FN-SKPOVR skips to next character  
2977 fe 29		        CP      $29             ; is it ')' ?  
2979 ca ef 28		        JP      Z,L28EF         ; jump back if so to V-RUN/SYN to look in  
297c			                                ; normal variables area.  
297c			  
297c cd ab 28		        CALL    L28AB           ; routine FN-SKPOVR skips past the ','  
297f			                                ; all syntax has been checked and these  
297f			                                ; things can be taken as read.  
297f 18 d9		        JR      L295A           ; back to SFA-LOOP while there are more  
2981			                                ; arguments.  
2981			  
2981			; ---  
2981			  
2981			;; SFA-MATCH  
2981 cb 69		L2981:  BIT     5,C             ; test if numeric  
2983 20 0c		        JR      NZ,L2991        ; to SFA-END if so as will be stacked  
2985			                                ; by scanning  
2985			  
2985 23			        INC     HL              ; point to start of string descriptor  
2986 ed 5b 65 5c	        LD      DE,($5C65)      ; set DE to STKEND  
298a cd c0 33		        CALL    L33C0           ; routine MOVE-FP puts parameters on stack.  
298d eb			        EX      DE,HL           ; new free location to HL.  
298e 22 65 5c		        LD      ($5C65),HL      ; use it to set STKEND system variable.  
2991			  
2991			;; SFA-END  
2991 d1			L2991:  POP     DE              ; discard  
2992 d1			        POP     DE              ; pointers.  
2993 af			        XOR     A               ; clear carry flag.  
2994 3c			        INC     A               ; and zero flag.  
2995 c9			        RET                     ; return.  
2996			  
2996			; ------------------------  
2996			; Stack variable component  
2996			; ------------------------  
2996			; This is called to evaluate a complex structure that has been found, in  
2996			; runtime, by LOOK-VARS in the variables area.  
2996			; In this case HL points to the initial letter, bits 7-5  
2996			; of which indicate the type of variable.  
2996			; 010 - simple string, 110 - string array, 100 - array of numbers.  
2996			;  
2996			; It is called from CLASS-01 when assigning to a string or array including  
2996			; a slice.  
2996			; It is called from SCANNING to isolate the required part of the structure.  
2996			;  
2996			; An important part of the runtime process is to check that the number of  
2996			; dimensions of the variable match the number of subscripts supplied in the  
2996			; BASIC line.  
2996			;  
2996			; If checking syntax,  
2996			; the B register, which counts dimensions is set to zero (256) to allow  
2996			; the loop to continue till all subscripts are checked. While doing this it  
2996			; is reading dimension sizes from some arbitrary area of memory. Although  
2996			; these are meaningless it is of no concern as the limit is never checked by  
2996			; int-exp during syntax checking.  
2996			;  
2996			; The routine is also called from the syntax path of DIM command to check the  
2996			; syntax of both string and numeric arrays definitions except that bit 6 of C  
2996			; is reset so both are checked as numeric arrays. This ruse avoids a terminal  
2996			; slice being accepted as part of the DIM command.  
2996			; All that is being checked is that there are a valid set of comma-separated  
2996			; expressions before a terminal ')', although, as above, it will still go  
2996			; through the motions of checking dummy dimension sizes.  
2996			  
2996			;; STK-VAR  
2996 af			L2996:  XOR     A               ; clear A  
2997 47			        LD      B,A             ; and B, the syntax dimension counter (256)  
2998 cb 79		        BIT     7,C             ; checking syntax ?  
299a 20 4b		        JR      NZ,L29E7        ; forward to SV-COUNT if so.  
299c			  
299c			; runtime evaluation.  
299c			  
299c cb 7e		        BIT     7,(HL)          ; will be reset if a simple string.  
299e 20 0e		        JR      NZ,L29AE        ; forward to SV-ARRAYS otherwise  
29a0			  
29a0 3c			        INC     A               ; set A to 1, simple string.  
29a1			  
29a1			;; SV-SIMPLE$  
29a1 23			L29A1:  INC     HL              ; address length low  
29a2 4e			        LD      C,(HL)          ; place in C  
29a3 23			        INC     HL              ; address length high  
29a4 46			        LD      B,(HL)          ; place in B  
29a5 23			        INC     HL              ; address start of string  
29a6 eb			        EX      DE,HL           ; DE = start now.  
29a7 cd b2 2a		        CALL    L2AB2           ; routine STK-STO-$ stacks string parameters  
29aa			                                ; DE start in variables area,  
29aa			                                ; BC length, A=1 simple string  
29aa			  
29aa			; the only thing now is to consider if a slice is required.  
29aa			  
29aa df			        RST     18H             ; GET-CHAR puts character at CH_ADD in A  
29ab c3 49 2a		        JP      L2A49           ; jump forward to SV-SLICE? to test for '('  
29ae			  
29ae			; --------------------------------------------------------  
29ae			  
29ae			; the branch was here with string and numeric arrays in runtime.  
29ae			  
29ae			;; SV-ARRAYS  
29ae 23			L29AE:  INC     HL              ; step past  
29af 23			        INC     HL              ; the total length  
29b0 23			        INC     HL              ; to address Number of dimensions.  
29b1 46			        LD      B,(HL)          ; transfer to B overwriting zero.  
29b2 cb 71		        BIT     6,C             ; a numeric array ?  
29b4 28 0a		        JR      Z,L29C0         ; forward to SV-PTR with numeric arrays  
29b6			  
29b6 05			        DEC     B               ; ignore the final element of a string array  
29b7			                                ; the fixed string size.  
29b7			  
29b7 28 e8		        JR      Z,L29A1         ; back to SV-SIMPLE$ if result is zero as has  
29b9			                                ; been created with DIM a$(10) for instance  
29b9			                                ; and can be treated as a simple string.  
29b9			  
29b9			; proceed with multi-dimensioned string arrays in runtime.  
29b9			  
29b9 eb			        EX      DE,HL           ; save pointer to dimensions in DE  
29ba			  
29ba df			        RST     18H             ; GET-CHAR looks at the BASIC line  
29bb fe 28		        CP      $28             ; is character '(' ?  
29bd 20 61		        JR      NZ,L2A20        ; to REPORT-3 if not  
29bf			                                ; 'Subscript wrong'  
29bf			  
29bf eb			        EX      DE,HL           ; dimensions pointer to HL to synchronize  
29c0			                                ; with next instruction.  
29c0			  
29c0			; runtime numeric arrays path rejoins here.  
29c0			  
29c0			;; SV-PTR  
29c0 eb			L29C0:  EX      DE,HL           ; save dimension pointer in DE  
29c1 18 24		        JR      L29E7           ; forward to SV-COUNT with true no of dims   
29c3			                                ; in B. As there is no initial comma the   
29c3			                                ; loop is entered at the midpoint.  
29c3			  
29c3			; ----------------------------------------------------------  
29c3			; the dimension counting loop which is entered at mid-point.  
29c3			  
29c3			;; SV-COMMA  
29c3 e5			L29C3:  PUSH    HL              ; save counter  
29c4			  
29c4 df			        RST     18H             ; GET-CHAR  
29c5			  
29c5 e1			        POP     HL              ; pop counter  
29c6 fe 2c		        CP      $2C             ; is character ',' ?  
29c8 28 20		        JR      Z,L29EA         ; forward to SV-LOOP if so  
29ca			  
29ca			; in runtime the variable definition indicates a comma should appear here  
29ca			  
29ca cb 79		        BIT     7,C             ; checking syntax ?  
29cc 28 52		        JR      Z,L2A20         ; forward to REPORT-3 if not  
29ce			                                ; 'Subscript error'  
29ce			  
29ce			; proceed if checking syntax of an array?  
29ce			  
29ce cb 71		        BIT     6,C             ; array of strings  
29d0 20 06		        JR      NZ,L29D8        ; forward to SV-CLOSE if so  
29d2			  
29d2			; an array of numbers.  
29d2			  
29d2 fe 29		        CP      $29             ; is character ')' ?  
29d4 20 3c		        JR      NZ,L2A12        ; forward to SV-RPT-C if not  
29d6			                                ; 'Nonsense in BASIC'  
29d6			  
29d6 e7			        RST     20H             ; NEXT-CHAR moves CH-ADD past the statement  
29d7 c9			        RET                     ; return ->  
29d8			  
29d8			; ---  
29d8			  
29d8			; the branch was here with an array of strings.  
29d8			  
29d8			;; SV-CLOSE  
29d8 fe 29		L29D8:  CP      $29             ; as above ')' could follow the expression  
29da 28 6c		        JR      Z,L2A48         ; forward to SV-DIM if so  
29dc			  
29dc fe cc		        CP      $CC             ; is it 'TO' ?  
29de 20 32		        JR      NZ,L2A12        ; to SV-RPT-C with anything else  
29e0			                                ; 'Nonsense in BASIC'  
29e0			  
29e0			; now backtrack CH_ADD to set up for slicing routine.  
29e0			; Note. in a BASIC line we can safely backtrack to a colour parameter.  
29e0			  
29e0			;; SV-CH-ADD  
29e0 df			L29E0:  RST     18H             ; GET-CHAR  
29e1 2b			        DEC     HL              ; backtrack HL  
29e2 22 5d 5c		        LD      ($5C5D),HL      ; to set CH_ADD up for slicing routine  
29e5 18 5e		        JR      L2A45           ; forward to SV-SLICE and make a return  
29e7			                                ; when all slicing complete.  
29e7			  
29e7			; ----------------------------------------  
29e7			; -> the mid-point entry point of the loop  
29e7			  
29e7			;; SV-COUNT  
29e7 21 00 00		L29E7:  LD      HL,$0000        ; initialize data pointer to zero.  
29ea			  
29ea			;; SV-LOOP  
29ea e5			L29EA:  PUSH    HL              ; save the data pointer.  
29eb			  
29eb e7			        RST     20H             ; NEXT-CHAR in BASIC area points to an  
29ec			                                ; expression.  
29ec			  
29ec e1			        POP     HL              ; restore the data pointer.  
29ed 79			        LD      A,C             ; transfer name/type to A.  
29ee fe c0		        CP      $C0             ; is it 11000000 ?  
29f0			                                ; Note. the letter component is absent if  
29f0			                                ; syntax checking.  
29f0 20 09		        JR      NZ,L29FB        ; forward to SV-MULT if not an array of  
29f2			                                ; strings.  
29f2			  
29f2			; proceed to check string arrays during syntax.  
29f2			  
29f2 df			        RST     18H             ; GET-CHAR  
29f3 fe 29		        CP      $29             ; ')'  end of subscripts ?  
29f5 28 51		        JR      Z,L2A48         ; forward to SV-DIM to consider further slice  
29f7			  
29f7 fe cc		        CP      $CC             ; is it 'TO' ?  
29f9 28 e5		        JR      Z,L29E0         ; back to SV-CH-ADD to consider a slice.  
29fb			                                ; (no need to repeat get-char at L29E0)  
29fb			  
29fb			; if neither, then an expression is required so rejoin runtime loop ??  
29fb			; registers HL and DE only point to somewhere meaningful in runtime so   
29fb			; comments apply to that situation.  
29fb			  
29fb			;; SV-MULT  
29fb c5			L29FB:  PUSH    BC              ; save dimension number.  
29fc e5			        PUSH    HL              ; push data pointer/rubbish.  
29fd			                                ; DE points to current dimension.  
29fd cd ee 2a		        CALL    L2AEE           ; routine DE,(DE+1) gets next dimension in DE  
2a00			                                ; and HL points to it.  
2a00 e3			        EX      (SP),HL         ; dim pointer to stack, data pointer to HL (*)  
2a01 eb			        EX      DE,HL           ; data pointer to DE, dim size to HL.  
2a02			  
2a02 cd cc 2a		        CALL    L2ACC           ; routine INT-EXP1 checks integer expression  
2a05			                                ; and gets result in BC in runtime.  
2a05 38 19		        JR      C,L2A20         ; to REPORT-3 if > HL  
2a07			                                ; 'Subscript out of range'  
2a07			  
2a07 0b			        DEC     BC              ; adjust returned result from 1-x to 0-x  
2a08 cd f4 2a		        CALL    L2AF4           ; routine GET-HL*DE multiplies data pointer by  
2a0b			                                ; dimension size.  
2a0b 09			        ADD     HL,BC           ; add the integer returned by expression.  
2a0c d1			        POP     DE              ; pop the dimension pointer.                              ***  
2a0d c1			        POP     BC              ; pop dimension counter.  
2a0e 10 b3		        DJNZ    L29C3           ; back to SV-COMMA if more dimensions  
2a10			                                ; Note. during syntax checking, unless there  
2a10			                                ; are more than 256 subscripts, the branch  
2a10			                                ; back to SV-COMMA is always taken.  
2a10			  
2a10 cb 79		        BIT     7,C             ; are we checking syntax ?  
2a12			                                ; then we've got a joker here.  
2a12			  
2a12			;; SV-RPT-C  
2a12 20 66		L2A12:  JR      NZ,L2A7A        ; forward to SL-RPT-C if so  
2a14			                                ; 'Nonsense in BASIC'  
2a14			                                ; more than 256 subscripts in BASIC line.  
2a14			  
2a14			; but in runtime the number of subscripts are at least the same as dims  
2a14			  
2a14 e5			        PUSH    HL              ; save data pointer.  
2a15 cb 71		        BIT     6,C             ; is it a string array ?  
2a17 20 13		        JR      NZ,L2A2C        ; forward to SV-ELEM$ if so.  
2a19			  
2a19			; a runtime numeric array subscript.  
2a19			  
2a19 42			        LD      B,D             ; register DE has advanced past all dimensions  
2a1a 4b			        LD      C,E             ; and points to start of data in variable.  
2a1b			                                ; transfer it to BC.  
2a1b			  
2a1b df			        RST     18H             ; GET-CHAR checks BASIC line  
2a1c fe 29		        CP      $29             ; must be a ')' ?  
2a1e 28 02		        JR      Z,L2A22         ; skip to SV-NUMBER if so  
2a20			  
2a20			; else more subscripts in BASIC line than the variable definition.  
2a20			  
2a20			;; REPORT-3  
2a20 cf			L2A20:  RST     08H             ; ERROR-1  
2a21 02			        DEFB    $02             ; Error Report: Subscript wrong  
2a22			  
2a22			; continue if subscripts matched the numeric array.  
2a22			  
2a22			;; SV-NUMBER  
2a22 e7			L2A22:  RST     20H             ; NEXT-CHAR moves CH_ADD to next statement  
2a23			                                ; - finished parsing.  
2a23			  
2a23 e1			        POP     HL              ; pop the data pointer.  
2a24 11 05 00		        LD      DE,$0005        ; each numeric element is 5 bytes.  
2a27 cd f4 2a		        CALL    L2AF4           ; routine GET-HL*DE multiplies.  
2a2a 09			        ADD     HL,BC           ; now add to start of data in the variable.  
2a2b			  
2a2b c9			        RET                     ; return with HL pointing at the numeric  
2a2c			                                ; array subscript.                       ->  
2a2c			  
2a2c			; ---------------------------------------------------------------  
2a2c			  
2a2c			; the branch was here for string subscripts when the number of subscripts  
2a2c			; in the BASIC line was one less than in variable definition.  
2a2c			  
2a2c			;; SV-ELEM$  
2a2c cd ee 2a		L2A2C:  CALL    L2AEE           ; routine DE,(DE+1) gets final dimension  
2a2f			                                ; the length of strings in this array.  
2a2f e3			        EX      (SP),HL         ; start pointer to stack, data pointer to HL.  
2a30 cd f4 2a		        CALL    L2AF4           ; routine GET-HL*DE multiplies by element  
2a33			                                ; size.  
2a33 c1			        POP     BC              ; the start of data pointer is added  
2a34 09			        ADD     HL,BC           ; in - now points to location before.  
2a35 23			        INC     HL              ; point to start of required string.  
2a36 42			        LD      B,D             ; transfer the length (final dimension size)  
2a37 4b			        LD      C,E             ; from DE to BC.  
2a38 eb			        EX      DE,HL           ; put start in DE.  
2a39 cd b1 2a		        CALL    L2AB1           ; routine STK-ST-0 stores the string parameters  
2a3c			                                ; with A=0 - a slice or subscript.  
2a3c			  
2a3c			; now check that there were no more subscripts in the BASIC line.  
2a3c			  
2a3c df			        RST     18H             ; GET-CHAR  
2a3d fe 29		        CP      $29             ; is it ')' ?  
2a3f 28 07		        JR      Z,L2A48         ; forward to SV-DIM to consider a separate  
2a41			                                ; subscript or/and a slice.  
2a41			  
2a41 fe 2c		        CP      $2C             ; a comma is allowed if the final subscript  
2a43			                                ; is to be sliced e.g a$(2,3,4 TO 6).  
2a43 20 db		        JR      NZ,L2A20        ; to REPORT-3 with anything else  
2a45			                                ; 'Subscript error'  
2a45			  
2a45			;; SV-SLICE  
2a45 cd 52 2a		L2A45:  CALL    L2A52           ; routine SLICING slices the string.  
2a48			  
2a48			; but a slice of a simple string can itself be sliced.  
2a48			  
2a48			;; SV-DIM  
2a48 e7			L2A48:  RST     20H             ; NEXT-CHAR  
2a49			  
2a49			;; SV-SLICE?  
2a49 fe 28		L2A49:  CP      $28             ; is character '(' ?  
2a4b 28 f8		        JR      Z,L2A45         ; loop back if so to SV-SLICE  
2a4d			  
2a4d fd cb 01 b6	        RES     6,(IY+$01)      ; update FLAGS  - Signal string result  
2a51 c9			        RET                     ; and return.  
2a52			  
2a52			; ---  
2a52			  
2a52			; The above section deals with the flexible syntax allowed.  
2a52			; DIM a$(3,3,10) can be considered as two dimensional array of ten-character  
2a52			; strings or a 3-dimensional array of characters.  
2a52			; a$(1,1) will return a 10-character string as will a$(1,1,1 TO 10)  
2a52			; a$(1,1,1) will return a single character.  
2a52			; a$(1,1) (1 TO 6) is the same as a$(1,1,1 TO 6)  
2a52			; A slice can itself be sliced ad infinitum  
2a52			; b$ () () () () () () (2 TO 10) (2 TO 9) (3) is the same as b$(5)  
2a52			  
2a52			  
2a52			  
2a52			; -------------------------  
2a52			; Handle slicing of strings  
2a52			; -------------------------  
2a52			; The syntax of string slicing is very natural and it is as well to reflect  
2a52			; on the permutations possible.  
2a52			; a$() and a$( TO ) indicate the entire string although just a$ would do  
2a52			; and would avoid coming here.  
2a52			; h$(16) indicates the single character at position 16.  
2a52			; a$( TO 32) indicates the first 32 characters.  
2a52			; a$(257 TO) indicates all except the first 256 characters.  
2a52			; a$(19000 TO 19999) indicates the thousand characters at position 19000.  
2a52			; Also a$(9 TO 5) returns a null string not an error.  
2a52			; This enables a$(2 TO) to return a null string if the passed string is  
2a52			; of length zero or 1.  
2a52			; A string expression in brackets can be sliced. e.g. (STR$ PI) (3 TO )  
2a52			; We arrived here from SCANNING with CH-ADD pointing to the initial '('  
2a52			; or from above.  
2a52			  
2a52			;; SLICING  
2a52 cd 30 25		L2A52:  CALL    L2530           ; routine SYNTAX-Z  
2a55 c4 f1 2b		        CALL    NZ,L2BF1        ; routine STK-FETCH fetches parameters of  
2a58			                                ; string at runtime, start in DE, length   
2a58			                                ; in BC. This could be an array subscript.  
2a58			  
2a58 e7			        RST     20H             ; NEXT-CHAR  
2a59 fe 29		        CP      $29             ; is it ')' ?     e.g. a$()  
2a5b 28 50		        JR      Z,L2AAD         ; forward to SL-STORE to store entire string.  
2a5d			  
2a5d d5			        PUSH    DE              ; else save start address of string  
2a5e			  
2a5e af			        XOR     A               ; clear accumulator to use as a running flag.  
2a5f f5			        PUSH    AF              ; and save on stack before any branching.  
2a60			  
2a60 c5			        PUSH    BC              ; save length of string to be sliced.  
2a61 11 01 00		        LD      DE,$0001        ; default the start point to position 1.  
2a64			  
2a64 df			        RST     18H             ; GET-CHAR  
2a65			  
2a65 e1			        POP     HL              ; pop length to HL as default end point  
2a66			                                ; and limit.  
2a66			  
2a66 fe cc		        CP      $CC             ; is it 'TO' ?    e.g. a$( TO 10000)  
2a68 28 17		        JR      Z,L2A81         ; to SL-SECOND to evaluate second parameter.  
2a6a			  
2a6a f1			        POP     AF              ; pop the running flag.  
2a6b			  
2a6b cd cd 2a		        CALL    L2ACD           ; routine INT-EXP2 fetches first parameter.  
2a6e			  
2a6e f5			        PUSH    AF              ; save flag (will be $FF if parameter>limit)  
2a6f			  
2a6f 50			        LD      D,B             ; transfer the start  
2a70 59			        LD      E,C             ; to DE overwriting 0001.  
2a71 e5			        PUSH    HL              ; save original length.  
2a72			  
2a72 df			        RST     18H             ; GET-CHAR  
2a73 e1			        POP     HL              ; pop the limit length.  
2a74 fe cc		        CP      $CC             ; is it 'TO' after a start ?  
2a76 28 09		        JR      Z,L2A81         ; to SL-SECOND to evaluate second parameter  
2a78			  
2a78 fe 29		        CP      $29             ; is it ')' ?       e.g. a$(365)  
2a7a			  
2a7a			;; SL-RPT-C  
2a7a c2 8a 1c		L2A7A:  JP      NZ,L1C8A        ; jump to REPORT-C with anything else  
2a7d			                                ; 'Nonsense in BASIC'  
2a7d			  
2a7d 62			        LD      H,D             ; copy start  
2a7e 6b			        LD      L,E             ; to end - just a one character slice.  
2a7f 18 13		        JR      L2A94           ; forward to SL-DEFINE.  
2a81			  
2a81			; ---------------------  
2a81			  
2a81			;; SL-SECOND  
2a81 e5			L2A81:  PUSH    HL              ; save limit length.  
2a82			  
2a82 e7			        RST     20H             ; NEXT-CHAR  
2a83			  
2a83 e1			        POP     HL              ; pop the length.  
2a84			  
2a84 fe 29		        CP      $29             ; is character ')' ?        e.g a$(7 TO )  
2a86 28 0c		        JR      Z,L2A94         ; to SL-DEFINE using length as end point.  
2a88			  
2a88 f1			        POP     AF              ; else restore flag.  
2a89 cd cd 2a		        CALL    L2ACD           ; routine INT-EXP2 gets second expression.  
2a8c			  
2a8c f5			        PUSH    AF              ; save the running flag.  
2a8d			  
2a8d df			        RST     18H             ; GET-CHAR  
2a8e			  
2a8e 60			        LD      H,B             ; transfer second parameter  
2a8f 69			        LD      L,C             ; to HL.              e.g. a$(42 to 99)  
2a90 fe 29		        CP      $29             ; is character a ')' ?  
2a92 20 e6		        JR      NZ,L2A7A        ; to SL-RPT-C if not  
2a94			                                ; 'Nonsense in BASIC'  
2a94			  
2a94			; we now have start in DE and an end in HL.  
2a94			  
2a94			;; SL-DEFINE  
2a94 f1			L2A94:  POP     AF              ; pop the running flag.  
2a95 e3			        EX      (SP),HL         ; put end point on stack, start address to HL  
2a96 19			        ADD     HL,DE           ; add address of string to the start point.  
2a97 2b			        DEC     HL              ; point to first character of slice.  
2a98 e3			        EX      (SP),HL         ; start address to stack, end point to HL (*)  
2a99 a7			        AND     A               ; prepare to subtract.  
2a9a ed 52		        SBC     HL,DE           ; subtract start point from end point.  
2a9c 01 00 00		        LD      BC,$0000        ; default the length result to zero.  
2a9f 38 07		        JR      C,L2AA8         ; forward to SL-OVER if start > end.  
2aa1			  
2aa1 23			        INC     HL              ; increment the length for inclusive byte.  
2aa2			  
2aa2 a7			        AND     A               ; now test the running flag.  
2aa3 fa 20 2a		        JP      M,L2A20         ; jump back to REPORT-3 if $FF.  
2aa6			                                ; 'Subscript out of range'  
2aa6			  
2aa6 44			        LD      B,H             ; transfer the length  
2aa7 4d			        LD      C,L             ; to BC.  
2aa8			  
2aa8			;; SL-OVER  
2aa8 d1			L2AA8:  POP     DE              ; restore start address from machine stack ***  
2aa9 fd cb 01 b6	        RES     6,(IY+$01)      ; update FLAGS - signal string result for  
2aad			                                ; syntax.  
2aad			  
2aad			;; SL-STORE  
2aad cd 30 25		L2AAD:  CALL    L2530           ; routine SYNTAX-Z  (UNSTACK-Z?)  
2ab0 c8			        RET     Z               ; return if checking syntax.  
2ab1			                                ; but continue to store the string in runtime.  
2ab1			  
2ab1			; ------------------------------------  
2ab1			; other than from above, this routine is called from STK-VAR to stack  
2ab1			; a known string array element.  
2ab1			; ------------------------------------  
2ab1			  
2ab1			;; STK-ST-0  
2ab1 af			L2AB1:  XOR     A               ; clear to signal a sliced string or element.  
2ab2			  
2ab2			; -------------------------  
2ab2			; this routine is called from chr$, scrn$ etc. to store a simple string result.  
2ab2			; --------------------------  
2ab2			  
2ab2			;; STK-STO-$  
2ab2 fd cb 01 b6	L2AB2:  RES     6,(IY+$01)      ; update FLAGS - signal string result.  
2ab6			                                ; and continue to store parameters of string.  
2ab6			  
2ab6			; ---------------------------------------  
2ab6			; Pass five registers to calculator stack  
2ab6			; ---------------------------------------  
2ab6			; This subroutine puts five registers on the calculator stack.  
2ab6			  
2ab6			;; STK-STORE  
2ab6 c5			L2AB6:  PUSH    BC              ; save two registers  
2ab7 cd a9 33		        CALL    L33A9           ; routine TEST-5-SP checks room and puts 5   
2aba			                                ; in BC.  
2aba c1			        POP     BC              ; fetch the saved registers.  
2abb 2a 65 5c		        LD      HL,($5C65)      ; make HL point to first empty location STKEND  
2abe 77			        LD      (HL),A          ; place the 5 registers.  
2abf 23			        INC     HL              ;  
2ac0 73			        LD      (HL),E          ;  
2ac1 23			        INC     HL              ;  
2ac2 72			        LD      (HL),D          ;  
2ac3 23			        INC     HL              ;  
2ac4 71			        LD      (HL),C          ;  
2ac5 23			        INC     HL              ;  
2ac6 70			        LD      (HL),B          ;  
2ac7 23			        INC     HL              ;  
2ac8 22 65 5c		        LD      ($5C65),HL      ; update system variable STKEND.  
2acb c9			        RET                     ; and return.  
2acc			  
2acc			; -------------------------------------------  
2acc			; Return result of evaluating next expression  
2acc			; -------------------------------------------  
2acc			; This clever routine is used to check and evaluate an integer expression  
2acc			; which is returned in BC, setting A to $FF, if greater than a limit supplied  
2acc			; in HL. It is used to check array subscripts, parameters of a string slice  
2acc			; and the arguments of the DIM command. In the latter case, the limit check  
2acc			; is not required and H is set to $FF. When checking optional string slice  
2acc			; parameters, it is entered at the second entry point so as not to disturb  
2acc			; the running flag A, which may be $00 or $FF from a previous invocation.  
2acc			  
2acc			;; INT-EXP1  
2acc af			L2ACC:  XOR     A               ; set result flag to zero.  
2acd			  
2acd			; -> The entry point is here if A is used as a running flag.  
2acd			  
2acd			;; INT-EXP2  
2acd d5			L2ACD:  PUSH    DE              ; preserve DE register throughout.  
2ace e5			        PUSH    HL              ; save the supplied limit.  
2acf f5			        PUSH    AF              ; save the flag.  
2ad0			  
2ad0 cd 82 1c		        CALL    L1C82           ; routine EXPT-1NUM evaluates expression  
2ad3			                                ; at CH_ADD returning if numeric result,  
2ad3			                                ; with value on calculator stack.  
2ad3			  
2ad3 f1			        POP     AF              ; pop the flag.  
2ad4 cd 30 25		        CALL    L2530           ; routine SYNTAX-Z  
2ad7 28 12		        JR      Z,L2AEB         ; forward to I-RESTORE if checking syntax so  
2ad9			                                ; avoiding a comparison with supplied limit.  
2ad9			  
2ad9 f5			        PUSH    AF              ; save the flag.  
2ada			  
2ada cd 99 1e		        CALL    L1E99           ; routine FIND-INT2 fetches value from  
2add			                                ; calculator stack to BC producing an error  
2add			                                ; if too high.  
2add			  
2add d1			        POP     DE              ; pop the flag to D.  
2ade 78			        LD      A,B             ; test value for zero and reject  
2adf b1			        OR      C               ; as arrays and strings begin at 1.  
2ae0 37			        SCF                     ; set carry flag.  
2ae1 28 05		        JR      Z,L2AE8         ; forward to I-CARRY if zero.  
2ae3			  
2ae3 e1			        POP     HL              ; restore the limit.  
2ae4 e5			        PUSH    HL              ; and save.  
2ae5 a7			        AND     A               ; prepare to subtract.  
2ae6 ed 42		        SBC     HL,BC           ; subtract value from limit.  
2ae8			  
2ae8			;; I-CARRY  
2ae8 7a			L2AE8:  LD      A,D             ; move flag to accumulator $00 or $FF.  
2ae9 de 00		        SBC     A,$00           ; will set to $FF if carry set.  
2aeb			  
2aeb			;; I-RESTORE  
2aeb e1			L2AEB:  POP     HL              ; restore the limit.  
2aec d1			        POP     DE              ; and DE register.  
2aed c9			        RET                     ; return.  
2aee			  
2aee			  
2aee			; -----------------------  
2aee			; LD DE,(DE+1) Subroutine  
2aee			; -----------------------  
2aee			; This routine just loads the DE register with the contents of the two  
2aee			; locations following the location addressed by DE.  
2aee			; It is used to step along the 16-bit dimension sizes in array definitions.  
2aee			; Note. Such code is made into subroutines to make programs easier to  
2aee			; write and it would use less space to include the five instructions in-line.  
2aee			; However, there are so many exchanges going on at the places this is invoked  
2aee			; that to implement it in-line would make the code hard to follow.  
2aee			; It probably had a zippier label though as the intention is to simplify the  
2aee			; program.  
2aee			  
2aee			;; DE,(DE+1)  
2aee eb			L2AEE:  EX      DE,HL           ;  
2aef 23			        INC     HL              ;  
2af0 5e			        LD      E,(HL)          ;  
2af1 23			        INC     HL              ;  
2af2 56			        LD      D,(HL)          ;  
2af3 c9			        RET                     ;  
2af4			  
2af4			; -------------------  
2af4			; HL=HL*DE Subroutine  
2af4			; -------------------  
2af4			; This routine calls the mathematical routine to multiply HL by DE in runtime.  
2af4			; It is called from STK-VAR and from DIM. In the latter case syntax is not  
2af4			; being checked so the entry point could have been at the second CALL  
2af4			; instruction to save a few clock-cycles.  
2af4			  
2af4			;; GET-HL*DE  
2af4 cd 30 25		L2AF4:  CALL    L2530           ; routine SYNTAX-Z.  
2af7 c8			        RET     Z               ; return if checking syntax.  
2af8			  
2af8 cd a9 30		        CALL    L30A9           ; routine HL-HL*DE.  
2afb da 15 1f		        JP      C,L1F15         ; jump back to REPORT-4 if over 65535.  
2afe			  
2afe c9			        RET                     ; else return with 16-bit result in HL.  
2aff			  
2aff			; -----------------  
2aff			; THE 'LET' COMMAND  
2aff			; -----------------  
2aff			; Sinclair BASIC adheres to the ANSI-78 standard and a LET is required in  
2aff			; assignments e.g. LET a = 1  :   LET h$ = "hat".  
2aff			;  
2aff			; Long names may contain spaces but not colour controls (when assigned).  
2aff			; a substring can appear to the left of the equals sign.  
2aff			  
2aff			; An earlier mathematician Lewis Carroll may have been pleased that  
2aff			; 10 LET Babies cannot manage crocodiles = Babies are illogical AND  
2aff			;    Nobody is despised who can manage a crocodile AND Illogical persons  
2aff			;    are despised  
2aff			; does not give the 'Nonsense..' error if the three variables exist.  
2aff			; I digress.  
2aff			  
2aff			;; LET  
2aff 2a 4d 5c		L2AFF:  LD      HL,($5C4D)      ; fetch system variable DEST to HL.  
2b02 fd cb 37 4e	        BIT     1,(IY+$37)      ; test FLAGX - handling a new variable ?  
2b06 28 5e		        JR      Z,L2B66         ; forward to L-EXISTS if not.  
2b08			  
2b08			; continue for a new variable. DEST points to start in BASIC line.  
2b08			; from the CLASS routines.  
2b08			  
2b08 01 05 00		        LD      BC,$0005        ; assume numeric and assign an initial 5 bytes  
2b0b			  
2b0b			;; L-EACH-CH  
2b0b 03			L2B0B:  INC     BC              ; increase byte count for each relevant  
2b0c			                                ; character  
2b0c			  
2b0c			;; L-NO-SP  
2b0c 23			L2B0C:  INC     HL              ; increase pointer.  
2b0d 7e			        LD      A,(HL)          ; fetch character.  
2b0e fe 20		        CP      $20             ; is it a space ?  
2b10 28 fa		        JR      Z,L2B0C         ; back to L-NO-SP is so.  
2b12			  
2b12 30 0b		        JR      NC,L2B1F        ; forward to L-TEST-CH if higher.  
2b14			  
2b14 fe 10		        CP      $10             ; is it $00 - $0F ?  
2b16 38 11		        JR      C,L2B29         ; forward to L-SPACES if so.  
2b18			  
2b18 fe 16		        CP      $16             ; is it $16 - $1F ?  
2b1a 30 0d		        JR      NC,L2B29        ; forward to L-SPACES if so.  
2b1c			  
2b1c			; it was $10 - $15  so step over a colour code.  
2b1c			  
2b1c 23			        INC     HL              ; increase pointer.  
2b1d 18 ed		        JR      L2B0C           ; loop back to L-NO-SP.  
2b1f			  
2b1f			; ---  
2b1f			  
2b1f			; the branch was to here if higher than space.  
2b1f			  
2b1f			;; L-TEST-CH  
2b1f cd 88 2c		L2B1F:  CALL    L2C88           ; routine ALPHANUM sets carry if alphanumeric  
2b22 38 e7		        JR      C,L2B0B         ; loop back to L-EACH-CH for more if so.  
2b24			  
2b24 fe 24		        CP      $24             ; is it '$' ?  
2b26 ca c0 2b		        JP      Z,L2BC0         ; jump forward if so, to L-NEW$  
2b29			                                ; with a new string.  
2b29			  
2b29			;; L-SPACES  
2b29 79			L2B29:  LD      A,C             ; save length lo in A.  
2b2a 2a 59 5c		        LD      HL,($5C59)      ; fetch E_LINE to HL.  
2b2d 2b			        DEC     HL              ; point to location before, the variables  
2b2e			                                ; end-marker.  
2b2e cd 55 16		        CALL    L1655           ; routine MAKE-ROOM creates BC spaces  
2b31			                                ; for name and numeric value.  
2b31 23			        INC     HL              ; advance to first new location.  
2b32 23			        INC     HL              ; then to second.  
2b33 eb			        EX      DE,HL           ; set DE to second location.  
2b34 d5			        PUSH    DE              ; save this pointer.  
2b35 2a 4d 5c		        LD      HL,($5C4D)      ; reload HL with DEST.  
2b38 1b			        DEC     DE              ; point to first.  
2b39 d6 06		        SUB     $06             ; subtract six from length_lo.  
2b3b 47			        LD      B,A             ; save count in B.  
2b3c 28 11		        JR      Z,L2B4F         ; forward to L-SINGLE if it was just  
2b3e			                                ; one character.  
2b3e			  
2b3e			; HL points to start of variable name after 'LET' in BASIC line.  
2b3e			  
2b3e			;; L-CHAR  
2b3e 23			L2B3E:  INC     HL              ; increase pointer.  
2b3f 7e			        LD      A,(HL)          ; pick up character.  
2b40 fe 21		        CP      $21             ; is it space or higher ?  
2b42 38 fa		        JR      C,L2B3E         ; back to L-CHAR with space and less.  
2b44			  
2b44 f6 20		        OR      $20             ; make variable lower-case.  
2b46 13			        INC     DE              ; increase destination pointer.  
2b47 12			        LD      (DE),A          ; and load to edit line.  
2b48 10 f4		        DJNZ    L2B3E           ; loop back to L-CHAR until B is zero.  
2b4a			  
2b4a f6 80		        OR      $80             ; invert the last character.  
2b4c 12			        LD      (DE),A          ; and overwrite that in edit line.  
2b4d			  
2b4d			; now consider first character which has bit 6 set  
2b4d			  
2b4d 3e c0		        LD      A,$C0           ; set A 11000000 is xor mask for a long name.  
2b4f			                                ; %101      is xor/or  result  
2b4f			  
2b4f			; single character numerics rejoin here with %00000000 in mask.  
2b4f			;                                            %011      will be xor/or result  
2b4f			  
2b4f			;; L-SINGLE  
2b4f 2a 4d 5c		L2B4F:  LD      HL,($5C4D)      ; fetch DEST - HL addresses first character.  
2b52 ae			        XOR     (HL)            ; apply variable type indicator mask (above).  
2b53 f6 20		        OR      $20             ; make lowercase - set bit 5.  
2b55 e1			        POP     HL              ; restore pointer to 2nd character.  
2b56 cd ea 2b		        CALL    L2BEA           ; routine L-FIRST puts A in first character.  
2b59			                                ; and returns with HL holding  
2b59			                                ; new E_LINE-1  the $80 vars end-marker.  
2b59			  
2b59			;; L-NUMERIC  
2b59 e5			L2B59:  PUSH    HL              ; save the pointer.  
2b5a			  
2b5a			; the value of variable is deleted but remains after calculator stack.  
2b5a			  
2b5a ef			        RST     28H             ;; FP-CALC  
2b5b 02			        DEFB    $02             ;;delete      ; delete variable value  
2b5c 38			        DEFB    $38             ;;end-calc  
2b5d			  
2b5d			; DE (STKEND) points to start of value.  
2b5d			  
2b5d e1			        POP     HL              ; restore the pointer.  
2b5e 01 05 00		        LD      BC,$0005        ; start of number is five bytes before.  
2b61 a7			        AND     A               ; prepare for true subtraction.  
2b62 ed 42		        SBC     HL,BC           ; HL points to start of value.  
2b64 18 40		        JR      L2BA6           ; forward to L-ENTER  ==>  
2b66			  
2b66			; ---  
2b66			  
2b66			  
2b66			; the jump was to here if the variable already existed.  
2b66			  
2b66			;; L-EXISTS  
2b66 fd cb 01 76	L2B66:  BIT     6,(IY+$01)      ; test FLAGS - numeric or string result ?  
2b6a 28 06		        JR      Z,L2B72         ; skip forward to L-DELETE$   -*->  
2b6c			                                ; if string result.  
2b6c			  
2b6c			; A numeric variable could be simple or an array element.  
2b6c			; They are treated the same and the old value is overwritten.  
2b6c			  
2b6c 11 06 00		        LD      DE,$0006        ; six bytes forward points to loc past value.  
2b6f 19			        ADD     HL,DE           ; add to start of number.  
2b70 18 e7		        JR      L2B59           ; back to L-NUMERIC to overwrite value.  
2b72			  
2b72			; ---  
2b72			  
2b72			; -*-> the branch was here if a string existed.  
2b72			  
2b72			;; L-DELETE$  
2b72 2a 4d 5c		L2B72:  LD      HL,($5C4D)      ; fetch DEST to HL.  
2b75			                                ; (still set from first instruction)  
2b75 ed 4b 72 5c	        LD      BC,($5C72)      ; fetch STRLEN to BC.  
2b79 fd cb 37 46	        BIT     0,(IY+$37)      ; test FLAGX - handling a complete simple  
2b7d			                                ; string ?  
2b7d 20 30		        JR      NZ,L2BAF        ; forward to L-ADD$ if so.  
2b7f			  
2b7f			; must be a string array or a slice in workspace.  
2b7f			; Note. LET a$(3 TO 6) = h$   will assign "hat " if h$ = "hat"  
2b7f			;                                  and    "hats" if h$ = "hatstand".  
2b7f			;  
2b7f			; This is known as Procrustian lengthening and shortening after a  
2b7f			; character Procrustes in Greek legend who made travellers sleep in his bed,  
2b7f			; cutting off their feet or stretching them so they fitted the bed perfectly.  
2b7f			; The bloke was hatstand and slain by Theseus.  
2b7f			  
2b7f 78			        LD      A,B             ; test if length  
2b80 b1			        OR      C               ; is zero and  
2b81 c8			        RET     Z               ; return if so.  
2b82			  
2b82 e5			        PUSH    HL              ; save pointer to start.  
2b83			  
2b83 f7			        RST     30H             ; BC-SPACES creates room.  
2b84 d5			        PUSH    DE              ; save pointer to first new location.  
2b85 c5			        PUSH    BC              ; and length            (*)  
2b86 54			        LD      D,H             ; set DE to point to last location.  
2b87 5d			        LD      E,L             ;  
2b88 23			        INC     HL              ; set HL to next location.  
2b89 36 20		        LD      (HL),$20        ; place a space there.  
2b8b ed b8		        LDDR                    ; copy bytes filling with spaces.  
2b8d			  
2b8d e5			        PUSH    HL              ; save pointer to start.  
2b8e cd f1 2b		        CALL    L2BF1           ; routine STK-FETCH start to DE,  
2b91			                                ; length to BC.  
2b91 e1			        POP     HL              ; restore the pointer.  
2b92 e3			        EX      (SP),HL         ; (*) length to HL, pointer to stack.  
2b93 a7			        AND     A               ; prepare for true subtraction.  
2b94 ed 42		        SBC     HL,BC           ; subtract old length from new.  
2b96 09			        ADD     HL,BC           ; and add back.  
2b97 30 02		        JR      NC,L2B9B        ; forward if it fits to L-LENGTH.  
2b99			  
2b99 44			        LD      B,H             ; otherwise set  
2b9a 4d			        LD      C,L             ; length to old length.  
2b9b			                                ; "hatstand" becomes "hats"  
2b9b			  
2b9b			;; L-LENGTH  
2b9b e3			L2B9B:  EX      (SP),HL         ; (*) length to stack, pointer to HL.  
2b9c eb			        EX      DE,HL           ; pointer to DE, start of string to HL.  
2b9d 78			        LD      A,B             ; is the length zero ?  
2b9e b1			        OR      C               ;  
2b9f 28 02		        JR      Z,L2BA3         ; forward to L-IN-W/S if so  
2ba1			                                ; leaving prepared spaces.  
2ba1			  
2ba1 ed b0		        LDIR                    ; else copy bytes overwriting some spaces.  
2ba3			  
2ba3			;; L-IN-W/S  
2ba3 c1			L2BA3:  POP     BC              ; pop the new length.  (*)  
2ba4 d1			        POP     DE              ; pop pointer to new area.  
2ba5 e1			        POP     HL              ; pop pointer to variable in assignment.  
2ba6			                                ; and continue copying from workspace  
2ba6			                                ; to variables area.  
2ba6			  
2ba6			; ==> branch here from  L-NUMERIC  
2ba6			  
2ba6			;; L-ENTER  
2ba6 eb			L2BA6:  EX      DE,HL           ; exchange pointers HL=STKEND DE=end of vars.  
2ba7 78			        LD      A,B             ; test the length  
2ba8 b1			        OR      C               ; and make a   
2ba9 c8			        RET     Z               ; return if zero (strings only).  
2baa			  
2baa d5			        PUSH    DE              ; save start of destination.  
2bab ed b0		        LDIR                    ; copy bytes.  
2bad e1			        POP     HL              ; address the start.  
2bae c9			        RET                     ; and return.  
2baf			  
2baf			; ---  
2baf			  
2baf			; the branch was here from L-DELETE$ if an existing simple string.  
2baf			; register HL addresses start of string in variables area.  
2baf			  
2baf			;; L-ADD$  
2baf 2b			L2BAF:  DEC     HL              ; point to high byte of length.  
2bb0 2b			        DEC     HL              ; to low byte.  
2bb1 2b			        DEC     HL              ; to letter.  
2bb2 7e			        LD      A,(HL)          ; fetch masked letter to A.  
2bb3 e5			        PUSH    HL              ; save the pointer on stack.  
2bb4 c5			        PUSH    BC              ; save new length.  
2bb5 cd c6 2b		        CALL    L2BC6           ; routine L-STRING adds new string at end  
2bb8			                                ; of variables area.  
2bb8			                                ; if no room we still have old one.  
2bb8 c1			        POP     BC              ; restore length.  
2bb9 e1			        POP     HL              ; restore start.  
2bba 03			        INC     BC              ; increase  
2bbb 03			        INC     BC              ; length by three  
2bbc 03			        INC     BC              ; to include character and length bytes.  
2bbd c3 e8 19		        JP      L19E8           ; jump to indirect exit via RECLAIM-2  
2bc0			                                ; deleting old version and adjusting pointers.  
2bc0			  
2bc0			; ---  
2bc0			  
2bc0			; the jump was here with a new string variable.  
2bc0			  
2bc0			;; L-NEW$  
2bc0 3e df		L2BC0:  LD      A,$DF           ; indicator mask %11011111 for  
2bc2			                                ;                %010xxxxx will be result  
2bc2 2a 4d 5c		        LD      HL,($5C4D)      ; address DEST first character.  
2bc5 a6			        AND     (HL)            ; combine mask with character.  
2bc6			  
2bc6			;; L-STRING  
2bc6 f5			L2BC6:  PUSH    AF              ; save first character and mask.  
2bc7 cd f1 2b		        CALL    L2BF1           ; routine STK-FETCH fetches parameters of  
2bca			                                ; the string.  
2bca eb			        EX      DE,HL           ; transfer start to HL.  
2bcb 09			        ADD     HL,BC           ; add to length.  
2bcc c5			        PUSH    BC              ; save the length.  
2bcd 2b			        DEC     HL              ; point to end of string.  
2bce 22 4d 5c		        LD      ($5C4D),HL      ; save pointer in DEST.  
2bd1			                                ; (updated by POINTERS if in workspace)  
2bd1 03			        INC     BC              ; extra byte for letter.  
2bd2 03			        INC     BC              ; two bytes  
2bd3 03			        INC     BC              ; for the length of string.  
2bd4 2a 59 5c		        LD      HL,($5C59)      ; address E_LINE.  
2bd7 2b			        DEC     HL              ; now end of VARS area.  
2bd8 cd 55 16		        CALL    L1655           ; routine MAKE-ROOM makes room for string.  
2bdb			                                ; updating pointers including DEST.  
2bdb 2a 4d 5c		        LD      HL,($5C4D)      ; pick up pointer to end of string from DEST.  
2bde c1			        POP     BC              ; restore length from stack.  
2bdf c5			        PUSH    BC              ; and save again on stack.  
2be0 03			        INC     BC              ; add a byte.  
2be1 ed b8		        LDDR                    ; copy bytes from end to start.  
2be3 eb			        EX      DE,HL           ; HL addresses length low  
2be4 23			        INC     HL              ; increase to address high byte  
2be5 c1			        POP     BC              ; restore length to BC  
2be6 70			        LD      (HL),B          ; insert high byte  
2be7 2b			        DEC     HL              ; address low byte location  
2be8 71			        LD      (HL),C          ; insert that byte  
2be9 f1			        POP     AF              ; restore character and mask  
2bea			  
2bea			;; L-FIRST  
2bea 2b			L2BEA:  DEC     HL              ; address variable name  
2beb 77			        LD      (HL),A          ; and insert character.  
2bec 2a 59 5c		        LD      HL,($5C59)      ; load HL with E_LINE.  
2bef 2b			        DEC     HL              ; now end of VARS area.  
2bf0 c9			        RET                     ; return  
2bf1			  
2bf1			; ------------------------------------  
2bf1			; Get last value from calculator stack  
2bf1			; ------------------------------------  
2bf1			;  
2bf1			;  
2bf1			  
2bf1			;; STK-FETCH  
2bf1 2a 65 5c		L2BF1:  LD      HL,($5C65)      ; STKEND  
2bf4 2b			        DEC     HL              ;  
2bf5 46			        LD      B,(HL)          ;  
2bf6 2b			        DEC     HL              ;  
2bf7 4e			        LD      C,(HL)          ;  
2bf8 2b			        DEC     HL              ;  
2bf9 56			        LD      D,(HL)          ;  
2bfa 2b			        DEC     HL              ;  
2bfb 5e			        LD      E,(HL)          ;  
2bfc 2b			        DEC     HL              ;  
2bfd 7e			        LD      A,(HL)          ;  
2bfe 22 65 5c		        LD      ($5C65),HL      ; STKEND  
2c01 c9			        RET                     ;  
2c02			  
2c02			; ------------------  
2c02			; Handle DIM command  
2c02			; ------------------  
2c02			; e.g. DIM a(2,3,4,7): DIM a$(32) : DIM b$(300,2,768) : DIM c$(20000)  
2c02			; the only limit to dimensions is memory so, for example,  
2c02			; DIM a(2,2,2,2,2,2,2,2,2,2,2,2,2) is possible and creates a multi-  
2c02			; dimensional array of zeros. String arrays are initialized to spaces.  
2c02			; It is not possible to erase an array, but it can be re-dimensioned to  
2c02			; a minimal size of 1, after use, to free up memory.  
2c02			  
2c02			;; DIM  
2c02 cd b2 28		L2C02:  CALL    L28B2           ; routine LOOK-VARS  
2c05			  
2c05			;; D-RPORT-C  
2c05 c2 8a 1c		L2C05:  JP      NZ,L1C8A        ; jump to REPORT-C if a long-name variable.  
2c08			                                ; DIM lottery numbers(49) doesn't work.  
2c08			  
2c08 cd 30 25		        CALL    L2530           ; routine SYNTAX-Z  
2c0b 20 08		        JR      NZ,L2C15        ; forward to D-RUN in runtime.  
2c0d			  
2c0d cb b1		        RES     6,C             ; signal 'numeric' array even if string as  
2c0f			                                ; this simplifies the syntax checking.  
2c0f			  
2c0f cd 96 29		        CALL    L2996           ; routine STK-VAR checks syntax.  
2c12 cd ee 1b		        CALL    L1BEE           ; routine CHECK-END performs early exit ->  
2c15			  
2c15			; the branch was here in runtime.  
2c15			  
2c15			;; D-RUN  
2c15 38 08		L2C15:  JR      C,L2C1F         ; skip to D-LETTER if variable did not exist.  
2c17			                                ; else reclaim the old one.  
2c17			  
2c17 c5			        PUSH    BC              ; save type in C.  
2c18 cd b8 19		        CALL    L19B8           ; routine NEXT-ONE find following variable  
2c1b			                                ; or position of $80 end-marker.  
2c1b cd e8 19		        CALL    L19E8           ; routine RECLAIM-2 reclaims the   
2c1e			                                ; space between.  
2c1e c1			        POP     BC              ; pop the type.  
2c1f			  
2c1f			;; D-LETTER  
2c1f cb f9		L2C1F:  SET     7,C             ; signal array.  
2c21 06 00		        LD      B,$00           ; initialize dimensions to zero and  
2c23 c5			        PUSH    BC              ; save with the type.  
2c24 21 01 00		        LD      HL,$0001        ; make elements one character presuming string  
2c27 cb 71		        BIT     6,C             ; is it a string ?  
2c29 20 02		        JR      NZ,L2C2D        ; forward to D-SIZE if so.  
2c2b			  
2c2b 2e 05		        LD      L,$05           ; make elements 5 bytes as is numeric.  
2c2d			  
2c2d			;; D-SIZE  
2c2d eb			L2C2D:  EX      DE,HL           ; save the element size in DE.  
2c2e			  
2c2e			; now enter a loop to parse each of the integers in the list.  
2c2e			  
2c2e			;; D-NO-LOOP  
2c2e e7			L2C2E:  RST     20H             ; NEXT-CHAR  
2c2f 26 ff		        LD      H,$FF           ; disable limit check by setting HL high  
2c31 cd cc 2a		        CALL    L2ACC           ; routine INT-EXP1  
2c34 da 20 2a		        JP      C,L2A20         ; to REPORT-3 if > 65280 and then some  
2c37			                                ; 'Subscript out of range'  
2c37			  
2c37 e1			        POP     HL              ; pop dimension counter, array type  
2c38 c5			        PUSH    BC              ; save dimension size                     ***  
2c39 24			        INC     H               ; increment the dimension counter  
2c3a e5			        PUSH    HL              ; save the dimension counter  
2c3b 60			        LD      H,B             ; transfer size  
2c3c 69			        LD      L,C             ; to HL  
2c3d cd f4 2a		        CALL    L2AF4           ; routine GET-HL*DE multiplies dimension by  
2c40			                                ; running total of size required initially  
2c40			                                ; 1 or 5.  
2c40 eb			        EX      DE,HL           ; save running total in DE  
2c41			  
2c41 df			        RST     18H             ; GET-CHAR  
2c42 fe 2c		        CP      $2C             ; is it ',' ?  
2c44 28 e8		        JR      Z,L2C2E         ; loop back to D-NO-LOOP until all dimensions  
2c46			                                ; have been considered  
2c46			  
2c46			; when loop complete continue.  
2c46			  
2c46 fe 29		        CP      $29             ; is it ')' ?  
2c48 20 bb		        JR      NZ,L2C05        ; to D-RPORT-C with anything else  
2c4a			                                ; 'Nonsense in BASIC'  
2c4a			  
2c4a			  
2c4a e7			        RST     20H             ; NEXT-CHAR advances to next statement/CR  
2c4b			  
2c4b c1			        POP     BC              ; pop dimension counter/type  
2c4c 79			        LD      A,C             ; type to A  
2c4d			  
2c4d			; now calculate space required for array variable  
2c4d			  
2c4d 68			        LD      L,B             ; dimensions to L since these require 16 bits  
2c4e			                                ; then this value will be doubled  
2c4e 26 00		        LD      H,$00           ; set high byte to zero  
2c50			  
2c50			; another four bytes are required for letter(1), total length(2), number of  
2c50			; dimensions(1) but since we have yet to double allow for two  
2c50			  
2c50 23			        INC     HL              ; increment  
2c51 23			        INC     HL              ; increment  
2c52			  
2c52 29			        ADD     HL,HL           ; now double giving 4 + dimensions * 2  
2c53			  
2c53 19			        ADD     HL,DE           ; add to space required for array contents  
2c54			  
2c54 da 15 1f		        JP      C,L1F15         ; to REPORT-4 if > 65535  
2c57			                                ; 'Out of memory'  
2c57			  
2c57 d5			        PUSH    DE              ; save data space  
2c58 c5			        PUSH    BC              ; save dimensions/type  
2c59 e5			        PUSH    HL              ; save total space  
2c5a 44			        LD      B,H             ; total space  
2c5b 4d			        LD      C,L             ; to BC  
2c5c 2a 59 5c		        LD      HL,($5C59)      ; address E_LINE - first location after  
2c5f			                                ; variables area  
2c5f 2b			        DEC     HL              ; point to location before - the $80 end-marker  
2c60 cd 55 16		        CALL    L1655           ; routine MAKE-ROOM creates the space if  
2c63			                                ; memory is available.  
2c63			  
2c63 23			        INC     HL              ; point to first new location and  
2c64 77			        LD      (HL),A          ; store letter/type  
2c65			  
2c65 c1			        POP     BC              ; pop total space  
2c66 0b			        DEC     BC              ; exclude name  
2c67 0b			        DEC     BC              ; exclude the 16-bit  
2c68 0b			        DEC     BC              ; counter itself  
2c69 23			        INC     HL              ; point to next location the 16-bit counter  
2c6a 71			        LD      (HL),C          ; insert low byte  
2c6b 23			        INC     HL              ; address next  
2c6c 70			        LD      (HL),B          ; insert high byte  
2c6d			  
2c6d c1			        POP     BC              ; pop the number of dimensions.  
2c6e 78			        LD      A,B             ; dimensions to A  
2c6f 23			        INC     HL              ; address next  
2c70 77			        LD      (HL),A          ; and insert "No. of dims"  
2c71			  
2c71 62			        LD      H,D             ; transfer DE space + 1 from make-room  
2c72 6b			        LD      L,E             ; to HL  
2c73 1b			        DEC     DE              ; set DE to next location down.  
2c74 36 00		        LD      (HL),$00        ; presume numeric and insert a zero  
2c76 cb 71		        BIT     6,C             ; test bit 6 of C. numeric or string ?  
2c78 28 02		        JR      Z,L2C7C         ; skip to DIM-CLEAR if numeric  
2c7a			  
2c7a 36 20		        LD      (HL),$20        ; place a space character in HL  
2c7c			  
2c7c			;; DIM-CLEAR  
2c7c c1			L2C7C:  POP     BC              ; pop the data length  
2c7d			  
2c7d ed b8		        LDDR                    ; LDDR sets to zeros or spaces  
2c7f			  
2c7f			; The number of dimensions is still in A.  
2c7f			; A loop is now entered to insert the size of each dimension that was pushed  
2c7f			; during the D-NO-LOOP working downwards from position before start of data.  
2c7f			  
2c7f			;; DIM-SIZES  
2c7f c1			L2C7F:  POP     BC              ; pop a dimension size                    ***  
2c80 70			        LD      (HL),B          ; insert high byte at position  
2c81 2b			        DEC     HL              ; next location down  
2c82 71			        LD      (HL),C          ; insert low byte  
2c83 2b			        DEC     HL              ; next location down  
2c84 3d			        DEC     A               ; decrement dimension counter  
2c85 20 f8		        JR      NZ,L2C7F        ; back to DIM-SIZES until all done.  
2c87			  
2c87 c9			        RET                     ; return.  
2c88			  
2c88			; -----------------------------  
2c88			; Check whether digit or letter  
2c88			; -----------------------------  
2c88			; This routine checks that the character in A is alphanumeric  
2c88			; returning with carry set if so.  
2c88			  
2c88			;; ALPHANUM  
2c88 cd 1b 2d		L2C88:  CALL    L2D1B           ; routine NUMERIC will reset carry if so.  
2c8b 3f			        CCF                     ; Complement Carry Flag  
2c8c d8			        RET     C               ; Return if numeric else continue into  
2c8d			                                ; next routine.  
2c8d			  
2c8d			; This routine checks that the character in A is alphabetic  
2c8d			  
2c8d			;; ALPHA  
2c8d fe 41		L2C8D:  CP      $41             ; less than 'A' ?  
2c8f 3f			        CCF                     ; Complement Carry Flag  
2c90 d0			        RET     NC              ; return if so  
2c91			  
2c91 fe 5b		        CP      $5B             ; less than 'Z'+1 ?  
2c93 d8			        RET     C               ; is within first range  
2c94			  
2c94 fe 61		        CP      $61             ; less than 'a' ?  
2c96 3f			        CCF                     ; Complement Carry Flag  
2c97 d0			        RET     NC              ; return if so.  
2c98			  
2c98 fe 7b		        CP      $7B             ; less than 'z'+1 ?  
2c9a c9			        RET                     ; carry set if within a-z.  
2c9b			  
2c9b			; -------------------------  
2c9b			; Decimal to floating point  
2c9b			; -------------------------  
2c9b			; This routine finds the floating point number represented by an expression  
2c9b			; beginning with BIN, '.' or a digit.  
2c9b			; Note that BIN need not have any '0's or '1's after it.  
2c9b			; BIN is really just a notational symbol and not a function.  
2c9b			  
2c9b			;; DEC-TO-FP  
2c9b fe c4		L2C9B:  CP      $C4             ; 'BIN' token ?  
2c9d 20 19		        JR      NZ,L2CB8        ; to NOT-BIN if not  
2c9f			  
2c9f 11 00 00		        LD      DE,$0000        ; initialize 16 bit buffer register.  
2ca2			  
2ca2			;; BIN-DIGIT  
2ca2 e7			L2CA2:  RST     20H             ; NEXT-CHAR  
2ca3 d6 31		        SUB     $31             ; '1'  
2ca5 ce 00		        ADC     A,$00           ; will be zero if '1' or '0'  
2ca7			                                ; carry will be set if was '0'  
2ca7 20 0a		        JR      NZ,L2CB3        ; forward to BIN-END if result not zero  
2ca9			  
2ca9 eb			        EX      DE,HL           ; buffer to HL  
2caa 3f			        CCF                     ; Carry now set if originally '1'  
2cab ed 6a		        ADC     HL,HL           ; shift the carry into HL  
2cad da ad 31		        JP      C,L31AD         ; to REPORT-6 if overflow - too many digits  
2cb0			                                ; after first '1'. There can be an unlimited  
2cb0			                                ; number of leading zeros.  
2cb0			                                ; 'Number too big' - raise an error  
2cb0			  
2cb0 eb			        EX      DE,HL           ; save the buffer  
2cb1 18 ef		        JR      L2CA2           ; back to BIN-DIGIT for more digits  
2cb3			  
2cb3			; ---  
2cb3			  
2cb3			;; BIN-END  
2cb3 42			L2CB3:  LD      B,D             ; transfer 16 bit buffer  
2cb4 4b			        LD      C,E             ; to BC register pair.  
2cb5 c3 2b 2d		        JP      L2D2B           ; JUMP to STACK-BC to put on calculator stack  
2cb8			  
2cb8			; ---  
2cb8			  
2cb8			; continue here with .1,  42, 3.14, 5., 2.3 E -4  
2cb8			  
2cb8			;; NOT-BIN  
2cb8 fe 2e		L2CB8:  CP      $2E             ; '.' - leading decimal point ?  
2cba 28 0f		        JR      Z,L2CCB         ; skip to DECIMAL if so.  
2cbc			  
2cbc cd 3b 2d		        CALL    L2D3B           ; routine INT-TO-FP to evaluate all digits  
2cbf			                                ; This number 'x' is placed on stack.  
2cbf fe 2e		        CP      $2E             ; '.' - mid decimal point ?  
2cc1			  
2cc1 20 28		        JR      NZ,L2CEB        ; to E-FORMAT if not to consider that format  
2cc3			  
2cc3 e7			        RST     20H             ; NEXT-CHAR  
2cc4 cd 1b 2d		        CALL    L2D1B           ; routine NUMERIC returns carry reset if 0-9  
2cc7			  
2cc7 38 22		        JR      C,L2CEB         ; to E-FORMAT if not a digit e.g. '1.'  
2cc9			  
2cc9 18 0a		        JR      L2CD5           ; to DEC-STO-1 to add the decimal part to 'x'  
2ccb			  
2ccb			; ---  
2ccb			  
2ccb			; a leading decimal point has been found in a number.  
2ccb			  
2ccb			;; DECIMAL  
2ccb e7			L2CCB:  RST     20H             ; NEXT-CHAR  
2ccc cd 1b 2d		        CALL    L2D1B           ; routine NUMERIC will reset carry if digit  
2ccf			  
2ccf			;; DEC-RPT-C  
2ccf da 8a 1c		L2CCF:  JP      C,L1C8A         ; to REPORT-C if just a '.'  
2cd2			                                ; raise 'Nonsense in BASIC'  
2cd2			  
2cd2			; since there is no leading zero put one on the calculator stack.  
2cd2			  
2cd2 ef			        RST     28H             ;; FP-CALC  
2cd3 a0			        DEFB    $A0             ;;stk-zero  ; 0.  
2cd4 38			        DEFB    $38             ;;end-calc  
2cd5			  
2cd5			; If rejoining from earlier there will be a value 'x' on stack.  
2cd5			; If continuing from above the value zero.  
2cd5			; Now store 1 in mem-0.  
2cd5			; Note. At each pass of the digit loop this will be divided by ten.  
2cd5			  
2cd5			;; DEC-STO-1  
2cd5 ef			L2CD5:  RST     28H             ;; FP-CALC  
2cd6 a1			        DEFB    $A1             ;;stk-one   ;x or 0,1.  
2cd7 c0			        DEFB    $C0             ;;st-mem-0  ;x or 0,1.  
2cd8 02			        DEFB    $02             ;;delete    ;x or 0.  
2cd9 38			        DEFB    $38             ;;end-calc  
2cda			  
2cda			  
2cda			;; NXT-DGT-1  
2cda df			L2CDA:  RST     18H             ; GET-CHAR  
2cdb cd 22 2d		        CALL    L2D22           ; routine STK-DIGIT stacks single digit 'd'  
2cde 38 0b		        JR      C,L2CEB         ; exit to E-FORMAT when digits exhausted  >  
2ce0			  
2ce0			  
2ce0 ef			        RST     28H             ;; FP-CALC   ;x or 0,d.           first pass.  
2ce1 e0			        DEFB    $E0             ;;get-mem-0  ;x or 0,d,1.  
2ce2 a4			        DEFB    $A4             ;;stk-ten    ;x or 0,d,1,10.  
2ce3 05			        DEFB    $05             ;;division   ;x or 0,d,1/10.  
2ce4 c0			        DEFB    $C0             ;;st-mem-0   ;x or 0,d,1/10.  
2ce5 04			        DEFB    $04             ;;multiply   ;x or 0,d/10.  
2ce6 0f			        DEFB    $0F             ;;addition   ;x or 0 + d/10.  
2ce7 38			        DEFB    $38             ;;end-calc   last value.  
2ce8			  
2ce8 e7			        RST     20H             ; NEXT-CHAR  moves to next character  
2ce9 18 ef		        JR      L2CDA           ; back to NXT-DGT-1  
2ceb			  
2ceb			; ---  
2ceb			  
2ceb			; although only the first pass is shown it can be seen that at each pass  
2ceb			; the new less significant digit is multiplied by an increasingly smaller  
2ceb			; factor (1/100, 1/1000, 1/10000 ... ) before being added to the previous  
2ceb			; last value to form a new last value.  
2ceb			  
2ceb			; Finally see if an exponent has been input.  
2ceb			  
2ceb			;; E-FORMAT  
2ceb fe 45		L2CEB:  CP      $45             ; is character 'E' ?  
2ced 28 03		        JR      Z,L2CF2         ; to SIGN-FLAG if so  
2cef			  
2cef fe 65		        CP      $65             ; 'e' is acceptable as well.  
2cf1 c0			        RET     NZ              ; return as no exponent.  
2cf2			  
2cf2			;; SIGN-FLAG  
2cf2 06 ff		L2CF2:  LD      B,$FF           ; initialize temporary sign byte to $FF  
2cf4			  
2cf4 e7			        RST     20H             ; NEXT-CHAR  
2cf5 fe 2b		        CP      $2B             ; is character '+' ?  
2cf7 28 05		        JR      Z,L2CFE         ; to SIGN-DONE  
2cf9			  
2cf9 fe 2d		        CP      $2D             ; is character '-' ?  
2cfb 20 02		        JR      NZ,L2CFF        ; to ST-E-PART as no sign  
2cfd			  
2cfd 04			        INC     B               ; set sign to zero  
2cfe			  
2cfe			; now consider digits of exponent.  
2cfe			; Note. incidentally this is the only occasion in Spectrum BASIC when an  
2cfe			; expression may not be used when a number is expected.  
2cfe			  
2cfe			;; SIGN-DONE  
2cfe e7			L2CFE:  RST     20H             ; NEXT-CHAR  
2cff			  
2cff			;; ST-E-PART  
2cff cd 1b 2d		L2CFF:  CALL    L2D1B           ; routine NUMERIC  
2d02 38 cb		        JR      C,L2CCF         ; to DEC-RPT-C if not  
2d04			                                ; raise 'Nonsense in BASIC'.  
2d04			  
2d04 c5			        PUSH    BC              ; save sign (in B)  
2d05 cd 3b 2d		        CALL    L2D3B           ; routine INT-TO-FP places exponent on stack  
2d08 cd d5 2d		        CALL    L2DD5           ; routine FP-TO-A  transfers it to A  
2d0b c1			        POP     BC              ; restore sign  
2d0c da ad 31		        JP      C,L31AD         ; to REPORT-6 if overflow (over 255)  
2d0f			                                ; raise 'Number too big'.  
2d0f			  
2d0f a7			        AND     A               ; set flags  
2d10 fa ad 31		        JP      M,L31AD         ; to REPORT-6 if over '127'.  
2d13			                                ; raise 'Number too big'.  
2d13			                                ; 127 is still way too high and it is  
2d13			                                ; impossible to enter an exponent greater  
2d13			                                ; than 39 from the keyboard. The error gets  
2d13			                                ; raised later in E-TO-FP so two different  
2d13			                                ; error messages depending how high A is.  
2d13			  
2d13 04			        INC     B               ; $FF to $00 or $00 to $01 - expendable now.  
2d14 28 02		        JR      Z,L2D18         ; forward to E-FP-JUMP if exponent positive  
2d16			  
2d16 ed 44		        NEG                     ; Negate the exponent.  
2d18			  
2d18			;; E-FP-JUMP  
2d18 c3 4f 2d		L2D18:  JP      L2D4F           ; JUMP forward to E-TO-FP to assign to  
2d1b			                                ; last value x on stack x * 10 to power A  
2d1b			                                ; a relative jump would have done.  
2d1b			  
2d1b			; ---------------------  
2d1b			; Check for valid digit  
2d1b			; ---------------------  
2d1b			; This routine checks that the ASCII character in A is numeric  
2d1b			; returning with carry reset if so.  
2d1b			  
2d1b			;; NUMERIC  
2d1b fe 30		L2D1B:  CP      $30             ; '0'  
2d1d d8			        RET     C               ; return if less than zero character.  
2d1e			  
2d1e fe 3a		        CP      $3A             ; The upper test is '9'  
2d20 3f			        CCF                     ; Complement Carry Flag  
2d21 c9			        RET                     ; Return - carry clear if character '0' - '9'  
2d22			  
2d22			; -----------  
2d22			; Stack Digit  
2d22			; -----------  
2d22			; This subroutine is called from INT-TO-FP and DEC-TO-FP to stack a digit  
2d22			; on the calculator stack.  
2d22			  
2d22			;; STK-DIGIT  
2d22 cd 1b 2d		L2D22:  CALL    L2D1B           ; routine NUMERIC  
2d25 d8			        RET     C               ; return if not numeric character  
2d26			  
2d26 d6 30		        SUB     $30             ; convert from ASCII to digit  
2d28			  
2d28			; -----------------  
2d28			; Stack accumulator  
2d28			; -----------------  
2d28			;  
2d28			;  
2d28			  
2d28			;; STACK-A  
2d28 4f			L2D28:  LD      C,A             ; transfer to C  
2d29 06 00		        LD      B,$00           ; and make B zero  
2d2b			  
2d2b			; ----------------------  
2d2b			; Stack BC register pair  
2d2b			; ----------------------  
2d2b			;  
2d2b			  
2d2b			;; STACK-BC  
2d2b fd 21 3a 5c	L2D2B:  LD      IY,$5C3A        ; re-initialize ERR_NR  
2d2f			  
2d2f af			        XOR     A               ; clear to signal small integer  
2d30 5f			        LD      E,A             ; place in E for sign  
2d31 51			        LD      D,C             ; LSB to D  
2d32 48			        LD      C,B             ; MSB to C  
2d33 47			        LD      B,A             ; last byte not used  
2d34 cd b6 2a		        CALL    L2AB6           ; routine STK-STORE  
2d37			  
2d37 ef			        RST     28H             ;; FP-CALC  
2d38 38			        DEFB    $38             ;;end-calc  make HL = STKEND-5  
2d39			  
2d39 a7			        AND     A               ; clear carry  
2d3a c9			        RET                     ; before returning  
2d3b			  
2d3b			; -------------------------  
2d3b			; Integer to floating point  
2d3b			; -------------------------  
2d3b			; This routine places one or more digits found in a BASIC line  
2d3b			; on the calculator stack multiplying the previous value by ten each time  
2d3b			; before adding in the new digit to form a last value on calculator stack.  
2d3b			  
2d3b			;; INT-TO-FP  
2d3b f5			L2D3B:  PUSH    AF              ; save first character  
2d3c			  
2d3c ef			        RST     28H             ;; FP-CALC  
2d3d a0			        DEFB    $A0             ;;stk-zero    ; v=0. initial value  
2d3e 38			        DEFB    $38             ;;end-calc  
2d3f			  
2d3f f1			        POP     AF              ; fetch first character back.  
2d40			  
2d40			;; NXT-DGT-2  
2d40 cd 22 2d		L2D40:  CALL    L2D22           ; routine STK-DIGIT puts 0-9 on stack  
2d43 d8			        RET     C               ; will return when character is not numeric >  
2d44			  
2d44 ef			        RST     28H             ;; FP-CALC    ; v, d.  
2d45 01			        DEFB    $01             ;;exchange    ; d, v.  
2d46 a4			        DEFB    $A4             ;;stk-ten     ; d, v, 10.  
2d47 04			        DEFB    $04             ;;multiply    ; d, v*10.  
2d48 0f			        DEFB    $0F             ;;addition    ; d + v*10 = newvalue  
2d49 38			        DEFB    $38             ;;end-calc    ; v.  
2d4a			  
2d4a cd 74 00		        CALL    L0074           ; routine CH-ADD+1 get next character  
2d4d 18 f1		        JR      L2D40           ; back to NXT-DGT-2 to process as a digit  
2d4f			  
2d4f			  
2d4f			;*********************************  
2d4f			;** Part 9. ARITHMETIC ROUTINES **  
2d4f			;*********************************  
2d4f			  
2d4f			; --------------------------  
2d4f			; E-format to floating point  
2d4f			; --------------------------  
2d4f			; This subroutine is used by the PRINT-FP routine and the decimal to FP  
2d4f			; routines to stack a number expressed in exponent format.  
2d4f			; Note. Though not used by the ROM as such, it has also been set up as  
2d4f			; a unary calculator literal but this will not work as the accumulator  
2d4f			; is not available from within the calculator.  
2d4f			  
2d4f			; on entry there is a value x on the calculator stack and an exponent of ten  
2d4f			; in A.    The required value is x + 10 ^ A  
2d4f			  
2d4f			;; e-to-fp  
2d4f			;; E-TO-FP  
2d4f 07			L2D4F:  RLCA                    ; this will set the          x.  
2d50 0f			        RRCA                    ; carry if bit 7 is set  
2d51			  
2d51 30 02		        JR      NC,L2D55        ; to E-SAVE  if positive.  
2d53			  
2d53 2f			        CPL                     ; make negative positive  
2d54 3c			        INC     A               ; without altering carry.  
2d55			  
2d55			;; E-SAVE  
2d55 f5			L2D55:  PUSH    AF              ; save positive exp and sign in carry  
2d56			  
2d56 21 92 5c		        LD      HL,$5C92        ; address MEM-0  
2d59			  
2d59 cd 0b 35		        CALL    L350B           ; routine FP-0/1  
2d5c			                                ; places an integer zero, if no carry,  
2d5c			                                ; else a one in mem-0 as a sign flag  
2d5c			  
2d5c ef			        RST     28H             ;; FP-CALC  
2d5d a4			        DEFB    $A4             ;;stk-ten                    x, 10.  
2d5e 38			        DEFB    $38             ;;end-calc  
2d5f			  
2d5f f1			        POP     AF              ; pop the exponent.  
2d60			  
2d60			; now enter a loop  
2d60			  
2d60			;; E-LOOP  
2d60 cb 3f		L2D60:  SRL     A               ; 0>76543210>C  
2d62			  
2d62 30 0d		        JR      NC,L2D71        ; forward to E-TST-END if no bit  
2d64			  
2d64 f5			        PUSH    AF              ; save shifted exponent.  
2d65			  
2d65 ef			        RST     28H             ;; FP-CALC  
2d66 c1			        DEFB    $C1             ;;st-mem-1                   x, 10.  
2d67 e0			        DEFB    $E0             ;;get-mem-0                  x, 10, (0/1).  
2d68 00			        DEFB    $00             ;;jump-true  
2d69			  
2d69 04			        DEFB    $04             ;;to L2D6D, E-DIVSN  
2d6a			  
2d6a 04			        DEFB    $04             ;;multiply                   x*10.  
2d6b 33			        DEFB    $33             ;;jump  
2d6c			  
2d6c 02			        DEFB    $02             ;;to L2D6E, E-FETCH  
2d6d			  
2d6d			;; E-DIVSN  
2d6d 05			L2D6D:  DEFB    $05             ;;division                   x/10.  
2d6e			  
2d6e			;; E-FETCH  
2d6e e1			L2D6E:  DEFB    $E1             ;;get-mem-1                  x/10 or x*10, 10.  
2d6f 38			        DEFB    $38             ;;end-calc                   new x, 10.  
2d70			  
2d70 f1			        POP     AF              ; restore shifted exponent  
2d71			  
2d71			; the loop branched to here with no carry  
2d71			  
2d71			;; E-TST-END  
2d71 28 08		L2D71:  JR      Z,L2D7B         ; forward to E-END  if A emptied of bits  
2d73			  
2d73 f5			        PUSH    AF              ; re-save shifted exponent  
2d74			  
2d74 ef			        RST     28H             ;; FP-CALC  
2d75 31			        DEFB    $31             ;;duplicate                  new x, 10, 10.  
2d76 04			        DEFB    $04             ;;multiply                   new x, 100.  
2d77 38			        DEFB    $38             ;;end-calc  
2d78			  
2d78 f1			        POP     AF              ; restore shifted exponent  
2d79 18 e5		        JR      L2D60           ; back to E-LOOP  until all bits done.  
2d7b			  
2d7b			; ---  
2d7b			  
2d7b			; although only the first pass is shown it can be seen that for each set bit  
2d7b			; representing a power of two, x is multiplied or divided by the  
2d7b			; corresponding power of ten.  
2d7b			  
2d7b			;; E-END  
2d7b ef			L2D7B:  RST     28H             ;; FP-CALC                   final x, factor.  
2d7c 02			        DEFB    $02             ;;delete                     final x.  
2d7d 38			        DEFB    $38             ;;end-calc                   x.  
2d7e			  
2d7e c9			        RET                     ; return  
2d7f			  
2d7f			  
2d7f			  
2d7f			  
2d7f			; -------------  
2d7f			; Fetch integer  
2d7f			; -------------  
2d7f			; This routine is called by the mathematical routines - FP-TO-BC, PRINT-FP,  
2d7f			; mult, re-stack and negate to fetch an integer from address HL.  
2d7f			; HL points to the stack or a location in MEM and no deletion occurs.  
2d7f			; If the number is negative then a similar process to that used in INT-STORE  
2d7f			; is used to restore the twos complement number to normal in DE and a sign  
2d7f			; in C.  
2d7f			  
2d7f			;; INT-FETCH  
2d7f 23			L2D7F:  INC     HL              ; skip zero indicator.  
2d80 4e			        LD      C,(HL)          ; fetch sign to C  
2d81 23			        INC     HL              ; address low byte  
2d82 7e			        LD      A,(HL)          ; fetch to A  
2d83 a9			        XOR     C               ; two's complement  
2d84 91			        SUB     C               ;  
2d85 5f			        LD      E,A             ; place in E  
2d86 23			        INC     HL              ; address high byte  
2d87 7e			        LD      A,(HL)          ; fetch to A  
2d88 89			        ADC     A,C             ; two's complement  
2d89 a9			        XOR     C               ;  
2d8a 57			        LD      D,A             ; place in D  
2d8b c9			        RET                     ; return  
2d8c			  
2d8c			; ------------------------  
2d8c			; Store a positive integer  
2d8c			; ------------------------  
2d8c			; This entry point is not used in this ROM but would  
2d8c			; store any integer as positive.  
2d8c			  
2d8c			;; p-int-sto  
2d8c 0e 00		L2D8C:  LD      C,$00           ; make sign byte positive and continue  
2d8e			  
2d8e			; -------------  
2d8e			; Store integer  
2d8e			; -------------  
2d8e			; this routine stores an integer in DE at address HL.  
2d8e			; It is called from mult, truncate, negate and sgn.  
2d8e			; The sign byte $00 +ve or $FF -ve is in C.  
2d8e			; If negative, the number is stored in 2's complement form so that it is  
2d8e			; ready to be added.  
2d8e			  
2d8e			;; INT-STORE  
2d8e e5			L2D8E:  PUSH    HL              ; preserve HL  
2d8f			  
2d8f 36 00		        LD      (HL),$00        ; first byte zero shows integer not exponent  
2d91 23			        INC     HL              ;  
2d92 71			        LD      (HL),C          ; then store the sign byte  
2d93 23			        INC     HL              ;  
2d94			                                ; e.g.             +1             -1  
2d94 7b			        LD      A,E             ; fetch low byte   00000001       00000001  
2d95 a9			        XOR     C               ; xor sign         00000000   or  11111111  
2d96			                                ; gives            00000001   or  11111110  
2d96 91			        SUB     C               ; sub sign         00000000   or  11111111  
2d97			                                ; gives            00000001>0 or  11111111>C  
2d97 77			        LD      (HL),A          ; store 2's complement.  
2d98 23			        INC     HL              ;  
2d99 7a			        LD      A,D             ; high byte        00000000       00000000  
2d9a 89			        ADC     A,C             ; sign             00000000<0     11111111<C  
2d9b			                                ; gives            00000000   or  00000000  
2d9b a9			        XOR     C               ; xor sign         00000000       11111111  
2d9c 77			        LD      (HL),A          ; store 2's complement.  
2d9d 23			        INC     HL              ;  
2d9e 36 00		        LD      (HL),$00        ; last byte always zero for integers.  
2da0			                                ; is not used and need not be looked at when  
2da0			                                ; testing for zero but comes into play should  
2da0			                                ; an integer be converted to fp.  
2da0 e1			        POP     HL              ; restore HL  
2da1 c9			        RET                     ; return.  
2da2			  
2da2			  
2da2			; -----------------------------  
2da2			; Floating point to BC register  
2da2			; -----------------------------  
2da2			; This routine gets a floating point number e.g. 127.4 from the calculator  
2da2			; stack to the BC register.  
2da2			  
2da2			;; FP-TO-BC  
2da2 ef			L2DA2:  RST     28H             ;; FP-CALC            set HL to  
2da3 38			        DEFB    $38             ;;end-calc            point to last value.  
2da4			  
2da4 7e			        LD      A,(HL)          ; get first of 5 bytes  
2da5 a7			        AND     A               ; and test  
2da6 28 05		        JR      Z,L2DAD         ; forward to FP-DELETE if an integer  
2da8			  
2da8			; The value is first rounded up and then converted to integer.  
2da8			  
2da8 ef			        RST     28H             ;; FP-CALC           x.  
2da9 a2			        DEFB    $A2             ;;stk-half           x. 1/2.  
2daa 0f			        DEFB    $0F             ;;addition           x + 1/2.  
2dab 27			        DEFB    $27             ;;int                int(x + .5)  
2dac 38			        DEFB    $38             ;;end-calc  
2dad			  
2dad			; now delete but leave HL pointing at integer  
2dad			  
2dad			;; FP-DELETE  
2dad ef			L2DAD:  RST     28H             ;; FP-CALC  
2dae 02			        DEFB    $02             ;;delete  
2daf 38			        DEFB    $38             ;;end-calc  
2db0			  
2db0 e5			        PUSH    HL              ; save pointer.  
2db1 d5			        PUSH    DE              ; and STKEND.  
2db2 eb			        EX      DE,HL           ; make HL point to exponent/zero indicator  
2db3 46			        LD      B,(HL)          ; indicator to B  
2db4 cd 7f 2d		        CALL    L2D7F           ; routine INT-FETCH  
2db7			                                ; gets int in DE sign byte to C  
2db7			                                ; but meaningless values if a large integer  
2db7			  
2db7 af			        XOR     A               ; clear A  
2db8 90			        SUB     B               ; subtract indicator byte setting carry  
2db9			                                ; if not a small integer.  
2db9			  
2db9 cb 79		        BIT     7,C             ; test a bit of the sign byte setting zero  
2dbb			                                ; if positive.  
2dbb			  
2dbb 42			        LD      B,D             ; transfer int  
2dbc 4b			        LD      C,E             ; to BC  
2dbd 7b			        LD      A,E             ; low byte to A as a useful return value.  
2dbe			  
2dbe d1			        POP     DE              ; pop STKEND  
2dbf e1			        POP     HL              ; and pointer to last value  
2dc0 c9			        RET                     ; return  
2dc1			                                ; if carry is set then the number was too big.  
2dc1			  
2dc1			; ------------  
2dc1			; LOG(2^A)  
2dc1			; ------------  
2dc1			; This routine is used when printing floating point numbers to calculate  
2dc1			; the number of digits before the decimal point.  
2dc1			  
2dc1			; first convert a one-byte signed integer to its five byte form.  
2dc1			  
2dc1			;; LOG(2^A)  
2dc1 57			L2DC1:  LD      D,A             ; store a copy of A in D.  
2dc2 17			        RLA                     ; test sign bit of A.  
2dc3 9f			        SBC     A,A             ; now $FF if negative or $00  
2dc4 5f			        LD      E,A             ; sign byte to E.  
2dc5 4f			        LD      C,A             ; and to C  
2dc6 af			        XOR     A               ; clear A  
2dc7 47			        LD      B,A             ; and B.  
2dc8 cd b6 2a		        CALL    L2AB6           ; routine STK-STORE stacks number AEDCB  
2dcb			  
2dcb			;  so 00 00 XX 00 00 (positive) or 00 FF XX FF 00 (negative).  
2dcb			;  i.e. integer indicator, sign byte, low, high, unused.  
2dcb			  
2dcb			; now multiply exponent by log to the base 10 of two.  
2dcb			  
2dcb ef			        RST      28H            ;; FP-CALC  
2dcc			  
2dcc 34			        DEFB    $34             ;;stk-data                      .30103 (log 2)  
2dcd ef			        DEFB    $EF             ;;Exponent: $7F, Bytes: 4  
2dce 1a 20 9a 85	        DEFB    $1A,$20,$9A,$85 ;;  
2dd2 04			        DEFB    $04             ;;multiply  
2dd3			  
2dd3 27			        DEFB    $27             ;;int  
2dd4			  
2dd4 38			        DEFB    $38             ;;end-calc  
2dd5			  
2dd5			; -------------------  
2dd5			; Floating point to A  
2dd5			; -------------------  
2dd5			; this routine collects a floating point number from the stack into the  
2dd5			; accumulator returning carry set if not in range 0 - 255.  
2dd5			; Not all the calling routines raise an error with overflow so no attempt  
2dd5			; is made to produce an error report here.  
2dd5			  
2dd5			;; FP-TO-A  
2dd5 cd a2 2d		L2DD5:  CALL    L2DA2           ; routine FP-TO-BC returns with C in A also.  
2dd8 d8			        RET     C               ; return with carry set if > 65535, overflow  
2dd9			  
2dd9 f5			        PUSH    AF              ; save the value and flags  
2dda 05			        DEC     B               ; and test that  
2ddb 04			        INC     B               ; the high byte is zero.  
2ddc 28 03		        JR      Z,L2DE1         ; forward  FP-A-END if zero  
2dde			  
2dde			; else there has been 8-bit overflow  
2dde			  
2dde f1			        POP     AF              ; retrieve the value  
2ddf 37			        SCF                     ; set carry flag to show overflow  
2de0 c9			        RET                     ; and return.  
2de1			  
2de1			; ---  
2de1			  
2de1			;; FP-A-END  
2de1 f1			L2DE1:  POP     AF              ; restore value and success flag and  
2de2 c9			        RET                     ; return.  
2de3			  
2de3			  
2de3			; -----------------------------  
2de3			; Print a floating point number  
2de3			; -----------------------------  
2de3			; Not a trivial task.  
2de3			; Begin by considering whether to print a leading sign for negative numbers.  
2de3			  
2de3			;; PRINT-FP  
2de3 ef			L2DE3:  RST     28H             ;; FP-CALC  
2de4 31			        DEFB    $31             ;;duplicate  
2de5 36			        DEFB    $36             ;;less-0  
2de6 00			        DEFB    $00             ;;jump-true  
2de7			  
2de7 0b			        DEFB    $0B             ;;to L2DF2, PF-NEGTVE  
2de8			  
2de8 31			        DEFB    $31             ;;duplicate  
2de9 37			        DEFB    $37             ;;greater-0  
2dea 00			        DEFB    $00             ;;jump-true  
2deb			  
2deb 0d			        DEFB    $0D             ;;to L2DF8, PF-POSTVE  
2dec			  
2dec			; must be zero itself  
2dec			  
2dec 02			        DEFB    $02             ;;delete  
2ded 38			        DEFB    $38             ;;end-calc  
2dee			  
2dee 3e 30		        LD      A,$30           ; prepare the character '0'  
2df0			  
2df0 d7			        RST     10H             ; PRINT-A  
2df1 c9			        RET                     ; return.                 ->  
2df2			; ---  
2df2			  
2df2			;; PF-NEGTVE  
2df2 2a			L2DF2:  DEFB    $2A             ;;abs  
2df3 38			        DEFB    $38             ;;end-calc  
2df4			  
2df4 3e 2d		        LD      A,$2D           ; the character '-'  
2df6			  
2df6 d7			        RST     10H             ; PRINT-A  
2df7			  
2df7			; and continue to print the now positive number.  
2df7			  
2df7 ef			        RST     28H             ;; FP-CALC  
2df8			  
2df8			;; PF-POSTVE  
2df8 a0			L2DF8:  DEFB    $A0             ;;stk-zero     x,0.     begin by  
2df9 c3			        DEFB    $C3             ;;st-mem-3     x,0.     clearing a temporary  
2dfa c4			        DEFB    $C4             ;;st-mem-4     x,0.     output buffer to  
2dfb c5			        DEFB    $C5             ;;st-mem-5     x,0.     fifteen zeros.  
2dfc 02			        DEFB    $02             ;;delete       x.  
2dfd 38			        DEFB    $38             ;;end-calc     x.  
2dfe			  
2dfe d9			        EXX                     ; in case called from 'str$' then save the  
2dff e5			        PUSH    HL              ; pointer to whatever comes after  
2e00 d9			        EXX                     ; str$ as H'L' will be used.  
2e01			  
2e01			; now enter a loop?  
2e01			  
2e01			;; PF-LOOP  
2e01 ef			L2E01:  RST     28H             ;; FP-CALC  
2e02 31			        DEFB    $31             ;;duplicate    x,x.  
2e03 27			        DEFB    $27             ;;int          x,int x.  
2e04 c2			        DEFB    $C2             ;;st-mem-2     x,int x.  
2e05 03			        DEFB    $03             ;;subtract     x-int x.     fractional part.  
2e06 e2			        DEFB    $E2             ;;get-mem-2    x-int x, int x.  
2e07 01			        DEFB    $01             ;;exchange     int x, x-int x.  
2e08 c2			        DEFB    $C2             ;;st-mem-2     int x, x-int x.  
2e09 02			        DEFB    $02             ;;delete       int x.  
2e0a 38			        DEFB    $38             ;;end-calc     int x.  
2e0b			                                ;  
2e0b			                                ; mem-2 holds the fractional part.  
2e0b			  
2e0b			; HL points to last value int x  
2e0b			  
2e0b 7e			        LD      A,(HL)          ; fetch exponent of int x.  
2e0c a7			        AND     A               ; test  
2e0d 20 47		        JR      NZ,L2E56        ; forward to PF-LARGE if a large integer  
2e0f			                                ; > 65535  
2e0f			  
2e0f			; continue with small positive integer components in range 0 - 65535   
2e0f			; if original number was say .999 then this integer component is zero.   
2e0f			  
2e0f cd 7f 2d		        CALL    L2D7F           ; routine INT-FETCH gets x in DE  
2e12			                                ; (but x is not deleted)  
2e12			  
2e12 06 10		        LD      B,$10           ; set B, bit counter, to 16d  
2e14			  
2e14 7a			        LD      A,D             ; test if  
2e15 a7			        AND     A               ; high byte is zero  
2e16 20 06		        JR      NZ,L2E1E        ; forward to PF-SAVE if 16-bit integer.  
2e18			  
2e18			; and continue with integer in range 0 - 255.  
2e18			  
2e18 b3			        OR      E               ; test the low byte for zero  
2e19			                                ; i.e. originally just point something or other.  
2e19 28 09		        JR      Z,L2E24         ; forward if so to PF-SMALL   
2e1b			  
2e1b			;   
2e1b			  
2e1b 53			        LD      D,E             ; transfer E to D  
2e1c 06 08		        LD      B,$08           ; and reduce the bit counter to 8.  
2e1e			  
2e1e			;; PF-SAVE  
2e1e d5			L2E1E:  PUSH    DE              ; save the part before decimal point.  
2e1f d9			        EXX                     ;  
2e20 d1			        POP     DE              ; and pop in into D'E'  
2e21 d9			        EXX                     ;  
2e22 18 57		        JR      L2E7B           ; forward to PF-BITS  
2e24			  
2e24			; ---------------------  
2e24			  
2e24			; the branch was here when 'int x' was found to be zero as in say 0.5.  
2e24			; The zero has been fetched from the calculator stack but not deleted and  
2e24			; this should occur now. This omission leaves the stack unbalanced and while  
2e24			; that causes no problems with a simple PRINT statement, it will if str$ is  
2e24			; being used in an expression e.g. "2" + STR$ 0.5 gives the result "0.5"  
2e24			; instead of the expected result "20.5".  
2e24			; credit Tony Stratton, 1982.  
2e24			; A DEFB 02 delete is required immediately on using the calculator.  
2e24			  
2e24			;; PF-SMALL  
2e24 ef			L2E24:  RST     28H             ;; FP-CALC       int x = 0.  
2e25 e2			L2E25:  DEFB    $E2             ;;get-mem-2      int x = 0, x-int x.  
2e26 38			        DEFB    $38             ;;end-calc  
2e27			  
2e27 7e			        LD      A,(HL)          ; fetch exponent of positive fractional number  
2e28 d6 7e		        SUB     $7E             ; subtract   
2e2a			  
2e2a cd c1 2d		        CALL    L2DC1           ; routine LOG(2^A) calculates leading digits.  
2e2d			  
2e2d 57			        LD      D,A             ; transfer count to D  
2e2e 3a ac 5c		        LD      A,($5CAC)       ; fetch total MEM-5-1  
2e31 92			        SUB     D               ;  
2e32 32 ac 5c		        LD      ($5CAC),A       ; MEM-5-1  
2e35 7a			        LD      A,D             ;   
2e36 cd 4f 2d		        CALL    L2D4F           ; routine E-TO-FP  
2e39			  
2e39 ef			        RST     28H             ;; FP-CALC  
2e3a 31			        DEFB    $31             ;;duplicate  
2e3b 27			        DEFB    $27             ;;int  
2e3c c1			        DEFB    $C1             ;;st-mem-1  
2e3d 03			        DEFB    $03             ;;subtract  
2e3e e1			        DEFB    $E1             ;;get-mem-1  
2e3f 38			        DEFB    $38             ;;end-calc  
2e40			  
2e40 cd d5 2d		        CALL    L2DD5           ; routine FP-TO-A  
2e43			  
2e43 e5			        PUSH    HL              ; save HL  
2e44 32 a1 5c		        LD      ($5CA1),A       ; MEM-3-1  
2e47 3d			        DEC     A               ;  
2e48 17			        RLA                     ;  
2e49 9f			        SBC     A,A             ;  
2e4a 3c			        INC     A               ;  
2e4b			  
2e4b 21 ab 5c		        LD      HL,$5CAB        ; address MEM-5-1 leading digit counter  
2e4e 77			        LD      (HL),A          ; store counter  
2e4f 23			        INC     HL              ; address MEM-5-2 total digits  
2e50 86			        ADD     A,(HL)          ; add counter to contents  
2e51 77			        LD      (HL),A          ; and store updated value  
2e52 e1			        POP     HL              ; restore HL  
2e53			  
2e53 c3 cf 2e		        JP      L2ECF           ; JUMP forward to PF-FRACTN  
2e56			  
2e56			; ---  
2e56			  
2e56			; Note. while it would be pedantic to comment on every occasion a JP  
2e56			; instruction could be replaced with a JR instruction, this applies to the  
2e56			; above, which is useful if you wish to correct the unbalanced stack error  
2e56			; by inserting a 'DEFB 02 delete' at L2E25, and maintain main addresses.  
2e56			  
2e56			; the branch was here with a large positive integer > 65535 e.g. 123456789  
2e56			; the accumulator holds the exponent.  
2e56			  
2e56			;; PF-LARGE  
2e56 d6 80		L2E56:  SUB     $80             ; make exponent positive  
2e58 fe 1c		        CP      $1C             ; compare to 28  
2e5a 38 13		        JR      C,L2E6F         ; to PF-MEDIUM if integer <= 2^27  
2e5c			  
2e5c cd c1 2d		        CALL    L2DC1           ; routine LOG(2^A)  
2e5f d6 07		        SUB     $07             ;  
2e61 47			        LD      B,A             ;  
2e62 21 ac 5c		        LD      HL,$5CAC        ; address MEM-5-1 the leading digits counter.  
2e65 86			        ADD     A,(HL)          ; add A to contents  
2e66 77			        LD      (HL),A          ; store updated value.  
2e67 78			        LD      A,B             ;   
2e68 ed 44		        NEG                     ; negate  
2e6a cd 4f 2d		        CALL    L2D4F           ; routine E-TO-FP  
2e6d 18 92		        JR      L2E01           ; back to PF-LOOP  
2e6f			  
2e6f			; ----------------------------  
2e6f			  
2e6f			;; PF-MEDIUM  
2e6f eb			L2E6F:  EX      DE,HL           ;  
2e70 cd ba 2f		        CALL    L2FBA           ; routine FETCH-TWO  
2e73 d9			        EXX                     ;  
2e74 cb fa		        SET     7,D             ;  
2e76 7d			        LD      A,L             ;  
2e77 d9			        EXX                     ;  
2e78 d6 80		        SUB     $80             ;  
2e7a 47			        LD      B,A             ;  
2e7b			  
2e7b			; the branch was here to handle bits in DE with 8 or 16 in B  if small int  
2e7b			; and integer in D'E', 6 nibbles will accommodate 065535 but routine does  
2e7b			; 32-bit numbers as well from above  
2e7b			  
2e7b			;; PF-BITS  
2e7b cb 23		L2E7B:  SLA     E               ;  C<xxxxxxxx<0  
2e7d cb 12		        RL      D               ;  C<xxxxxxxx<C  
2e7f d9			        EXX                     ;  
2e80 cb 13		        RL      E               ;  C<xxxxxxxx<C  
2e82 cb 12		        RL      D               ;  C<xxxxxxxx<C  
2e84 d9			        EXX                     ;  
2e85			  
2e85 21 aa 5c		        LD      HL,$5CAA        ; set HL to mem-4-5th last byte of buffer  
2e88 0e 05		        LD      C,$05           ; set byte count to 5 -  10 nibbles  
2e8a			  
2e8a			;; PF-BYTES  
2e8a 7e			L2E8A:  LD      A,(HL)          ; fetch 0 or prev value  
2e8b 8f			        ADC     A,A             ; shift left add in carry    C<xxxxxxxx<C  
2e8c			  
2e8c 27			        DAA                     ; Decimal Adjust Accumulator.  
2e8d			                                ; if greater than 9 then the left hand  
2e8d			                                ; nibble is incremented. If greater than  
2e8d			                                ; 99 then adjusted and carry set.  
2e8d			                                ; so if we'd built up 7 and a carry came in  
2e8d			                                ;      0000 0111 < C  
2e8d			                                ;      0000 1111  
2e8d			                                ; daa     1 0101  which is 15 in BCD  
2e8d			  
2e8d 77			        LD      (HL),A          ; put back  
2e8e 2b			        DEC     HL              ; work down thru mem 4  
2e8f 0d			        DEC     C               ; decrease the 5 counter.  
2e90 20 f8		        JR      NZ,L2E8A        ; back to PF-BYTES until the ten nibbles rolled  
2e92			  
2e92 10 e7		        DJNZ    L2E7B           ; back to PF-BITS until 8 or 16 (or 32) done  
2e94			  
2e94			; at most 9 digits for 32-bit number will have been loaded with digits  
2e94			; each of the 9 nibbles in mem 4 is placed into ten bytes in mem-3 and mem 4  
2e94			; unless the nibble is zero as the buffer is already zero.  
2e94			; ( or in the case of mem-5 will become zero as a result of RLD instruction )  
2e94			  
2e94 af			        XOR     A               ; clear to accept  
2e95 21 a6 5c		        LD      HL,$5CA6        ; address MEM-4-0 byte destination.  
2e98 11 a1 5c		        LD      DE,$5CA1        ; address MEM-3-0 nibble source.  
2e9b 06 09		        LD      B,$09           ; the count is 9 (not ten) as the first   
2e9d			                                ; nibble is known to be blank.  
2e9d			  
2e9d ed 6f		        RLD                     ; shift RH nibble to left in (HL)  
2e9f			                                ;    A           (HL)  
2e9f			                                ; 0000 0000 < 0000 3210  
2e9f			                                ; 0000 0000   3210 0000  
2e9f			                                ; A picks up the blank nibble  
2e9f			  
2e9f			  
2e9f 0e ff		        LD      C,$FF           ; set a flag to indicate when a significant  
2ea1			                                ; digit has been encountered.  
2ea1			  
2ea1			;; PF-DIGITS  
2ea1 ed 6f		L2EA1:  RLD                     ; pick up leftmost nibble from (HL)  
2ea3			                                ;    A           (HL)  
2ea3			                                ; 0000 0000 < 7654 3210  
2ea3			                                ; 0000 7654   3210 0000  
2ea3			  
2ea3			  
2ea3 20 04		        JR      NZ,L2EA9        ; to PF-INSERT if non-zero value picked up.  
2ea5			  
2ea5 0d			        DEC     C               ; test  
2ea6 0c			        INC     C               ; flag  
2ea7 20 0a		        JR      NZ,L2EB3        ; skip forward to PF-TEST-2 if flag still $FF  
2ea9			                                ; indicating this is a leading zero.  
2ea9			  
2ea9			; but if the zero is a significant digit e.g. 10 then include in digit totals.  
2ea9			; the path for non-zero digits rejoins here.  
2ea9			  
2ea9			;; PF-INSERT  
2ea9 12			L2EA9:  LD      (DE),A          ; insert digit at destination  
2eaa 13			        INC     DE              ; increase the destination pointer  
2eab fd 34 71		        INC     (IY+$71)        ; increment MEM-5-1st  digit counter  
2eae fd 34 72		        INC     (IY+$72)        ; increment MEM-5-2nd  leading digit counter  
2eb1 0e 00		        LD      C,$00           ; set flag to zero indicating that any   
2eb3			                                ; subsequent zeros are significant and not   
2eb3			                                ; leading.  
2eb3			  
2eb3			;; PF-TEST-2  
2eb3 cb 40		L2EB3:  BIT     0,B             ; test if the nibble count is even  
2eb5 28 01		        JR      Z,L2EB8         ; skip to PF-ALL-9 if so to deal with the  
2eb7			                                ; other nibble in the same byte  
2eb7			  
2eb7 23			        INC     HL              ; point to next source byte if not  
2eb8			  
2eb8			;; PF-ALL-9  
2eb8 10 e7		L2EB8:  DJNZ    L2EA1           ; decrement the nibble count, back to PF-DIGITS  
2eba			                                ; if all nine not done.  
2eba			  
2eba			; For 8-bit integers there will be at most 3 digits.  
2eba			; For 16-bit integers there will be at most 5 digits.   
2eba			; but for larger integers there could be nine leading digits.  
2eba			; if nine digits complete then the last one is rounded up as the number will  
2eba			; be printed using E-format notation  
2eba			  
2eba 3a ab 5c		        LD      A,($5CAB)       ; fetch digit count from MEM-5-1st  
2ebd d6 09		        SUB     $09             ; subtract 9 - max possible  
2ebf 38 0a		        JR      C,L2ECB         ; forward if less to PF-MORE  
2ec1			  
2ec1 fd 35 71		        DEC     (IY+$71)        ; decrement digit counter MEM-5-1st to 8  
2ec4 3e 04		        LD      A,$04           ; load A with the value 4.  
2ec6 fd be 6f		        CP      (IY+$6F)        ; compare with MEM-4-4th - the ninth digit  
2ec9 18 41		        JR      L2F0C           ; forward to PF-ROUND  
2ecb			                                ; to consider rounding.  
2ecb			  
2ecb			; ---------------------------------------  
2ecb			   
2ecb			; now delete int x from calculator stack and fetch fractional part.  
2ecb			  
2ecb			;; PF-MORE  
2ecb ef			L2ECB:  RST     28H             ;; FP-CALC        int x.  
2ecc 02			        DEFB    $02             ;;delete          .  
2ecd e2			        DEFB    $E2             ;;get-mem-2       x - int x = f.  
2ece 38			        DEFB    $38             ;;end-calca       f.  
2ecf			  
2ecf			;; PF-FRACTN  
2ecf eb			L2ECF:  EX      DE,HL           ;  
2ed0 cd ba 2f		        CALL    L2FBA           ; routine FETCH-TWO  
2ed3 d9			        EXX                     ;  
2ed4 3e 80		        LD      A,$80           ;  
2ed6 95			        SUB     L               ;  
2ed7 2e 00		        LD      L,$00           ;  
2ed9 cb fa		        SET     7,D             ;  
2edb d9			        EXX                     ;  
2edc cd dd 2f		        CALL    L2FDD           ; routine SHIFT-FP  
2edf			  
2edf			;; PF-FRN-LP  
2edf fd 7e 71		L2EDF:  LD      A,(IY+$71)      ; MEM-5-1st  
2ee2 fe 08		        CP      $08             ;  
2ee4 38 06		        JR      C,L2EEC         ; to PF-FR-DGT  
2ee6			  
2ee6 d9			        EXX                     ;  
2ee7 cb 12		        RL      D               ;  
2ee9 d9			        EXX                     ;  
2eea 18 20		        JR      L2F0C           ; to PF-ROUND  
2eec			  
2eec			; ---  
2eec			  
2eec			;; PF-FR-DGT  
2eec 01 00 02		L2EEC:  LD      BC,$0200        ;  
2eef			  
2eef			;; PF-FR-EXX  
2eef 7b			L2EEF:  LD      A,E             ;  
2ef0 cd 8b 2f		        CALL    L2F8B           ; routine CA-10*A+C  
2ef3 5f			        LD      E,A             ;  
2ef4 7a			        LD      A,D             ;  
2ef5 cd 8b 2f		        CALL    L2F8B           ; routine CA-10*A+C  
2ef8 57			        LD      D,A             ;  
2ef9 c5			        PUSH    BC              ;  
2efa d9			        EXX                     ;  
2efb c1			        POP     BC              ;  
2efc 10 f1		        DJNZ    L2EEF           ; to PF-FR-EXX  
2efe			  
2efe 21 a1 5c		        LD      HL,$5CA1        ; MEM-3  
2f01 79			        LD      A,C             ;  
2f02 fd 4e 71		        LD      C,(IY+$71)      ; MEM-5-1st  
2f05 09			        ADD     HL,BC           ;  
2f06 77			        LD      (HL),A          ;  
2f07 fd 34 71		        INC     (IY+$71)        ; MEM-5-1st  
2f0a 18 d3		        JR      L2EDF           ; to PF-FRN-LP  
2f0c			  
2f0c			; ----------------  
2f0c			  
2f0c			; 1) with 9 digits but 8 in mem-5-1 and A holding 4, carry set if rounding up.  
2f0c			; e.g.   
2f0c			;      999999999 is printed as 1E+9  
2f0c			;      100000001 is printed as 1E+8  
2f0c			;      100000009 is printed as 1.0000001E+8  
2f0c			  
2f0c			;; PF-ROUND  
2f0c f5			L2F0C:  PUSH    AF              ; save A and flags  
2f0d 21 a1 5c		        LD      HL,$5CA1        ; address MEM-3 start of digits  
2f10 fd 4e 71		        LD      C,(IY+$71)      ; MEM-5-1st No. of digits to C  
2f13 06 00		        LD      B,$00           ; prepare to add  
2f15 09			        ADD     HL,BC           ; address last digit + 1  
2f16 41			        LD      B,C             ; No. of digits to B counter  
2f17 f1			        POP     AF              ; restore A and carry flag from comparison.  
2f18			  
2f18			;; PF-RND-LP  
2f18 2b			L2F18:  DEC     HL              ; address digit at rounding position.  
2f19 7e			        LD      A,(HL)          ; fetch it  
2f1a ce 00		        ADC     A,$00           ; add carry from the comparison  
2f1c 77			        LD      (HL),A          ; put back result even if $0A.  
2f1d a7			        AND     A               ; test A  
2f1e 28 05		        JR      Z,L2F25         ; skip to PF-R-BACK if ZERO?  
2f20			  
2f20 fe 0a		        CP      $0A             ; compare to 'ten' - overflow  
2f22 3f			        CCF                     ; complement carry flag so that set if ten.  
2f23 30 08		        JR      NC,L2F2D        ; forward to PF-COUNT with 1 - 9.  
2f25			  
2f25			;; PF-R-BACK  
2f25 10 f1		L2F25:  DJNZ    L2F18           ; loop back to PF-RND-LP  
2f27			  
2f27			; if B counts down to zero then we've rounded right back as in 999999995.  
2f27			; and the first 8 locations all hold $0A.  
2f27			  
2f27			  
2f27 36 01		        LD      (HL),$01        ; load first location with digit 1.  
2f29 04			        INC     B               ; make B hold 1 also.  
2f2a			                                ; could save an instruction byte here.  
2f2a fd 34 72		        INC     (IY+$72)        ; make MEM-5-2nd hold 1.  
2f2d			                                ; and proceed to initialize total digits to 1.  
2f2d			  
2f2d			;; PF-COUNT  
2f2d fd 70 71		L2F2D:  LD      (IY+$71),B      ; MEM-5-1st  
2f30			  
2f30			; now balance the calculator stack by deleting  it  
2f30			  
2f30 ef			        RST     28H             ;; FP-CALC  
2f31 02			        DEFB    $02             ;;delete  
2f32 38			        DEFB    $38             ;;end-calc  
2f33			  
2f33			; note if used from str$ then other values may be on the calculator stack.  
2f33			; we can also restore the next literal pointer from its position on the  
2f33			; machine stack.  
2f33			  
2f33 d9			        EXX                     ;  
2f34 e1			        POP     HL              ; restore next literal pointer.  
2f35 d9			        EXX                     ;  
2f36			  
2f36 ed 4b ab 5c	        LD      BC,($5CAB)      ; set C to MEM-5-1st digit counter.  
2f3a			                                ; set B to MEM-5-2nd leading digit counter.  
2f3a 21 a1 5c		        LD      HL,$5CA1        ; set HL to start of digits at MEM-3-1  
2f3d 78			        LD      A,B             ;  
2f3e fe 09		        CP      $09             ;  
2f40 38 04		        JR      C,L2F46         ; to PF-NOT-E  
2f42			  
2f42 fe fc		        CP      $FC             ;  
2f44 38 26		        JR      C,L2F6C         ; to PF-E-FRMT  
2f46			  
2f46			;; PF-NOT-E  
2f46 a7			L2F46:  AND     A               ; test for zero leading digits as in .123  
2f47			  
2f47 cc ef 15		        CALL    Z,L15EF         ; routine OUT-CODE prints a zero e.g. 0.123  
2f4a			  
2f4a			;; PF-E-SBRN  
2f4a af			L2F4A:  XOR     A               ;  
2f4b 90			        SUB     B               ;  
2f4c fa 52 2f		        JP      M,L2F52         ; skip forward to PF-OUT-LP if originally +ve  
2f4f			  
2f4f 47			        LD      B,A             ; else negative count now +ve  
2f50 18 0c		        JR      L2F5E           ; forward to PF-DC-OUT       ->  
2f52			  
2f52			; ---  
2f52			  
2f52			;; PF-OUT-LP  
2f52 79			L2F52:  LD      A,C             ; fetch total digit count  
2f53 a7			        AND     A               ; test for zero  
2f54 28 03		        JR      Z,L2F59         ; forward to PF-OUT-DT if so  
2f56			  
2f56 7e			        LD      A,(HL)          ; fetch digit  
2f57 23			        INC     HL              ; address next digit  
2f58 0d			        DEC     C               ; decrease total digit counter  
2f59			  
2f59			;; PF-OUT-DT  
2f59 cd ef 15		L2F59:  CALL    L15EF           ; routine OUT-CODE outputs it.  
2f5c 10 f4		        DJNZ    L2F52           ; loop back to PF-OUT-LP until B leading   
2f5e			                                ; digits output.  
2f5e			  
2f5e			;; PF-DC-OUT  
2f5e 79			L2F5E:  LD      A,C             ; fetch total digits and  
2f5f a7			        AND     A               ; test if also zero  
2f60 c8			        RET     Z               ; return if so              -->  
2f61			  
2f61			;   
2f61			  
2f61 04			        INC     B               ; increment B  
2f62 3e 2e		        LD      A,$2E           ; prepare the character '.'  
2f64			  
2f64			;; PF-DEC-0$  
2f64 d7			L2F64:  RST     10H             ; PRINT-A outputs the character '.' or '0'  
2f65			  
2f65 3e 30		        LD      A,$30           ; prepare the character '0'  
2f67			                                ; (for cases like .000012345678)  
2f67 10 fb		        DJNZ    L2F64           ; loop back to PF-DEC-0$ for B times.  
2f69			  
2f69 41			        LD      B,C             ; load B with now trailing digit counter.  
2f6a 18 e6		        JR      L2F52           ; back to PF-OUT-LP  
2f6c			  
2f6c			; ---------------------------------  
2f6c			  
2f6c			; the branch was here for E-format printing e.g 123456789 => 1.2345679e+8  
2f6c			  
2f6c			;; PF-E-FRMT  
2f6c 50			L2F6C:  LD      D,B             ; counter to D  
2f6d 15			        DEC     D               ; decrement  
2f6e 06 01		        LD      B,$01           ; load B with 1.  
2f70			  
2f70 cd 4a 2f		        CALL    L2F4A           ; routine PF-E-SBRN above  
2f73			  
2f73 3e 45		        LD      A,$45           ; prepare character 'e'  
2f75 d7			        RST     10H             ; PRINT-A  
2f76			  
2f76 4a			        LD      C,D             ; exponent to C  
2f77 79			        LD      A,C             ; and to A  
2f78 a7			        AND     A               ; test exponent  
2f79 f2 83 2f		        JP      P,L2F83         ; to PF-E-POS if positive  
2f7c			  
2f7c ed 44		        NEG                     ; negate  
2f7e 4f			        LD      C,A             ; positive exponent to C  
2f7f 3e 2d		        LD      A,$2D           ; prepare character '-'  
2f81 18 02		        JR      L2F85           ; skip to PF-E-SIGN  
2f83			  
2f83			; ---  
2f83			  
2f83			;; PF-E-POS  
2f83 3e 2b		L2F83:  LD      A,$2B           ; prepare character '+'  
2f85			  
2f85			;; PF-E-SIGN  
2f85 d7			L2F85:  RST     10H             ; PRINT-A outputs the sign  
2f86			  
2f86 06 00		        LD      B,$00           ; make the high byte zero.  
2f88 c3 1b 1a		        JP      L1A1B           ; exit via OUT-NUM-1 to print exponent in BC  
2f8b			  
2f8b			; ------------------------------  
2f8b			; Handle printing floating point  
2f8b			; ------------------------------  
2f8b			; This subroutine is called twice from above when printing floating-point  
2f8b			; numbers. It returns 10*A +C in registers C and A  
2f8b			  
2f8b			;; CA-10*A+C  
2f8b d5			L2F8B:  PUSH    DE              ; preserve DE.  
2f8c 6f			        LD      L,A             ; transfer A to L  
2f8d 26 00		        LD      H,$00           ; zero high byte.  
2f8f 5d			        LD      E,L             ; copy HL  
2f90 54			        LD      D,H             ; to DE.  
2f91 29			        ADD     HL,HL           ; double (*2)  
2f92 29			        ADD     HL,HL           ; double (*4)  
2f93 19			        ADD     HL,DE           ; add DE (*5)  
2f94 29			        ADD     HL,HL           ; double (*10)  
2f95 59			        LD      E,C             ; copy C to E    (D is 0)  
2f96 19			        ADD     HL,DE           ; and add to give required result.  
2f97 4c			        LD      C,H             ; transfer to  
2f98 7d			        LD      A,L             ; destination registers.  
2f99 d1			        POP     DE              ; restore DE  
2f9a c9			        RET                     ; return with result.  
2f9b			  
2f9b			; --------------  
2f9b			; Prepare to add  
2f9b			; --------------  
2f9b			; This routine is called twice by addition to prepare the two numbers. The  
2f9b			; exponent is picked up in A and the location made zero. Then the sign bit  
2f9b			; is tested before being set to the implied state. Negative numbers are twos  
2f9b			; complemented.  
2f9b			  
2f9b			;; PREP-ADD  
2f9b 7e			L2F9B:  LD      A,(HL)          ; pick up exponent  
2f9c 36 00		        LD      (HL),$00        ; make location zero  
2f9e a7			        AND     A               ; test if number is zero  
2f9f c8			        RET     Z               ; return if so  
2fa0			  
2fa0 23			        INC     HL              ; address mantissa  
2fa1 cb 7e		        BIT     7,(HL)          ; test the sign bit  
2fa3 cb fe		        SET     7,(HL)          ; set it to implied state  
2fa5 2b			        DEC     HL              ; point to exponent  
2fa6 c8			        RET     Z               ; return if positive number.  
2fa7			  
2fa7 c5			        PUSH    BC              ; preserve BC  
2fa8 01 05 00		        LD      BC,$0005        ; length of number  
2fab 09			        ADD     HL,BC           ; point HL past end  
2fac 41			        LD      B,C             ; set B to 5 counter  
2fad 4f			        LD      C,A             ; store exponent in C  
2fae 37			        SCF                     ; set carry flag  
2faf			  
2faf			;; NEG-BYTE  
2faf 2b			L2FAF:  DEC     HL              ; work from LSB to MSB  
2fb0 7e			        LD      A,(HL)          ; fetch byte  
2fb1 2f			        CPL                     ; complement  
2fb2 ce 00		        ADC     A,$00           ; add in initial carry or from prev operation  
2fb4 77			        LD      (HL),A          ; put back  
2fb5 10 f8		        DJNZ    L2FAF           ; loop to NEG-BYTE till all 5 done  
2fb7			  
2fb7 79			        LD      A,C             ; stored exponent to A  
2fb8 c1			        POP     BC              ; restore original BC  
2fb9 c9			        RET                     ; return  
2fba			  
2fba			; -----------------  
2fba			; Fetch two numbers  
2fba			; -----------------  
2fba			; This routine is called twice when printing floating point numbers and also  
2fba			; to fetch two numbers by the addition, multiply and division routines.  
2fba			; HL addresses the first number, DE addresses the second number.  
2fba			; For arithmetic only, A holds the sign of the result which is stored in  
2fba			; the second location.   
2fba			  
2fba			;; FETCH-TWO  
2fba e5			L2FBA:  PUSH    HL              ; save pointer to first number, result if math.  
2fbb f5			        PUSH    AF              ; save result sign.  
2fbc			  
2fbc 4e			        LD      C,(HL)          ;  
2fbd 23			        INC     HL              ;  
2fbe			  
2fbe 46			        LD      B,(HL)          ;  
2fbf 77			        LD      (HL),A          ; store the sign at correct location in   
2fc0			                                ; destination 5 bytes for arithmetic only.  
2fc0 23			        INC     HL              ;  
2fc1			  
2fc1 79			        LD      A,C             ;  
2fc2 4e			        LD      C,(HL)          ;  
2fc3 c5			        PUSH    BC              ;  
2fc4 23			        INC     HL              ;  
2fc5 4e			        LD      C,(HL)          ;  
2fc6 23			        INC     HL              ;  
2fc7 46			        LD      B,(HL)          ;  
2fc8 eb			        EX      DE,HL           ;  
2fc9 57			        LD      D,A             ;  
2fca 5e			        LD      E,(HL)          ;  
2fcb d5			        PUSH    DE              ;  
2fcc 23			        INC     HL              ;  
2fcd 56			        LD      D,(HL)          ;  
2fce 23			        INC     HL              ;  
2fcf 5e			        LD      E,(HL)          ;  
2fd0 d5			        PUSH    DE              ;  
2fd1 d9			        EXX                     ;  
2fd2 d1			        POP     DE              ;  
2fd3 e1			        POP     HL              ;  
2fd4 c1			        POP     BC              ;  
2fd5 d9			        EXX                     ;  
2fd6 23			        INC     HL              ;  
2fd7 56			        LD      D,(HL)          ;  
2fd8 23			        INC     HL              ;  
2fd9 5e			        LD      E,(HL)          ;  
2fda			  
2fda f1			        POP     AF              ; restore possible result sign.  
2fdb e1			        POP     HL              ; and pointer to possible result.  
2fdc c9			        RET                     ; return.  
2fdd			  
2fdd			; ---------------------------------  
2fdd			; Shift floating point number right  
2fdd			; ---------------------------------  
2fdd			;  
2fdd			;  
2fdd			  
2fdd			;; SHIFT-FP  
2fdd a7			L2FDD:  AND     A               ;  
2fde c8			        RET     Z               ;  
2fdf			  
2fdf fe 21		        CP      $21             ;  
2fe1 30 16		        JR      NC,L2FF9        ; to ADDEND-0  
2fe3			  
2fe3 c5			        PUSH    BC              ;  
2fe4 47			        LD      B,A             ;  
2fe5			  
2fe5			;; ONE-SHIFT  
2fe5 d9			L2FE5:  EXX                     ;  
2fe6 cb 2d		        SRA     L               ;  
2fe8 cb 1a		        RR      D               ;  
2fea cb 1b		        RR      E               ;  
2fec d9			        EXX                     ;  
2fed cb 1a		        RR      D               ;  
2fef cb 1b		        RR      E               ;  
2ff1 10 f2		        DJNZ    L2FE5           ; to ONE-SHIFT  
2ff3			  
2ff3 c1			        POP     BC              ;  
2ff4 d0			        RET     NC              ;  
2ff5			  
2ff5 cd 04 30		        CALL    L3004           ; routine ADD-BACK  
2ff8 c0			        RET     NZ              ;  
2ff9			  
2ff9			;; ADDEND-0  
2ff9 d9			L2FF9:  EXX                     ;  
2ffa af			        XOR     A               ;  
2ffb			  
2ffb			;; ZEROS-4/5  
2ffb 2e 00		L2FFB:  LD      L,$00           ;  
2ffd 57			        LD      D,A             ;  
2ffe 5d			        LD      E,L             ;  
2fff d9			        EXX                     ;  
3000 11 00 00		        LD      DE,$0000        ;  
3003 c9			        RET                     ;  
3004			  
3004			; ------------------  
3004			; Add back any carry  
3004			; ------------------  
3004			;  
3004			;  
3004			  
3004			;; ADD-BACK  
3004 1c			L3004:  INC     E               ;  
3005 c0			        RET     NZ              ;  
3006			  
3006 14			        INC      D              ;  
3007 c0			        RET     NZ              ;  
3008			  
3008 d9			        EXX                     ;  
3009 1c			        INC     E               ;  
300a 20 01		        JR      NZ,L300D        ; to ALL-ADDED  
300c			  
300c 14			        INC     D               ;  
300d			  
300d			;; ALL-ADDED  
300d d9			L300D:  EXX                     ;  
300e c9			        RET                     ;  
300f			  
300f			; -----------------------  
300f			; Handle subtraction (03)  
300f			; -----------------------  
300f			; Subtraction is done by switching the sign byte/bit of the second number  
300f			; which may be integer of floating point and continuing into addition.  
300f			  
300f			;; subtract  
300f eb			L300F:  EX      DE,HL           ; address second number with HL  
3010			  
3010 cd 6e 34		        CALL    L346E           ; routine NEGATE switches sign  
3013			  
3013 eb			        EX      DE,HL           ; address first number again  
3014			                                ; and continue.  
3014			  
3014			; --------------------  
3014			; Handle addition (0F)  
3014			; --------------------  
3014			; HL points to first number, DE to second.  
3014			; If they are both integers, then go for the easy route.  
3014			  
3014			;; addition  
3014 1a			L3014:  LD      A,(DE)          ; fetch first byte of second  
3015 b6			        OR      (HL)            ; combine with first byte of first  
3016 20 26		        JR      NZ,L303E        ; forward to FULL-ADDN if at least one was  
3018			                                ; in floating point form.  
3018			  
3018			; continue if both were small integers.  
3018			  
3018 d5			        PUSH    DE              ; save pointer to lowest number for result.  
3019			  
3019 23			        INC     HL              ; address sign byte and  
301a e5			        PUSH    HL              ; push the pointer.  
301b			  
301b 23			        INC     HL              ; address low byte  
301c 5e			        LD      E,(HL)          ; to E  
301d 23			        INC     HL              ; address high byte  
301e 56			        LD      D,(HL)          ; to D  
301f 23			        INC     HL              ; address unused byte  
3020			  
3020 23			        INC     HL              ; address known zero indicator of 1st number  
3021 23			        INC     HL              ; address sign byte  
3022			  
3022 7e			        LD      A,(HL)          ; sign to A, $00 or $FF  
3023			  
3023 23			        INC     HL              ; address low byte  
3024 4e			        LD      C,(HL)          ; to C  
3025 23			        INC     HL              ; address high byte  
3026 46			        LD      B,(HL)          ; to B  
3027			  
3027 e1			        POP     HL              ; pop result sign pointer  
3028 eb			        EX      DE,HL           ; integer to HL  
3029			  
3029 09			        ADD     HL,BC           ; add to the other one in BC  
302a			                                ; setting carry if overflow.  
302a			  
302a eb			        EX      DE,HL           ; save result in DE bringing back sign pointer  
302b			  
302b 8e			        ADC     A,(HL)          ; if pos/pos A=01 with overflow else 00  
302c			                                ; if neg/neg A=FF with overflow else FE  
302c			                                ; if mixture A=00 with overflow else FF  
302c			  
302c 0f			        RRCA                    ; bit 0 to (C)  
302d			  
302d ce 00		        ADC     A,$00           ; both acceptable signs now zero  
302f			  
302f 20 0b		        JR      NZ,L303C        ; forward to ADDN-OFLW if not  
3031			  
3031 9f			        SBC     A,A             ; restore a negative result sign  
3032			  
3032 77			        LD      (HL),A          ;  
3033 23			        INC     HL              ;  
3034 73			        LD      (HL),E          ;  
3035 23			        INC     HL              ;  
3036 72			        LD      (HL),D          ;  
3037 2b			        DEC     HL              ;  
3038 2b			        DEC     HL              ;  
3039 2b			        DEC     HL              ;  
303a			  
303a d1			        POP     DE              ; STKEND  
303b c9			        RET                     ;  
303c			  
303c			; ---  
303c			  
303c			;; ADDN-OFLW  
303c 2b			L303C:  DEC     HL              ;  
303d d1			        POP     DE              ;  
303e			  
303e			;; FULL-ADDN  
303e cd 93 32		L303E:  CALL    L3293           ; routine RE-ST-TWO  
3041 d9			        EXX                     ;  
3042 e5			        PUSH    HL              ;  
3043 d9			        EXX                     ;  
3044 d5			        PUSH    DE              ;  
3045 e5			        PUSH    HL              ;  
3046 cd 9b 2f		        CALL    L2F9B           ; routine PREP-ADD  
3049 47			        LD      B,A             ;  
304a eb			        EX      DE,HL           ;  
304b cd 9b 2f		        CALL    L2F9B           ; routine PREP-ADD  
304e 4f			        LD       C,A            ;  
304f b8			        CP      B               ;  
3050 30 03		        JR      NC,L3055        ; to SHIFT-LEN  
3052			  
3052 78			        LD      A,B             ;  
3053 41			        LD      B,C             ;  
3054 eb			        EX      DE,HL           ;  
3055			  
3055			;; SHIFT-LEN  
3055 f5			L3055:  PUSH    AF              ;  
3056 90			        SUB     B               ;  
3057 cd ba 2f		        CALL    L2FBA           ; routine FETCH-TWO  
305a cd dd 2f		        CALL    L2FDD           ; routine SHIFT-FP  
305d f1			        POP     AF              ;  
305e e1			        POP     HL              ;  
305f 77			        LD      (HL),A          ;  
3060 e5			        PUSH    HL              ;  
3061 68			        LD      L,B             ;  
3062 61			        LD      H,C             ;  
3063 19			        ADD     HL,DE           ;  
3064 d9			        EXX                     ;  
3065 eb			        EX      DE,HL           ;  
3066 ed 4a		        ADC     HL,BC           ;  
3068 eb			        EX      DE,HL           ;  
3069 7c			        LD      A,H             ;  
306a 8d			        ADC     A,L             ;  
306b 6f			        LD      L,A             ;  
306c 1f			        RRA                     ;  
306d ad			        XOR     L               ;  
306e d9			        EXX                     ;  
306f eb			        EX      DE,HL           ;  
3070 e1			        POP     HL              ;  
3071 1f			        RRA                     ;  
3072 30 08		        JR      NC,L307C        ; to TEST-NEG  
3074			  
3074 3e 01		        LD      A,$01           ;  
3076 cd dd 2f		        CALL    L2FDD           ; routine SHIFT-FP  
3079 34			        INC     (HL)            ;  
307a 28 23		        JR      Z,L309F         ; to ADD-REP-6  
307c			  
307c			;; TEST-NEG  
307c d9			L307C:  EXX                     ;  
307d 7d			        LD      A,L             ;  
307e e6 80		        AND     $80             ;  
3080 d9			        EXX                     ;  
3081 23			        INC     HL              ;  
3082 77			        LD      (HL),A          ;  
3083 2b			        DEC     HL              ;  
3084 28 1f		        JR      Z,L30A5         ; to GO-NC-MLT  
3086			  
3086 7b			        LD      A,E             ;  
3087 ed 44		        NEG                     ; Negate  
3089 3f			        CCF                     ; Complement Carry Flag  
308a 5f			        LD      E,A             ;  
308b 7a			        LD      A,D             ;  
308c 2f			        CPL                     ;  
308d ce 00		        ADC     A,$00           ;  
308f 57			        LD      D,A             ;  
3090 d9			        EXX                     ;  
3091 7b			        LD      A,E             ;  
3092 2f			        CPL                     ;  
3093 ce 00		        ADC     A,$00           ;  
3095 5f			        LD      E,A             ;  
3096 7a			        LD      A,D             ;  
3097 2f			        CPL                     ;  
3098 ce 00		        ADC     A,$00           ;  
309a 30 07		        JR      NC,L30A3        ; to END-COMPL  
309c			  
309c 1f			        RRA                     ;  
309d d9			        EXX                     ;  
309e 34			        INC     (HL)            ;  
309f			  
309f			;; ADD-REP-6  
309f ca ad 31		L309F:  JP      Z,L31AD         ; to REPORT-6  
30a2			  
30a2 d9			        EXX                     ;  
30a3			  
30a3			;; END-COMPL  
30a3 57			L30A3:  LD      D,A             ;  
30a4 d9			        EXX                     ;  
30a5			  
30a5			;; GO-NC-MLT  
30a5 af			L30A5:  XOR     A               ;  
30a6 c3 55 31		        JP      L3155           ; to TEST-NORM  
30a9			  
30a9			; -----------------------------  
30a9			; Used in 16 bit multiplication  
30a9			; -----------------------------  
30a9			; This routine is used, in the first instance, by the multiply calculator  
30a9			; literal to perform an integer multiplication in preference to  
30a9			; 32-bit multiplication to which it will resort if this overflows.  
30a9			;  
30a9			; It is also used by STK-VAR to calculate array subscripts and by DIM to  
30a9			; calculate the space required for multi-dimensional arrays.  
30a9			  
30a9			;; HL-HL*DE  
30a9 c5			L30A9:  PUSH    BC              ; preserve BC throughout  
30aa 06 10		        LD      B,$10           ; set B to 16  
30ac 7c			        LD      A,H             ; save H in A high byte  
30ad 4d			        LD      C,L             ; save L in C low byte  
30ae 21 00 00		        LD      HL,$0000        ; initialize result to zero  
30b1			  
30b1			; now enter a loop.  
30b1			  
30b1			;; HL-LOOP  
30b1 29			L30B1:  ADD     HL,HL           ; double result  
30b2 38 0a		        JR      C,L30BE         ; to HL-END if overflow  
30b4			  
30b4 cb 11		        RL      C               ; shift AC left into carry  
30b6 17			        RLA                     ;  
30b7 30 03		        JR      NC,L30BC        ; to HL-AGAIN to skip addition if no carry  
30b9			  
30b9 19			        ADD     HL,DE           ; add in DE  
30ba 38 02		        JR      C,L30BE         ; to HL-END if overflow  
30bc			  
30bc			;; HL-AGAIN  
30bc 10 f3		L30BC:  DJNZ    L30B1           ; back to HL-LOOP for all 16 bits  
30be			  
30be			;; HL-END  
30be c1			L30BE:  POP     BC              ; restore preserved BC  
30bf c9			        RET                     ; return with carry reset if successful  
30c0			                                ; and result in HL.  
30c0			  
30c0			; -----------------------------  
30c0			; Prepare to multiply or divide  
30c0			; -----------------------------  
30c0			; This routine is called in succession from multiply and divide to prepare  
30c0			; two mantissas by setting the leftmost bit that is used for the sign.  
30c0			; On the first call A holds zero and picks up the sign bit. On the second  
30c0			; call the two bits are XORed to form the result sign - minus * minus giving  
30c0			; plus etc. If either number is zero then this is flagged.  
30c0			; HL addresses the exponent.  
30c0			  
30c0			;; PREP-M/D  
30c0 cd e9 34		L30C0:  CALL    L34E9           ; routine TEST-ZERO  preserves accumulator.  
30c3 d8			        RET     C               ; return carry set if zero  
30c4			  
30c4 23			        INC     HL              ; address first byte of mantissa  
30c5 ae			        XOR     (HL)            ; pick up the first or xor with first.  
30c6 cb fe		        SET     7,(HL)          ; now set to give true 32-bit mantissa  
30c8 2b			        DEC     HL              ; point to exponent  
30c9 c9			        RET                     ; return with carry reset  
30ca			  
30ca			; --------------------------  
30ca			; Handle multiplication (04)  
30ca			; --------------------------  
30ca			;  
30ca			;  
30ca			  
30ca			;; multiply  
30ca 1a			L30CA:  LD      A,(DE)          ;  
30cb b6			        OR      (HL)            ;  
30cc 20 22		        JR      NZ,L30F0        ; to MULT-LONG  
30ce			  
30ce d5			        PUSH    DE              ;  
30cf e5			        PUSH    HL              ;  
30d0 d5			        PUSH    DE              ;  
30d1 cd 7f 2d		        CALL    L2D7F           ; routine INT-FETCH  
30d4 eb			        EX      DE,HL           ;  
30d5 e3			        EX      (SP),HL         ;  
30d6 41			        LD      B,C             ;  
30d7 cd 7f 2d		        CALL    L2D7F           ; routine INT-FETCH  
30da 78			        LD      A,B             ;  
30db a9			        XOR     C               ;  
30dc 4f			        LD      C,A             ;  
30dd e1			        POP     HL              ;  
30de cd a9 30		        CALL    L30A9           ; routine HL-HL*DE  
30e1 eb			        EX      DE,HL           ;  
30e2 e1			        POP     HL              ;  
30e3 38 0a		        JR      C,L30EF         ; to MULT-OFLW  
30e5			  
30e5 7a			        LD      A,D             ;  
30e6 b3			        OR      E               ;  
30e7 20 01		        JR      NZ,L30EA        ; to MULT-RSLT  
30e9			  
30e9 4f			        LD      C,A             ;  
30ea			  
30ea			;; MULT-RSLT  
30ea cd 8e 2d		L30EA:  CALL    L2D8E           ; routine INT-STORE  
30ed d1			        POP      DE             ;  
30ee c9			        RET                     ;  
30ef			  
30ef			; ---  
30ef			  
30ef			;; MULT-OFLW  
30ef d1			L30EF:  POP     DE              ;  
30f0			  
30f0			;; MULT-LONG  
30f0 cd 93 32		L30F0:  CALL    L3293           ; routine RE-ST-TWO  
30f3 af			        XOR     A               ;  
30f4 cd c0 30		        CALL    L30C0           ; routine PREP-M/D  
30f7 d8			        RET     C               ;  
30f8			  
30f8 d9			        EXX                     ;  
30f9 e5			        PUSH    HL              ;  
30fa d9			        EXX                     ;  
30fb d5			        PUSH    DE              ;  
30fc eb			        EX      DE,HL           ;  
30fd cd c0 30		        CALL    L30C0           ; routine PREP-M/D  
3100 eb			        EX      DE,HL           ;  
3101 38 5a		        JR      C,L315D         ; to ZERO-RSLT  
3103			  
3103 e5			        PUSH    HL              ;  
3104 cd ba 2f		        CALL    L2FBA           ; routine FETCH-TWO  
3107 78			        LD      A,B             ;  
3108 a7			        AND     A               ;  
3109 ed 62		        SBC     HL,HL           ;  
310b d9			        EXX                     ;  
310c e5			        PUSH    HL              ;  
310d ed 62		        SBC     HL,HL           ;  
310f d9			        EXX                     ;  
3110 06 21		        LD      B,$21           ;  
3112 18 11		        JR      L3125           ; to STRT-MLT  
3114			  
3114			; ---  
3114			  
3114			;; MLT-LOOP  
3114 30 05		L3114:  JR      NC,L311B        ; to NO-ADD  
3116			  
3116 19			        ADD     HL,DE           ;  
3117 d9			        EXX                     ;  
3118 ed 5a		        ADC     HL,DE           ;  
311a d9			        EXX                     ;  
311b			  
311b			;; NO-ADD  
311b d9			L311B:  EXX                     ;  
311c cb 1c		        RR      H               ;  
311e cb 1d		        RR      L               ;  
3120 d9			        EXX                     ;  
3121 cb 1c		        RR      H               ;  
3123 cb 1d		        RR      L               ;  
3125			  
3125			;; STRT-MLT  
3125 d9			L3125:  EXX                     ;  
3126 cb 18		        RR      B               ;  
3128 cb 19		        RR      C               ;  
312a d9			        EXX                     ;  
312b cb 19		        RR      C               ;  
312d 1f			        RRA                     ;  
312e 10 e4		        DJNZ    L3114           ; to MLT-LOOP  
3130			  
3130 eb			        EX      DE,HL           ;  
3131 d9			        EXX                     ;  
3132 eb			        EX      DE,HL           ;  
3133 d9			        EXX                     ;  
3134 c1			        POP     BC              ;  
3135 e1			        POP     HL              ;  
3136 78			        LD      A,B             ;  
3137 81			        ADD     A,C             ;  
3138 20 01		        JR      NZ,L313B        ; to MAKE-EXPT  
313a			  
313a a7			        AND     A               ;  
313b			  
313b			;; MAKE-EXPT  
313b 3d			L313B:  DEC     A               ;  
313c 3f			        CCF                     ; Complement Carry Flag  
313d			  
313d			;; DIVN-EXPT  
313d 17			L313D:  RLA                     ;  
313e 3f			        CCF                     ; Complement Carry Flag  
313f 1f			        RRA                     ;  
3140 f2 46 31		        JP      P,L3146         ; to OFLW1-CLR  
3143			  
3143 30 68		        JR      NC,L31AD        ; to REPORT-6  
3145			  
3145 a7			        AND     A               ;  
3146			  
3146			;; OFLW1-CLR  
3146 3c			L3146:  INC     A               ;  
3147 20 08		        JR      NZ,L3151        ; to OFLW2-CLR  
3149			  
3149 38 06		        JR      C,L3151         ; to OFLW2-CLR  
314b			  
314b d9			        EXX                     ;  
314c cb 7a		        BIT     7,D             ;  
314e d9			        EXX                     ;  
314f 20 5c		        JR      NZ,L31AD        ; to REPORT-6  
3151			  
3151			;; OFLW2-CLR  
3151 77			L3151:  LD      (HL),A          ;  
3152 d9			        EXX                     ;  
3153 78			        LD      A,B             ;  
3154 d9			        EXX                     ;  
3155			  
3155			;; TEST-NORM  
3155 30 15		L3155:  JR      NC,L316C        ; to NORMALISE  
3157			  
3157 7e			        LD      A,(HL)          ;  
3158 a7			        AND     A               ;  
3159			  
3159			;; NEAR-ZERO  
3159 3e 80		L3159:  LD      A,$80           ;  
315b 28 01		        JR      Z,L315E         ; to SKIP-ZERO  
315d			  
315d			;; ZERO-RSLT  
315d af			L315D:  XOR     A               ;  
315e			  
315e			;; SKIP-ZERO  
315e d9			L315E:  EXX                     ;  
315f a2			        AND     D               ;  
3160 cd fb 2f		        CALL    L2FFB           ; routine ZEROS-4/5  
3163 07			        RLCA                    ;  
3164 77			        LD      (HL),A          ;  
3165 38 2e		        JR      C,L3195         ; to OFLOW-CLR  
3167			  
3167 23			        INC     HL              ;  
3168 77			        LD      (HL),A          ;  
3169 2b			        DEC     HL              ;  
316a 18 29		        JR      L3195           ; to OFLOW-CLR  
316c			  
316c			; ---  
316c			  
316c			;; NORMALISE  
316c 06 20		L316C:  LD      B,$20           ;  
316e			  
316e			;; SHIFT-ONE  
316e d9			L316E:  EXX                     ;  
316f cb 7a		        BIT     7,D             ;  
3171 d9			        EXX                     ;  
3172 20 12		        JR      NZ,L3186        ; to NORML-NOW  
3174			  
3174 07			        RLCA                    ;  
3175 cb 13		        RL      E               ;  
3177 cb 12		        RL      D               ;  
3179 d9			        EXX                     ;  
317a cb 13		        RL      E               ;  
317c cb 12		        RL      D               ;  
317e d9			        EXX                     ;  
317f 35			        DEC     (HL)            ;  
3180 28 d7		        JR      Z,L3159         ; to NEAR-ZERO  
3182			  
3182 10 ea		        DJNZ    L316E           ; to SHIFT-ONE  
3184			  
3184 18 d7		        JR      L315D           ; to ZERO-RSLT  
3186			  
3186			; ---  
3186			  
3186			;; NORML-NOW  
3186 17			L3186:  RLA                     ;  
3187 30 0c		        JR      NC,L3195        ; to OFLOW-CLR  
3189			  
3189 cd 04 30		        CALL    L3004           ; routine ADD-BACK  
318c 20 07		        JR      NZ,L3195        ; to OFLOW-CLR  
318e			  
318e d9			        EXX                     ;  
318f 16 80		        LD       D,$80          ;  
3191 d9			        EXX                     ;  
3192 34			        INC     (HL)            ;  
3193 28 18		        JR      Z,L31AD         ; to REPORT-6  
3195			  
3195			;; OFLOW-CLR  
3195 e5			L3195:  PUSH    HL              ;  
3196 23			        INC     HL              ;  
3197 d9			        EXX                     ;  
3198 d5			        PUSH    DE              ;  
3199 d9			        EXX                     ;  
319a c1			        POP     BC              ;  
319b 78			        LD      A,B             ;  
319c 17			        RLA                     ;  
319d cb 16		        RL      (HL)            ;  
319f 1f			        RRA                     ;  
31a0 77			        LD      (HL),A          ;  
31a1 23			        INC     HL              ;  
31a2 71			        LD      (HL),C          ;  
31a3 23			        INC     HL              ;  
31a4 72			        LD      (HL),D          ;  
31a5 23			        INC     HL              ;  
31a6 73			        LD      (HL),E          ;  
31a7 e1			        POP     HL              ;  
31a8 d1			        POP     DE              ;  
31a9 d9			        EXX                     ;  
31aa e1			        POP     HL              ;  
31ab d9			        EXX                     ;  
31ac c9			        RET                     ;  
31ad			  
31ad			; ---  
31ad			  
31ad			;; REPORT-6  
31ad cf			L31AD:  RST     08H             ; ERROR-1  
31ae 05			        DEFB    $05             ; Error Report: Number too big  
31af			  
31af			; --------------------  
31af			; Handle division (05)  
31af			; --------------------  
31af			;  
31af			;  
31af			  
31af			;; division  
31af cd 93 32		L31AF:  CALL    L3293           ; routine RE-ST-TWO  
31b2 eb			        EX      DE,HL           ;  
31b3 af			        XOR     A               ;  
31b4 cd c0 30		        CALL    L30C0           ; routine PREP-M/D  
31b7 38 f4		        JR      C,L31AD         ; to REPORT-6  
31b9			  
31b9 eb			        EX      DE,HL           ;  
31ba cd c0 30		        CALL    L30C0           ; routine PREP-M/D  
31bd d8			        RET     C               ;  
31be			  
31be d9			        EXX                     ;  
31bf e5			        PUSH    HL              ;  
31c0 d9			        EXX                     ;  
31c1 d5			        PUSH    DE              ;  
31c2 e5			        PUSH    HL              ;  
31c3 cd ba 2f		        CALL    L2FBA           ; routine FETCH-TWO  
31c6 d9			        EXX                     ;  
31c7 e5			        PUSH    HL              ;  
31c8 60			        LD      H,B             ;  
31c9 69			        LD      L,C             ;  
31ca d9			        EXX                     ;  
31cb 61			        LD      H,C             ;  
31cc 68			        LD      L,B             ;  
31cd af			        XOR     A               ;  
31ce 06 df		        LD      B,$DF           ;  
31d0 18 10		        JR      L31E2           ; to DIV-START  
31d2			  
31d2			; ---  
31d2			  
31d2			;; DIV-LOOP  
31d2 17			L31D2:  RLA                     ;  
31d3 cb 11		        RL      C               ;  
31d5 d9			        EXX                     ;  
31d6 cb 11		        RL      C               ;  
31d8 cb 10		        RL      B               ;  
31da d9			        EXX                     ;  
31db			  
31db			;; div-34th  
31db 29			L31DB:  ADD     HL,HL           ;  
31dc d9			        EXX                     ;  
31dd ed 6a		        ADC     HL,HL           ;  
31df d9			        EXX                     ;  
31e0 38 10		        JR      C,L31F2         ; to SUBN-ONLY  
31e2			  
31e2			;; DIV-START  
31e2 ed 52		L31E2:  SBC     HL,DE           ;  
31e4 d9			        EXX                     ;  
31e5 ed 52		        SBC     HL,DE           ;  
31e7 d9			        EXX                     ;  
31e8 30 0f		        JR      NC,L31F9        ; to NO-RSTORE  
31ea			  
31ea 19			        ADD     HL,DE           ;  
31eb d9			        EXX                     ;  
31ec ed 5a		        ADC     HL,DE           ;  
31ee d9			        EXX                     ;  
31ef a7			        AND     A               ;  
31f0 18 08		        JR      L31FA           ; to COUNT-ONE  
31f2			  
31f2			; ---  
31f2			  
31f2			;; SUBN-ONLY  
31f2 a7			L31F2:  AND     A               ;  
31f3 ed 52		        SBC     HL,DE           ;  
31f5 d9			        EXX                     ;  
31f6 ed 52		        SBC     HL,DE           ;  
31f8 d9			        EXX                     ;  
31f9			  
31f9			;; NO-RSTORE  
31f9 37			L31F9:  SCF                     ; Set Carry Flag  
31fa			  
31fa			;; COUNT-ONE  
31fa 04			L31FA:  INC     B               ;  
31fb fa d2 31		        JP      M,L31D2         ; to DIV-LOOP  
31fe			  
31fe f5			        PUSH    AF              ;  
31ff 28 e1		        JR      Z,L31E2         ; to DIV-START  
3201			  
3201			;  
3201			;  
3201			;  
3201			;  
3201			  
3201 5f			        LD      E,A             ;  
3202 51			        LD      D,C             ;  
3203 d9			        EXX                     ;  
3204 59			        LD      E,C             ;  
3205 50			        LD      D,B             ;  
3206 f1			        POP     AF              ;  
3207 cb 18		        RR      B               ;  
3209 f1			        POP     AF              ;  
320a cb 18		        RR      B               ;  
320c d9			        EXX                     ;  
320d c1			        POP     BC              ;  
320e e1			        POP     HL              ;  
320f 78			        LD      A,B             ;  
3210 91			        SUB     C               ;  
3211 c3 3d 31		        JP      L313D           ; jump back to DIVN-EXPT  
3214			  
3214			; ------------------------------------  
3214			; Integer truncation towards zero ($3A)  
3214			; ------------------------------------  
3214			;  
3214			;  
3214			  
3214			;; truncate  
3214 7e			L3214:  LD      A,(HL)          ;  
3215 a7			        AND     A               ;  
3216 c8			        RET     Z               ;  
3217			  
3217 fe 81		        CP      $81             ;  
3219 30 06		        JR      NC,L3221        ; to T-GR-ZERO  
321b			  
321b 36 00		        LD      (HL),$00        ;  
321d 3e 20		        LD      A,$20           ;  
321f 18 51		        JR      L3272           ; to NIL-BYTES  
3221			  
3221			; ---  
3221			  
3221			;; T-GR-ZERO  
3221 fe 91		L3221:  CP      $91             ;  
3223 20 1a		        JR      NZ,L323F        ; to T-SMALL  
3225			  
3225 23			        INC     HL              ;  
3226 23			        INC     HL              ;  
3227 23			        INC     HL              ;  
3228 3e 80		        LD      A,$80           ;  
322a a6			        AND     (HL)            ;  
322b 2b			        DEC      HL             ;  
322c b6			        OR      (HL)            ;  
322d 2b			        DEC     HL              ;  
322e 20 03		        JR      NZ,L3233        ; to T-FIRST  
3230			  
3230 3e 80		        LD      A,$80           ;  
3232 ae			        XOR     (HL)            ;  
3233			  
3233			;; T-FIRST  
3233 2b			L3233:  DEC     HL              ;  
3234 20 36		        JR      NZ,L326C        ; to T-EXPNENT  
3236			  
3236 77			        LD      (HL),A          ;  
3237 23			        INC     HL              ;  
3238 36 ff		        LD      (HL),$FF        ;  
323a 2b			        DEC     HL              ;  
323b 3e 18		        LD      A,$18           ;  
323d 18 33		        JR      L3272           ; to NIL-BYTES  
323f			  
323f			; ---  
323f			  
323f			;; T-SMALL  
323f 30 2c		L323F:  JR      NC,L326D        ; to X-LARGE  
3241			  
3241 d5			        PUSH    DE              ;  
3242 2f			        CPL                     ;  
3243 c6 91		        ADD     A,$91           ;  
3245 23			        INC     HL              ;  
3246 56			        LD      D,(HL)          ;  
3247 23			        INC     HL              ;  
3248 5e			        LD      E,(HL)          ;  
3249 2b			        DEC     HL              ;  
324a 2b			        DEC     HL              ;  
324b 0e 00		        LD      C,$00           ;  
324d cb 7a		        BIT     7,D             ;  
324f 28 01		        JR      Z,L3252         ; to T-NUMERIC  
3251			  
3251 0d			        DEC     C               ;  
3252			  
3252			;; T-NUMERIC  
3252 cb fa		L3252:  SET     7,D             ;  
3254 06 08		        LD      B,$08           ;  
3256 90			        SUB     B               ;  
3257 80			        ADD     A,B             ;  
3258 38 04		        JR      C,L325E         ; to T-TEST  
325a			  
325a 5a			        LD      E,D             ;  
325b 16 00		        LD      D,$00           ;  
325d 90			        SUB     B               ;  
325e			  
325e			;; T-TEST  
325e 28 07		L325E:  JR      Z,L3267         ; to T-STORE  
3260			  
3260 47			        LD      B,A             ;  
3261			  
3261			;; T-SHIFT  
3261 cb 3a		L3261:  SRL     D               ;  
3263 cb 1b		        RR      E               ;  
3265 10 fa		        DJNZ    L3261           ; to T-SHIFT  
3267			  
3267			;; T-STORE  
3267 cd 8e 2d		L3267:  CALL    L2D8E           ; routine INT-STORE  
326a d1			        POP     DE              ;  
326b c9			        RET                     ;  
326c			  
326c			; ---  
326c			  
326c			;; T-EXPNENT  
326c 7e			L326C:  LD      A,(HL)          ;  
326d			  
326d			;; X-LARGE  
326d d6 a0		L326D:  SUB     $A0             ;  
326f f0			        RET     P               ;  
3270			  
3270 ed 44		        NEG                     ; Negate  
3272			  
3272			;; NIL-BYTES  
3272 d5			L3272:  PUSH    DE              ;  
3273 eb			        EX      DE,HL           ;  
3274 2b			        DEC     HL              ;  
3275 47			        LD      B,A             ;  
3276 cb 38		        SRL     B               ;  
3278 cb 38		        SRL     B               ;  
327a cb 38		        SRL     B               ;  
327c 28 05		        JR      Z,L3283         ; to BITS-ZERO  
327e			  
327e			;; BYTE-ZERO  
327e 36 00		L327E:  LD      (HL),$00        ;  
3280 2b			        DEC     HL              ;  
3281 10 fb		        DJNZ    L327E           ; to BYTE-ZERO  
3283			  
3283			;; BITS-ZERO  
3283 e6 07		L3283:  AND     $07             ;  
3285 28 09		        JR      Z,L3290         ; to IX-END  
3287			  
3287 47			        LD      B,A             ;  
3288 3e ff		        LD      A,$FF           ;  
328a			  
328a			;; LESS-MASK  
328a cb 27		L328A:  SLA     A               ;  
328c 10 fc		        DJNZ    L328A           ; to LESS-MASK  
328e			  
328e a6			        AND     (HL)            ;  
328f 77			        LD      (HL),A          ;  
3290			  
3290			;; IX-END  
3290 eb			L3290:  EX      DE,HL           ;  
3291 d1			        POP     DE              ;  
3292 c9			        RET                     ;  
3293			  
3293			; ----------------------------------  
3293			; Storage of numbers in 5 byte form.  
3293			; ==================================  
3293			; Both integers and floating-point numbers can be stored in five bytes.  
3293			; Zero is a special case stored as 5 zeros.  
3293			; For integers the form is  
3293			; Byte 1 - zero,  
3293			; Byte 2 - sign byte, $00 +ve, $FF -ve.  
3293			; Byte 3 - Low byte of integer.  
3293			; Byte 4 - High byte  
3293			; Byte 5 - unused but always zero.  
3293			;  
3293			; it seems unusual to store the low byte first but it is just as easy either  
3293			; way. Statistically it just increases the chances of trailing zeros which  
3293			; is an advantage elsewhere in saving ROM code.  
3293			;  
3293			;             zero     sign     low      high    unused  
3293			; So +1 is  00000000 00000000 00000001 00000000 00000000  
3293			;  
3293			; and -1 is 00000000 11111111 11111111 11111111 00000000  
3293			;  
3293			; much of the arithmetic found in BASIC lines can be done using numbers  
3293			; in this form using the Z80's 16 bit register operation ADD.  
3293			; (multiplication is done by a sequence of additions).  
3293			;  
3293			; Storing -ve integers in two's complement form, means that they are ready for  
3293			; addition and you might like to add the numbers above to prove that the  
3293			; answer is zero. If, as in this case, the carry is set then that denotes that  
3293			; the result is positive. This only applies when the signs don't match.  
3293			; With positive numbers a carry denotes the result is out of integer range.  
3293			; With negative numbers a carry denotes the result is within range.  
3293			; The exception to the last rule is when the result is -65536  
3293			;  
3293			; Floating point form is an alternative method of storing numbers which can  
3293			; be used for integers and larger (or fractional) numbers.  
3293			;  
3293			; In this form 1 is stored as  
3293			;           10000001 00000000 00000000 00000000 00000000  
3293			;  
3293			; When a small integer is converted to a floating point number the last two  
3293			; bytes are always blank so they are omitted in the following steps  
3293			;  
3293			; first make exponent +1 +16d  (bit 7 of the exponent is set if positive)  
3293			  
3293			; 10010001 00000000 00000001  
3293			; 10010000 00000000 00000010 <-  now shift left and decrement exponent  
3293			; ...  
3293			; 10000010 01000000 00000000 <-  until a 1 abuts the imaginary point  
3293			; 10000001 10000000 00000000     to the left of the mantissa.  
3293			;  
3293			; however since the leftmost bit of the mantissa is always set then it can  
3293			; be used to denote the sign of the mantissa and put back when needed by the  
3293			; PREP routines which gives  
3293			;  
3293			; 10000001 00000000 00000000  
3293			  
3293			; -----------------------------  
3293			; Re-stack two `small' integers  
3293			; -----------------------------  
3293			; This routine is called to re-stack two numbers in full floating point form  
3293			; e.g. from mult when integer multiplication has overflowed.  
3293			  
3293			;; RE-ST-TWO  
3293 cd 96 32		L3293:  CALL    L3296           ; routine RESTK-SUB  below and continue  
3296			                                ; into the routine to do the other one.  
3296			  
3296			;; RESTK-SUB  
3296 eb			L3296:  EX      DE,HL           ; swap pointers  
3297			  
3297			; --------------------------------  
3297			; Re-stack one number in full form  
3297			; --------------------------------  
3297			; This routine re-stacks an integer usually on the calculator stack  
3297			; in full floating point form.  
3297			; HL points to first byte.  
3297			  
3297			;; re-stack  
3297 7e			L3297:  LD      A,(HL)          ; Fetch Exponent byte to A  
3298 a7			        AND     A               ; test it  
3299 c0			        RET     NZ              ; return if not zero as already in full  
329a			                                ; floating-point form.  
329a			  
329a d5			        PUSH    DE              ; preserve DE.  
329b cd 7f 2d		        CALL    L2D7F           ; routine INT-FETCH  
329e			                                ; integer to DE, sign to C.  
329e			  
329e			; HL points to 4th byte.  
329e			  
329e af			        XOR     A               ; clear accumulator.  
329f 23			        INC     HL              ; point to 5th.  
32a0 77			        LD      (HL),A          ; and blank.  
32a1 2b			        DEC     HL              ; point to 4th.  
32a2 77			        LD      (HL),A          ; and blank.  
32a3			  
32a3 06 91		        LD      B,$91           ; set exponent byte +ve $81  
32a5			                                ; and imaginary dec point 16 bits to right  
32a5			                                ; of first bit.  
32a5			  
32a5			; we could skip to normalize now but it's quicker to avoid  
32a5			; normalizing through an empty D.  
32a5			  
32a5 7a			        LD      A,D             ; fetch the high byte D  
32a6 a7			        AND     A               ; is it zero ?  
32a7 20 08		        JR      NZ,L32B1        ; skip to RS-NRMLSE if not.  
32a9			  
32a9 b3			        OR      E               ; low byte E to A and test for zero  
32aa 42			        LD      B,D             ; set B exponent to 0  
32ab 28 10		        JR      Z,L32BD         ; forward to RS-STORE if value is zero.  
32ad			  
32ad 53			        LD      D,E             ; transfer E to D  
32ae 58			        LD      E,B             ; set E to 0  
32af 06 89		        LD      B,$89           ; reduce the initial exponent by eight.  
32b1			  
32b1			  
32b1			;; RS-NRMLSE  
32b1 eb			L32B1:  EX      DE,HL           ; integer to HL, addr of 4th byte to DE.  
32b2			  
32b2			;; RSTK-LOOP  
32b2 05			L32B2:  DEC     B               ; decrease exponent  
32b3 29			        ADD     HL,HL           ; shift DE left  
32b4 30 fc		        JR      NC,L32B2        ; loop back to RSTK-LOOP  
32b6			                                ; until a set bit pops into carry  
32b6			  
32b6 cb 09		        RRC     C               ; now rotate the sign byte $00 or $FF  
32b8			                                ; into carry to give a sign bit  
32b8			  
32b8 cb 1c		        RR      H               ; rotate the sign bit to left of H  
32ba cb 1d		        RR      L               ; rotate any carry into L  
32bc			  
32bc eb			        EX      DE,HL           ; address 4th byte, normalized int to DE  
32bd			  
32bd			;; RS-STORE  
32bd 2b			L32BD:  DEC     HL              ; address 3rd byte  
32be 73			        LD      (HL),E          ; place E  
32bf 2b			        DEC     HL              ; address 2nd byte  
32c0 72			        LD      (HL),D          ; place D  
32c1 2b			        DEC     HL              ; address 1st byte  
32c2 70			        LD      (HL),B          ; store the exponent  
32c3			  
32c3 d1			        POP     DE              ; restore initial DE.  
32c4 c9			        RET                     ; return.  
32c5			  
32c5			;****************************************  
32c5			;** Part 10. FLOATING-POINT CALCULATOR **  
32c5			;****************************************  
32c5			  
32c5			; As a general rule the calculator avoids using the IY register.  
32c5			; exceptions are val, val$ and str$.  
32c5			; So an assembly language programmer who has disabled interrupts to use  
32c5			; IY for other purposes can still use the calculator for mathematical  
32c5			; purposes.  
32c5			  
32c5			  
32c5			; ------------------  
32c5			; Table of constants  
32c5			; ------------------  
32c5			;  
32c5			;  
32c5			  
32c5			; used 11 times  
32c5			;; stk-zero                                                 00 00 00 00 00  
32c5 00			L32C5:  DEFB    $00             ;;Bytes: 1  
32c6 b0			        DEFB    $B0             ;;Exponent $00  
32c7 00			        DEFB    $00             ;;(+00,+00,+00)  
32c8			  
32c8			; used 19 times  
32c8			;; stk-one                                                  00 00 01 00 00  
32c8 40			L32C8:  DEFB    $40             ;;Bytes: 2  
32c9 b0			        DEFB    $B0             ;;Exponent $00  
32ca 00 01		        DEFB    $00,$01         ;;(+00,+00)  
32cc			  
32cc			; used 9 times  
32cc			;; stk-half                                                 80 00 00 00 00  
32cc 30			L32CC:  DEFB    $30             ;;Exponent: $80, Bytes: 1  
32cd 00			        DEFB    $00             ;;(+00,+00,+00)  
32ce			  
32ce			; used 4 times.  
32ce			;; stk-pi/2                                                 81 49 0F DA A2  
32ce f1			L32CE:  DEFB    $F1             ;;Exponent: $81, Bytes: 4  
32cf 49 0f da a2	        DEFB    $49,$0F,$DA,$A2 ;;  
32d3			  
32d3			; used 3 times.  
32d3			;; stk-ten                                                  00 00 0A 00 00  
32d3 40			L32D3:  DEFB    $40             ;;Bytes: 2  
32d4 b0			        DEFB    $B0             ;;Exponent $00  
32d5 00 0a		        DEFB    $00,$0A         ;;(+00,+00)  
32d7			  
32d7			  
32d7			; ------------------  
32d7			; Table of addresses  
32d7			; ------------------  
32d7			;  
32d7			; starts with binary operations which have two operands and one result.  
32d7			; three pseudo binary operations first.  
32d7			  
32d7			;; tbl-addrs  
32d7 8f 36		L32D7:  DEFW    L368F           ; $00 Address: $368F - jump-true  
32d9 3c 34		        DEFW    L343C           ; $01 Address: $343C - exchange  
32db a1 33		        DEFW    L33A1           ; $02 Address: $33A1 - delete  
32dd			  
32dd			; true binary operations.  
32dd			  
32dd 0f 30		        DEFW    L300F           ; $03 Address: $300F - subtract  
32df ca 30		        DEFW    L30CA           ; $04 Address: $30CA - multiply  
32e1 af 31		        DEFW    L31AF           ; $05 Address: $31AF - division  
32e3 51 38		        DEFW    L3851           ; $06 Address: $3851 - to-power  
32e5 1b 35		        DEFW    L351B           ; $07 Address: $351B - or  
32e7			  
32e7 24 35		        DEFW    L3524           ; $08 Address: $3524 - no-&-no  
32e9 3b 35		        DEFW    L353B           ; $09 Address: $353B - no-l-eql  
32eb 3b 35		        DEFW    L353B           ; $0A Address: $353B - no-gr-eql  
32ed 3b 35		        DEFW    L353B           ; $0B Address: $353B - nos-neql  
32ef 3b 35		        DEFW    L353B           ; $0C Address: $353B - no-grtr  
32f1 3b 35		        DEFW    L353B           ; $0D Address: $353B - no-less  
32f3 3b 35		        DEFW    L353B           ; $0E Address: $353B - nos-eql  
32f5 14 30		        DEFW    L3014           ; $0F Address: $3014 - addition  
32f7			  
32f7 2d 35		        DEFW    L352D           ; $10 Address: $352D - str-&-no  
32f9 3b 35		        DEFW    L353B           ; $11 Address: $353B - str-l-eql  
32fb 3b 35		        DEFW    L353B           ; $12 Address: $353B - str-gr-eql  
32fd 3b 35		        DEFW    L353B           ; $13 Address: $353B - strs-neql  
32ff 3b 35		        DEFW    L353B           ; $14 Address: $353B - str-grtr  
3301 3b 35		        DEFW    L353B           ; $15 Address: $353B - str-less  
3303 3b 35		        DEFW    L353B           ; $16 Address: $353B - strs-eql  
3305 9c 35		        DEFW    L359C           ; $17 Address: $359C - strs-add  
3307			  
3307			; unary follow  
3307			  
3307 de 35		        DEFW    L35DE           ; $18 Address: $35DE - val$  
3309 bc 34		        DEFW    L34BC           ; $19 Address: $34BC - usr-$  
330b 45 36		        DEFW    L3645           ; $1A Address: $3645 - read-in  
330d 6e 34		        DEFW    L346E           ; $1B Address: $346E - negate  
330f			  
330f 69 36		        DEFW    L3669           ; $1C Address: $3669 - code  
3311 de 35		        DEFW    L35DE           ; $1D Address: $35DE - val  
3313 74 36		        DEFW    L3674           ; $1E Address: $3674 - len  
3315 b5 37		        DEFW    L37B5           ; $1F Address: $37B5 - sin  
3317 aa 37		        DEFW    L37AA           ; $20 Address: $37AA - cos  
3319 da 37		        DEFW    L37DA           ; $21 Address: $37DA - tan  
331b 33 38		        DEFW    L3833           ; $22 Address: $3833 - asn  
331d 43 38		        DEFW    L3843           ; $23 Address: $3843 - acs  
331f e2 37		        DEFW    L37E2           ; $24 Address: $37E2 - atn  
3321 13 37		        DEFW    L3713           ; $25 Address: $3713 - ln  
3323 c4 36		        DEFW    L36C4           ; $26 Address: $36C4 - exp  
3325 af 36		        DEFW    L36AF           ; $27 Address: $36AF - int  
3327 4a 38		        DEFW    L384A           ; $28 Address: $384A - sqr  
3329 92 34		        DEFW    L3492           ; $29 Address: $3492 - sgn  
332b 6a 34		        DEFW    L346A           ; $2A Address: $346A - abs  
332d ac 34		        DEFW    L34AC           ; $2B Address: $34AC - peek  
332f a5 34		        DEFW    L34A5           ; $2C Address: $34A5 - in  
3331 b3 34		        DEFW    L34B3           ; $2D Address: $34B3 - usr-no  
3333 1f 36		        DEFW    L361F           ; $2E Address: $361F - str$  
3335 c9 35		        DEFW    L35C9           ; $2F Address: $35C9 - chrs  
3337 01 35		        DEFW    L3501           ; $30 Address: $3501 - not  
3339			  
3339			; end of true unary  
3339			  
3339 c0 33		        DEFW    L33C0           ; $31 Address: $33C0 - duplicate  
333b a0 36		        DEFW    L36A0           ; $32 Address: $36A0 - n-mod-m  
333d 86 36		        DEFW    L3686           ; $33 Address: $3686 - jump  
333f c6 33		        DEFW    L33C6           ; $34 Address: $33C6 - stk-data  
3341 7a 36		        DEFW    L367A           ; $35 Address: $367A - dec-jr-nz  
3343 06 35		        DEFW    L3506           ; $36 Address: $3506 - less-0  
3345 f9 34		        DEFW    L34F9           ; $37 Address: $34F9 - greater-0  
3347 9b 36		        DEFW    L369B           ; $38 Address: $369B - end-calc  
3349 83 37		        DEFW    L3783           ; $39 Address: $3783 - get-argt  
334b 14 32		        DEFW    L3214           ; $3A Address: $3214 - truncate  
334d a2 33		        DEFW    L33A2           ; $3B Address: $33A2 - fp-calc-2  
334f 4f 2d		        DEFW    L2D4F           ; $3C Address: $2D4F - e-to-fp  
3351 97 32		        DEFW    L3297           ; $3D Address: $3297 - re-stack  
3353			  
3353			; the following are just the next available slots for the 128 compound literals  
3353			; which are in range $80 - $FF.  
3353			  
3353 49 34		        DEFW    L3449           ; $3E Address: $3449 - series-xx    $80 - $9F.  
3355 1b 34		        DEFW    L341B           ; $3F Address: $341B - stk-const-xx $A0 - $BF.  
3357 2d 34		        DEFW    L342D           ; $40 Address: $342D - st-mem-xx    $C0 - $DF.  
3359 0f 34		        DEFW    L340F           ; $41 Address: $340F - get-mem-xx   $E0 - $FF.  
335b			  
335b			; Aside: 3E - 7F are therefore unused calculator literals.  
335b			;        3E - 7B would be available for expansion.  
335b			  
335b			; --------------  
335b			; The Calculator  
335b			; --------------  
335b			;  
335b			;  
335b			  
335b			;; CALCULATE  
335b cd bf 35		L335B:  CALL    L35BF           ; routine STK-PNTRS is called to set up the  
335e			                                ; calculator stack pointers for a default  
335e			                                ; unary operation. HL = last value on stack.  
335e			                                ; DE = STKEND first location after stack.  
335e			  
335e			; the calculate routine is called at this point by the series generator...  
335e			  
335e			;; GEN-ENT-1  
335e 78			L335E:  LD      A,B             ; fetch the Z80 B register to A  
335f 32 67 5c		        LD      ($5C67),A       ; and store value in system variable BREG.  
3362			                                ; this will be the counter for dec-jr-nz  
3362			                                ; or if used from fp-calc2 the calculator  
3362			                                ; instruction.  
3362			  
3362			; ... and again later at this point  
3362			  
3362			;; GEN-ENT-2  
3362 d9			L3362:  EXX                     ; switch sets  
3363 e3			        EX      (SP),HL         ; and store the address of next instruction,  
3364			                                ; the return address, in H'L'.  
3364			                                ; If this is a recursive call the the H'L'  
3364			                                ; of the previous invocation goes on stack.  
3364			                                ; c.f. end-calc.  
3364 d9			        EXX                     ; switch back to main set  
3365			  
3365			; this is the re-entry looping point when handling a string of literals.  
3365			  
3365			;; RE-ENTRY  
3365 ed 53 65 5c	L3365:  LD      ($5C65),DE      ; save end of stack in system variable STKEND  
3369 d9			        EXX                     ; switch to alt  
336a 7e			        LD      A,(HL)          ; get next literal  
336b 23			        INC     HL              ; increase pointer'  
336c			  
336c			; single operation jumps back to here  
336c			  
336c			;; SCAN-ENT  
336c e5			L336C:  PUSH    HL              ; save pointer on stack  
336d a7			        AND     A               ; now test the literal  
336e f2 80 33		        JP      P,L3380         ; forward to FIRST-3D if in range $00 - $3D  
3371			                                ; anything with bit 7 set will be one of  
3371			                                ; 128 compound literals.  
3371			  
3371			; compound literals have the following format.  
3371			; bit 7 set indicates compound.  
3371			; bits 6-5 the subgroup 0-3.  
3371			; bits 4-0 the embedded parameter $00 - $1F.  
3371			; The subgroup 0-3 needs to be manipulated to form the next available four  
3371			; address places after the simple literals in the address table.  
3371			  
3371 57			        LD      D,A             ; save literal in D  
3372 e6 60		        AND     $60             ; and with 01100000 to isolate subgroup  
3374 0f			        RRCA                    ; rotate bits  
3375 0f			        RRCA                    ; 4 places to right  
3376 0f			        RRCA                    ; not five as we need offset * 2  
3377 0f			        RRCA                    ; 00000xx0  
3378 c6 7c		        ADD     A,$7C           ; add ($3E * 2) to give correct offset.  
337a			                                ; alter above if you add more literals.  
337a 6f			        LD      L,A             ; store in L for later indexing.  
337b 7a			        LD      A,D             ; bring back compound literal  
337c e6 1f		        AND     $1F             ; use mask to isolate parameter bits  
337e 18 0e		        JR      L338E           ; forward to ENT-TABLE  
3380			  
3380			; ---  
3380			  
3380			; the branch was here with simple literals.  
3380			  
3380			;; FIRST-3D  
3380 fe 18		L3380:  CP      $18             ; compare with first unary operations.  
3382 30 08		        JR      NC,L338C        ; to DOUBLE-A with unary operations  
3384			  
3384			; it is binary so adjust pointers.  
3384			  
3384 d9			        EXX                     ;  
3385 01 fb ff		        LD      BC,$FFFB        ; the value -5  
3388 54			        LD      D,H             ; transfer HL, the last value, to DE.  
3389 5d			        LD      E,L             ;  
338a 09			        ADD     HL,BC           ; subtract 5 making HL point to second  
338b			                                ; value.  
338b d9			        EXX                     ;  
338c			  
338c			;; DOUBLE-A  
338c 07			L338C:  RLCA                    ; double the literal  
338d 6f			        LD      L,A             ; and store in L for indexing  
338e			  
338e			;; ENT-TABLE  
338e 11 d7 32		L338E:  LD      DE,L32D7        ; Address: tbl-addrs  
3391 26 00		        LD      H,$00           ; prepare to index  
3393 19			        ADD     HL,DE           ; add to get address of routine  
3394 5e			        LD      E,(HL)          ; low byte to E  
3395 23			        INC     HL              ;  
3396 56			        LD      D,(HL)          ; high byte to D  
3397 21 65 33		        LD      HL,L3365        ; Address: RE-ENTRY  
339a e3			        EX      (SP),HL         ; goes to stack  
339b d5			        PUSH    DE              ; now address of routine  
339c d9			        EXX                     ; main set  
339d			                                ; avoid using IY register.  
339d ed 4b 66 5c	        LD      BC,($5C66)      ; STKEND_hi  
33a1			                                ; nothing much goes to C but BREG to B  
33a1			                                ; and continue into next ret instruction  
33a1			                                ; which has a dual identity  
33a1			  
33a1			  
33a1			; ------------------  
33a1			; Handle delete (02)  
33a1			; ------------------  
33a1			; A simple return but when used as a calculator literal this  
33a1			; deletes the last value from the calculator stack.  
33a1			; On entry, as always with binary operations,  
33a1			; HL=first number, DE=second number  
33a1			; On exit, HL=result, DE=stkend.  
33a1			; So nothing to do  
33a1			  
33a1			;; delete  
33a1 c9			L33A1:  RET                     ; return - indirect jump if from above.  
33a2			  
33a2			; ---------------------  
33a2			; Single operation (3B)  
33a2			; ---------------------  
33a2			; this single operation is used, in the first instance, to evaluate most  
33a2			; of the mathematical and string functions found in BASIC expressions.  
33a2			  
33a2			;; fp-calc-2  
33a2 f1			L33A2:  POP     AF              ; drop return address.  
33a3 3a 67 5c		        LD      A,($5C67)       ; load accumulator from system variable BREG  
33a6			                                ; value will be literal eg. 'tan'  
33a6 d9			        EXX                     ; switch to alt  
33a7 18 c3		        JR      L336C           ; back to SCAN-ENT  
33a9			                                ; next literal will be end-calc at L2758  
33a9			  
33a9			; ----------------  
33a9			; Test five-spaces  
33a9			; ----------------  
33a9			; This routine is called from MOVE-FP, STK-CONST and STK-STORE to  
33a9			; test that there is enough space between the calculator stack and the  
33a9			; machine stack for another five-byte value. It returns with BC holding  
33a9			; the value 5 ready for any subsequent LDIR.  
33a9			  
33a9			;; TEST-5-SP  
33a9 d5			L33A9:  PUSH    DE              ; save  
33aa e5			        PUSH    HL              ; registers  
33ab 01 05 00		        LD      BC,$0005        ; an overhead of five bytes  
33ae cd 05 1f		        CALL    L1F05           ; routine TEST-ROOM tests free RAM raising  
33b1			                                ; an error if not.  
33b1 e1			        POP     HL              ; else restore  
33b2 d1			        POP     DE              ; registers.  
33b3 c9			        RET                     ; return with BC set at 5.  
33b4			  
33b4			; ------------  
33b4			; Stack number  
33b4			; ------------  
33b4			; This routine is called to stack a hidden floating point number found in  
33b4			; a BASIC line. It is also called to stack a numeric variable value, and  
33b4			; from BEEP, to stack an entry in the semi-tone table. It is not part of the  
33b4			; calculator suite of routines.  
33b4			; On entry HL points to the number to be stacked.  
33b4			  
33b4			;; STACK-NUM  
33b4 ed 5b 65 5c	L33B4:  LD      DE,($5C65)      ; load destination from STKEND system variable.  
33b8 cd c0 33		        CALL    L33C0           ; routine MOVE-FP puts on calculator stack   
33bb			                                ; with a memory check.  
33bb ed 53 65 5c	        LD      ($5C65),DE      ; set STKEND to next free location.  
33bf c9			        RET                     ; return.  
33c0			  
33c0			; ---------------------------------  
33c0			; Move a floating point number (31)  
33c0			; ---------------------------------  
33c0			; This simple routine is a 5-byte LDIR instruction  
33c0			; that incorporates a memory check.  
33c0			; When used as a calculator literal it duplicates the last value on the  
33c0			; calculator stack.  
33c0			; Unary so on entry HL points to last value, DE to stkend  
33c0			  
33c0			;; duplicate  
33c0			;; MOVE-FP  
33c0 cd a9 33		L33C0:  CALL    L33A9           ; routine TEST-5-SP test free memory  
33c3			                                ; and sets BC to 5.  
33c3 ed b0		        LDIR                    ; copy the five bytes.  
33c5 c9			        RET                     ; return with DE addressing new STKEND  
33c6			                                ; and HL addressing new last value.  
33c6			  
33c6			; -------------------  
33c6			; Stack literals ($34)  
33c6			; -------------------  
33c6			; When a calculator subroutine needs to put a value on the calculator  
33c6			; stack that is not a regular constant this routine is called with a  
33c6			; variable number of following data bytes that convey to the routine  
33c6			; the integer or floating point form as succinctly as is possible.  
33c6			  
33c6			;; stk-data  
33c6 62			L33C6:  LD      H,D             ; transfer STKEND  
33c7 6b			        LD      L,E             ; to HL for result.  
33c8			  
33c8			;; STK-CONST  
33c8 cd a9 33		L33C8:  CALL    L33A9           ; routine TEST-5-SP tests that room exists  
33cb			                                ; and sets BC to $05.  
33cb			  
33cb d9			        EXX                     ; switch to alternate set  
33cc e5			        PUSH    HL              ; save the pointer to next literal on stack  
33cd d9			        EXX                     ; switch back to main set  
33ce			  
33ce e3			        EX      (SP),HL         ; pointer to HL, destination to stack.  
33cf			  
33cf c5			        PUSH    BC              ; save BC - value 5 from test room ??.  
33d0			  
33d0 7e			        LD      A,(HL)          ; fetch the byte following 'stk-data'  
33d1 e6 c0		        AND     $C0             ; isolate bits 7 and 6  
33d3 07			        RLCA                    ; rotate  
33d4 07			        RLCA                    ; to bits 1 and 0  range $00 - $03.  
33d5 4f			        LD      C,A             ; transfer to C  
33d6 0c			        INC     C               ; and increment to give number of bytes  
33d7			                                ; to read. $01 - $04  
33d7 7e			        LD      A,(HL)          ; reload the first byte  
33d8 e6 3f		        AND     $3F             ; mask off to give possible exponent.  
33da 20 02		        JR      NZ,L33DE        ; forward to FORM-EXP if it was possible to  
33dc			                                ; include the exponent.  
33dc			  
33dc			; else byte is just a byte count and exponent comes next.  
33dc			  
33dc 23			        INC     HL              ; address next byte and  
33dd 7e			        LD      A,(HL)          ; pick up the exponent ( - $50).  
33de			  
33de			;; FORM-EXP  
33de c6 50		L33DE:  ADD     A,$50           ; now add $50 to form actual exponent  
33e0 12			        LD      (DE),A          ; and load into first destination byte.  
33e1 3e 05		        LD      A,$05           ; load accumulator with $05 and  
33e3 91			        SUB     C               ; subtract C to give count of trailing  
33e4			                                ; zeros plus one.  
33e4 23			        INC     HL              ; increment source  
33e5 13			        INC     DE              ; increment destination  
33e6 06 00		        LD      B,$00           ; prepare to copy  
33e8 ed b0		        LDIR                    ; copy C bytes  
33ea			  
33ea c1			        POP     BC              ; restore 5 counter to BC ??.  
33eb			  
33eb e3			        EX      (SP),HL         ; put HL on stack as next literal pointer  
33ec			                                ; and the stack value - result pointer -  
33ec			                                ; to HL.  
33ec			  
33ec d9			        EXX                     ; switch to alternate set.  
33ed e1			        POP     HL              ; restore next literal pointer from stack  
33ee			                                ; to H'L'.  
33ee d9			        EXX                     ; switch back to main set.  
33ef			  
33ef 47			        LD      B,A             ; zero count to B  
33f0 af			        XOR     A               ; clear accumulator  
33f1			  
33f1			;; STK-ZEROS  
33f1 05			L33F1:  DEC     B               ; decrement B counter  
33f2 c8			        RET     Z               ; return if zero.          >>  
33f3			                                ; DE points to new STKEND  
33f3			                                ; HL to new number.  
33f3			  
33f3 12			        LD      (DE),A          ; else load zero to destination  
33f4 13			        INC     DE              ; increase destination  
33f5 18 fa		        JR      L33F1           ; loop back to STK-ZEROS until done.  
33f7			  
33f7			; -------------------------------  
33f7			; THE 'SKIP CONSTANTS' SUBROUTINE  
33f7			; -------------------------------  
33f7			; This routine traverses variable-length entries in the table of constants,  
33f7			; stacking intermediate, unwanted constants onto a dummy calculator stack,  
33f7			; in the first five bytes of ROM. The destination DE normally points to the  
33f7			; end of the calculator stack which might be in the normal place or in the  
33f7			; system variables area during E-LINE-NO; INT-TO-FP; stk-ten. In any case,  
33f7			; it would be simpler all round if the routine just shoved unwanted values   
33f7			; where it is going to stick the wanted value.   
33f7			; The instruction LD DE, $0000 can be removed.  
33f7			  
33f7			;; SKIP-CONS  
33f7 a7			L33F7:  AND     A               ; test if initially zero.  
33f8			  
33f8			;; SKIP-NEXT  
33f8 c8			L33F8:  RET     Z               ; return if zero.          >>  
33f9			  
33f9 f5			        PUSH    AF              ; save count.  
33fa d5			        PUSH    DE              ; and normal STKEND  
33fb			  
33fb 11 00 00		        LD      DE,$0000        ; dummy value for STKEND at start of ROM  
33fe			                                ; Note. not a fault but this has to be  
33fe			                                ; moved elsewhere when running in RAM.  
33fe			                                ; e.g. with Expandor Systems 'Soft ROM'.  
33fe			                                ; Better still, write to the normal place.  
33fe cd c8 33		        CALL    L33C8           ; routine STK-CONST works through variable  
3401			                                ; length records.  
3401			  
3401 d1			        POP     DE              ; restore real STKEND  
3402 f1			        POP     AF              ; restore count  
3403 3d			        DEC     A               ; decrease  
3404 18 f2		        JR      L33F8           ; loop back to SKIP-NEXT  
3406			  
3406			; ---------------  
3406			; Memory location  
3406			; ---------------  
3406			; This routine, when supplied with a base address in HL and an index in A  
3406			; will calculate the address of the A'th entry, where each entry occupies  
3406			; five bytes. It is used for reading the semi-tone table and addressing  
3406			; floating-point numbers in the calculator's memory area.  
3406			  
3406			;; LOC-MEM  
3406 4f			L3406:  LD      C,A             ; store the original number $00-$1F.  
3407 07			        RLCA                    ; double.  
3408 07			        RLCA                    ; quadruple.  
3409 81			        ADD     A,C             ; now add original to multiply by five.  
340a			  
340a 4f			        LD      C,A             ; place the result in C.  
340b 06 00		        LD      B,$00           ; set B to 0.  
340d 09			        ADD     HL,BC           ; add to form address of start of number in HL.  
340e c9			        RET                     ; return.  
340f			  
340f			; ------------------------------  
340f			; Get from memory area ($E0 etc.)  
340f			; ------------------------------  
340f			; Literals $E0 to $FF  
340f			; A holds $00-$1F offset.  
340f			; The calculator stack increases by 5 bytes.  
340f			  
340f			;; get-mem-xx  
340f d5			L340F:  PUSH    DE              ; save STKEND  
3410 2a 68 5c		        LD      HL,($5C68)      ; MEM is base address of the memory cells.  
3413 cd 06 34		        CALL    L3406           ; routine LOC-MEM so that HL = first byte  
3416 cd c0 33		        CALL    L33C0           ; routine MOVE-FP moves 5 bytes with memory  
3419			                                ; check.  
3419			                                ; DE now points to new STKEND.  
3419 e1			        POP     HL              ; original STKEND is now RESULT pointer.  
341a c9			        RET                     ; return.  
341b			  
341b			; --------------------------  
341b			; Stack a constant (A0 etc.)  
341b			; --------------------------  
341b			; This routine allows a one-byte instruction to stack up to 32 constants  
341b			; held in short form in a table of constants. In fact only 5 constants are  
341b			; required. On entry the A register holds the literal ANDed with 1F.  
341b			; It isn't very efficient and it would have been better to hold the  
341b			; numbers in full, five byte form and stack them in a similar manner  
341b			; to that used for semi-tone table values.  
341b			  
341b			;; stk-const-xx  
341b 62			L341B:  LD      H,D             ; save STKEND - required for result  
341c 6b			        LD      L,E             ;  
341d d9			        EXX                     ; swap  
341e e5			        PUSH    HL              ; save pointer to next literal  
341f 21 c5 32		        LD      HL,L32C5        ; Address: stk-zero - start of table of  
3422			                                ; constants  
3422 d9			        EXX                     ;  
3423 cd f7 33		        CALL    L33F7           ; routine SKIP-CONS  
3426 cd c8 33		        CALL    L33C8           ; routine STK-CONST  
3429 d9			        EXX                     ;  
342a e1			        POP     HL              ; restore pointer to next literal.  
342b d9			        EXX                     ;  
342c c9			        RET                     ; return.  
342d			  
342d			; --------------------------------  
342d			; Store in a memory area ($C0 etc.)  
342d			; --------------------------------  
342d			; Offsets $C0 to $DF  
342d			; Although 32 memory storage locations can be addressed, only six  
342d			; $C0 to $C5 are required by the ROM and only the thirty bytes (6*5)  
342d			; required for these are allocated. Spectrum programmers who wish to  
342d			; use the floating point routines from assembly language may wish to  
342d			; alter the system variable MEM to point to 160 bytes of RAM to have   
342d			; use the full range available.  
342d			; A holds the derived offset $00-$1F.  
342d			; This is a unary operation, so on entry HL points to the last value and DE   
342d			; points to STKEND.  
342d			  
342d			;; st-mem-xx  
342d e5			L342D:  PUSH    HL              ; save the result pointer.  
342e eb			        EX      DE,HL           ; transfer to DE.  
342f 2a 68 5c		        LD      HL,($5C68)      ; fetch MEM the base of memory area.  
3432 cd 06 34		        CALL    L3406           ; routine LOC-MEM sets HL to the destination.  
3435 eb			        EX      DE,HL           ; swap - HL is start, DE is destination.  
3436 cd c0 33		        CALL    L33C0           ; routine MOVE-FP.  
3439			                                ; note. a short ld bc,5; ldir  
3439			                                ; the embedded memory check is not required  
3439			                                ; so these instructions would be faster.  
3439 eb			        EX      DE,HL           ; DE = STKEND  
343a e1			        POP     HL              ; restore original result pointer  
343b c9			        RET                     ; return.  
343c			  
343c			; ------------------------------------  
343c			; Swap first number with second number  
343c			; ------------------------------------  
343c			; This routine exchanges the last two values on the calculator stack  
343c			; On entry, as always with binary operations,  
343c			; HL=first number, DE=second number  
343c			; On exit, HL=result, DE=stkend.  
343c			  
343c			;; exchange  
343c 06 05		L343C:  LD      B,$05           ; there are five bytes to be swapped  
343e			  
343e			; start of loop.  
343e			  
343e			;; SWAP-BYTE  
343e 1a			L343E:  LD      A,(DE)          ; each byte of second  
343f 4e			        LD      C,(HL)          ; each byte of first  
3440 eb			        EX      DE,HL           ; swap pointers  
3441 12			        LD      (DE),A          ; store each byte of first  
3442 71			        LD      (HL),C          ; store each byte of second  
3443 23			        INC     HL              ; advance both  
3444 13			        INC     DE              ; pointers.  
3445 10 f7		        DJNZ    L343E           ; loop back to SWAP-BYTE until all 5 done.  
3447			  
3447 eb			        EX      DE,HL           ; even up the exchanges  
3448			                                ; so that DE addresses STKEND.  
3448 c9			        RET                     ; return.  
3449			  
3449			; --------------------------  
3449			; Series generator (86 etc.)  
3449			; --------------------------  
3449			; The Spectrum uses Chebyshev polynomials to generate approximations for  
3449			; SIN, ATN, LN and EXP. These are named after the Russian mathematician  
3449			; Pafnuty Chebyshev, born in 1821, who did much pioneering work on numerical  
3449			; series. As far as calculators are concerned, Chebyshev polynomials have an  
3449			; advantage over other series, for example the Taylor series, as they can  
3449			; reach an approximation in just six iterations for SIN, eight for EXP and  
3449			; twelve for LN and ATN. The mechanics of the routine are interesting but  
3449			; for full treatment of how these are generated with demonstrations in  
3449			; Sinclair BASIC see "The Complete Spectrum ROM Disassembly" by Dr Ian Logan  
3449			; and Dr Frank O'Hara, published 1983 by Melbourne House.  
3449			  
3449			;; series-xx  
3449 47			L3449:  LD      B,A             ; parameter $00 - $1F to B counter  
344a cd 5e 33		        CALL    L335E           ; routine GEN-ENT-1 is called.  
344d			                                ; A recursive call to a special entry point  
344d			                                ; in the calculator that puts the B register  
344d			                                ; in the system variable BREG. The return  
344d			                                ; address is the next location and where  
344d			                                ; the calculator will expect its first  
344d			                                ; instruction - now pointed to by HL'.  
344d			                                ; The previous pointer to the series of  
344d			                                ; five-byte numbers goes on the machine stack.  
344d			  
344d			; The initialization phase.  
344d			  
344d 31			        DEFB    $31             ;;duplicate       x,x  
344e 0f			        DEFB    $0F             ;;addition        x+x  
344f c0			        DEFB    $C0             ;;st-mem-0        x+x  
3450 02			        DEFB    $02             ;;delete          .  
3451 a0			        DEFB    $A0             ;;stk-zero        0  
3452 c2			        DEFB    $C2             ;;st-mem-2        0  
3453			  
3453			; a loop is now entered to perform the algebraic calculation for each of  
3453			; the numbers in the series  
3453			  
3453			;; G-LOOP  
3453 31			L3453:  DEFB    $31             ;;duplicate       v,v.  
3454 e0			        DEFB    $E0             ;;get-mem-0       v,v,x+2  
3455 04			        DEFB    $04             ;;multiply        v,v*x+2  
3456 e2			        DEFB    $E2             ;;get-mem-2       v,v*x+2,v  
3457 c1			        DEFB    $C1             ;;st-mem-1  
3458 03			        DEFB    $03             ;;subtract  
3459 38			        DEFB    $38             ;;end-calc  
345a			  
345a			; the previous pointer is fetched from the machine stack to H'L' where it  
345a			; addresses one of the numbers of the series following the series literal.  
345a			  
345a cd c6 33		        CALL    L33C6           ; routine STK-DATA is called directly to  
345d			                                ; push a value and advance H'L'.  
345d cd 62 33		        CALL    L3362           ; routine GEN-ENT-2 recursively re-enters  
3460			                                ; the calculator without disturbing  
3460			                                ; system variable BREG  
3460			                                ; H'L' value goes on the machine stack and is  
3460			                                ; then loaded as usual with the next address.  
3460			  
3460 0f			        DEFB    $0F             ;;addition  
3461 01			        DEFB    $01             ;;exchange  
3462 c2			        DEFB    $C2             ;;st-mem-2  
3463 02			        DEFB    $02             ;;delete  
3464			  
3464 35			        DEFB    $35             ;;dec-jr-nz  
3465 ee			        DEFB    $EE             ;;back to L3453, G-LOOP  
3466			  
3466			; when the counted loop is complete the final subtraction yields the result  
3466			; for example SIN X.  
3466			  
3466 e1			        DEFB    $E1             ;;get-mem-1  
3467 03			        DEFB    $03             ;;subtract  
3468 38			        DEFB    $38             ;;end-calc  
3469			  
3469 c9			        RET                     ; return with H'L' pointing to location  
346a			                                ; after last number in series.  
346a			  
346a			; -----------------------  
346a			; Absolute magnitude (2A)  
346a			; -----------------------  
346a			; This calculator literal finds the absolute value of the last value,  
346a			; integer or floating point, on calculator stack.  
346a			  
346a			;; abs  
346a 06 ff		L346A:  LD      B,$FF           ; signal abs  
346c 18 06		        JR      L3474           ; forward to NEG-TEST  
346e			  
346e			; -----------------------  
346e			; Handle unary minus (1B)  
346e			; -----------------------  
346e			; Unary so on entry HL points to last value, DE to STKEND.  
346e			  
346e			;; NEGATE  
346e			;; negate  
346e cd e9 34		L346E:  CALL    L34E9           ; call routine TEST-ZERO and  
3471 d8			        RET     C               ; return if so leaving zero unchanged.  
3472			  
3472 06 00		        LD      B,$00           ; signal negate required before joining  
3474			                                ; common code.  
3474			  
3474			;; NEG-TEST  
3474 7e			L3474:  LD      A,(HL)          ; load first byte and   
3475 a7			        AND     A               ; test for zero  
3476 28 0b		        JR      Z,L3483         ; forward to INT-CASE if a small integer  
3478			  
3478			; for floating point numbers a single bit denotes the sign.  
3478			  
3478 23			        INC     HL              ; address the first byte of mantissa.  
3479 78			        LD      A,B             ; action flag $FF=abs, $00=neg.  
347a e6 80		        AND     $80             ; now         $80      $00  
347c b6			        OR      (HL)            ; sets bit 7 for abs  
347d 17			        RLA                     ; sets carry for abs and if number negative  
347e 3f			        CCF                     ; complement carry flag  
347f 1f			        RRA                     ; and rotate back in altering sign  
3480 77			        LD      (HL),A          ; put the altered adjusted number back  
3481 2b			        DEC     HL              ; HL points to result  
3482 c9			        RET                     ; return with DE unchanged  
3483			  
3483			; ---  
3483			  
3483			; for integer numbers an entire byte denotes the sign.  
3483			  
3483			;; INT-CASE  
3483 d5			L3483:  PUSH    DE              ; save STKEND.  
3484			  
3484 e5			        PUSH    HL              ; save pointer to the last value/result.  
3485			  
3485 cd 7f 2d		        CALL    L2D7F           ; routine INT-FETCH puts integer in DE  
3488			                                ; and the sign in C.  
3488			  
3488 e1			        POP     HL              ; restore the result pointer.  
3489			  
3489 78			        LD      A,B             ; $FF=abs, $00=neg  
348a b1			        OR      C               ; $FF for abs, no change neg  
348b 2f			        CPL                     ; $00 for abs, switched for neg  
348c 4f			        LD      C,A             ; transfer result to sign byte.  
348d			  
348d cd 8e 2d		        CALL    L2D8E           ; routine INT-STORE to re-write the integer.  
3490			  
3490 d1			        POP     DE              ; restore STKEND.  
3491 c9			        RET                     ; return.  
3492			  
3492			; -----------  
3492			; Signum (29)  
3492			; -----------  
3492			; This routine replaces the last value on the calculator stack,  
3492			; which may be in floating point or integer form, with the integer values  
3492			; zero if zero, with one if positive and  with -minus one if negative.  
3492			  
3492			;; sgn  
3492 cd e9 34		L3492:  CALL    L34E9           ; call routine TEST-ZERO and  
3495 d8			        RET     C               ; exit if so as no change is required.  
3496			  
3496 d5			        PUSH    DE              ; save pointer to STKEND.  
3497			  
3497 11 01 00		        LD      DE,$0001        ; the result will be 1.  
349a 23			        INC     HL              ; skip over the exponent.  
349b cb 16		        RL      (HL)            ; rotate the sign bit into the carry flag.  
349d 2b			        DEC     HL              ; step back to point to the result.  
349e 9f			        SBC     A,A             ; byte will be $FF if negative, $00 if positive.  
349f 4f			        LD      C,A             ; store the sign byte in the C register.  
34a0 cd 8e 2d		        CALL    L2D8E           ; routine INT-STORE to overwrite the last  
34a3			                                ; value with 0001 and sign.  
34a3			  
34a3 d1			        POP     DE              ; restore STKEND.  
34a4 c9			        RET                     ; return.  
34a5			  
34a5			; -----------------------  
34a5			; Handle IN function (2C)  
34a5			; -----------------------  
34a5			; This function reads a byte from an input port.  
34a5			  
34a5			;; in  
34a5 cd 99 1e		L34A5:  CALL    L1E99           ; routine FIND-INT2 puts port address in BC.  
34a8			                                ; all 16 bits are put on the address line.  
34a8 ed 78		        IN      A,(C)           ; read the port.  
34aa			  
34aa 18 04		        JR      L34B0           ; exit to STACK-A (via IN-PK-STK to save a byte   
34ac			                                ; of instruction code).  
34ac			  
34ac			; -------------------------  
34ac			; Handle PEEK function (2B)  
34ac			; -------------------------  
34ac			; This function returns the contents of a memory address.  
34ac			; The entire address space can be peeked including the ROM.  
34ac			  
34ac			;; peek  
34ac cd 99 1e		L34AC:  CALL    L1E99           ; routine FIND-INT2 puts address in BC.  
34af 0a			        LD      A,(BC)          ; load contents into A register.  
34b0			  
34b0			;; IN-PK-STK  
34b0 c3 28 2d		L34B0:  JP      L2D28           ; exit via STACK-A to put value on the   
34b3			                                ; calculator stack.  
34b3			  
34b3			; ---------------  
34b3			; USR number (2D)  
34b3			; ---------------  
34b3			; The USR function followed by a number 0-65535 is the method by which  
34b3			; the Spectrum invokes machine code programs. This function returns the  
34b3			; contents of the BC register pair.  
34b3			; Note. that STACK-BC re-initializes the IY register if a user-written  
34b3			; program has altered it.  
34b3			  
34b3			;; usr-no  
34b3 cd 99 1e		L34B3:  CALL    L1E99           ; routine FIND-INT2 to fetch the  
34b6			                                ; supplied address into BC.  
34b6			  
34b6 21 2b 2d		        LD      HL,L2D2B        ; address: STACK-BC is  
34b9 e5			        PUSH    HL              ; pushed onto the machine stack.  
34ba c5			        PUSH    BC              ; then the address of the machine code  
34bb			                                ; routine.  
34bb			  
34bb c9			        RET                     ; make an indirect jump to the routine  
34bc			                                ; and, hopefully, to STACK-BC also.  
34bc			  
34bc			; ---------------  
34bc			; USR string (19)  
34bc			; ---------------  
34bc			; The user function with a one-character string argument, calculates the  
34bc			; address of the User Defined Graphic character that is in the string.  
34bc			; As an alternative, the ASCII equivalent, upper or lower case,  
34bc			; may be supplied. This provides a user-friendly method of redefining  
34bc			; the 21 User Definable Graphics e.g.  
34bc			; POKE USR "a", BIN 10000000 will put a dot in the top left corner of the  
34bc			; character 144.  
34bc			; Note. the curious double check on the range. With 26 UDGs the first check  
34bc			; only is necessary. With anything less the second check only is required.  
34bc			; It is highly likely that the first check was written by Steven Vickers.  
34bc			  
34bc			;; usr-$  
34bc cd f1 2b		L34BC:  CALL    L2BF1           ; routine STK-FETCH fetches the string  
34bf			                                ; parameters.  
34bf 0b			        DEC     BC              ; decrease BC by  
34c0 78			        LD      A,B             ; one to test  
34c1 b1			        OR      C               ; the length.  
34c2 20 23		        JR      NZ,L34E7        ; to REPORT-A if not a single character.  
34c4			  
34c4 1a			        LD      A,(DE)          ; fetch the character  
34c5 cd 8d 2c		        CALL    L2C8D           ; routine ALPHA sets carry if 'A-Z' or 'a-z'.  
34c8 38 09		        JR      C,L34D3         ; forward to USR-RANGE if ASCII.  
34ca			  
34ca d6 90		        SUB     $90             ; make udgs range 0-20d  
34cc 38 19		        JR      C,L34E7         ; to REPORT-A if too low. e.g. usr " ".  
34ce			  
34ce fe 15		        CP      $15             ; Note. this test is not necessary.  
34d0 30 15		        JR      NC,L34E7        ; to REPORT-A if higher than 20.  
34d2			  
34d2 3c			        INC     A               ; make range 1-21d to match LSBs of ASCII  
34d3			  
34d3			;; USR-RANGE  
34d3 3d			L34D3:  DEC     A               ; make range of bits 0-4 start at zero  
34d4 87			        ADD     A,A             ; multiply by eight  
34d5 87			        ADD     A,A             ; and lose any set bits  
34d6 87			        ADD     A,A             ; range now 0 - 25*8  
34d7 fe a8		        CP      $A8             ; compare to 21*8  
34d9 30 0c		        JR      NC,L34E7        ; to REPORT-A if originally higher   
34db			                                ; than 'U','u' or graphics U.  
34db			  
34db ed 4b 7b 5c	        LD      BC,($5C7B)      ; fetch the UDG system variable value.  
34df 81			        ADD     A,C             ; add the offset to character  
34e0 4f			        LD      C,A             ; and store back in register C.  
34e1 30 01		        JR      NC,L34E4        ; forward to USR-STACK if no overflow.  
34e3			  
34e3 04			        INC     B               ; increment high byte.  
34e4			  
34e4			;; USR-STACK  
34e4 c3 2b 2d		L34E4:  JP      L2D2B           ; jump back and exit via STACK-BC to store  
34e7			  
34e7			; ---  
34e7			  
34e7			;; REPORT-A  
34e7 cf			L34E7:  RST     08H             ; ERROR-1  
34e8 09			        DEFB    $09             ; Error Report: Invalid argument  
34e9			  
34e9			; -------------  
34e9			; Test for zero  
34e9			; -------------  
34e9			; Test if top value on calculator stack is zero.  
34e9			; The carry flag is set if the last value is zero but no registers are altered.  
34e9			; All five bytes will be zero but first four only need be tested.  
34e9			; On entry HL points to the exponent the first byte of the value.  
34e9			  
34e9			;; TEST-ZERO  
34e9 e5			L34E9:  PUSH    HL              ; preserve HL which is used to address.  
34ea c5			        PUSH    BC              ; preserve BC which is used as a store.  
34eb 47			        LD      B,A             ; preserve A in B.  
34ec			  
34ec 7e			        LD      A,(HL)          ; load first byte to accumulator  
34ed 23			        INC     HL              ; advance.  
34ee b6			        OR      (HL)            ; OR with second byte and clear carry.  
34ef 23			        INC     HL              ; advance.  
34f0 b6			        OR      (HL)            ; OR with third byte.  
34f1 23			        INC     HL              ; advance.  
34f2 b6			        OR      (HL)            ; OR with fourth byte.  
34f3			  
34f3 78			        LD      A,B             ; restore A without affecting flags.  
34f4 c1			        POP     BC              ; restore the saved  
34f5 e1			        POP     HL              ; registers.  
34f6			  
34f6 c0			        RET     NZ              ; return if not zero and with carry reset.  
34f7			  
34f7 37			        SCF                     ; set the carry flag.  
34f8 c9			        RET                     ; return with carry set if zero.  
34f9			  
34f9			; -----------------------  
34f9			; Greater than zero ($37)  
34f9			; -----------------------  
34f9			; Test if the last value on the calculator stack is greater than zero.  
34f9			; This routine is also called directly from the end-tests of the comparison   
34f9			; routine.  
34f9			  
34f9			;; GREATER-0  
34f9			;; greater-0  
34f9 cd e9 34		L34F9:  CALL    L34E9           ; routine TEST-ZERO  
34fc d8			        RET     C               ; return if was zero as this  
34fd			                                ; is also the Boolean 'false' value.  
34fd			  
34fd 3e ff		        LD      A,$FF           ; prepare XOR mask for sign bit  
34ff 18 06		        JR      L3507           ; forward to SIGN-TO-C  
3501			                                ; to put sign in carry  
3501			                                ; (carry will become set if sign is positive)  
3501			                                ; and then overwrite location with 1 or 0   
3501			                                ; as appropriate.  
3501			  
3501			; ------------------------  
3501			; Handle NOT operator ($30)  
3501			; ------------------------  
3501			; This overwrites the last value with 1 if it was zero else with zero  
3501			; if it was any other value.  
3501			;  
3501			; e.g NOT 0 returns 1, NOT 1 returns 0, NOT -3 returns 0.  
3501			;  
3501			; The subroutine is also called directly from the end-tests of the comparison  
3501			; operator.  
3501			  
3501			;; NOT  
3501			;; not  
3501 cd e9 34		L3501:  CALL    L34E9           ; routine TEST-ZERO sets carry if zero  
3504			  
3504 18 05		        JR      L350B           ; to FP-0/1 to overwrite operand with  
3506			                                ; 1 if carry is set else to overwrite with zero.  
3506			  
3506			; -------------------  
3506			; Less than zero (36)  
3506			; -------------------  
3506			; Destructively test if last value on calculator stack is less than zero.  
3506			; Bit 7 of second byte will be set if so.  
3506			  
3506			;; less-0  
3506 af			L3506:  XOR     A               ; set xor mask to zero  
3507			                                ; (carry will become set if sign is negative).  
3507			  
3507			; transfer sign of mantissa to Carry Flag.  
3507			  
3507			;; SIGN-TO-C  
3507 23			L3507:  INC     HL              ; address 2nd byte.  
3508 ae			        XOR     (HL)            ; bit 7 of HL will be set if number is negative.  
3509 2b			        DEC     HL              ; address 1st byte again.  
350a 07			        RLCA                    ; rotate bit 7 of A to carry.  
350b			  
350b			; -----------  
350b			; Zero or one  
350b			; -----------  
350b			; This routine places an integer value of zero or one at the addressed location  
350b			; of the calculator stack or MEM area.  The value one is written if carry is   
350b			; set on entry else zero.  
350b			  
350b			;; FP-0/1  
350b e5			L350B:  PUSH    HL              ; save pointer to the first byte  
350c 3e 00		        LD      A,$00           ; load accumulator with zero - without  
350e			                                ; disturbing flags.  
350e 77			        LD      (HL),A          ; zero to first byte  
350f 23			        INC     HL              ; address next  
3510 77			        LD      (HL),A          ; zero to 2nd byte  
3511 23			        INC     HL              ; address low byte of integer  
3512 17			        RLA                     ; carry to bit 0 of A  
3513 77			        LD      (HL),A          ; load one or zero to low byte.  
3514 1f			        RRA                     ; restore zero to accumulator.  
3515 23			        INC     HL              ; address high byte of integer.  
3516 77			        LD      (HL),A          ; put a zero there.  
3517 23			        INC     HL              ; address fifth byte.  
3518 77			        LD      (HL),A          ; put a zero there.  
3519 e1			        POP     HL              ; restore pointer to the first byte.  
351a c9			        RET                     ; return.  
351b			  
351b			; -----------------------  
351b			; Handle OR operator (07)  
351b			; -----------------------  
351b			; The Boolean OR operator. eg. X OR Y  
351b			; The result is zero if both values are zero else a non-zero value.  
351b			;  
351b			; e.g.    0 OR 0  returns 0.  
351b			;        -3 OR 0  returns -3.  
351b			;         0 OR -3 returns 1.  
351b			;        -3 OR 2  returns 1.  
351b			;  
351b			; A binary operation.  
351b			; On entry HL points to first operand (X) and DE to second operand (Y).  
351b			  
351b			;; or  
351b eb			L351B:  EX      DE,HL           ; make HL point to second number  
351c cd e9 34		        CALL    L34E9           ; routine TEST-ZERO  
351f eb			        EX      DE,HL           ; restore pointers  
3520 d8			        RET     C               ; return if result was zero - first operand,   
3521			                                ; now the last value, is the result.  
3521			  
3521 37			        SCF                     ; set carry flag  
3522 18 e7		        JR      L350B           ; back to FP-0/1 to overwrite the first operand  
3524			                                ; with the value 1.  
3524			  
3524			  
3524			; -----------------------------  
3524			; Handle number AND number (08)  
3524			; -----------------------------  
3524			; The Boolean AND operator.  
3524			;  
3524			; e.g.    -3 AND 2  returns -3.  
3524			;         -3 AND 0  returns 0.  
3524			;          0 and -2 returns 0.  
3524			;          0 and 0  returns 0.  
3524			;  
3524			; Compare with OR routine above.  
3524			  
3524			;; no-&-no  
3524 eb			L3524:  EX      DE,HL           ; make HL address second operand.  
3525			  
3525 cd e9 34		        CALL    L34E9           ; routine TEST-ZERO sets carry if zero.  
3528			  
3528 eb			        EX      DE,HL           ; restore pointers.  
3529 d0			        RET     NC              ; return if second non-zero, first is result.  
352a			  
352a			;  
352a			  
352a a7			        AND     A               ; else clear carry.  
352b 18 de		        JR      L350B           ; back to FP-0/1 to overwrite first operand  
352d			                                ; with zero for return value.  
352d			  
352d			; -----------------------------  
352d			; Handle string AND number (10)  
352d			; -----------------------------  
352d			; e.g. "You Win" AND score>99 will return the string if condition is true  
352d			; or the null string if false.  
352d			  
352d			;; str-&-no  
352d eb			L352D:  EX      DE,HL           ; make HL point to the number.  
352e cd e9 34		        CALL    L34E9           ; routine TEST-ZERO.  
3531 eb			        EX      DE,HL           ; restore pointers.   
3532 d0			        RET     NC              ; return if number was not zero - the string   
3533			                                ; is the result.  
3533			  
3533			; if the number was zero (false) then the null string must be returned by  
3533			; altering the length of the string on the calculator stack to zero.  
3533			  
3533 d5			        PUSH    DE              ; save pointer to the now obsolete number   
3534			                                ; (which will become the new STKEND)  
3534			  
3534 1b			        DEC     DE              ; point to the 5th byte of string descriptor.  
3535 af			        XOR     A               ; clear the accumulator.  
3536 12			        LD      (DE),A          ; place zero in high byte of length.  
3537 1b			        DEC     DE              ; address low byte of length.  
3538 12			        LD      (DE),A          ; place zero there - now the null string.  
3539			  
3539 d1			        POP     DE              ; restore pointer - new STKEND.  
353a c9			        RET                     ; return.  
353b			  
353b			; -----------------------------------  
353b			; Perform comparison ($09-$0E, $11-$16)  
353b			; -----------------------------------  
353b			; True binary operations.  
353b			;  
353b			; A single entry point is used to evaluate six numeric and six string  
353b			; comparisons. On entry, the calculator literal is in the B register and  
353b			; the two numeric values, or the two string parameters, are on the   
353b			; calculator stack.  
353b			; The individual bits of the literal are manipulated to group similar  
353b			; operations although the SUB 8 instruction does nothing useful and merely  
353b			; alters the string test bit.  
353b			; Numbers are compared by subtracting one from the other, strings are   
353b			; compared by comparing every character until a mismatch, or the end of one  
353b			; or both, is reached.  
353b			;  
353b			; Numeric Comparisons.  
353b			; --------------------  
353b			; The 'x>y' example is the easiest as it employs straight-thru logic.  
353b			; Number y is subtracted from x and the result tested for greater-0 yielding  
353b			; a final value 1 (true) or 0 (false).   
353b			; For 'x<y' the same logic is used but the two values are first swapped on the  
353b			; calculator stack.   
353b			; For 'x=y' NOT is applied to the subtraction result yielding true if the  
353b			; difference was zero and false with anything else.   
353b			; The first three numeric comparisons are just the opposite of the last three  
353b			; so the same processing steps are used and then a final NOT is applied.  
353b			;  
353b			; literal    Test   No  sub 8       ExOrNot  1st RRCA  exch sub  ?   End-Tests  
353b			; =========  ====   == ======== === ======== ========  ==== ===  =  === === ===  
353b			; no-l-eql   x<=y   09 00000001 dec 00000000 00000000  ---- x-y  ?  --- >0? NOT  
353b			; no-gr-eql  x>=y   0A 00000010 dec 00000001 10000000c swap y-x  ?  --- >0? NOT  
353b			; nos-neql   x<>y   0B 00000011 dec 00000010 00000001  ---- x-y  ?  NOT --- NOT  
353b			; no-grtr    x>y    0C 00000100  -  00000100 00000010  ---- x-y  ?  --- >0? ---  
353b			; no-less    x<y    0D 00000101  -  00000101 10000010c swap y-x  ?  --- >0? ---  
353b			; nos-eql    x=y    0E 00000110  -  00000110 00000011  ---- x-y  ?  NOT --- ---  
353b			;  
353b			;                                                           comp -> C/F  
353b			;                                                           ====    ===  
353b			; str-l-eql  x$<=y$ 11 00001001 dec 00001000 00000100  ---- x$y$ 0  !or >0? NOT  
353b			; str-gr-eql x$>=y$ 12 00001010 dec 00001001 10000100c swap y$x$ 0  !or >0? NOT  
353b			; strs-neql  x$<>y$ 13 00001011 dec 00001010 00000101  ---- x$y$ 0  !or >0? NOT  
353b			; str-grtr   x$>y$  14 00001100  -  00001100 00000110  ---- x$y$ 0  !or >0? ---  
353b			; str-less   x$<y$  15 00001101  -  00001101 10000110c swap y$x$ 0  !or >0? ---  
353b			; strs-eql   x$=y$  16 00001110  -  00001110 00000111  ---- x$y$ 0  !or >0? ---  
353b			;  
353b			; String comparisons are a little different in that the eql/neql carry flag  
353b			; from the 2nd RRCA is, as before, fed into the first of the end tests but  
353b			; along the way it gets modified by the comparison process. The result on the  
353b			; stack always starts off as zero and the carry fed in determines if NOT is   
353b			; applied to it. So the only time the greater-0 test is applied is if the  
353b			; stack holds zero which is not very efficient as the test will always yield  
353b			; zero. The most likely explanation is that there were once separate end tests  
353b			; for numbers and strings.  
353b			  
353b			;; no-l-eql, etc.  
353b 78			L353B:  LD      A,B             ; transfer literal to accumulator.  
353c d6 08		        SUB     $08             ; subtract eight - which is not useful.   
353e			  
353e cb 57		        BIT     2,A             ; isolate '>', '<', '='.  
3540			  
3540 20 01		        JR      NZ,L3543        ; skip to EX-OR-NOT with these.  
3542			  
3542 3d			        DEC     A               ; else make $00-$02, $08-$0A to match bits 0-2.  
3543			  
3543			;; EX-OR-NOT  
3543 0f			L3543:  RRCA                    ; the first RRCA sets carry for a swap.   
3544 30 08		        JR      NC,L354E        ; forward to NU-OR-STR with other 8 cases  
3546			  
3546			; for the other 4 cases the two values on the calculator stack are exchanged.  
3546			  
3546 f5			        PUSH    AF              ; save A and carry.  
3547 e5			        PUSH    HL              ; save HL - pointer to first operand.  
3548			                                ; (DE points to second operand).  
3548			  
3548 cd 3c 34		        CALL    L343C           ; routine exchange swaps the two values.  
354b			                                ; (HL = second operand, DE = STKEND)  
354b			  
354b d1			        POP     DE              ; DE = first operand  
354c eb			        EX      DE,HL           ; as we were.  
354d f1			        POP     AF              ; restore A and carry.  
354e			  
354e			; Note. it would be better if the 2nd RRCA preceded the string test.  
354e			; It would save two duplicate bytes and if we also got rid of that sub 8   
354e			; at the beginning we wouldn't have to alter which bit we test.  
354e			  
354e			;; NU-OR-STR  
354e cb 57		L354E:  BIT     2,A             ; test if a string comparison.  
3550 20 07		        JR      NZ,L3559        ; forward to STRINGS if so.  
3552			  
3552			; continue with numeric comparisons.  
3552			  
3552 0f			        RRCA                    ; 2nd RRCA causes eql/neql to set carry.  
3553 f5			        PUSH    AF              ; save A and carry  
3554			  
3554 cd 0f 30		        CALL    L300F           ; routine subtract leaves result on stack.  
3557 18 33		        JR      L358C           ; forward to END-TESTS  
3559			  
3559			; ---  
3559			  
3559			;; STRINGS  
3559 0f			L3559:  RRCA                    ; 2nd RRCA causes eql/neql to set carry.  
355a f5			        PUSH    AF              ; save A and carry.  
355b			  
355b cd f1 2b		        CALL    L2BF1           ; routine STK-FETCH gets 2nd string params  
355e d5			        PUSH    DE              ; save start2 *.  
355f c5			        PUSH    BC              ; and the length.  
3560			  
3560 cd f1 2b		        CALL    L2BF1           ; routine STK-FETCH gets 1st string   
3563			                                ; parameters - start in DE, length in BC.  
3563 e1			        POP     HL              ; restore length of second to HL.  
3564			  
3564			; A loop is now entered to compare, by subtraction, each corresponding character  
3564			; of the strings. For each successful match, the pointers are incremented and   
3564			; the lengths decreased and the branch taken back to here. If both string   
3564			; remainders become null at the same time, then an exact match exists.  
3564			  
3564			;; BYTE-COMP  
3564 7c			L3564:  LD      A,H             ; test if the second string  
3565 b5			        OR      L               ; is the null string and hold flags.  
3566			  
3566 e3			        EX      (SP),HL         ; put length2 on stack, bring start2 to HL *.  
3567 78			        LD      A,B             ; hi byte of length1 to A  
3568			  
3568 20 0b		        JR      NZ,L3575        ; forward to SEC-PLUS if second not null.  
356a			  
356a b1			        OR      C               ; test length of first string.  
356b			  
356b			;; SECND-LOW  
356b c1			L356B:  POP     BC              ; pop the second length off stack.  
356c 28 04		        JR      Z,L3572         ; forward to BOTH-NULL if first string is also  
356e			                                ; of zero length.  
356e			  
356e			; the true condition - first is longer than second (SECND-LESS)  
356e			  
356e f1			        POP     AF              ; restore carry (set if eql/neql)  
356f 3f			        CCF                     ; complement carry flag.  
3570			                                ; Note. equality becomes false.  
3570			                                ; Inequality is true. By swapping or applying  
3570			                                ; a terminal 'not', all comparisons have been  
3570			                                ; manipulated so that this is success path.   
3570 18 16		        JR      L3588           ; forward to leave via STR-TEST  
3572			  
3572			; ---  
3572			; the branch was here with a match  
3572			  
3572			;; BOTH-NULL  
3572 f1			L3572:  POP     AF              ; restore carry - set for eql/neql  
3573 18 13		        JR      L3588           ; forward to STR-TEST  
3575			  
3575			; ---    
3575			; the branch was here when 2nd string not null and low byte of first is yet  
3575			; to be tested.  
3575			  
3575			  
3575			;; SEC-PLUS  
3575 b1			L3575:  OR      C               ; test the length of first string.  
3576 28 0d		        JR      Z,L3585         ; forward to FRST-LESS if length is zero.  
3578			  
3578			; both strings have at least one character left.  
3578			  
3578 1a			        LD      A,(DE)          ; fetch character of first string.   
3579 96			        SUB     (HL)            ; subtract with that of 2nd string.  
357a 38 09		        JR      C,L3585         ; forward to FRST-LESS if carry set  
357c			  
357c 20 ed		        JR      NZ,L356B        ; back to SECND-LOW and then STR-TEST  
357e			                                ; if not exact match.  
357e			  
357e 0b			        DEC     BC              ; decrease length of 1st string.  
357f 13			        INC     DE              ; increment 1st string pointer.  
3580			  
3580 23			        INC     HL              ; increment 2nd string pointer.  
3581 e3			        EX      (SP),HL         ; swap with length on stack  
3582 2b			        DEC     HL              ; decrement 2nd string length  
3583 18 df		        JR      L3564           ; back to BYTE-COMP  
3585			  
3585			; ---  
3585			; the false condition.  
3585			  
3585			;; FRST-LESS  
3585 c1			L3585:  POP     BC              ; discard length  
3586 f1			        POP     AF              ; pop A  
3587 a7			        AND     A               ; clear the carry for false result.  
3588			  
3588			; ---  
3588			; exact match and x$>y$ rejoin here  
3588			  
3588			;; STR-TEST  
3588 f5			L3588:  PUSH    AF              ; save A and carry  
3589			  
3589 ef			        RST     28H             ;; FP-CALC  
358a a0			        DEFB    $A0             ;;stk-zero      an initial false value.  
358b 38			        DEFB    $38             ;;end-calc  
358c			  
358c			; both numeric and string paths converge here.  
358c			  
358c			;; END-TESTS  
358c f1			L358C:  POP     AF              ; pop carry  - will be set if eql/neql  
358d f5			        PUSH    AF              ; save it again.  
358e			  
358e dc 01 35		        CALL    C,L3501         ; routine NOT sets true(1) if equal(0)  
3591			                                ; or, for strings, applies true result.  
3591			  
3591 f1			        POP     AF              ; pop carry and  
3592 f5			        PUSH    AF              ; save A  
3593			  
3593 d4 f9 34		        CALL    NC,L34F9        ; routine GREATER-0 tests numeric subtraction   
3596			                                ; result but also needlessly tests the string   
3596			                                ; value for zero - it must be.  
3596			  
3596 f1			        POP     AF              ; pop A   
3597 0f			        RRCA                    ; the third RRCA - test for '<=', '>=' or '<>'.  
3598 d4 01 35		        CALL    NC,L3501        ; apply a terminal NOT if so.  
359b c9			        RET                     ; return.  
359c			  
359c			; -------------------------  
359c			; String concatenation ($17)  
359c			; -------------------------  
359c			; This literal combines two strings into one e.g. LET a$ = b$ + c$  
359c			; The two parameters of the two strings to be combined are on the stack.  
359c			  
359c			;; strs-add  
359c cd f1 2b		L359C:  CALL    L2BF1           ; routine STK-FETCH fetches string parameters  
359f			                                ; and deletes calculator stack entry.  
359f d5			        PUSH    DE              ; save start address.  
35a0 c5			        PUSH    BC              ; and length.  
35a1			  
35a1 cd f1 2b		        CALL    L2BF1           ; routine STK-FETCH for first string  
35a4 e1			        POP     HL              ; re-fetch first length  
35a5 e5			        PUSH    HL              ; and save again  
35a6 d5			        PUSH    DE              ; save start of second string  
35a7 c5			        PUSH    BC              ; and its length.  
35a8			  
35a8 09			        ADD     HL,BC           ; add the two lengths.  
35a9 44			        LD      B,H             ; transfer to BC  
35aa 4d			        LD      C,L             ; and create  
35ab f7			        RST     30H             ; BC-SPACES in workspace.  
35ac			                                ; DE points to start of space.  
35ac			  
35ac cd b2 2a		        CALL    L2AB2           ; routine STK-STO-$ stores parameters  
35af			                                ; of new string updating STKEND.  
35af			  
35af c1			        POP     BC              ; length of first  
35b0 e1			        POP     HL              ; address of start  
35b1 78			        LD      A,B             ; test for  
35b2 b1			        OR      C               ; zero length.  
35b3 28 02		        JR      Z,L35B7         ; to OTHER-STR if null string  
35b5			  
35b5 ed b0		        LDIR                    ; copy string to workspace.  
35b7			  
35b7			;; OTHER-STR  
35b7 c1			L35B7:  POP     BC              ; now second length  
35b8 e1			        POP     HL              ; and start of string  
35b9 78			        LD      A,B             ; test this one  
35ba b1			        OR      C               ; for zero length  
35bb 28 02		        JR      Z,L35BF         ; skip forward to STK-PNTRS if so as complete.  
35bd			  
35bd ed b0		        LDIR                    ; else copy the bytes.  
35bf			                                ; and continue into next routine which  
35bf			                                ; sets the calculator stack pointers.  
35bf			  
35bf			; --------------------  
35bf			; Check stack pointers  
35bf			; --------------------  
35bf			; Register DE is set to STKEND and HL, the result pointer, is set to five   
35bf			; locations below this.  
35bf			; This routine is used when it is inconvenient to save these values at the  
35bf			; time the calculator stack is manipulated due to other activity on the   
35bf			; machine stack.  
35bf			; This routine is also used to terminate the VAL and READ-IN  routines for  
35bf			; the same reason and to initialize the calculator stack at the start of  
35bf			; the CALCULATE routine.  
35bf			  
35bf			;; STK-PNTRS  
35bf 2a 65 5c		L35BF:  LD      HL,($5C65)      ; fetch STKEND value from system variable.  
35c2 11 fb ff		        LD      DE,$FFFB        ; the value -5  
35c5 e5			        PUSH    HL              ; push STKEND value.  
35c6			  
35c6 19			        ADD     HL,DE           ; subtract 5 from HL.  
35c7			  
35c7 d1			        POP     DE              ; pop STKEND to DE.  
35c8 c9			        RET                     ; return.  
35c9			  
35c9			; ----------------  
35c9			; Handle CHR$ (2F)  
35c9			; ----------------  
35c9			; This function returns a single character string that is a result of   
35c9			; converting a number in the range 0-255 to a string e.g. CHR$ 65 = "A".  
35c9			  
35c9			;; chrs  
35c9 cd d5 2d		L35C9:  CALL    L2DD5           ; routine FP-TO-A puts the number in A.  
35cc			  
35cc 38 0e		        JR      C,L35DC         ; forward to REPORT-Bd if overflow  
35ce 20 0c		        JR      NZ,L35DC        ; forward to REPORT-Bd if negative  
35d0			  
35d0 f5			        PUSH    AF              ; save the argument.  
35d1			  
35d1 01 01 00		        LD      BC,$0001        ; one space required.  
35d4 f7			        RST     30H             ; BC-SPACES makes DE point to start  
35d5			  
35d5 f1			        POP     AF              ; restore the number.  
35d6			  
35d6 12			        LD      (DE),A          ; and store in workspace  
35d7			  
35d7 cd b2 2a		        CALL    L2AB2           ; routine STK-STO-$ stacks descriptor.  
35da			  
35da eb			        EX      DE,HL           ; make HL point to result and DE to STKEND.  
35db c9			        RET                     ; return.  
35dc			  
35dc			; ---  
35dc			  
35dc			;; REPORT-Bd  
35dc cf			L35DC:  RST     08H             ; ERROR-1  
35dd 0a			        DEFB    $0A             ; Error Report: Integer out of range  
35de			  
35de			; ----------------------------  
35de			; Handle VAL and VAL$ ($1D, $18)  
35de			; ----------------------------  
35de			; VAL treats the characters in a string as a numeric expression.  
35de			;     e.g. VAL "2.3" = 2.3, VAL "2+4" = 6, VAL ("2" + "4") = 24.  
35de			; VAL$ treats the characters in a string as a string expression.  
35de			;     e.g. VAL$ (z$+"(2)") = a$(2) if z$ happens to be "a$".  
35de			  
35de			;; val  
35de			;; val$  
35de 2a 5d 5c		L35DE:  LD      HL,($5C5D)      ; fetch value of system variable CH_ADD  
35e1 e5			        PUSH    HL              ; and save on the machine stack.  
35e2 78			        LD      A,B             ; fetch the literal (either $1D or $18).  
35e3 c6 e3		        ADD     A,$E3           ; add $E3 to form $00 (setting carry) or $FB.  
35e5 9f			        SBC     A,A             ; now form $FF bit 6 = numeric result  
35e6			                                ; or $00 bit 6 = string result.  
35e6 f5			        PUSH    AF              ; save this mask on the stack  
35e7			  
35e7 cd f1 2b		        CALL    L2BF1           ; routine STK-FETCH fetches the string operand  
35ea			                                ; from calculator stack.  
35ea			  
35ea d5			        PUSH    DE              ; save the address of the start of the string.  
35eb 03			        INC     BC              ; increment the length for a carriage return.  
35ec			  
35ec f7			        RST     30H             ; BC-SPACES creates the space in workspace.  
35ed e1			        POP     HL              ; restore start of string to HL.  
35ee ed 53 5d 5c	        LD      ($5C5D),DE      ; load CH_ADD with start DE in workspace.  
35f2			  
35f2 d5			        PUSH    DE              ; save the start in workspace  
35f3 ed b0		        LDIR                    ; copy string from program or variables or  
35f5			                                ; workspace to the workspace area.  
35f5 eb			        EX      DE,HL           ; end of string + 1 to HL  
35f6 2b			        DEC     HL              ; decrement HL to point to end of new area.  
35f7 36 0d		        LD      (HL),$0D        ; insert a carriage return at end.  
35f9 fd cb 01 be	        RES     7,(IY+$01)      ; update FLAGS  - signal checking syntax.  
35fd cd fb 24		        CALL    L24FB           ; routine SCANNING evaluates string  
3600			                                ; expression and result.  
3600			  
3600 df			        RST     18H             ; GET-CHAR fetches next character.  
3601 fe 0d		        CP      $0D             ; is it the expected carriage return ?  
3603 20 07		        JR      NZ,L360C        ; forward to V-RPORT-C if not  
3605			                                ; 'Nonsense in BASIC'.  
3605			  
3605 e1			        POP     HL              ; restore start of string in workspace.  
3606 f1			        POP     AF              ; restore expected result flag (bit 6).  
3607 fd ae 01		        XOR     (IY+$01)        ; xor with FLAGS now updated by SCANNING.  
360a e6 40		        AND     $40             ; test bit 6 - should be zero if result types  
360c			                                ; match.  
360c			  
360c			;; V-RPORT-C  
360c c2 8a 1c		L360C:  JP      NZ,L1C8A        ; jump back to REPORT-C with a result mismatch.  
360f			  
360f 22 5d 5c		        LD      ($5C5D),HL      ; set CH_ADD to the start of the string again.  
3612 fd cb 01 fe	        SET     7,(IY+$01)      ; update FLAGS  - signal running program.  
3616 cd fb 24		        CALL    L24FB           ; routine SCANNING evaluates the string  
3619			                                ; in full leaving result on calculator stack.  
3619			  
3619 e1			        POP     HL              ; restore saved character address in program.  
361a 22 5d 5c		        LD      ($5C5D),HL      ; and reset the system variable CH_ADD.  
361d			  
361d 18 a0		        JR      L35BF           ; back to exit via STK-PNTRS.  
361f			                                ; resetting the calculator stack pointers  
361f			                                ; HL and DE from STKEND as it wasn't possible   
361f			                                ; to preserve them during this routine.  
361f			  
361f			; ----------------  
361f			; Handle STR$ (2E)  
361f			; ----------------  
361f			;  
361f			;  
361f			  
361f			;; str$  
361f 01 01 00		L361F:  LD      BC,$0001        ; create an initial byte in workspace  
3622 f7			        RST     30H             ; using BC-SPACES restart.  
3623			  
3623 22 5b 5c		        LD      ($5C5B),HL      ; set system variable K_CUR to new location.  
3626 e5			        PUSH    HL              ; and save start on machine stack also.  
3627			  
3627 2a 51 5c		        LD      HL,($5C51)      ; fetch value of system variable CURCHL  
362a e5			        PUSH    HL              ; and save that too.  
362b			  
362b 3e ff		        LD      A,$FF           ; select system channel 'R'.  
362d cd 01 16		        CALL    L1601           ; routine CHAN-OPEN opens it.  
3630 cd e3 2d		        CALL    L2DE3           ; routine PRINT-FP outputs the number to  
3633			                                ; workspace updating K-CUR.  
3633			  
3633 e1			        POP     HL              ; restore current channel.  
3634 cd 15 16		        CALL    L1615           ; routine CHAN-FLAG resets flags.  
3637			  
3637 d1			        POP     DE              ; fetch saved start of string to DE.  
3638 2a 5b 5c		        LD      HL,($5C5B)      ; load HL with end of string from K_CUR.  
363b			  
363b a7			        AND     A               ; prepare for true subtraction.  
363c ed 52		        SBC     HL,DE           ; subtract start from end to give length.  
363e 44			        LD      B,H             ; transfer the length to  
363f 4d			        LD      C,L             ; the BC register pair.  
3640			  
3640 cd b2 2a		        CALL    L2AB2           ; routine STK-STO-$ stores string parameters  
3643			                                ; on the calculator stack.  
3643			  
3643 eb			        EX      DE,HL           ; HL = last value, DE = STKEND.  
3644 c9			        RET                     ; return.  
3645			  
3645			; ------------  
3645			; Read-in (1A)  
3645			; ------------  
3645			; This is the calculator literal used by the INKEY$ function when a '#'  
3645			; is encountered after the keyword.  
3645			; INKEY$ # does not interact correctly with the keyboard, #0 or #1, and  
3645			; its uses are for other channels.  
3645			  
3645			;; read-in  
3645 cd 94 1e		L3645:  CALL    L1E94           ; routine FIND-INT1 fetches stream to A  
3648 fe 10		        CP      $10             ; compare with 16 decimal.  
364a d2 9f 1e		        JP      NC,L1E9F        ; jump to REPORT-Bb if not in range 0 - 15.  
364d			                                ; 'Integer out of range'  
364d			                                ; (REPORT-Bd is within range)  
364d			  
364d 2a 51 5c		        LD      HL,($5C51)      ; fetch current channel CURCHL  
3650 e5			        PUSH    HL              ; save it  
3651 cd 01 16		        CALL    L1601           ; routine CHAN-OPEN opens channel  
3654			  
3654 cd e6 15		        CALL    L15E6           ; routine INPUT-AD - the channel must have an  
3657			                                ; input stream or else error here from stream  
3657			                                ; stub.  
3657 01 00 00		        LD      BC,$0000        ; initialize length of string to zero  
365a 30 03		        JR      NC,L365F        ; forward to R-I-STORE if no key detected.  
365c			  
365c 0c			        INC     C               ; increase length to one.  
365d			  
365d f7			        RST     30H             ; BC-SPACES creates space for one character  
365e			                                ; in workspace.  
365e 12			        LD      (DE),A          ; the character is inserted.  
365f			  
365f			;; R-I-STORE  
365f cd b2 2a		L365F:  CALL    L2AB2           ; routine STK-STO-$ stacks the string  
3662			                                ; parameters.  
3662 e1			        POP     HL              ; restore current channel address  
3663 cd 15 16		        CALL    L1615           ; routine CHAN-FLAG resets current channel  
3666			                                ; system variable and flags.  
3666 c3 bf 35		        JP      L35BF           ; jump back to STK-PNTRS  
3669			  
3669			; ----------------  
3669			; Handle CODE (1C)  
3669			; ----------------  
3669			; Returns the ASCII code of a character or first character of a string  
3669			; e.g. CODE "Aardvark" = 65, CODE "" = 0.  
3669			  
3669			;; code  
3669 cd f1 2b		L3669:  CALL    L2BF1           ; routine STK-FETCH to fetch and delete the  
366c			                                ; string parameters.  
366c			                                ; DE points to the start, BC holds the length.  
366c 78			        LD      A,B             ; test length  
366d b1			        OR      C               ; of the string.  
366e 28 01		        JR      Z,L3671         ; skip to STK-CODE with zero if the null string.  
3670			  
3670 1a			        LD      A,(DE)          ; else fetch the first character.  
3671			  
3671			;; STK-CODE  
3671 c3 28 2d		L3671:  JP      L2D28           ; jump back to STACK-A (with memory check)  
3674			  
3674			; ---------------  
3674			; Handle LEN (1E)  
3674			; ---------------  
3674			; Returns the length of a string.  
3674			; In Sinclair BASIC strings can be more than twenty thousand characters long  
3674			; so a sixteen-bit register is required to store the length  
3674			  
3674			;; len  
3674 cd f1 2b		L3674:  CALL    L2BF1           ; routine STK-FETCH to fetch and delete the  
3677			                                ; string parameters from the calculator stack.  
3677			                                ; register BC now holds the length of string.  
3677			  
3677 c3 2b 2d		        JP      L2D2B           ; jump back to STACK-BC to save result on the  
367a			                                ; calculator stack (with memory check).  
367a			  
367a			; -------------------------  
367a			; Decrease the counter (35)  
367a			; -------------------------  
367a			; The calculator has an instruction that decrements a single-byte  
367a			; pseudo-register and makes consequential relative jumps just like  
367a			; the Z80's DJNZ instruction.  
367a			  
367a			;; dec-jr-nz  
367a d9			L367A:  EXX                     ; switch in set that addresses code  
367b			  
367b e5			        PUSH    HL              ; save pointer to offset byte  
367c 21 67 5c		        LD      HL,$5C67        ; address BREG in system variables  
367f 35			        DEC     (HL)            ; decrement it  
3680 e1			        POP     HL              ; restore pointer  
3681			  
3681 20 04		        JR      NZ,L3687        ; to JUMP-2 if not zero  
3683			  
3683 23			        INC     HL              ; step past the jump length.  
3684 d9			        EXX                     ; switch in the main set.  
3685 c9			        RET                     ; return.  
3686			  
3686			; Note. as a general rule the calculator avoids using the IY register  
3686			; otherwise the cumbersome 4 instructions in the middle could be replaced by  
3686			; dec (iy+$2d) - three bytes instead of six.  
3686			  
3686			  
3686			; ---------  
3686			; Jump (33)  
3686			; ---------  
3686			; This enables the calculator to perform relative jumps just like  
3686			; the Z80 chip's JR instruction  
3686			  
3686			;; jump  
3686			;; JUMP  
3686 d9			L3686:  EXX                     ;switch in pointer set  
3687			  
3687			;; JUMP-2  
3687 5e			L3687:  LD      E,(HL)          ; the jump byte 0-127 forward, 128-255 back.  
3688 7b			        LD      A,E             ; transfer to accumulator.  
3689 17			        RLA                     ; if backward jump, carry is set.  
368a 9f			        SBC     A,A             ; will be $FF if backward or $00 if forward.  
368b 57			        LD      D,A             ; transfer to high byte.  
368c 19			        ADD     HL,DE           ; advance calculator pointer forward or back.  
368d d9			        EXX                     ; switch back.  
368e c9			        RET                     ; return.  
368f			  
368f			; -----------------  
368f			; Jump on true (00)  
368f			; -----------------  
368f			; This enables the calculator to perform conditional relative jumps  
368f			; dependent on whether the last test gave a true result  
368f			  
368f			;; jump-true  
368f 13			L368F:  INC     DE              ; collect the   
3690 13			        INC     DE              ; third byte  
3691 1a			        LD      A,(DE)          ; of the test  
3692 1b			        DEC     DE              ; result and  
3693 1b			        DEC     DE              ; backtrack.  
3694			  
3694 a7			        AND     A               ; is result 0 or 1 ?   
3695 20 ef		        JR      NZ,L3686        ; back to JUMP if true (1).  
3697			  
3697 d9			        EXX                     ; else switch in the pointer set.  
3698 23			        INC     HL              ; step past the jump length.  
3699 d9			        EXX                     ; switch in the main set.  
369a c9			        RET                     ; return.  
369b			  
369b			; -----------------------  
369b			; End of calculation (38)  
369b			; -----------------------  
369b			; The end-calc literal terminates a mini-program written in the Spectrum's  
369b			; internal language.  
369b			  
369b			;; end-calc  
369b f1			L369B:  POP     AF              ; drop the calculator return address RE-ENTRY  
369c d9			        EXX                     ; switch to the other set.  
369d			  
369d e3			        EX      (SP),HL         ; transfer H'L' to machine stack for the  
369e			                                ; return address.  
369e			                                ; when exiting recursion then the previous  
369e			                                ; pointer is transferred to H'L'.  
369e			  
369e d9			        EXX                     ; back to main set.  
369f c9			        RET                     ; return.  
36a0			  
36a0			  
36a0			; ------------------------  
36a0			; THE 'MODULUS' SUBROUTINE   
36a0			; ------------------------  
36a0			; (offset: $32 'n-mod-m')  
36a0			;  
36a0			;  
36a0			  
36a0			;; n-mod-m  
36a0 ef			L36A0:  RST     28H             ;; FP-CALC          17, 3.  
36a1 c0			        DEFB    $C0             ;;st-mem-0          17, 3.  
36a2 02			        DEFB    $02             ;;delete            17.  
36a3 31			        DEFB    $31             ;;duplicate         17, 17.  
36a4 e0			        DEFB    $E0             ;;get-mem-0         17, 17, 3.  
36a5 05			        DEFB    $05             ;;division          17, 17/3.  
36a6 27			        DEFB    $27             ;;int               17, 5.  
36a7 e0			        DEFB    $E0             ;;get-mem-0         17, 5, 3.  
36a8 01			        DEFB    $01             ;;exchange          17, 3, 5.  
36a9 c0			        DEFB    $C0             ;;st-mem-0          17, 3, 5.  
36aa 04			        DEFB    $04             ;;multiply          17, 15.  
36ab 03			        DEFB    $03             ;;subtract          2.  
36ac e0			        DEFB    $E0             ;;get-mem-0         2, 5.  
36ad 38			        DEFB    $38             ;;end-calc          2, 5.  
36ae			  
36ae c9			        RET                     ; return.  
36af			  
36af			  
36af			; ------------------  
36af			; THE 'INT' FUNCTION  
36af			; ------------------  
36af			; (offset $27: 'int' )  
36af			;  
36af			; This function returns the integer of x, which is just the same as truncate  
36af			; for positive numbers. The truncate literal truncates negative numbers  
36af			; upwards so that -3.4 gives -3 whereas the BASIC INT function has to  
36af			; truncate negative numbers down so that INT -3.4 is -4.  
36af			; It is best to work through using, say, +-3.4 as examples.  
36af			  
36af			;; int  
36af ef			L36AF:  RST     28H             ;; FP-CALC              x.    (= 3.4 or -3.4).  
36b0 31			        DEFB    $31             ;;duplicate             x, x.  
36b1 36			        DEFB    $36             ;;less-0                x, (1/0)  
36b2 00			        DEFB    $00             ;;jump-true             x, (1/0)  
36b3 04			        DEFB    $04             ;;to L36B7, X-NEG  
36b4			  
36b4 3a			        DEFB    $3A             ;;truncate              trunc 3.4 = 3.  
36b5 38			        DEFB    $38             ;;end-calc              3.  
36b6			  
36b6 c9			        RET                     ; return with + int x on stack.  
36b7			  
36b7			; ---  
36b7			  
36b7			  
36b7			;; X-NEG  
36b7 31			L36B7:  DEFB    $31             ;;duplicate             -3.4, -3.4.  
36b8 3a			        DEFB    $3A             ;;truncate              -3.4, -3.  
36b9 c0			        DEFB    $C0             ;;st-mem-0              -3.4, -3.  
36ba 03			        DEFB    $03             ;;subtract              -.4  
36bb e0			        DEFB    $E0             ;;get-mem-0             -.4, -3.  
36bc 01			        DEFB    $01             ;;exchange              -3, -.4.  
36bd 30			        DEFB    $30             ;;not                   -3, (0).  
36be 00			        DEFB    $00             ;;jump-true             -3.  
36bf 03			        DEFB    $03             ;;to L36C2, EXIT        -3.  
36c0			  
36c0 a1			        DEFB    $A1             ;;stk-one               -3, 1.  
36c1 03			        DEFB    $03             ;;subtract              -4.  
36c2			  
36c2			;; EXIT  
36c2 38			L36C2:  DEFB    $38             ;;end-calc              -4.  
36c3			  
36c3 c9			        RET                     ; return.  
36c4			  
36c4			  
36c4			; ----------------  
36c4			; Exponential (26)  
36c4			; ----------------  
36c4			;  
36c4			;  
36c4			  
36c4			;; EXP  
36c4			;; exp  
36c4 ef			L36C4:  RST     28H             ;; FP-CALC  
36c5 3d			        DEFB    $3D             ;;re-stack  
36c6 34			        DEFB    $34             ;;stk-data  
36c7 f1			        DEFB    $F1             ;;Exponent: $81, Bytes: 4  
36c8 38 aa 3b 29	        DEFB    $38,$AA,$3B,$29 ;;  
36cc 04			        DEFB    $04             ;;multiply  
36cd 31			        DEFB    $31             ;;duplicate  
36ce 27			        DEFB    $27             ;;int  
36cf c3			        DEFB    $C3             ;;st-mem-3  
36d0 03			        DEFB    $03             ;;subtract  
36d1 31			        DEFB    $31             ;;duplicate  
36d2 0f			        DEFB    $0F             ;;addition  
36d3 a1			        DEFB    $A1             ;;stk-one  
36d4 03			        DEFB    $03             ;;subtract  
36d5 88			        DEFB    $88             ;;series-08  
36d6 13			        DEFB    $13             ;;Exponent: $63, Bytes: 1  
36d7 36			        DEFB    $36             ;;(+00,+00,+00)  
36d8 58			        DEFB    $58             ;;Exponent: $68, Bytes: 2  
36d9 65 66		        DEFB    $65,$66         ;;(+00,+00)  
36db 9d			        DEFB    $9D             ;;Exponent: $6D, Bytes: 3  
36dc 78 65 40		        DEFB    $78,$65,$40     ;;(+00)  
36df a2			        DEFB    $A2             ;;Exponent: $72, Bytes: 3  
36e0 60 32 c9		        DEFB    $60,$32,$C9     ;;(+00)  
36e3 e7			        DEFB    $E7             ;;Exponent: $77, Bytes: 4  
36e4 21 f7 af 24	        DEFB    $21,$F7,$AF,$24 ;;  
36e8 eb			        DEFB    $EB             ;;Exponent: $7B, Bytes: 4  
36e9 2f b0 b0 14	        DEFB    $2F,$B0,$B0,$14 ;;  
36ed ee			        DEFB    $EE             ;;Exponent: $7E, Bytes: 4  
36ee 7e bb 94 58	        DEFB    $7E,$BB,$94,$58 ;;  
36f2 f1			        DEFB    $F1             ;;Exponent: $81, Bytes: 4  
36f3 3a 7e f8 cf	        DEFB    $3A,$7E,$F8,$CF ;;  
36f7 e3			        DEFB    $E3             ;;get-mem-3  
36f8 38			        DEFB    $38             ;;end-calc  
36f9			  
36f9 cd d5 2d		        CALL    L2DD5           ; routine FP-TO-A  
36fc 20 07		        JR      NZ,L3705        ; to N-NEGTV  
36fe			  
36fe 38 03		        JR      C,L3703         ; to REPORT-6b  
3700			  
3700 86			        ADD     A,(HL)          ;  
3701 30 09		        JR      NC,L370C        ; to RESULT-OK  
3703			  
3703			  
3703			;; REPORT-6b  
3703 cf			L3703:  RST     08H             ; ERROR-1  
3704 05			        DEFB    $05             ; Error Report: Number too big  
3705			  
3705			;; N-NEGTV  
3705 38 07		L3705:  JR      C,L370E         ; to RSLT-ZERO  
3707			  
3707 96			        SUB     (HL)            ;  
3708 30 04		        JR      NC,L370E        ; to RSLT-ZERO  
370a			  
370a ed 44		        NEG                     ; Negate  
370c			  
370c			;; RESULT-OK  
370c 77			L370C:  LD      (HL),A          ;  
370d c9			        RET                     ; return.  
370e			  
370e			; ---  
370e			  
370e			  
370e			;; RSLT-ZERO  
370e ef			L370E:  RST     28H             ;; FP-CALC  
370f 02			        DEFB    $02             ;;delete  
3710 a0			        DEFB    $A0             ;;stk-zero  
3711 38			        DEFB    $38             ;;end-calc  
3712			  
3712 c9			        RET                     ; return.  
3713			  
3713			  
3713			; ----------------------  
3713			; Natural logarithm (25)  
3713			; ----------------------  
3713			;  
3713			;  
3713			  
3713			;; ln  
3713 ef			L3713:  RST     28H             ;; FP-CALC  
3714 3d			        DEFB    $3D             ;;re-stack  
3715 31			        DEFB    $31             ;;duplicate  
3716 37			        DEFB    $37             ;;greater-0  
3717 00			        DEFB    $00             ;;jump-true  
3718 04			        DEFB    $04             ;;to L371C, VALID  
3719			  
3719 38			        DEFB    $38             ;;end-calc  
371a			  
371a			  
371a			;; REPORT-Ab  
371a cf			L371A:  RST     08H             ; ERROR-1  
371b 09			        DEFB    $09             ; Error Report: Invalid argument  
371c			  
371c			;; VALID  
371c a0			L371C:  DEFB    $A0             ;;stk-zero  
371d 02			        DEFB    $02             ;;delete  
371e 38			        DEFB    $38             ;;end-calc  
371f 7e			        LD      A,(HL)          ;  
3720			  
3720 36 80		        LD      (HL),$80        ;  
3722 cd 28 2d		        CALL    L2D28           ; routine STACK-A  
3725			  
3725 ef			        RST     28H             ;; FP-CALC  
3726 34			        DEFB    $34             ;;stk-data  
3727 38			        DEFB    $38             ;;Exponent: $88, Bytes: 1  
3728 00			        DEFB    $00             ;;(+00,+00,+00)  
3729 03			        DEFB    $03             ;;subtract  
372a 01			        DEFB    $01             ;;exchange  
372b 31			        DEFB    $31             ;;duplicate  
372c 34			        DEFB    $34             ;;stk-data  
372d f0			        DEFB    $F0             ;;Exponent: $80, Bytes: 4  
372e 4c cc cc cd	        DEFB    $4C,$CC,$CC,$CD ;;  
3732 03			        DEFB    $03             ;;subtract  
3733 37			        DEFB    $37             ;;greater-0  
3734 00			        DEFB    $00             ;;jump-true  
3735 08			        DEFB    $08             ;;to L373D, GRE.8  
3736			  
3736 01			        DEFB    $01             ;;exchange  
3737 a1			        DEFB    $A1             ;;stk-one  
3738 03			        DEFB    $03             ;;subtract  
3739 01			        DEFB    $01             ;;exchange  
373a 38			        DEFB    $38             ;;end-calc  
373b			  
373b 34			        INC     (HL)            ;  
373c			  
373c ef			        RST     28H             ;; FP-CALC  
373d			  
373d			;; GRE.8  
373d 01			L373D:  DEFB    $01             ;;exchange  
373e 34			        DEFB    $34             ;;stk-data  
373f f0			        DEFB    $F0             ;;Exponent: $80, Bytes: 4  
3740 31 72 17 f8	        DEFB    $31,$72,$17,$F8 ;;  
3744 04			        DEFB    $04             ;;multiply  
3745 01			        DEFB    $01             ;;exchange  
3746 a2			        DEFB    $A2             ;;stk-half  
3747 03			        DEFB    $03             ;;subtract  
3748 a2			        DEFB    $A2             ;;stk-half  
3749 03			        DEFB    $03             ;;subtract  
374a 31			        DEFB    $31             ;;duplicate  
374b 34			        DEFB    $34             ;;stk-data  
374c 32			        DEFB    $32             ;;Exponent: $82, Bytes: 1  
374d 20			        DEFB    $20             ;;(+00,+00,+00)  
374e 04			        DEFB    $04             ;;multiply  
374f a2			        DEFB    $A2             ;;stk-half  
3750 03			        DEFB    $03             ;;subtract  
3751 8c			        DEFB    $8C             ;;series-0C  
3752 11			        DEFB    $11             ;;Exponent: $61, Bytes: 1  
3753 ac			        DEFB    $AC             ;;(+00,+00,+00)  
3754 14			        DEFB    $14             ;;Exponent: $64, Bytes: 1  
3755 09			        DEFB    $09             ;;(+00,+00,+00)  
3756 56			        DEFB    $56             ;;Exponent: $66, Bytes: 2  
3757 da a5		        DEFB    $DA,$A5         ;;(+00,+00)  
3759 59			        DEFB    $59             ;;Exponent: $69, Bytes: 2  
375a 30 c5		        DEFB    $30,$C5         ;;(+00,+00)  
375c 5c			        DEFB    $5C             ;;Exponent: $6C, Bytes: 2  
375d 90 aa		        DEFB    $90,$AA         ;;(+00,+00)  
375f 9e			        DEFB    $9E             ;;Exponent: $6E, Bytes: 3  
3760 70 6f 61		        DEFB    $70,$6F,$61     ;;(+00)  
3763 a1			        DEFB    $A1             ;;Exponent: $71, Bytes: 3  
3764 cb da 96		        DEFB    $CB,$DA,$96     ;;(+00)  
3767 a4			        DEFB    $A4             ;;Exponent: $74, Bytes: 3  
3768 31 9f b4		        DEFB    $31,$9F,$B4     ;;(+00)  
376b e7			        DEFB    $E7             ;;Exponent: $77, Bytes: 4  
376c a0 fe 5c fc	        DEFB    $A0,$FE,$5C,$FC ;;  
3770 ea			        DEFB    $EA             ;;Exponent: $7A, Bytes: 4  
3771 1b 43 ca 36	        DEFB    $1B,$43,$CA,$36 ;;  
3775 ed			        DEFB    $ED             ;;Exponent: $7D, Bytes: 4  
3776 a7 9c 7e 5e	        DEFB    $A7,$9C,$7E,$5E ;;  
377a f0			        DEFB    $F0             ;;Exponent: $80, Bytes: 4  
377b 6e 23 80 93	        DEFB    $6E,$23,$80,$93 ;;  
377f 04			        DEFB    $04             ;;multiply  
3780 0f			        DEFB    $0F             ;;addition  
3781 38			        DEFB    $38             ;;end-calc  
3782			  
3782 c9			        RET                     ; return.  
3783			  
3783			  
3783			; -----------------------------  
3783			; THE 'TRIGONOMETRIC' FUNCTIONS  
3783			; -----------------------------  
3783			; Trigonometry is rocket science. It is also used by carpenters and pyramid  
3783			; builders.   
3783			; Some uses can be quite abstract but the principles can be seen in simple  
3783			; right-angled triangles. Triangles have some special properties -  
3783			;  
3783			; 1) The sum of the three angles is always PI radians (180 degrees).  
3783			;    Very helpful if you know two angles and wish to find the third.  
3783			; 2) In any right-angled triangle the sum of the squares of the two shorter  
3783			;    sides is equal to the square of the longest side opposite the right-angle.  
3783			;    Very useful if you know the length of two sides and wish to know the  
3783			;    length of the third side.  
3783			; 3) Functions sine, cosine and tangent enable one to calculate the length   
3783			;    of an unknown side when the length of one other side and an angle is   
3783			;    known.  
3783			; 4) Functions arcsin, arccosine and arctan enable one to calculate an unknown  
3783			;    angle when the length of two of the sides is known.  
3783			  
3783			;---------------------------------  
3783			; THE 'REDUCE ARGUMENT' SUBROUTINE  
3783			;---------------------------------  
3783			; (offset $39: 'get-argt')  
3783			;  
3783			; This routine performs two functions on the angle, in radians, that forms  
3783			; the argument to the sine and cosine functions.  
3783			; First it ensures that the angle 'wraps round'. That if a ship turns through   
3783			; an angle of, say, 3*PI radians (540 degrees) then the net effect is to turn   
3783			; through an angle of PI radians (180 degrees).  
3783			; Secondly it converts the angle in radians to a fraction of a right angle,  
3783			; depending within which quadrant the angle lies, with the periodicity   
3783			; resembling that of the desired sine value.  
3783			; The result lies in the range -1 to +1.                
3783			;  
3783			;                     90 deg.  
3783			;   
3783			;                     (pi/2)  
3783			;              II       +1        I  
3783			;                       |  
3783			;        sin+      |\   |   /|    sin+  
3783			;        cos-      | \  |  / |    cos+  
3783			;        tan-      |  \ | /  |    tan+  
3783			;                  |   \|/)  |             
3783			; 180 deg. (pi) 0 -|----+----|-- 0  (0)   0 degrees  
3783			;                  |   /|\   |  
3783			;        sin-      |  / | \  |    sin-  
3783			;        cos-      | /  |  \ |    cos+  
3783			;        tan+      |/   |   \|    tan-  
3783			;                       |  
3783			;              III      -1       IV  
3783			;                     (3pi/2)  
3783			;  
3783			;                     270 deg.  
3783			;  
3783			  
3783			;; get-argt  
3783 ef			L3783:  RST     28H             ;; FP-CALC      X.  
3784 3d			        DEFB    $3D             ;;re-stack  
3785 34			        DEFB    $34             ;;stk-data  
3786 ee			        DEFB    $EE             ;;Exponent: $7E,   
3787			                                ;;Bytes: 4  
3787 22 f9 83 6e	        DEFB    $22,$F9,$83,$6E ;;              X, 1/(2*PI)  
378b 04			        DEFB    $04             ;;multiply      X/(2*PI) = fraction  
378c 31			        DEFB    $31             ;;duplicate  
378d a2			        DEFB    $A2             ;;stk-half  
378e 0f			        DEFB    $0F             ;;addition  
378f 27			        DEFB    $27             ;;int  
3790			  
3790 03			        DEFB    $03             ;;subtract      now range -.5 to .5  
3791			  
3791 31			        DEFB    $31             ;;duplicate  
3792 0f			        DEFB    $0F             ;;addition      now range -1 to 1.  
3793 31			        DEFB    $31             ;;duplicate  
3794 0f			        DEFB    $0F             ;;addition      now range -2 to +2.  
3795			  
3795			; quadrant I (0 to +1) and quadrant IV (-1 to 0) are now correct.  
3795			; quadrant II ranges +1 to +2.  
3795			; quadrant III ranges -2 to -1.  
3795			  
3795 31			        DEFB    $31             ;;duplicate     Y, Y.  
3796 2a			        DEFB    $2A             ;;abs           Y, abs(Y).    range 1 to 2  
3797 a1			        DEFB    $A1             ;;stk-one       Y, abs(Y), 1.  
3798 03			        DEFB    $03             ;;subtract      Y, abs(Y)-1.  range 0 to 1  
3799 31			        DEFB    $31             ;;duplicate     Y, Z, Z.  
379a 37			        DEFB    $37             ;;greater-0     Y, Z, (1/0).  
379b			  
379b c0			        DEFB    $C0             ;;st-mem-0         store as possible sign   
379c			                                ;;                 for cosine function.  
379c			  
379c 00			        DEFB    $00             ;;jump-true  
379d 04			        DEFB    $04             ;;to L37A1, ZPLUS  with quadrants II and III.  
379e			  
379e			; else the angle lies in quadrant I or IV and value Y is already correct.  
379e			  
379e 02			        DEFB    $02             ;;delete        Y.   delete the test value.  
379f 38			        DEFB    $38             ;;end-calc      Y.  
37a0			  
37a0 c9			        RET                     ; return.       with Q1 and Q4           >>>  
37a1			  
37a1			; ---  
37a1			  
37a1			; the branch was here with quadrants II (0 to 1) and III (1 to 0).  
37a1			; Y will hold -2 to -1 if this is quadrant III.  
37a1			  
37a1			;; ZPLUS  
37a1 a1			L37A1:  DEFB    $A1             ;;stk-one         Y, Z, 1.  
37a2 03			        DEFB    $03             ;;subtract        Y, Z-1.       Q3 = 0 to -1  
37a3 01			        DEFB    $01             ;;exchange        Z-1, Y.  
37a4 36			        DEFB    $36             ;;less-0          Z-1, (1/0).  
37a5 00			        DEFB    $00             ;;jump-true       Z-1.  
37a6 02			        DEFB    $02             ;;to L37A8, YNEG  
37a7			                                ;;if angle in quadrant III  
37a7			  
37a7			; else angle is within quadrant II (-1 to 0)  
37a7			  
37a7 1b			        DEFB    $1B             ;;negate          range +1 to 0.  
37a8			  
37a8			;; YNEG  
37a8 38			L37A8:  DEFB    $38             ;;end-calc        quadrants II and III correct.  
37a9			  
37a9 c9			        RET                     ; return.  
37aa			  
37aa			  
37aa			;----------------------  
37aa			; THE 'COSINE' FUNCTION  
37aa			;----------------------  
37aa			; (offset $20: 'cos')  
37aa			; Cosines are calculated as the sine of the opposite angle rectifying the   
37aa			; sign depending on the quadrant rules.   
37aa			;  
37aa			;  
37aa			;           /|  
37aa			;        h /y|  
37aa			;         /  |o  
37aa			;        /x  |  
37aa			;       /----|      
37aa			;         a  
37aa			;  
37aa			; The cosine of angle x is the adjacent side (a) divided by the hypotenuse 1.  
37aa			; However if we examine angle y then a/h is the sine of that angle.  
37aa			; Since angle x plus angle y equals a right-angle, we can find angle y by   
37aa			; subtracting angle x from pi/2.  
37aa			; However it's just as easy to reduce the argument first and subtract the  
37aa			; reduced argument from the value 1 (a reduced right-angle).  
37aa			; It's even easier to subtract 1 from the angle and rectify the sign.  
37aa			; In fact, after reducing the argument, the absolute value of the argument  
37aa			; is used and rectified using the test result stored in mem-0 by 'get-argt'  
37aa			; for that purpose.  
37aa			;  
37aa			  
37aa			;; cos  
37aa ef			L37AA:  RST     28H             ;; FP-CALC              angle in radians.  
37ab 39			        DEFB    $39             ;;get-argt              X     reduce -1 to +1   
37ac			  
37ac 2a			        DEFB    $2A             ;;abs                   ABS X.   0 to 1  
37ad a1			        DEFB    $A1             ;;stk-one               ABS X, 1.  
37ae 03			        DEFB    $03             ;;subtract              now opposite angle  
37af			                                ;;                      although sign is -ve.  
37af			  
37af e0			        DEFB    $E0             ;;get-mem-0             fetch the sign indicator  
37b0 00			        DEFB    $00             ;;jump-true  
37b1 06			        DEFB    $06             ;;fwd to L37B7, C-ENT  
37b2			                                ;;forward to common code if in QII or QIII.  
37b2			  
37b2 1b			        DEFB    $1B             ;;negate                else make sign +ve.  
37b3 33			        DEFB    $33             ;;jump  
37b4 03			        DEFB    $03             ;;fwd to L37B7, C-ENT  
37b5			                                ;; with quadrants I and IV.  
37b5			  
37b5			;--------------------  
37b5			; THE 'SINE' FUNCTION  
37b5			;--------------------  
37b5			; (offset $1F: 'sin')  
37b5			; This is a fundamental transcendental function from which others such as cos  
37b5			; and tan are directly, or indirectly, derived.  
37b5			; It uses the series generator to produce Chebyshev polynomials.  
37b5			;  
37b5			;  
37b5			;           /|  
37b5			;        1 / |  
37b5			;         /  |x  
37b5			;        /a  |  
37b5			;       /----|      
37b5			;         y  
37b5			;  
37b5			; The 'get-argt' function is designed to modify the angle and its sign   
37b5			; in line with the desired sine value and afterwards it can launch straight  
37b5			; into common code.  
37b5			  
37b5			;; sin  
37b5 ef			L37B5:  RST     28H             ;; FP-CALC      angle in radians  
37b6 39			        DEFB    $39             ;;get-argt      reduce - sign now correct.  
37b7			  
37b7			;; C-ENT  
37b7 31			L37B7:  DEFB    $31             ;;duplicate  
37b8 31			        DEFB    $31             ;;duplicate  
37b9 04			        DEFB    $04             ;;multiply  
37ba 31			        DEFB    $31             ;;duplicate  
37bb 0f			        DEFB    $0F             ;;addition  
37bc a1			        DEFB    $A1             ;;stk-one  
37bd 03			        DEFB    $03             ;;subtract  
37be			  
37be 86			        DEFB    $86             ;;series-06  
37bf 14			        DEFB    $14             ;;Exponent: $64, Bytes: 1  
37c0 e6			        DEFB    $E6             ;;(+00,+00,+00)  
37c1 5c			        DEFB    $5C             ;;Exponent: $6C, Bytes: 2  
37c2 1f 0b		        DEFB    $1F,$0B         ;;(+00,+00)  
37c4 a3			        DEFB    $A3             ;;Exponent: $73, Bytes: 3  
37c5 8f 38 ee		        DEFB    $8F,$38,$EE     ;;(+00)  
37c8 e9			        DEFB    $E9             ;;Exponent: $79, Bytes: 4  
37c9 15 63 bb 23	        DEFB    $15,$63,$BB,$23 ;;  
37cd ee			        DEFB    $EE             ;;Exponent: $7E, Bytes: 4  
37ce 92 0d cd ed	        DEFB    $92,$0D,$CD,$ED ;;  
37d2 f1			        DEFB    $F1             ;;Exponent: $81, Bytes: 4  
37d3 23 5d 1b ea	        DEFB    $23,$5D,$1B,$EA ;;  
37d7 04			        DEFB    $04             ;;multiply  
37d8 38			        DEFB    $38             ;;end-calc  
37d9			  
37d9 c9			        RET                     ; return.  
37da			  
37da			;-----------------------  
37da			; THE 'TANGENT' FUNCTION  
37da			;-----------------------  
37da			; (offset $21: 'tan')  
37da			;  
37da			; Evaluates tangent x as    sin(x) / cos(x).  
37da			;  
37da			;  
37da			;           /|  
37da			;        h / |  
37da			;         /  |o  
37da			;        /x  |  
37da			;       /----|      
37da			;         a  
37da			;  
37da			; the tangent of angle x is the ratio of the length of the opposite side   
37da			; divided by the length of the adjacent side. As the opposite length can   
37da			; be calculates using sin(x) and the adjacent length using cos(x) then   
37da			; the tangent can be defined in terms of the previous two functions.  
37da			  
37da			; Error 6 if the argument, in radians, is too close to one like pi/2  
37da			; which has an infinite tangent. e.g. PRINT TAN (PI/2)  evaluates as 1/0.  
37da			; Similarly PRINT TAN (3*PI/2), TAN (5*PI/2) etc.  
37da			  
37da			;; tan  
37da ef			L37DA:  RST     28H             ;; FP-CALC          x.  
37db 31			        DEFB    $31             ;;duplicate         x, x.  
37dc 1f			        DEFB    $1F             ;;sin               x, sin x.  
37dd 01			        DEFB    $01             ;;exchange          sin x, x.  
37de 20			        DEFB    $20             ;;cos               sin x, cos x.  
37df 05			        DEFB    $05             ;;division          sin x/cos x (= tan x).  
37e0 38			        DEFB    $38             ;;end-calc          tan x.  
37e1			  
37e1 c9			        RET                     ; return.  
37e2			  
37e2			;----------------------  
37e2			; THE 'ARCTAN' FUNCTION  
37e2			;----------------------  
37e2			; (Offset $24: 'atn')  
37e2			; the inverse tangent function with the result in radians.  
37e2			; This is a fundamental transcendental function from which others such as asn  
37e2			; and acs are directly, or indirectly, derived.  
37e2			; It uses the series generator to produce Chebyshev polynomials.  
37e2			  
37e2			;; atn  
37e2 cd 97 32		L37E2:  CALL    L3297           ; routine re-stack  
37e5 7e			        LD      A,(HL)          ; fetch exponent byte.  
37e6 fe 81		        CP      $81             ; compare to that for 'one'  
37e8 38 0e		        JR      C,L37F8         ; forward, if less, to SMALL  
37ea			  
37ea ef			        RST     28H             ;; FP-CALC  
37eb a1			        DEFB    $A1             ;;stk-one  
37ec 1b			        DEFB    $1B             ;;negate  
37ed 01			        DEFB    $01             ;;exchange  
37ee 05			        DEFB    $05             ;;division  
37ef 31			        DEFB    $31             ;;duplicate  
37f0 36			        DEFB    $36             ;;less-0  
37f1 a3			        DEFB    $A3             ;;stk-pi/2  
37f2 01			        DEFB    $01             ;;exchange  
37f3 00			        DEFB    $00             ;;jump-true  
37f4 06			        DEFB    $06             ;;to L37FA, CASES  
37f5			  
37f5 1b			        DEFB    $1B             ;;negate  
37f6 33			        DEFB    $33             ;;jump  
37f7 03			        DEFB    $03             ;;to L37FA, CASES  
37f8			  
37f8			;; SMALL  
37f8 ef			L37F8:  RST     28H             ;; FP-CALC  
37f9 a0			        DEFB    $A0             ;;stk-zero  
37fa			  
37fa			;; CASES  
37fa 01			L37FA:  DEFB    $01             ;;exchange  
37fb 31			        DEFB    $31             ;;duplicate  
37fc 31			        DEFB    $31             ;;duplicate  
37fd 04			        DEFB    $04             ;;multiply  
37fe 31			        DEFB    $31             ;;duplicate  
37ff 0f			        DEFB    $0F             ;;addition  
3800 a1			        DEFB    $A1             ;;stk-one  
3801 03			        DEFB    $03             ;;subtract  
3802 8c			        DEFB    $8C             ;;series-0C  
3803 10			        DEFB    $10             ;;Exponent: $60, Bytes: 1  
3804 b2			        DEFB    $B2             ;;(+00,+00,+00)  
3805 13			        DEFB    $13             ;;Exponent: $63, Bytes: 1  
3806 0e			        DEFB    $0E             ;;(+00,+00,+00)  
3807 55			        DEFB    $55             ;;Exponent: $65, Bytes: 2  
3808 e4 8d		        DEFB    $E4,$8D         ;;(+00,+00)  
380a 58			        DEFB    $58             ;;Exponent: $68, Bytes: 2  
380b 39 bc		        DEFB    $39,$BC         ;;(+00,+00)  
380d 5b			        DEFB    $5B             ;;Exponent: $6B, Bytes: 2  
380e 98 fd		        DEFB    $98,$FD         ;;(+00,+00)  
3810 9e			        DEFB    $9E             ;;Exponent: $6E, Bytes: 3  
3811 00 36 75		        DEFB    $00,$36,$75     ;;(+00)  
3814 a0			        DEFB    $A0             ;;Exponent: $70, Bytes: 3  
3815 db e8 b4		        DEFB    $DB,$E8,$B4     ;;(+00)  
3818 63			        DEFB    $63             ;;Exponent: $73, Bytes: 2  
3819 42 c4		        DEFB    $42,$C4         ;;(+00,+00)  
381b e6			        DEFB    $E6             ;;Exponent: $76, Bytes: 4  
381c b5 09 36 be	        DEFB    $B5,$09,$36,$BE ;;  
3820 e9			        DEFB    $E9             ;;Exponent: $79, Bytes: 4  
3821 36 73 1b 5d	        DEFB    $36,$73,$1B,$5D ;;  
3825 ec			        DEFB    $EC             ;;Exponent: $7C, Bytes: 4  
3826 d8 de 63 be	        DEFB    $D8,$DE,$63,$BE ;;  
382a f0			        DEFB    $F0             ;;Exponent: $80, Bytes: 4  
382b 61 a1 b3 0c	        DEFB    $61,$A1,$B3,$0C ;;  
382f 04			        DEFB    $04             ;;multiply  
3830 0f			        DEFB    $0F             ;;addition  
3831 38			        DEFB    $38             ;;end-calc  
3832			  
3832 c9			        RET                     ; return.  
3833			  
3833			  
3833			;----------------------  
3833			; THE 'ARCSIN' FUNCTION  
3833			;----------------------  
3833			; (Offset $22: 'asn')  
3833			; the inverse sine function with result in radians.  
3833			; derived from arctan function above.  
3833			; Error A unless the argument is between -1 and +1 inclusive.  
3833			; uses an adaptation of the formula asn(x) = atn(x/sqr(1-x*x))  
3833			;  
3833			;  
3833			;           /|  
3833			;        1 / |  
3833			;         /  |x  
3833			;        /a  |  
3833			;       /----|      
3833			;         y  
3833			;  
3833			; e.g. we know the opposite side (x) and hypotenuse (1)   
3833			; and we wish to find angle a in radians.  
3833			; we can derive length y by Pythagorus and then use ATN instead.   
3833			; since y*y + x*x = 1*1 (Pythagorus Theorem) then  
3833			; y=sqr(1-x*x)                         - no need to multiply 1 by itself.  
3833			; so, asn(a) = atn(x/y)  
3833			; or more fully,  
3833			; asn(a) = atn(x/sqr(1-x*x))  
3833			  
3833			; Close but no cigar.  
3833			  
3833			; While PRINT ATN (x/SQR (1-x*x)) gives the same results as PRINT ASN x,  
3833			; it leads to division by zero when x is 1 or -1.  
3833			; To overcome this, 1 is added to y giving half the required angle and the   
3833			; result is then doubled.   
3833			; That is PRINT ATN (x/(SQR (1-x*x) +1)) *2  
3833			; A value higher than 1 gives the required error as attempting to find  the  
3833			; square root of a negative number generates an error in Sinclair BASIC.  
3833			  
3833			;; asn  
3833 ef			L3833:  RST     28H             ;; FP-CALC      x.  
3834 31			        DEFB    $31             ;;duplicate     x, x.  
3835 31			        DEFB    $31             ;;duplicate     x, x, x.  
3836 04			        DEFB    $04             ;;multiply      x, x*x.  
3837 a1			        DEFB    $A1             ;;stk-one       x, x*x, 1.  
3838 03			        DEFB    $03             ;;subtract      x, x*x-1.  
3839 1b			        DEFB    $1B             ;;negate        x, 1-x*x.  
383a 28			        DEFB    $28             ;;sqr           x, sqr(1-x*x) = y  
383b a1			        DEFB    $A1             ;;stk-one       x, y, 1.  
383c 0f			        DEFB    $0F             ;;addition      x, y+1.  
383d 05			        DEFB    $05             ;;division      x/y+1.  
383e 24			        DEFB    $24             ;;atn           a/2       (half the angle)  
383f 31			        DEFB    $31             ;;duplicate     a/2, a/2.  
3840 0f			        DEFB    $0F             ;;addition      a.  
3841 38			        DEFB    $38             ;;end-calc      a.  
3842			  
3842 c9			        RET                     ; return.  
3843			  
3843			  
3843			;-------------------------  
3843			; THE 'ARCCOS' FUNCTION  
3843			;-------------------------  
3843			; (Offset $23: 'acs')  
3843			; the inverse cosine function with the result in radians.  
3843			; Error A unless the argument is between -1 and +1.  
3843			; Result in range 0 to pi.  
3843			; Derived from asn above which is in turn derived from the preceding atn.  
3843			; It could have been derived directly from atn using acs(x) = atn(sqr(1-x*x)/x).  
3843			; However, as sine and cosine are horizontal translations of each other,  
3843			; uses acs(x) = pi/2 - asn(x)  
3843			  
3843			; e.g. the arccosine of a known x value will give the required angle b in   
3843			; radians.  
3843			; We know, from above, how to calculate the angle a using asn(x).   
3843			; Since the three angles of any triangle add up to 180 degrees, or pi radians,  
3843			; and the largest angle in this case is a right-angle (pi/2 radians), then  
3843			; we can calculate angle b as pi/2 (both angles) minus asn(x) (angle a).  
3843			;   
3843			;  
3843			;           /|  
3843			;        1 /b|  
3843			;         /  |x  
3843			;        /a  |  
3843			;       /----|      
3843			;         y  
3843			;  
3843			  
3843			;; acs  
3843 ef			L3843:  RST     28H             ;; FP-CALC      x.  
3844 22			        DEFB    $22             ;;asn           asn(x).  
3845 a3			        DEFB    $A3             ;;stk-pi/2      asn(x), pi/2.  
3846 03			        DEFB    $03             ;;subtract      asn(x) - pi/2.  
3847 1b			        DEFB    $1B             ;;negate        pi/2 -asn(x)  =  acs(x).  
3848 38			        DEFB    $38             ;;end-calc      acs(x).  
3849			  
3849 c9			        RET                     ; return.  
384a			  
384a			  
384a			; --------------------------  
384a			; THE 'SQUARE ROOT' FUNCTION  
384a			; --------------------------  
384a			; (Offset $28: 'sqr')  
384a			; This routine is remarkable only in its brevity - 7 bytes.  
384a			; It wasn't written here but in the ZX81 where the programmers had to squeeze  
384a			; a bulky operating sytem into an 8K ROM. It simply calculates   
384a			; the square root by stacking the value .5 and continuing into the 'to-power'  
384a			; routine. With more space available the much faster Newton-Raphson method  
384a			; should have been used as on the Jupiter Ace.  
384a			  
384a			;; sqr  
384a ef			L384A:  RST     28H             ;; FP-CALC  
384b 31			        DEFB    $31             ;;duplicate  
384c 30			        DEFB    $30             ;;not  
384d 00			        DEFB    $00             ;;jump-true  
384e 1e			        DEFB    $1E             ;;to L386C, LAST  
384f			  
384f a2			        DEFB    $A2             ;;stk-half  
3850 38			        DEFB    $38             ;;end-calc  
3851			  
3851			  
3851			; ------------------------------  
3851			; THE 'EXPONENTIATION' OPERATION  
3851			; ------------------------------  
3851			; (Offset $06: 'to-power')  
3851			; This raises the first number X to the power of the second number Y.  
3851			; As with the ZX80,  
3851			; 0 ^ 0 = 1.  
3851			; 0 ^ +n = 0.  
3851			; 0 ^ -n = arithmetic overflow.  
3851			;  
3851			  
3851			;; to-power  
3851 ef			L3851:  RST     28H             ;; FP-CALC              X, Y.  
3852 01			        DEFB    $01             ;;exchange              Y, X.  
3853 31			        DEFB    $31             ;;duplicate             Y, X, X.  
3854 30			        DEFB    $30             ;;not                   Y, X, (1/0).  
3855 00			        DEFB    $00             ;;jump-true  
3856 07			        DEFB    $07             ;;to L385D, XISO   if X is zero.  
3857			  
3857			; else X is non-zero. Function 'ln' will catch a negative value of X.  
3857			  
3857 25			        DEFB    $25             ;;ln                    Y, LN X.  
3858 04			        DEFB    $04             ;;multiply              Y * LN X.  
3859 38			        DEFB    $38             ;;end-calc  
385a			  
385a c3 c4 36		        JP      L36C4           ; jump back to EXP routine   ->  
385d			  
385d			; ---  
385d			  
385d			; these routines form the three simple results when the number is zero.  
385d			; begin by deleting the known zero to leave Y the power factor.  
385d			  
385d			;; XISO  
385d 02			L385D:  DEFB    $02             ;;delete                Y.  
385e 31			        DEFB    $31             ;;duplicate             Y, Y.  
385f 30			        DEFB    $30             ;;not                   Y, (1/0).  
3860 00			        DEFB    $00             ;;jump-true  
3861 09			        DEFB    $09             ;;to L386A, ONE         if Y is zero.  
3862			  
3862 a0			        DEFB    $A0             ;;stk-zero              Y, 0.  
3863 01			        DEFB    $01             ;;exchange              0, Y.  
3864 37			        DEFB    $37             ;;greater-0             0, (1/0).  
3865 00			        DEFB    $00             ;;jump-true             0.  
3866 06			        DEFB    $06             ;;to L386C, LAST        if Y was any positive   
3867			                                ;;                      number.  
3867			  
3867			; else force division by zero thereby raising an Arithmetic overflow error.  
3867			; There are some one and two-byte alternatives but perhaps the most formal  
3867			; might have been to use end-calc; rst 08; defb 05.  
3867			  
3867 a1			        DEFB    $A1             ;;stk-one               0, 1.  
3868 01			        DEFB    $01             ;;exchange              1, 0.  
3869 05			        DEFB    $05             ;;division              1/0        ouch!  
386a			  
386a			; ---  
386a			  
386a			;; ONE  
386a 02			L386A:  DEFB    $02             ;;delete                .  
386b a1			        DEFB    $A1             ;;stk-one               1.  
386c			  
386c			;; LAST  
386c 38			L386C:  DEFB    $38             ;;end-calc              last value is 1 or 0.  
386d			  
386d c9			        RET                     ; return.               Whew!  
386e			  
386e			  
386e			;*********************************  
386e			;** Spectrum 128 Patch Routines **  
386e			;*********************************  
386e			  
386e			; The new code added to the standard 48K Spectrum ROM is mainly devoted to the scanning and decoding of the keypad.  
386e			; These routines occupy addresses 386E through to 3B3A. Addresses 3B3B through to 3C96 contain a variety of routines for the following purposes: displaying the new tokens 'PLAY' and 'SPECTRUM',  
386e			; dealing with the keypad when using INKEY$, handling new 128 BASIC error messages, and producing the TV tuner display. Addresses 3BE1 to 3BFE and addresses 3C97 to 3CFF are unused and all contain 00.  
386e			; Documented by Paul Farrow.  
386e			  
386e			; --------------------------------  
386e			; SCAN THE KEYPAD AND THE KEYBOARD  
386e			; --------------------------------  
386e			; This patch will attempt to scan the keypad if in 128K mode and will then scan the keyboard.  
386e			  
386e			;; KEYS  
386e dd e5		L386E:  PUSH    IX  
3870 fd cb 01 66	        BIT     4,(IY+$01)      ; [FLAGS] Test if in 128K mode  
3874 28 03		        JR      Z,L3879         ; Z=in 48K mode  
3876			  
3876 cd 42 3a		        CALL    L3A42           ; Attempt to scan the keypad  
3879			  
3879			;; KEYS_CONT  
3879 cd bf 02		L3879:  CALL    L02BF           ; Scan the keyboard  
387c dd e1		        POP     IX  
387e c9			        RET  
387f			  
387f			; ----------------------------------  
387f			; READ THE STATE OF THE OUTPUT LINES  
387f			; ----------------------------------  
387f			; This routine returns the state of the four output lines (bits 0-3) in the lower four bits of L. The LSB of L corresponds to the output communication line to the keypad.  
387f			; In this way the state of the other three outputs are maintained when the state of the LSB of L is changed and sent out to register 14 of the AY-3-8912.  
387f			  
387f			;; READ_OUTPUTS  
387f 0e fd		L387F:  LD      C,$FD           ; FFFD = Address of the  
3881 16 ff		        LD      D,$FF           ; command register (register 7)  
3883 1e bf		        LD      E,$BF           ; BFFD = Address of the  
3885 42			        LD      B,D             ; data register (register 14)  
3886 3e 07		        LD      A,$07  
3888 ed 79		        OUT     (C),A           ; Select command register  
388a ed 60		        IN      H,(C)           ; Read its status  
388c 3e 0e		        LD      A,$0E  
388e ed 79		        OUT     (C),A           ; Select data register  
3890 ed 78		        IN      A,(C)           ; Read its status  
3892 f6 f0		        OR      $F0             ; Mask off the input lines   
3894 6f			        LD      L,A             ; L=state of output lines at the  
3895 c9			        RET                     ; keypad socket  
3896			  
3896			; --------------------------  
3896			; SET THE OUTPUT LINE, BIT 0  
3896			; --------------------------  
3896			; The output line to the keypad is set via the LSB of L.  
3896			  
3896			;; SET_REG14  
3896 42			L3896:  LD      B,D  
3897 3e 0e		        LD      A,$0E   
3899 ed 79		        OUT     (C),A           ; Select the data register  
389b 43			        LD      B,E  
389c ed 69		        OUT     (C),L           ; Send L out to the data register  
389e c9			        RET                     ; Set the output line  
389f			  
389f			; ----------------------------------------  
389f			; FETCH THE STATE OF THE INPUT LINE, BIT 5  
389f			; ----------------------------------------  
389f			; Return the state of the input line from the keypad in bit 5 of A.  
389f			  
389f			;; GET_REG14  
389f 42			L389F:  LD      B,D  
38a0 3e 0e		        LD      A,$0E  
38a2 ed 79		        OUT     (C),A           ; Select the data register  
38a4 ed 78		        IN      A,(C)           ; Read the input line  
38a6 c9			        RET  
38a7			  
38a7			; ------------------------------  
38a7			; SET THE OUTPUT LINE LOW, BIT 0  
38a7			; ------------------------------  
38a7			  
38a7			;; RESET_LINE  
38a7 7d			L38A7:  LD      A,L  
38a8 e6 fe		        AND     $FE             ; Reset bit 0 of L  
38aa 6f			        LD      L,A  
38ab 18 e9		        JR      L3896           ; Send out L to the data register  
38ad			  
38ad			; -------------------------------  
38ad			; SET THE OUTPUT LINE HIGH, BIT 0  
38ad			; -------------------------------  
38ad			  
38ad			;; SET_LINE  
38ad 7d			L38AD:  LD      A,L  
38ae f6 01		        OR      $01             ; Set bit 0 of L  
38b0 6f			        LD      L,A  
38b1 18 e3		        JR      L3896           ; Send out L to the data register  
38b3			  
38b3			; -------------------  
38b3			; MINOR DELAY ROUTINE  
38b3			; -------------------  
38b3			; Delay for (B*13)+5 T-States.  
38b3			  
38b3			;; DELAY  
38b3 10 fe		L38B3:  DJNZ    L38B3  
38b5 c9			        RET  
38b6			  
38b6			; -------------------  
38b6			; MAJOR DELAY ROUTINE  
38b6			; -------------------  
38b6			; Delay for (B*271)+5 T-states.  
38b6			  
38b6			;; DELAY2  
38b6 c5			L38B6:  PUSH    BC   
38b7 06 10		        LD      B,$10  
38b9 cd b3 38		        CALL    L38B3           ; Inner delay of 135 T-States  
38bc c1			        POP     BC  
38bd 10 f7		        DJNZ    L38B6  
38bf			  
38bf c9			        RET  
38c0			  
38c0			; ------------------------------------  
38c0			; MONITOR FOR THE INPUT LINE TO GO LOW  
38c0			; ------------------------------------  
38c0			; Monitor the input line, bit 5, for up to (B*108)+5 T-states.  
38c0			  
38c0			;; MON_B5_LO  
38c0 c5			L38C0:  PUSH    BC  
38c1 cd 9f 38		        CALL    L389F           ; Read the state of the input line  
38c4 c1			        POP     BC  
38c5 e6 20		        AND     $20             ; Test bit 5, the input line  
38c7 28 02		        JR      Z,L38CB         ; Exit if input line found low  
38c9 10 f5		        DJNZ    L38C0           ; Repeat until timeout expires  
38cb			  
38cb			;; EXT_MON_LO  
38cb c9			L38CB:  RET  
38cc			  
38cc			; -------------------------------------  
38cc			; MONITOR FOR THE INPUT LINE TO GO HIGH  
38cc			; -------------------------------------  
38cc			; Monitor the input line, bit 5, for up to (B*108)+5 T-states.  
38cc			  
38cc			;; MON_B5_HI  
38cc c5			L38CC:  PUSH    BC  
38cd cd 9f 38		        CALL    L389F           ; Read the state of the input line  
38d0 c1			        POP     BC  
38d1 e6 20		        AND     $20             ; Test bit 5, the input line  
38d3 20 02		        JR      NZ,L38D7        ; Exit if input line found low  
38d5 10 f5		        DJNZ    L38CC           ; Repeat until timeout expires  
38d7			  
38d7			;; EXT_MON_HI  
38d7 c9			L38D7:  RET  
38d8			  
38d8			; -------------------------  
38d8			; READ KEY PRESS STATUS BIT  
38d8			; -------------------------  
38d8			; This entry point is used to read in the status bit for a keypad row. If a key is being pressed in the current row then the bit read in will be a 1.  
38d8			  
38d8			;; READ_STATUS  
38d8 cd 7f 38		L38D8:  CALL    L387F           ; Read the output lines  
38db 06 01		        LD      B,$01           ; Read in one bit  
38dd 18 05		        JR      L38E4  
38df			  
38df			; ----------------  
38df			; READ IN A NIBBLE   
38df			; ----------------  
38df			; This entry point is used to read in a nibble of data from the keypad. It is used for two functions. The first is to read in the poll nibble and the second is to read in a row of key press data.  
38df			; For a nibble of key press data, a bit read in as 1 indicates that the corresponding key was pressed.  
38df			  
38df			;; READ_NIBBLE  
38df cd 7f 38		L38DF:  CALL    L387F           ; Read the state of the output lines  
38e2 06 04		        LD      B,$04           ; Read in four bits  
38e4			  
38e4			;; READ_BIT  
38e4 c5			L38E4:  PUSH    BC   
38e5 cd 9f 38		        CALL    L389F           ; Read the input line from the keypad  
38e8 c1			        POP     BC  
38e9 e6 20		        AND     $20             ; This line should initially be high  
38eb 28 40		        JR      Z,L392D         ; Z=read in a 0, there must be an error  
38ed			  
38ed af			        XOR     A               ; The bits read in will be stored in register A  
38ee			  
38ee			;; BIT_LOOP  
38ee c5			L38EE:  PUSH    BC              ; Preserve the loop count and any bits  
38ef f5			        PUSH    AF              ; read in so far  
38f0 cd ad 38		        CALL    L38AD           ; Set the output line high  
38f3			  
38f3 06 a3		        LD      B,$A3           ; Monitor for 17609 T-states for the  
38f5 cd c0 38		        CALL    L38C0           ; input line to go low  
38f8 20 31		        JR      NZ,L392B        ; NZ=the line did not go low  
38fa			  
38fa cd a7 38		        CALL    L38A7           ; Set the output line low  
38fd 18 02		        JR      L3901           ; Insert a delay of 12 T-states  
38ff			  
38ff ff ff		L38FF:  DEFB    $FF, $FF  
3901			  
3901			;; BL_CONTINUE  
3901 06 2b		L3901:  LD      B,$2B           ; Delay for 564 T-states  
3903 cd b3 38		        CALL    L38B3  
3906 cd 9f 38		        CALL    L389F           ; Read in the bit value   
3909 cb 6f		        BIT     5,A  
390b 28 04		        JR      Z,L3911         ; Z=read in a 0  
390d			  
390d f1			        POP     AF              ; Retrieve read in bits  
390e 37			        SCF                     ; Set carry bit  
390f 18 03		        JR      L3914  
3911			  
3911			;; BL_READ_0  
3911 f1			L3911:  POP     AF              ; Retrieve read in bits  
3912 37			        SCF  
3913 3f			        CCF                     ; Clear carry bit  
3914			  
3914			;; BL_STORE  
3914 1f			L3914:  RRA                     ; Shift the carry bit into bit 0 of A  
3915 f5			        PUSH    AF              ; Save bits read in  
3916 cd ad 38		        CALL    L38AD           ; Set the output line high  
3919			  
3919 06 26		        LD      B,$26           ; Delay for 499 T-states  
391b cd b3 38		        CALL    L38B3  
391e			  
391e cd a7 38		        CALL    L38A7           ; Set the output line low  
3921			  
3921 06 23		        LD      B,$23           ; Delay for 460 T-states  
3923 cd b3 38		        CALL    L38B3  
3926			  
3926 f1			        POP     AF              ; Retrieve read in bits  
3927 c1			        POP     BC              ; Retrieve loop counter and repeat  
3928 10 c4		        DJNZ    L38EE           ; for all bits to read in  
392a			  
392a c9			        RET  
392b			  
392b			; ----------  
392b			; LINE ERROR  
392b			; ----------  
392b			; The input line was found at the wrong level. The output line is now set high which will eventually cause the keypad to abandon its transmissions.  
392b			; The upper nibble of system variable FLAGS/ROW3 will be cleared to indicate that communications to the keypad is no longer in progress.  
392b			  
392b			;; LINE_ERROR  
392b f1			L392B:  POP     AF  
392c c1			        POP     BC              ; Clear the stack  
392d			  
392d			;; LINE_ERROR2  
392d cd ad 38		L392D:  CALL    L38AD           ; Set the output line high  
3930			  
3930 af			        XOR     A               ; Clear FLAGS nibble  
3931 32 88 5b		        LD      ($5B88),A       ; [FLAGS/ROW3]  
3934			  
3934 3c			        INC     A               ; Return zero flag reset  
3935 37			        SCF  
3936 3f			        CCF                     ; Return carry flag reset  
3937 c9			        RET  
3938			  
3938			; ---------------  
3938			; POLL THE KEYPAD  
3938			; ---------------  
3938			; The Spectrum 128 polls the keypad by changing the state of the output line and monitoring for responses from the keypad on the input line.  
3938			; Before a poll occurs, the poll counter must be decremented until it reaches zero. This counter causes a delay of three seconds before a communications attempt to the keypad is made.  
3938			; The routine can exit at five different places and it is the state of the A register, the zero flag and the carry flag which indicates the cause of the exit. This is summarised below:  
3938			;  
3938			; A Register    Zero Flag       Carry Flag    Cause  
3938			; 0             set             set           Communications already established  
3938			; 0             set             reset         Nibble read in OK  
3938			; 1             reset           reset         Nibble read in with an error or i/p line initially low  
3938			; 1             reset           set           Poll counter has not yet reached zero  
3938			;  
3938			; The third bit of the nibble read in must be set for the poll to be subsequently accepted.  
3938			  
3938			;; ATTEMPT_POLL  
3938 cd 7f 38		L3938:  CALL    L387F           ; Read the output line states  
393b			  
393b 3a 88 5b		        LD      A,($5B88)       ; [FLAGS/ROW3] Has communications already been  
393e e6 80		        AND     $80             ; established with the keypad?  
3940 20 57		        JR      NZ,L3999        ; NZ=yes, so skip the poll  
3942			  
3942 cd 9f 38		        CALL    L389F           ; Read the input line  
3945 e6 20		        AND     $20             ; It should be high initially  
3947 28 e4		        JR      Z,L392D         ; Z=error, input line found low  
3949			  
3949 3a 88 5b		        LD      A,($5B88)       ; [FLAGS/ROW3] Test if poll counter already zero thus  
394c a7			        AND     A               ; indicating a previous comms error  
394d 20 0b		        JR      NZ,L395A        ; NZ=ready to poll the keypad  
394f			  
394f 3c			        INC     A               ; Indicate comms not established  
3950 32 88 5b		        LD      ($5B88),A       ; [FLAGS/ROW3]  
3953 3e 4c		        LD      A,$4C           ; Reset the poll counter  
3955 32 89 5b		        LD      ($5B89),A       ; [ROW2/ROW1]  
3958 18 42		        JR      L399C           ; Exit the routine  
395a			  
395a			;;POLL_KEYPAD  
395a 3a 89 5b		L395A:  LD      A,($5B89)       ; [ROW2/ROW1] Decrement the poll counter  
395d 3d			        DEC     A  
395e 32 89 5b		        LD      ($5B89),A       ; [ROW2/ROW1]  
3961 20 39		        JR      NZ,L399C        ; Exit the routine if it is not yet zero  
3963			  
3963			; The poll counter has reached zero so a poll of the keypad can now occur.  
3963			  
3963 af			        XOR     A   
3964 32 88 5b		        LD      ($5B88),A       ; [FLAGS/ROW3] Indicate that a poll can occur  
3967 32 89 5b		        LD      ($5B89),A       ; [ROW2/ROW1]  
396a 32 8a 5b		        LD      ($5B8A),A       ; [ROW4/ROW5] Clear all the row nibble stores  
396d			  
396d cd a7 38		        CALL    L38A7           ; Set the output line low  
3970			  
3970 06 21		        LD      B,$21           ; Wait up to 3569 T-States for the  
3972 cd c0 38		        CALL    L38C0           ; input line to go low  
3975 20 b6		        JR      NZ,L392D        ; NZ=line did not go low  
3977			  
3977 cd ad 38		        CALL    L38AD           ; Set the output line high  
397a			  
397a 06 24		        LD      B,$24           ; Wait up to 3893 T-States for the  
397c cd cc 38		        CALL    L38CC           ; input line to go high  
397f 28 ac		        JR      Z,L392D         ; NZ=line did not go high  
3981			  
3981 cd a7 38		        CALL    L38A7           ; Set the output line low  
3984			  
3984 06 0f		        LD      B,$0F  
3986 cd b6 38		        CALL    L38B6           ; Delay for 4070 T-States  
3989 cd df 38		        CALL    L38DF           ; Read in a nibble of data  
398c 20 9f		        JR      NZ,L392D        ; NZ=error occurred when reading in nibble  
398e			  
398e cb ff		        SET     7,A             ; Set bit 7  
3990 e6 f0		        AND     $F0             ; Keep only the upper four bits  
3992			                                ; (Bit 6 will be set if poll successful)  
3992 32 88 5b		        LD      ($5B88),A       ; [FLAGS/ROW3] Store the flags nibble  
3995 af			        XOR     A  
3996 cb 3f		        SRL     A               ; Exit: Zero flag set, Carry flag reset  
3998 c9			        RET  
3999			  
3999			;; AP_SKIP_POLL  
3999 af			L3999:  XOR     A               ; Communications already established  
399a 37			        SCF                     ; Exit: Zero flag set, Carry flag set  
399b c9			        RET  
399c			  
399c			;; PK_EXIT  
399c af			L399C:  XOR     A               ; Poll counter not zero  
399d 3c			        INC     A  
399e 37			        SCF                     ; Exit: Zero flag reset, Carry flag set  
399f c9			        RET  
39a0			  
39a0			; -----------------------  
39a0			; SCAN THE KEYPAD ROUTINE  
39a0			; -----------------------  
39a0			; If a successful poll of the keypad occurs then the five rows of keys are read in and a unique key code generated.  
39a0			  
39a0			;; KEYPAD_SCAN  
39a0 cd 38 39		L39A0:  CALL    L3938           ; Try to poll the keypad  
39a3			  
39a3 3a 88 5b		        LD      A,($5B88)       ; [FLAGS/ROW3] Test the flags nibble  
39a6 2f			        CPL  
39a7 e6 c0		        AND     $C0             ; Bits 6 and 7 must be set in FLAGS  
39a9 c0			        RET     NZ              ; NZ=poll was not successful  
39aa			  
39aa			; The poll was successful so now read in data for the five keypad rows.  
39aa			  
39aa dd 21 8a 5b	        LD      IX,$5B8A        ; [ROW4/ROW5]  
39ae 06 05		        LD      B,$05           ; The five rows  
39b0			  
39b0			;; KS_LOOP  
39b0 c5			L39B0:  PUSH    BC              ; Save counter  
39b1			  
39b1 cd d8 38		        CALL    L38D8           ; Read the key press status bit  
39b4 c2 3a 3a		        JP      NZ,L3A3A        ; NZ=error occurred  
39b7			  
39b7 cb 7f		        BIT     7,A             ; Test the bit read in  
39b9 28 21		        JR      Z,L39DC         ; Z=no key pressed in this row  
39bb			  
39bb cd df 38		        CALL    L38DF           ; Read in the row's nibble of data  
39be 20 7a		        JR      NZ,L3A3A        ; NZ=error occurred  
39c0			  
39c0 c1			        POP     BC              ; Fetch the nibble loop counter  
39c1 c5			        PUSH    BC  
39c2 4f			        LD      C,A             ; Move the nibble read in to C  
39c3 dd 7e 00		        LD      A,(IX+$00)      ; Fetch the nibble store  
39c6 cb 40		        BIT     0,B             ; Test if an upper or lower nibble  
39c8 28 0c		        JR      Z,L39D6         ; Z=upper nibble  
39ca			  
39ca cb 39		        SRL     C               ; Shift the nibble to the lower position  
39cc cb 39		        SRL     C  
39ce cb 39		        SRL     C  
39d0 cb 39		        SRL     C  
39d2 e6 f0		        AND     $F0             ; Mask off the lower nibble of the  
39d4 18 02		        JR      L39D8           ; nibble store  
39d6			  
39d6			;; KS_UPPER  
39d6 e6 0f		L39D6:  AND     $0F             ; Mask off the upper nibble of the nibble store  
39d8			  
39d8			;; KS_STORE  
39d8 b1			L39D8:  OR      C               ; Combine the existing and new  
39d9 dd 77 00		        LD      (IX+$00),A      ; nibbles and store them  
39dc			  
39dc			;; KS_NEXT  
39dc c1			L39DC:  POP     BC              ; Retrieve the row counter  
39dd cb 40		        BIT     0,B             ; Test if next nibble store is required  
39df 20 02		        JR      NZ,L39E3        ; NZ=use same nibble store  
39e1			  
39e1 dd 2b		        DEC     IX              ; Point to the next nibble store  
39e3			  
39e3			;; KS_NEW  
39e3 10 cb		L39E3:  DJNZ    L39B0           ; Repeat for the next keypad row  
39e5			  
39e5			; All five rows have now been read so compose a unique code for the key pressed.  
39e5			  
39e5 1e 80		        LD      E,$80           ; Signal no key press found yet  
39e7 dd 21 88 5b	        LD      IX,$5B88        ; [FLAGS/ROW3]  
39eb 21 3f 3a		        LD      HL,$3A3F        ; Point to the key mask data  
39ee 06 03		        LD      B,$03           ; Scan three nibbles  
39f0			  
39f0			;; GEN_LOOP  
39f0 dd 7e 00		L39F0:  LD      A,(IX+$00)      ; Fetch a pair of nibbles  
39f3 a6			        AND     (HL)            ; This will mask off the FLAGS nibble and the SHIFT/0 key  
39f4			  
39f4 28 21		        JR      Z,L3A17         ; Z=no key pressed in these nibbles  
39f6			  
39f6 cb 7b		        BIT     7,E             ; Test if a key has already been found  
39f8 28 42		        JR      Z,L3A3C         ; Z=multiple keys pressed  
39fa			  
39fa c5			        PUSH    BC              ; Save the loop counter  
39fb f5			        PUSH    AF              ; Save the byte of key bit data  
39fc 78			        LD      A,B             ; Move loop counter to A  
39fd 18 02		        JR      L3A01           ; A delay of 12 T-States  
39ff			  
39ff ff ff		L39FF:  DEFB    $FF, $FF        ; Unused locations  
3a01			  
3a01			;; GEN_CONT  
3a01 3d			L3A01:  DEC     A               ; These lines of code generate base  
3a02 cb 27		        SLA     A               ; values of 7, 15 and 23 for the three  
3a04 cb 27		        SLA     A               ; nibble stores 5B88, 5B89 & 5B8A.  
3a06 cb 27		        SLA     A  
3a08 f6 07		        OR      $07  
3a0a 47			        LD      B,A             ; B=(loop counter-1)*8+7  
3a0b f1			        POP     AF              ; Fetch the byte of key press data  
3a0c			  
3a0c			;; GEN_BIT  
3a0c cb 27		L3A0C:  SLA     A               ; Shift until a set key bit drops into the  
3a0e da 13 3a		        JP      C,L3A13         ; carry flag  
3a11			  
3a11 10 f9		        DJNZ    L3A0C           ; Decrement B for each 'unsuccessful' shift of the A register  
3a13			  
3a13			;; GEN_FOUND  
3a13 58			L3A13:  LD      E,B             ; E=a unique number for the key pressed, between 1 - 19 except 2 & 3  
3a14			  
3a14 c1			        POP     BC              ; As a result shifting the set key bit  
3a15			                                ; into the carry flag, the A register will  
3a15			                                ; hold 00 if only one key was pressed  
3a15 20 25		        JR      NZ,L3A3C        ; NZ=multiple keys pressed  
3a17			  
3a17			;; GEN_NEXT  
3a17 dd 23		L3A17:  INC     IX              ; Point to the next nibble store  
3a19 23			        INC     HL              ; Point to the corresponding mask data  
3a1a 10 d4		        DJNZ    L39F0           ; Repeat for all three 'nibble' bytes  
3a1c			  
3a1c cb 7b		        BIT     7,E             ; Test if any keys were pressed  
3a1e 20 07		        JR      NZ,L3A27        ; NZ=no keys were pressed  
3a20			  
3a20 7b			        LD      A,E             ; Copy the key code  
3a21 e6 fc		        AND     $FC             ; Test for the '.' key (E=1)  
3a23 28 02		        JR      Z,L3A27         ; Z='.' key pressed  
3a25			  
3a25 1d			        DEC     E  
3a26 1d			        DEC     E               ; Key code in range 2 - 17  
3a27			  
3a27			; The E register now holds a unique key code value between 1 and 17.  
3a27			  
3a27			;; GEN_POINT  
3a27 3a 8a 5b		L3A27:  LD      A,($5B8A)       ; [ROW4/ROW5] Test if the SHIFT key was pressed  
3a2a e6 08		        AND     $08  
3a2c 28 06		        JR      Z,L3A34         ; Z=the SHIFT key was not pressed  
3a2e			  
3a2e			; The SHIFT key was pressed or no key was pressed.  
3a2e			  
3a2e 7b			        LD      A,E             ; Fetch the key code  
3a2f e6 7f		        AND     $7F             ; Mask off 'no key pressed' bit  
3a31 c6 12		        ADD     A,$12           ; Add on a shift offset of 12  
3a33 5f			        LD      E,A  
3a34			  
3a34			; Add a base offset of 5A to all key codes. Note that no key press will result in a key code of DA. This is the only code with bit 7 set and so will be detected later.  
3a34			  
3a34			;; GEN_NOSHIFT  
3a34 7b			L3A34:  LD      A,E  
3a35 c6 5a		        ADD     A,$5A           ; Add a base offset of 5A  
3a37 5f			        LD      E,A             ; Return key codes in range 5B - 7D  
3a38 af			        XOR     A  
3a39 c9			        RET                     ; Exit: Zero flag set, key found OK  
3a3a			  
3a3a			; These two lines belong with the loop above to read in the five keypad rows and are jumped to when an error occurs during reading in a nibble of data.  
3a3a			  
3a3a			;; KS_ERROR  
3a3a c1			L3A3A:  POP     BC              ; Clear the stack and exit  
3a3b c9			        RET                     ; Exit: Zero flag reset  
3a3c			  
3a3c			;; GEN_INVALID  
3a3c af			L3A3C:  XOR     A               ; Exit: Zero flag reset indicating an  
3a3d 3c			        INC     A               ; invalid key press  
3a3e c9			        RET  
3a3f			  
3a3f			; ----------------  
3a3f			; KEYPAD MASK DATA  
3a3f			; ----------------  
3a3f			  
3a3f			;; KEY_MASKS  
3a3f 0f ff f2		L3A3F:  DEFB    $0F, $FF, $F2   ; Key mask data  
3a42			  
3a42			; ---------------  
3a42			; READ THE KEYPAD  
3a42			; ---------------  
3a42			; This routine reads the keypad and handles key repeat and decoding. The bulk of the key repeat code is very similar to that used in the equivalent keyboard routine and works are follows.  
3a42			; A double system of KSTATE system variables (KSTATE0 - KSTATE3 and KSTATE4 - KSTATE7) is used to allow the detection of one key while in the repeat period of the previous key.  
3a42			; In this way, a 'spike' from another key will not stop the previous key from repeating. For a new key to be acknowledged, it must be held down for at least 1/5th of a second, i.e. ten calls to KEYPAD.  
3a42			; The KSTATE system variables store the following data:  
3a42			;  
3a42			;       KSTATE0/4       Un-decoded Key Value (00-27 for keyboard, 5B-7D for keypad, FF for no key)  
3a42			;       KSTATE1/5       10 Call Counter  
3a42			;       KSTATE2/6       Repeat Delay  
3a42			;       KSTATE3/7       Decoded Key Value  
3a42			;  
3a42			; The code returned is then stored in system variable LAST_K (5C08) and a new key signalled by setting bit 5 of FLAGS (5C3B).  
3a42			;  
3a42			; If the Spectrum 128 were to operate identically to the standard 48K Spectrum when in 48K mode, it would have to spend zero time in reading the keypad.  
3a42			; As this is not possible, the loading on the CPU is reduced by scanning the keypad upon every other interrupt. A '10 Call Counter' is then used to ensure that a key is held down for at least 1/5th of a second  
3a42			; before it is registered. Note that this is twice as long as for keyboard key presses and so the keypad key repeat delay is halved.  
3a42			;  
3a42			; At every other interrupt the keypad scanning routine is skipped. The net result of the routine is simply to decrement both '10 Call Counters', if appropriate. By loading the E register with 80 ensures that  
3a42			; the call to KP_TEST will reject the key code and cause a return. A test for keyboard key codes prevents the Call Counter decrements affecting a keyboard key press. It would have been more efficient to execute  
3a42			; a return upon every other call to KEYPAD and then to have used a '5 Call Counter' just as the keyboard routine does.  
3a42			;  
3a42			; A side effect of both the keyboard and keypad using the same KSTATE system variables is that if a key is held down on the keypad and then a key is held down on the keyboard, both keys will be monitored and  
3a42			; repeated alternatively, but with a reduced repeat delay. This delay is between the keypad key repeat delay and the keyboard key repeat delay. This occurs because both the keypad and keyboard routines will  
3a42			; decrement the KSTATE system variable Call Counters. The keypad routine 'knows' of the existence of keyboard key codes but the reverse is not true.  
3a42			  
3a42			;; KEYPAD  
3a42 1e 80		L3A42:  LD      E,$80           ; Signal no key pressed  
3a44 3a 78 5c		        LD      A,($5C78)       ; [FRAMES]  
3a47 e6 01		        AND     $01             ; Scan the keypad every other  
3a49 20 04		        JR      NZ,L3A4F        ; interrupt  
3a4b			  
3a4b cd a0 39		        CALL    L39A0  
3a4e c0			        RET     NZ              ; NZ=no valid key pressed  
3a4f			  
3a4f			;; KP_CHECK  
3a4f 21 00 5c		L3A4F:  LD HL,$5C00             ; [KSTATE0] Test the first KSTATE variable  
3a52			  
3a52			;; KP_LOOP  
3a52 cb 7e		L3A52:  BIT     7,(HL)          ; Is the set free?  
3a54 20 0c		        JR      NZ,L3A62        ; NZ=yes  
3a56			  
3a56 7e			        LD      A,(HL)          ; Fetch the un-decoded key value  
3a57 fe 5b		        CP      $5B             ; Is it a keyboard code?  
3a59 38 07		        JR      C,L3A62         ; C=yes, so do not decrement counter  
3a5b			  
3a5b 23			        INC     HL  
3a5c 35			        DEC     (HL)            ; Decrement the 10 Call Counter  
3a5d 2b			        DEC     HL  
3a5e 20 02		        JR      NZ,L3A62        ; If the counter reaches zero, then  
3a60			                                ; signal the set is free  
3a60 36 ff		        LD      (HL),$FF  
3a62			  
3a62			;; KP_CH_SET  
3a62 7d			L3A62:  LD      A,L             ; Jump back and test the second set if  
3a63 21 04 5c		        LD      HL,$5C04        ; [KSTATE4] not yet considered  
3a66 bd			        CP      L  
3a67 20 e9		        JR      NZ,L3A52  
3a69			  
3a69 cd ae 3a		        CALL    L3AAE           ; Test for valid key combinations and  
3a6c c0			        RET     NZ              ; return if invalid  
3a6d			  
3a6d 7b			        LD      A,E             ; Test if the key in the first set is being  
3a6e 21 00 5c		        LD      HL,$5C00        ; [KSTATE0] repeated  
3a71 be			        CP      (HL)  
3a72 28 2a		        JR      Z,L3A9E         ; Jump if being repeated  
3a74			  
3a74 eb			        EX      DE,HL           ; Save the address of KSTATE0  
3a75 21 04 5c		        LD      HL,$5C04        ; [KSTATE4] Test if the key in the second set is  
3a78 be			        CP      (HL)            ; being repeated  
3a79 28 23		        JR      Z,L3A9E         ; Jump if being repeated  
3a7b			  
3a7b			; A new key will not be accepted unless one of the KSTATE sets is free.  
3a7b			  
3a7b cb 7e		        BIT     7,(HL)          ; Test if the second set is free  
3a7d 20 04		        JR      NZ,L3A83        ; Jump if set is free  
3a7f			  
3a7f eb			        EX      DE,HL  
3a80 cb 7e		        BIT     7,(HL)          ; Test if the first set is free  
3a82 c8			        RET     Z               ; Return if no set is free  
3a83			  
3a83			;; KP_NEW  
3a83 5f			L3A83:  LD      E,A             ; Pass the key code to the E register  
3a84 77			        LD      (HL),A          ; and to KSTATE0/4  
3a85 23			        INC     HL  
3a86 36 0a		        LD      (HL),$0A        ; Set the '10 Call Counter' to 10  
3a88 23			        INC     HL  
3a89			  
3a89 3a 09 5c		        LD      A,($5C09)       ; [REPDEL] Fetch the initial repeat delay  
3a8c cb 3f		        SRL     A               ; Divide delay by two  
3a8e 77			        LD      (HL),A          ; Store the repeat delay  
3a8f 23			        INC     HL  
3a90			  
3a90 cd d7 3a		        CALL    L3AD7           ; Decode the keypad key code  
3a93 73			        LD      (HL),E          ; and store it in KSTATE3/7  
3a94			  
3a94			; This section is common for both new keys and repeated keys.  
3a94			  
3a94			;; KP_END  
3a94 7b			L3A94:  LD      A,E  
3a95 32 08 5c		        LD      ($5C08),A       ; [LAST_K] Store the key value in LAST_K  
3a98 21 3b 5c		        LD      HL,$5C3B        ; FLAGS  
3a9b cb ee		        SET     5,(HL)          ; Signal a new key pressed  
3a9d c9			        RET  
3a9e			  
3a9e			; -------------------------  
3a9e			; THE KEY REPEAT SUBROUTINE  
3a9e			; -------------------------  
3a9e			  
3a9e			;; KP_REPEAT  
3a9e 23			L3A9E:  INC     HL  
3a9f 36 0a		        LD      (HL),$0A        ; Reset the '10 Call Counter' to 10  
3aa1 23			        INC     HL  
3aa2 35			        DEC     (HL)            ; Decrement the repeat delay  
3aa3 c0			        RET     NZ              ; Return if not zero  
3aa4			  
3aa4 3a 0a 5c		        LD      A,($5C0A)       ; [REPPER] The subsequent repeat delay is  
3aa7 cb 3f		        SRL     A               ; divided by two and stored  
3aa9 77			        LD      (HL),A  
3aaa 23			        INC     HL  
3aab 5e			        LD      E,(HL)          ; The key repeating is fetched  
3aac 18 e6		        JR      L3A94           ; and then returned in LAST_K  
3aae			  
3aae			; ----------------------------------------  
3aae			; THE TEST FOR A VALID KEY CODE SUBROUTINE  
3aae			; ----------------------------------------  
3aae			; The zero flag is returned set if the key code is valid. No key press, SHIFT only or invalid shifted key presses return the zero flag reset.  
3aae			  
3aae			;; KP_TEST  
3aae 7b			L3AAE:  LD      A,E  
3aaf 21 66 5b		        LD      HL,$5B66        ; FLAGS3 Test if in BASIC or EDIT mode  
3ab2 cb 46		        BIT     0,(HL)  
3ab4 28 06		        JR      Z,L3ABC         ; Z=EDIT mode  
3ab6			  
3ab6			; Test key codes when in BASIC/CALCULATOR mode  
3ab6			  
3ab6 fe 6d		        CP      $6D             ; Test for shifted keys  
3ab8 30 1a		        JR      NC,L3AD4        ; and signal an error if found  
3aba			  
3aba			;; KPT_OK  
3aba af			L3ABA:  XOR     A               ; Signal valid key code  
3abb c9			        RET                     ; Exit: Zero flag set  
3abc			  
3abc			; Test key codes when in EDIT/MENU mode.  
3abc			  
3abc			;; KPT_EDIT  
3abc fe 80		L3ABC:  CP      $80             ; Test for no key press  
3abe 30 14		        JR      NC,L3AD4        ; NC=no key press  
3ac0			  
3ac0 fe 6c		        CP      $6C             ; Test for SHIFT on its own  
3ac2 20 f6		        JR      NZ,L3ABA        ; NZ=valid key code  
3ac4			  
3ac4 00 00 00		L3AC4:  DEFB    $00, $00, $00   ; Delay for 64 T-States  
3ac7 00 00 00		        DEFB    $00, $00, $00  
3aca 00 00 00		        DEFB    $00, $00, $00  
3acd 00 00 00		        DEFB    $00, $00, $00  
3ad0 00 00 00		        DEFB    $00, $00, $00  
3ad3 00			        DEFB    $00  
3ad4			  
3ad4			;; KPT_INVALID  
3ad4 af			L3AD4:  XOR     A               ; Signal invalid key code  
3ad5 3c			        INC     A  
3ad6 c9			        RET                     ; Exit: Zero flag reset  
3ad7			  
3ad7			; ---------------------------  
3ad7			; THE KEY DECODING SUBROUTINE  
3ad7			; ---------------------------  
3ad7			  
3ad7			;; KP_DECODE  
3ad7 e5			L3AD7:  PUSH    HL              ; Save the KSTATE pointer  
3ad8 7b			        LD      A,E  
3ad9 d6 5b		        SUB     $5B             ; Reduce the key code range to  
3adb 16 00		        LD      D,$00           ; 00 - 22 and transfer to DE  
3add 5f			        LD      E,A  
3ade			  
3ade 21 66 5b		        LD      HL,$5B66        ; FLAGS3 Test if in EDIT or BASIC mode  
3ae1 cb 46		        BIT     0,(HL)  
3ae3 28 05		        JR      Z,L3AEA         ; Z=EDIT/MENU mode  
3ae5			  
3ae5			; Use Table 1 when in CALCULATOR/BASIC mode.  
3ae5			  
3ae5 21 13 3b		        LD      HL,L3B13  
3ae8 18 25		        JR      L3B0F           ; Look up the key value  
3aea			  
3aea			; Deal with EDIT/MENU mode.  
3aea			  
3aea			;; KPD_EDIT  
3aea 21 25 3b		L3AEA:  LD      HL,L3B25        ; Use Table 4 for unshifted key  
3aed fe 11		        CP      $11             ; presses  
3aef 38 1e		        JR      C,L3B0F  
3af1			  
3af1			; Deal with shifted keys in EDIT/MENU mode.  
3af1			  
3af1			; Use Table 3 with SHIFT 1 (delete to beginning of line), SHIFT 2 (delete to end of line), SHIFT 3 (SHIFT TOGGLE). Note that although SHIFT TOGGLE produces a unique valid code,  
3af1			; it actually performs no function when editing a BASIC program.  
3af1			  
3af1 21 21 3b		        LD      HL,L3B21  
3af4 fe 15		        CP      $15             ; Test for SHIFT 1  
3af6 28 17		        JR      Z,L3B0F  
3af8			  
3af8 fe 16		        CP      $16             ; Test for SHIFT 2  
3afa 28 13		        JR      Z,L3B0F  
3afc			  
3afc 18 03		        JR      L3B01           ; Delay for 12 T-States  
3afe			  
3afe 00 ff ff		L3AFE:  DEFB    $00, $FF, $FF   ; Unused locations  
3b01			  
3b01			;; KPD_CONT  
3b01 fe 17		L3B01:  CP      $17             ; Test for SHIFT 3  
3b03 28 0a		        JR      Z,L3B0F  
3b05			  
3b05			; Use Table 2 with SHIFT 4 (delete to beginning of word) and SHIFT 5 (delete to end of word).  
3b05			  
3b05 21 18 3b		        LD      HL,L3B18  
3b08 fe 21		        CP      $21             ; Test for SHIFT 4 and above  
3b0a 30 03		        JR      NC,L3B0F  
3b0c			  
3b0c			;Use Table 1 for all other shifted key presses.  
3b0c			  
3b0c 21 13 3b		        LD      HL,L3B13  
3b0f			  
3b0f			;; KPD_EXIT  
3b0f 19			L3B0F:  ADD     HL,DE           ; Look up the key value  
3b10 5e			        LD      E,(HL)  
3b11 e1			        POP     HL              ; Retrieve the KSTATE address  
3b12 c9			        RET  
3b13			  
3b13			; --------------------------------  
3b13			; THE KEYPAD DECODE LOOK-UP TABLES  
3b13			; --------------------------------  
3b13			  
3b13			;; KPD_TABLE1  
3b13 2e 0d 33		L3B13:  DEFB    $2E, $0D, $33   ; '.', ENTER, 3  
3b16 32 31		        DEFB    $32, $31        ; 2, 1  
3b18			  
3b18			;; KPD_TABLE2  
3b18 29 28 2a		L3B18:  DEFB    $29, $28, $2A   ; ), (, *  
3b1b 2f 2d 39		        DEFB    $2F, $2D, $39   ; /, - , 9  
3b1e 38 37 2b		        DEFB    $38, $37, $2B   ; 8, 7, +  
3b21			  
3b21			;; KPD_TABLE3  
3b21 36 35 34		L3B21:  DEFB    $36, $35, $34   ; 6, 5, 4  
3b24 30			        DEFB    $30             ; 0  
3b25			  
3b25			;; KPD_TABLE4  
3b25 a5 0d a6		L3B25:  DEFB    $A5, $0D, $A6   ; Bottom, ENTER, Top  
3b28 a7 a8 a9		        DEFB    $A7, $A8, $A9   ; End of line, Start of line, TOGGLE  
3b2b aa 0b 0c		        DEFB    $AA, $0B, $0C   ; DEL right, Up, DEL  
3b2e 07 09 0a		        DEFB    $07, $09, $0A   ; CMND, Right, Down  
3b31 08 ac ad		        DEFB    $08, $AC, $AD   ; Left, Down ten, Up ten  
3b34 ae af		        DEFB    $AE, $AF        ; End word, Beginning of word  
3b36 b0 b1 b2		        DEFB    $B0, $B1, $B2   ; DEL to end of line, DEL to start of line, SHIFT TOGGLE  
3b39 b3 b4		        DEFB    $B3, $B4        ; DEL to end of word, DEL to beginning of word  
3b3b			  
3b3b			; -----------------------------  
3b3b			; PRINT NEW ERROR MESSAGE PATCH  
3b3b			; -----------------------------  
3b3b			  
3b3b fd cb 01 66	L3B3B:  BIT     4,(IY+$01)      ; FLAGS 3 - In 128K mode?  
3b3f 20 05		        JR      NZ,L3B46        ; NZ=128K mode  
3b41			  
3b41			; In 48K mode  
3b41			  
3b41 af			        XOR     A               ; Replicate code from standard ROM that the patch over-wrote  
3b42 11 36 15		        LD      DE,$1536  
3b45 c9			        RET       
3b46			  
3b46			; In 128K mode  
3b46			  
3b46 21 0f 01		L3B46:  LD      HL,$010F        ; Vector table entry in Editor ROM -> JP $03A2  
3b49			  
3b49			; Return to Editor ROM at address in HL  
3b49			  
3b49 e3			L3B49:  EX      (SP),HL         ; Change the return address  
3b4a c3 00 5b		        JP      $5B00           ; Page Editor ROM and return to the address on the stack  
3b4d			  
3b4d			; -------------------------------------  
3b4d			; STATEMENT INTERPRETATION RETURN PATCH  
3b4d			; -------------------------------------  
3b4d			  
3b4d fd cb 01 66	L3B4D:  BIT     4,(IY+$01)      ; In 128K mode?  
3b51 20 05		        JR      NZ,L3B58        ; NZ=128K mode  
3b53			  
3b53			; In 48K mode  
3b53			  
3b53 fd cb 0a 7e	        BIT     7,(IY+$0A)      ; replicate code from standard ROM that the patch over-wrote  
3b57 c9			        RET       
3b58			  
3b58			; In 128K mode  
3b58			  
3b58 21 12 01		L3B58:  LD      HL,$0112        ; Handle in Editor ROM by jumping to Vector table entry in Editor ROM -> JP #182A  
3b5b 18 ec		        JR      L3B49  
3b5d			  
3b5d			; --------------------------  
3b5d			; GO TO NEXT STATEMENT PATCH  
3b5d			; --------------------------  
3b5d			  
3b5d fd cb 01 66	L3B5D:  BIT     4,(IY+$01)      ; In 128K mode?  
3b61 20 04		        JR      NZ,L3B67        ; NZ=128K mode  
3b63			  
3b63			; In 48K mode  
3b63			  
3b63 df			        RST     18H             ; replicate code from standard ROM that the patch over-wrote  
3b64 fe 0d		        CP      $0D  
3b66 c9			        RET       
3b67			  
3b67			; In 128K mode  
3b67			  
3b67 21 15 01		L3B67:  LD      HL,$0115        ; Handle in Editor ROM by jumping to Vector table entry in Editor ROM -> JP #18A8  
3b6a 18 dd		        JR      L3B49  
3b6c			  
3b6c			; --------------------------------------  
3b6c			; INKEY$ ROUTINE TO DEAL WITH THE KEYPAD  
3b6c			; --------------------------------------  
3b6c			  
3b6c			;; KEYSCAN2  
3b6c cd 8e 02		L3B6C:  CALL    L028E           ; KEYSCAN Scan the keyboard  
3b6f 0e 00		        LD      C,$00  
3b71 20 0d		        JR      NZ,L3B80        ; NZ=multiple keys  
3b73			  
3b73 cd 1e 03		        CALL    L031E           ; K_TEST  
3b76 30 08		        JR      NC,L3B80        ; NC=shift only or no key  
3b78			  
3b78 15			        DEC     D  
3b79 5f			        LD      E,A  
3b7a cd 33 03		        CALL    L0333           ; K_DECODE  
3b7d c3 57 26		        JP      L2657           ; S_CONT Get string and continue scanning  
3b80			  
3b80			;; KPI_SCAN  
3b80 fd cb 01 66	L3B80:  BIT     4,(IY+$01)      ; 128K mode?  
3b84 ca 60 26		        JP      Z,L2660         ; S_IK$_STK Z=no, stack keyboard code  
3b87			  
3b87 f3			        DI                      ; Disable interrupts whilst scanning  
3b88 cd a0 39		        CALL    L39A0           ; the keypad  
3b8b fb			        EI  
3b8c 20 0c		        JR      NZ,L3B9A        ; NZ=multiple keys  
3b8e			  
3b8e cd ae 3a		        CALL    L3AAE           ; Test the keypad  
3b91 20 07		        JR      NZ,L3B9A        ; NZ=no key, shift only or invalid combination  
3b93			  
3b93 cd d7 3a		        CALL    L3AD7           ; Form the key code  
3b96 7b			        LD      A,E  
3b97 c3 57 26		        JP      L2657           ; S_CONT Get string and continue scanning  
3b9a			  
3b9a			;; KPI_INVALID  
3b9a 0e 00		L3B9A:  LD      C,$00           ; Signal no key, i.e. length=0  
3b9c c3 60 26		        JP      L2660           ; S_IK$_STK  
3b9f			  
3b9f			; ---------------------  
3b9f			; PRINT TOKEN/UDG PATCH  
3b9f			; ---------------------  
3b9f			  
3b9f fe a3		L3B9F:  CP      $A3             ; SPECTRUM (T)  
3ba1 28 0c		        JR      Z,L3BAF  
3ba3			  
3ba3 fe a4		        CP      $A4             ; PLAY (U)  
3ba5 28 08		        JR      Z,L3BAF  
3ba7			  
3ba7			; In 48K mode here  
3ba7			  
3ba7 d6 a5		L3BA7:  SUB     $A5             ; Check as per original ROM  
3ba9 d2 5f 0b		        JP      NC,$0B5F  
3bac			  
3bac c3 56 0b		        JP      $0B56           ; Rejoin original ROM routine  
3baf			  
3baf fd cb 01 66	L3BAF:  BIT     4,(IY+$01)      ; FLAGS3 - Bit 4=1 if in 128K mode  
3bb3 28 f2		        JR      Z,L3BA7         ; Rejoin code for when in 48K mode  
3bb5			  
3bb5			; In 128K mode here  
3bb5			  
3bb5 11 c9 3b		        LD      DE,L3BC9  
3bb8 d5			        PUSH    DE              ; Stack return address  
3bb9			  
3bb9 d6 a3		        SUB     $A3             ; Check whether the SPECTRUM token  
3bbb			  
3bbb 11 d2 3b		        LD      DE,L3BD2        ; SPECTRUM token  
3bbe 28 03		        JR      Z,L3BC3  
3bc0			  
3bc0 11 da 3b		        LD      DE,L3BDA        ; PLAY token  
3bc3			  
3bc3 3e 04		L3BC3:  LD      A,$04           ; Signal not RND, INKEY$ or PI so that a trailing space is printed  
3bc5 f5			        PUSH    AF  
3bc6 c3 17 0c		        JP      L0C17           ; Rejoin printing routine PO-TABLE+3  
3bc9			  
3bc9			; Return address from above  
3bc9			  
3bc9 37			L3BC9:  SCF                     ; Return as if no trailing space  
3bca			  
3bca fd cb 01 4e	        BIT     1,(IY+$01)      ; Test if printer is in use  
3bce c0			        RET     NZ              ; NZ=printer in use  
3bcf			  
3bcf c3 03 0b		        JP      $0B03           ; PO-FETCH - Return via Position Fetch routine  
3bd2			  
3bd2 ..			L3BD2:  DEFM    "SPECTRU"       ; SPECTRUM token  
3bd9 cd			        DEFB    $80+'M'  
3bda			  
3bda ..			L3BDA:  DEFM    "PLA"           ; PLAY token  
3bdd d9			        DEFB    $80+'Y'  
3bde			  
3bde			;; KP_SCAN2  
3bde c3 01 3c		L3BDE:  JP      L3C01           ; This is not called from either ROM. It can be used to scan the keypad.  
3be1			  
3be1 00 00 00		L3BE1:  DEFB    $00, $00, $00   ; Unused locations  
3be4 00 00 00		        DEFB    $00, $00, $00  
3be7 00 00 00		        DEFB    $00, $00, $00  
3bea 00 00 00		        DEFB    $00, $00, $00  
3bed 00 00 00		        DEFB    $00, $00, $00  
3bf0 00 00 00		        DEFB    $00, $00, $00  
3bf3 00 00 00		        DEFB    $00, $00, $00  
3bf6 00 00 00		        DEFB    $00, $00, $00  
3bf9 00 00 00		        DEFB    $00, $00, $00  
3bfc 00 00 00		        DEFB    $00, $00, $00  
3bff ff ff		        DEFB    $FF, $FF  
3c01			  
3c01			;; KP_SCAN  
3c01 c3 a0 39		L3C01:  JP      L39A0           ; This was to be called via the vector table in the EDITOR ROM but due to a programming error it never gets called.  
3c04			  
3c04			; -----------------------  
3c04			; TV TUNER VECTOR ENTRIES  
3c04			; -----------------------  
3c04			  
3c04 c3 10 3c		L3C04:  JP      L3C10  
3c07 c3 10 3c		L3C07:  JP      L3C10  
3c0a c3 10 3c		L3C0A:  JP      L3C10  
3c0d c3 10 3c		L3C0D:  JP      L3C10  
3c10			  
3c10			; ----------------  
3c10			; TV TUNER ROUTINE  
3c10			; ----------------  
3c10			; This routine generates a display showing all possible colours and emitting a continuous cycle of a 440 Hz tone for 1 second followed by silence for 1 second.  
3c10			; Its purpose is to ease the tuning in of TV sets to the Spectrum 128's RF signal. The display consists of vertical stripes of width four character squares showing each of the eight colours  
3c10			; available at both their normal and bright intensities. The display begins with white on the left progressing up to black on the right. With in each colour stripe in the first eight rows is  
3c10			; shown the year '1986' in varying ink colours. This leads to a display that shows all possible ink colours on all possible paper colours.  
3c10			  
3c10			;; TV_TUNER  
3c10 3e 7f		L3C10:  LD      A,$7F           ; Test for the BREAK key  
3c12 db fe		        IN      A,($FE)  
3c14 1f			        RRA       
3c15 d8			        RET     C               ; C=SPACE not pressed  
3c16			  
3c16 3e fe		        LD      A,$FE  
3c18 db fe		        IN      A,($FE)  
3c1a 1f			        RRA       
3c1b d8			        RET     C               ; C=SPACE not pressed  
3c1c			  
3c1c 3e 07		        LD      A,$07  
3c1e d3 fe		        OUT     ($FE),A         ; Set the border to white  
3c20			  
3c20 3e 02		        LD      A,$02           ; Open channel 2 (main screen)  
3c22 cd 01 16		        CALL    $1601  
3c25			  
3c25 af			        XOR     A  
3c26 32 3c 5c		        LD      ($5C3C),A       ; [TV_FLAG] Signal using main screen  
3c29			  
3c29 3e 16		        LD      A,$16           ; Print character 'AT'  
3c2b d7			        RST     10H  
3c2c			  
3c2c af			        XOR     A               ; Print character '0'  
3c2d d7			        RST     10H  
3c2e			  
3c2e af			        XOR     A               ; Print character '0'  
3c2f d7			        RST     10H  
3c30			  
3c30 1e 08		        LD      E,$08           ; Number of characters per colour  
3c32 43			        LD      B,E             ; Paper counter + 1  
3c33 50			        LD      D,B             ; Ink counter + 1  
3c34			  
3c34			;; TVT_ROW  
3c34 78			L3C34:  LD      A,B             ; Calculate the paper colour  
3c35 3d			        DEC     A               ; Bits 3-5 of each screen attribute  
3c36 cb 17		        RL      A               ; holds the paper colour; bits 0-2  
3c38 cb 17		        RL      A               ; the ink colour  
3c3a cb 17		        RL      A  
3c3c 82			        ADD     A,D             ; Add the ink colour  
3c3d 3d			        DEC     A  
3c3e 32 8f 5c		        LD      ($5C8F),A       ; [ATTR_T] Store as temporary attribute value  
3c41			  
3c41 21 8f 3c		        LD      HL,L3C8F        ; TVT_DATA Point to the 'year' data  
3c44 4b			        LD      C,E             ; Get number of characters to print  
3c45			  
3c45			;; TVT_YEAR  
3c45 7e			L3C45:  LD      A,(HL)          ; Fetch a character from the data  
3c46 d7			        RST     10H             ; Print it  
3c47 23			        INC     HL  
3c48 0d			        DEC     C  
3c49 20 fa		        JR      NZ,L3C45        ; Repeat for the 8 characters  
3c4b			  
3c4b 10 e7		        DJNZ    L3C34           ; Repeat for all colours in this row  
3c4d			  
3c4d 43			        LD      B,E             ; Reset paper colour  
3c4e 15			        DEC     D               ; Next ink colour  
3c4f 20 e3		        JR      NZ,L3C34        ; Produce next row with new ink colour  
3c51			  
3c51 21 00 48		        LD      HL,$4800        ; Point to 2nd third of display file  
3c54 54			        LD      D,H  
3c55 5d			        LD      E,L  
3c56 13			        INC     DE              ; Point to the next display cell  
3c57 af			        XOR     A  
3c58 77			        LD      (HL),A          ; Clear first display cell  
3c59 01 ff 0f		        LD      BC,$0FFF  
3c5c ed b0		        LDIR                    ; Clear lower 2 thirds of display file  
3c5e			  
3c5e eb			        EX      DE,HL           ; HL points to start of attributes file  
3c5f 11 00 59		        LD      DE,$5900        ; Point to 2nd third of attributes file  
3c62 01 00 02		        LD      BC,$0200  
3c65 ed b0		        LDIR                    ; Copy screen attributes  
3c67			  
3c67			; Now that the display has been constructed, produce a continuous cycle of a 440 Hz tone for 1 second followed by a period of silence for 1 second (actually 962ms).  
3c67			  
3c67 f3			        DI                      ; Disable interrupts so that a pure tone can be generated  
3c68			  
3c68			;; TVT_TONE  
3c68 11 70 03		L3C68:  LD      DE,$0370        ; DE=twice the tone frequency in Hz  
3c6b 2e 07		        LD      L,$07           ; Border colour of white  
3c6d			  
3c6d			;; TVT_DURATION  
3c6d 01 99 00		L3C6D:  LD      BC,$0099        ; Delay for 950.4us  
3c70			  
3c70			;; TVT_PERIOD  
3c70 0b			L3C70:  DEC     BC  
3c71 78			        LD      A,B  
3c72 b1			        OR      C  
3c73 20 fb		        JR      NZ,L3C70  
3c75			  
3c75 7d			        LD      A,L  
3c76 ee 10		        XOR     $10              ; Toggle the speaker output whilst  
3c78 6f			        LD      L,A              ; preserving the border colour  
3c79 d3 fe		        OUT     ($FE),A  
3c7b			  
3c7b 1b			        DEC     DE               ; Generate the tone for 1 second  
3c7c 7a			        LD      A,D  
3c7d b3			        OR      E  
3c7e 20 ed		        JR      NZ,L3C6D  
3c80			  
3c80			; At this point the speaker is turned off, so delay for 1 second.  
3c80			  
3c80 01 00 00		        LD      BC,$0000         ; Delay for 480.4us  
3c83			  
3c83			;; TVT_DELAY1  
3c83 0b			L3C83:  DEC     BC  
3c84 78			        LD      A,B  
3c85 b1			        OR      C  
3c86 20 fb		        JR      NZ,L3C83  
3c88			  
3c88			;; TVT_DELAY2  
3c88 0b			L3C88:  DEC     BC               ; Delay for 480.4us  
3c89 78			        LD      A,B  
3c8a b1			        OR      C  
3c8b 20 fb		        JR      NZ,L3C88  
3c8d			  
3c8d 18 d9		        JR      L3C68            ; Repeat the tone cycle  
3c8f			  
3c8f			;; TVT_DATA  
3c8f 13 00		L3C8F:  DEFB    $13, $00         ; Bright, off  
3c91 31 39		        DEFB    $31, $39         ; '1', '9'  
3c93 13 01		        DEFB    $13, $01         ; Bright, on  
3c95 38 36		        DEFB    $38, $36         ; '8', '6'  
3c97			  
3c97			; ------  
3c97			; UNUSED  
3c97			; ------  
3c97			  
3c97 00 00 00		L3C97:  DEFB    $00, $00, $00    ; Unused locations  
3c9a 00 00 00		        DEFB    $00, $00, $00  
3c9d 00 00 00		        DEFB    $00, $00, $00  
3ca0 00 00 00		        DEFB    $00, $00, $00  
3ca3 00 00 00		        DEFB    $00, $00, $00  
3ca6 00 00 00		        DEFB    $00, $00, $00  
3ca9 00 00 00		        DEFB    $00, $00, $00  
3cac 00 00 00		        DEFB    $00, $00, $00  
3caf 00 00 00		        DEFB    $00, $00, $00  
3cb2 00 00 00		        DEFB    $00, $00, $00  
3cb5 00 00 00		        DEFB    $00, $00, $00  
3cb8 00 00 00		        DEFB    $00, $00, $00  
3cbb 00 00 00		        DEFB    $00, $00, $00  
3cbe 00 00 00		        DEFB    $00, $00, $00  
3cc1 00 00 00		        DEFB    $00, $00, $00  
3cc4 00 00 00		        DEFB    $00, $00, $00  
3cc7 00 00 00		        DEFB    $00, $00, $00  
3cca 00 00 00		        DEFB    $00, $00, $00  
3ccd 00 00 00		        DEFB    $00, $00, $00  
3cd0 00 00 00		        DEFB    $00, $00, $00  
3cd3 00 00 00		        DEFB    $00, $00, $00  
3cd6 00 00 00		        DEFB    $00, $00, $00  
3cd9 00 00 00		        DEFB    $00, $00, $00  
3cdc 00 00 00		        DEFB    $00, $00, $00  
3cdf 00 00 00		        DEFB    $00, $00, $00  
3ce2 00 00 00		        DEFB    $00, $00, $00  
3ce5 00 00 00		        DEFB    $00, $00, $00  
3ce8 00 00 00		        DEFB    $00, $00, $00  
3ceb 00 00 00		        DEFB    $00, $00, $00  
3cee 00 00 00		        DEFB    $00, $00, $00  
3cf1 00 00 00		        DEFB    $00, $00, $00  
3cf4 00 00 00		        DEFB    $00, $00, $00  
3cf7 00 00 00		        DEFB    $00, $00, $00  
3cfa 00 00 00		        DEFB    $00, $00, $00  
3cfd 00 00 00		        DEFB    $00, $00, $00  
3d00			  
3d00			        ORG     $3D00  
3d00			  
3d00			; -------------------------------  
3d00			; THE 'ZX SPECTRUM CHARACTER SET'  
3d00			; -------------------------------  
3d00			  
3d00			;; char-set  
3d00			  
3d00			; $20 - Character: ' '          CHR$(32)  
3d00			  
3d00 00			L3D00:  DEFB    %00000000  
3d01 00			        DEFB    %00000000  
3d02 00			        DEFB    %00000000  
3d03 00			        DEFB    %00000000  
3d04 00			        DEFB    %00000000  
3d05 00			        DEFB    %00000000  
3d06 00			        DEFB    %00000000  
3d07 00			        DEFB    %00000000  
3d08			  
3d08			; $21 - Character: '!'          CHR$(33)  
3d08			  
3d08 00			        DEFB    %00000000  
3d09 10			        DEFB    %00010000  
3d0a 10			        DEFB    %00010000  
3d0b 10			        DEFB    %00010000  
3d0c 10			        DEFB    %00010000  
3d0d 00			        DEFB    %00000000  
3d0e 10			        DEFB    %00010000  
3d0f 00			        DEFB    %00000000  
3d10			  
3d10			; $22 - Character: '"'          CHR$(34)  
3d10			  
3d10 00			        DEFB    %00000000  
3d11 24			        DEFB    %00100100  
3d12 24			        DEFB    %00100100  
3d13 00			        DEFB    %00000000  
3d14 00			        DEFB    %00000000  
3d15 00			        DEFB    %00000000  
3d16 00			        DEFB    %00000000  
3d17 00			        DEFB    %00000000  
3d18			  
3d18			; $23 - Character: '#'          CHR$(35)  
3d18			  
3d18 00			        DEFB    %00000000  
3d19 24			        DEFB    %00100100  
3d1a 7e			        DEFB    %01111110  
3d1b 24			        DEFB    %00100100  
3d1c 24			        DEFB    %00100100  
3d1d 7e			        DEFB    %01111110  
3d1e 24			        DEFB    %00100100  
3d1f 00			        DEFB    %00000000  
3d20			  
3d20			; $24 - Character: '$'          CHR$(36)  
3d20			  
3d20 00			        DEFB    %00000000  
3d21 08			        DEFB    %00001000  
3d22 3e			        DEFB    %00111110  
3d23 28			        DEFB    %00101000  
3d24 3e			        DEFB    %00111110  
3d25 0a			        DEFB    %00001010  
3d26 3e			        DEFB    %00111110  
3d27 08			        DEFB    %00001000  
3d28			  
3d28			; $25 - Character: '%'          CHR$(37)  
3d28			  
3d28 00			        DEFB    %00000000  
3d29 62			        DEFB    %01100010  
3d2a 64			        DEFB    %01100100  
3d2b 08			        DEFB    %00001000  
3d2c 10			        DEFB    %00010000  
3d2d 26			        DEFB    %00100110  
3d2e 46			        DEFB    %01000110  
3d2f 00			        DEFB    %00000000  
3d30			  
3d30			; $26 - Character: '&'          CHR$(38)  
3d30			  
3d30 00			        DEFB    %00000000  
3d31 10			        DEFB    %00010000  
3d32 28			        DEFB    %00101000  
3d33 10			        DEFB    %00010000  
3d34 2a			        DEFB    %00101010  
3d35 44			        DEFB    %01000100  
3d36 3a			        DEFB    %00111010  
3d37 00			        DEFB    %00000000  
3d38			  
3d38			; $27 - Character: '''          CHR$(39)  
3d38			  
3d38 00			        DEFB    %00000000  
3d39 08			        DEFB    %00001000  
3d3a 10			        DEFB    %00010000  
3d3b 00			        DEFB    %00000000  
3d3c 00			        DEFB    %00000000  
3d3d 00			        DEFB    %00000000  
3d3e 00			        DEFB    %00000000  
3d3f 00			        DEFB    %00000000  
3d40			  
3d40			; $28 - Character: '('          CHR$(40)  
3d40			  
3d40 00			        DEFB    %00000000  
3d41 04			        DEFB    %00000100  
3d42 08			        DEFB    %00001000  
3d43 08			        DEFB    %00001000  
3d44 08			        DEFB    %00001000  
3d45 08			        DEFB    %00001000  
3d46 04			        DEFB    %00000100  
3d47 00			        DEFB    %00000000  
3d48			  
3d48			; $29 - Character: ')'          CHR$(41)  
3d48			  
3d48 00			        DEFB    %00000000  
3d49 20			        DEFB    %00100000  
3d4a 10			        DEFB    %00010000  
3d4b 10			        DEFB    %00010000  
3d4c 10			        DEFB    %00010000  
3d4d 10			        DEFB    %00010000  
3d4e 20			        DEFB    %00100000  
3d4f 00			        DEFB    %00000000  
3d50			  
3d50			; $2A - Character: '*'          CHR$(42)  
3d50			  
3d50 00			        DEFB    %00000000  
3d51 00			        DEFB    %00000000  
3d52 14			        DEFB    %00010100  
3d53 08			        DEFB    %00001000  
3d54 3e			        DEFB    %00111110  
3d55 08			        DEFB    %00001000  
3d56 14			        DEFB    %00010100  
3d57 00			        DEFB    %00000000  
3d58			  
3d58			; $2B - Character: '+'          CHR$(43)  
3d58			  
3d58 00			        DEFB    %00000000  
3d59 00			        DEFB    %00000000  
3d5a 08			        DEFB    %00001000  
3d5b 08			        DEFB    %00001000  
3d5c 3e			        DEFB    %00111110  
3d5d 08			        DEFB    %00001000  
3d5e 08			        DEFB    %00001000  
3d5f 00			        DEFB    %00000000  
3d60			  
3d60			; $2C - Character: ','          CHR$(44)  
3d60			  
3d60 00			        DEFB    %00000000  
3d61 00			        DEFB    %00000000  
3d62 00			        DEFB    %00000000  
3d63 00			        DEFB    %00000000  
3d64 00			        DEFB    %00000000  
3d65 08			        DEFB    %00001000  
3d66 08			        DEFB    %00001000  
3d67 10			        DEFB    %00010000  
3d68			  
3d68			; $2D - Character: '-'          CHR$(45)  
3d68			  
3d68 00			        DEFB    %00000000  
3d69 00			        DEFB    %00000000  
3d6a 00			        DEFB    %00000000  
3d6b 00			        DEFB    %00000000  
3d6c 3e			        DEFB    %00111110  
3d6d 00			        DEFB    %00000000  
3d6e 00			        DEFB    %00000000  
3d6f 00			        DEFB    %00000000  
3d70			  
3d70			; $2E - Character: '.'          CHR$(46)  
3d70			  
3d70 00			        DEFB    %00000000  
3d71 00			        DEFB    %00000000  
3d72 00			        DEFB    %00000000  
3d73 00			        DEFB    %00000000  
3d74 00			        DEFB    %00000000  
3d75 18			        DEFB    %00011000  
3d76 18			        DEFB    %00011000  
3d77 00			        DEFB    %00000000  
3d78			  
3d78			; $2F - Character: '/'          CHR$(47)  
3d78			  
3d78 00			        DEFB    %00000000  
3d79 00			        DEFB    %00000000  
3d7a 02			        DEFB    %00000010  
3d7b 04			        DEFB    %00000100  
3d7c 08			        DEFB    %00001000  
3d7d 10			        DEFB    %00010000  
3d7e 20			        DEFB    %00100000  
3d7f 00			        DEFB    %00000000  
3d80			  
3d80			; $30 - Character: '0'          CHR$(48)  
3d80			  
3d80 00			        DEFB    %00000000  
3d81 3c			        DEFB    %00111100  
3d82 46			        DEFB    %01000110  
3d83 4a			        DEFB    %01001010  
3d84 52			        DEFB    %01010010  
3d85 62			        DEFB    %01100010  
3d86 3c			        DEFB    %00111100  
3d87 00			        DEFB    %00000000  
3d88			  
3d88			; $31 - Character: '1'          CHR$(49)  
3d88			  
3d88 00			        DEFB    %00000000  
3d89 18			        DEFB    %00011000  
3d8a 28			        DEFB    %00101000  
3d8b 08			        DEFB    %00001000  
3d8c 08			        DEFB    %00001000  
3d8d 08			        DEFB    %00001000  
3d8e 3e			        DEFB    %00111110  
3d8f 00			        DEFB    %00000000  
3d90			  
3d90			; $32 - Character: '2'          CHR$(50)  
3d90			  
3d90 00			        DEFB    %00000000  
3d91 3c			        DEFB    %00111100  
3d92 42			        DEFB    %01000010  
3d93 02			        DEFB    %00000010  
3d94 3c			        DEFB    %00111100  
3d95 40			        DEFB    %01000000  
3d96 7e			        DEFB    %01111110  
3d97 00			        DEFB    %00000000  
3d98			  
3d98			; $33 - Character: '3'          CHR$(51)  
3d98			  
3d98 00			        DEFB    %00000000  
3d99 3c			        DEFB    %00111100  
3d9a 42			        DEFB    %01000010  
3d9b 0c			        DEFB    %00001100  
3d9c 02			        DEFB    %00000010  
3d9d 42			        DEFB    %01000010  
3d9e 3c			        DEFB    %00111100  
3d9f 00			        DEFB    %00000000  
3da0			  
3da0			; $34 - Character: '4'          CHR$(52)  
3da0			  
3da0 00			        DEFB    %00000000  
3da1 08			        DEFB    %00001000  
3da2 18			        DEFB    %00011000  
3da3 28			        DEFB    %00101000  
3da4 48			        DEFB    %01001000  
3da5 7e			        DEFB    %01111110  
3da6 08			        DEFB    %00001000  
3da7 00			        DEFB    %00000000  
3da8			  
3da8			; $35 - Character: '5'          CHR$(53)  
3da8			  
3da8 00			        DEFB    %00000000  
3da9 7e			        DEFB    %01111110  
3daa 40			        DEFB    %01000000  
3dab 7c			        DEFB    %01111100  
3dac 02			        DEFB    %00000010  
3dad 42			        DEFB    %01000010  
3dae 3c			        DEFB    %00111100  
3daf 00			        DEFB    %00000000  
3db0			  
3db0			; $36 - Character: '6'          CHR$(54)  
3db0			  
3db0 00			        DEFB    %00000000  
3db1 3c			        DEFB    %00111100  
3db2 40			        DEFB    %01000000  
3db3 7c			        DEFB    %01111100  
3db4 42			        DEFB    %01000010  
3db5 42			        DEFB    %01000010  
3db6 3c			        DEFB    %00111100  
3db7 00			        DEFB    %00000000  
3db8			  
3db8			; $37 - Character: '7'          CHR$(55)  
3db8			  
3db8 00			        DEFB    %00000000  
3db9 7e			        DEFB    %01111110  
3dba 02			        DEFB    %00000010  
3dbb 04			        DEFB    %00000100  
3dbc 08			        DEFB    %00001000  
3dbd 10			        DEFB    %00010000  
3dbe 10			        DEFB    %00010000  
3dbf 00			        DEFB    %00000000  
3dc0			  
3dc0			; $38 - Character: '8'          CHR$(56)  
3dc0			  
3dc0 00			        DEFB    %00000000  
3dc1 3c			        DEFB    %00111100  
3dc2 42			        DEFB    %01000010  
3dc3 3c			        DEFB    %00111100  
3dc4 42			        DEFB    %01000010  
3dc5 42			        DEFB    %01000010  
3dc6 3c			        DEFB    %00111100  
3dc7 00			        DEFB    %00000000  
3dc8			  
3dc8			; $39 - Character: '9'          CHR$(57)  
3dc8			  
3dc8 00			        DEFB    %00000000  
3dc9 3c			        DEFB    %00111100  
3dca 42			        DEFB    %01000010  
3dcb 42			        DEFB    %01000010  
3dcc 3e			        DEFB    %00111110  
3dcd 02			        DEFB    %00000010  
3dce 3c			        DEFB    %00111100  
3dcf 00			        DEFB    %00000000  
3dd0			  
3dd0			; $3A - Character: ':'          CHR$(58)  
3dd0			  
3dd0 00			        DEFB    %00000000  
3dd1 00			        DEFB    %00000000  
3dd2 00			        DEFB    %00000000  
3dd3 10			        DEFB    %00010000  
3dd4 00			        DEFB    %00000000  
3dd5 00			        DEFB    %00000000  
3dd6 10			        DEFB    %00010000  
3dd7 00			        DEFB    %00000000  
3dd8			  
3dd8			; $3B - Character: ';'          CHR$(59)  
3dd8			  
3dd8 00			        DEFB    %00000000  
3dd9 00			        DEFB    %00000000  
3dda 10			        DEFB    %00010000  
3ddb 00			        DEFB    %00000000  
3ddc 00			        DEFB    %00000000  
3ddd 10			        DEFB    %00010000  
3dde 10			        DEFB    %00010000  
3ddf 20			        DEFB    %00100000  
3de0			  
3de0			; $3C - Character: '<'          CHR$(60)  
3de0			  
3de0 00			        DEFB    %00000000  
3de1 00			        DEFB    %00000000  
3de2 04			        DEFB    %00000100  
3de3 08			        DEFB    %00001000  
3de4 10			        DEFB    %00010000  
3de5 08			        DEFB    %00001000  
3de6 04			        DEFB    %00000100  
3de7 00			        DEFB    %00000000  
3de8			  
3de8			; $3D - Character: '='          CHR$(61)  
3de8			  
3de8 00			        DEFB    %00000000  
3de9 00			        DEFB    %00000000  
3dea 00			        DEFB    %00000000  
3deb 3e			        DEFB    %00111110  
3dec 00			        DEFB    %00000000  
3ded 3e			        DEFB    %00111110  
3dee 00			        DEFB    %00000000  
3def 00			        DEFB    %00000000  
3df0			  
3df0			; $3E - Character: '>'          CHR$(62)  
3df0			  
3df0 00			        DEFB    %00000000  
3df1 00			        DEFB    %00000000  
3df2 10			        DEFB    %00010000  
3df3 08			        DEFB    %00001000  
3df4 04			        DEFB    %00000100  
3df5 08			        DEFB    %00001000  
3df6 10			        DEFB    %00010000  
3df7 00			        DEFB    %00000000  
3df8			  
3df8			; $3F - Character: '?'          CHR$(63)  
3df8			  
3df8 00			        DEFB    %00000000  
3df9 3c			        DEFB    %00111100  
3dfa 42			        DEFB    %01000010  
3dfb 04			        DEFB    %00000100  
3dfc 08			        DEFB    %00001000  
3dfd 00			        DEFB    %00000000  
3dfe 08			        DEFB    %00001000  
3dff 00			        DEFB    %00000000  
3e00			  
3e00			; $40 - Character: '@'          CHR$(64)  
3e00			  
3e00 00			        DEFB    %00000000  
3e01 3c			        DEFB    %00111100  
3e02 4a			        DEFB    %01001010  
3e03 56			        DEFB    %01010110  
3e04 5e			        DEFB    %01011110  
3e05 40			        DEFB    %01000000  
3e06 3c			        DEFB    %00111100  
3e07 00			        DEFB    %00000000  
3e08			  
3e08			; $41 - Character: 'A'          CHR$(65)  
3e08			  
3e08 00			        DEFB    %00000000  
3e09 3c			        DEFB    %00111100  
3e0a 42			        DEFB    %01000010  
3e0b 42			        DEFB    %01000010  
3e0c 7e			        DEFB    %01111110  
3e0d 42			        DEFB    %01000010  
3e0e 42			        DEFB    %01000010  
3e0f 00			        DEFB    %00000000  
3e10			  
3e10			; $42 - Character: 'B'          CHR$(66)  
3e10			  
3e10 00			        DEFB    %00000000  
3e11 7c			        DEFB    %01111100  
3e12 42			        DEFB    %01000010  
3e13 7c			        DEFB    %01111100  
3e14 42			        DEFB    %01000010  
3e15 42			        DEFB    %01000010  
3e16 7c			        DEFB    %01111100  
3e17 00			        DEFB    %00000000  
3e18			  
3e18			; $43 - Character: 'C'          CHR$(67)  
3e18			  
3e18 00			        DEFB    %00000000  
3e19 3c			        DEFB    %00111100  
3e1a 42			        DEFB    %01000010  
3e1b 40			        DEFB    %01000000  
3e1c 40			        DEFB    %01000000  
3e1d 42			        DEFB    %01000010  
3e1e 3c			        DEFB    %00111100  
3e1f 00			        DEFB    %00000000  
3e20			  
3e20			; $44 - Character: 'D'          CHR$(68)  
3e20			  
3e20 00			        DEFB    %00000000  
3e21 78			        DEFB    %01111000  
3e22 44			        DEFB    %01000100  
3e23 42			        DEFB    %01000010  
3e24 42			        DEFB    %01000010  
3e25 44			        DEFB    %01000100  
3e26 78			        DEFB    %01111000  
3e27 00			        DEFB    %00000000  
3e28			  
3e28			; $45 - Character: 'E'          CHR$(69)  
3e28			  
3e28 00			        DEFB    %00000000  
3e29 7e			        DEFB    %01111110  
3e2a 40			        DEFB    %01000000  
3e2b 7c			        DEFB    %01111100  
3e2c 40			        DEFB    %01000000  
3e2d 40			        DEFB    %01000000  
3e2e 7e			        DEFB    %01111110  
3e2f 00			        DEFB    %00000000  
3e30			  
3e30			; $46 - Character: 'F'          CHR$(70)  
3e30			  
3e30 00			        DEFB    %00000000  
3e31 7e			        DEFB    %01111110  
3e32 40			        DEFB    %01000000  
3e33 7c			        DEFB    %01111100  
3e34 40			        DEFB    %01000000  
3e35 40			        DEFB    %01000000  
3e36 40			        DEFB    %01000000  
3e37 00			        DEFB    %00000000  
3e38			  
3e38			; $47 - Character: 'G'          CHR$(71)  
3e38			  
3e38 00			        DEFB    %00000000  
3e39 3c			        DEFB    %00111100  
3e3a 42			        DEFB    %01000010  
3e3b 40			        DEFB    %01000000  
3e3c 4e			        DEFB    %01001110  
3e3d 42			        DEFB    %01000010  
3e3e 3c			        DEFB    %00111100  
3e3f 00			        DEFB    %00000000  
3e40			  
3e40			; $48 - Character: 'H'          CHR$(72)  
3e40			  
3e40 00			        DEFB    %00000000  
3e41 42			        DEFB    %01000010  
3e42 42			        DEFB    %01000010  
3e43 7e			        DEFB    %01111110  
3e44 42			        DEFB    %01000010  
3e45 42			        DEFB    %01000010  
3e46 42			        DEFB    %01000010  
3e47 00			        DEFB    %00000000  
3e48			  
3e48			; $49 - Character: 'I'          CHR$(73)  
3e48			  
3e48 00			        DEFB    %00000000  
3e49 3e			        DEFB    %00111110  
3e4a 08			        DEFB    %00001000  
3e4b 08			        DEFB    %00001000  
3e4c 08			        DEFB    %00001000  
3e4d 08			        DEFB    %00001000  
3e4e 3e			        DEFB    %00111110  
3e4f 00			        DEFB    %00000000  
3e50			  
3e50			; $4A - Character: 'J'          CHR$(74)  
3e50			  
3e50 00			        DEFB    %00000000  
3e51 02			        DEFB    %00000010  
3e52 02			        DEFB    %00000010  
3e53 02			        DEFB    %00000010  
3e54 42			        DEFB    %01000010  
3e55 42			        DEFB    %01000010  
3e56 3c			        DEFB    %00111100  
3e57 00			        DEFB    %00000000  
3e58			  
3e58			; $4B - Character: 'K'          CHR$(75)  
3e58			  
3e58 00			        DEFB    %00000000  
3e59 44			        DEFB    %01000100  
3e5a 48			        DEFB    %01001000  
3e5b 70			        DEFB    %01110000  
3e5c 48			        DEFB    %01001000  
3e5d 44			        DEFB    %01000100  
3e5e 42			        DEFB    %01000010  
3e5f 00			        DEFB    %00000000  
3e60			  
3e60			; $4C - Character: 'L'          CHR$(76)  
3e60			  
3e60 00			        DEFB    %00000000  
3e61 40			        DEFB    %01000000  
3e62 40			        DEFB    %01000000  
3e63 40			        DEFB    %01000000  
3e64 40			        DEFB    %01000000  
3e65 40			        DEFB    %01000000  
3e66 7e			        DEFB    %01111110  
3e67 00			        DEFB    %00000000  
3e68			  
3e68			; $4D - Character: 'M'          CHR$(77)  
3e68			  
3e68 00			        DEFB    %00000000  
3e69 42			        DEFB    %01000010  
3e6a 66			        DEFB    %01100110  
3e6b 5a			        DEFB    %01011010  
3e6c 42			        DEFB    %01000010  
3e6d 42			        DEFB    %01000010  
3e6e 42			        DEFB    %01000010  
3e6f 00			        DEFB    %00000000  
3e70			  
3e70			; $4E - Character: 'N'          CHR$(78)  
3e70			  
3e70 00			        DEFB    %00000000  
3e71 42			        DEFB    %01000010  
3e72 62			        DEFB    %01100010  
3e73 52			        DEFB    %01010010  
3e74 4a			        DEFB    %01001010  
3e75 46			        DEFB    %01000110  
3e76 42			        DEFB    %01000010  
3e77 00			        DEFB    %00000000  
3e78			  
3e78			; $4F - Character: 'O'          CHR$(79)  
3e78			  
3e78 00			        DEFB    %00000000  
3e79 3c			        DEFB    %00111100  
3e7a 42			        DEFB    %01000010  
3e7b 42			        DEFB    %01000010  
3e7c 42			        DEFB    %01000010  
3e7d 42			        DEFB    %01000010  
3e7e 3c			        DEFB    %00111100  
3e7f 00			        DEFB    %00000000  
3e80			  
3e80			; $50 - Character: 'P'          CHR$(80)  
3e80			  
3e80 00			        DEFB    %00000000  
3e81 7c			        DEFB    %01111100  
3e82 42			        DEFB    %01000010  
3e83 42			        DEFB    %01000010  
3e84 7c			        DEFB    %01111100  
3e85 40			        DEFB    %01000000  
3e86 40			        DEFB    %01000000  
3e87 00			        DEFB    %00000000  
3e88			  
3e88			; $51 - Character: 'Q'          CHR$(81)  
3e88			  
3e88 00			        DEFB    %00000000  
3e89 3c			        DEFB    %00111100  
3e8a 42			        DEFB    %01000010  
3e8b 42			        DEFB    %01000010  
3e8c 52			        DEFB    %01010010  
3e8d 4a			        DEFB    %01001010  
3e8e 3c			        DEFB    %00111100  
3e8f 00			        DEFB    %00000000  
3e90			  
3e90			; $52 - Character: 'R'          CHR$(82)  
3e90			  
3e90 00			        DEFB    %00000000  
3e91 7c			        DEFB    %01111100  
3e92 42			        DEFB    %01000010  
3e93 42			        DEFB    %01000010  
3e94 7c			        DEFB    %01111100  
3e95 44			        DEFB    %01000100  
3e96 42			        DEFB    %01000010  
3e97 00			        DEFB    %00000000  
3e98			  
3e98			; $53 - Character: 'S'          CHR$(83)  
3e98			  
3e98 00			        DEFB    %00000000  
3e99 3c			        DEFB    %00111100  
3e9a 40			        DEFB    %01000000  
3e9b 3c			        DEFB    %00111100  
3e9c 02			        DEFB    %00000010  
3e9d 42			        DEFB    %01000010  
3e9e 3c			        DEFB    %00111100  
3e9f 00			        DEFB    %00000000  
3ea0			  
3ea0			; $54 - Character: 'T'          CHR$(84)  
3ea0			  
3ea0 00			        DEFB    %00000000  
3ea1 fe			        DEFB    %11111110  
3ea2 10			        DEFB    %00010000  
3ea3 10			        DEFB    %00010000  
3ea4 10			        DEFB    %00010000  
3ea5 10			        DEFB    %00010000  
3ea6 10			        DEFB    %00010000  
3ea7 00			        DEFB    %00000000  
3ea8			  
3ea8			; $55 - Character: 'U'          CHR$(85)  
3ea8			  
3ea8 00			        DEFB    %00000000  
3ea9 42			        DEFB    %01000010  
3eaa 42			        DEFB    %01000010  
3eab 42			        DEFB    %01000010  
3eac 42			        DEFB    %01000010  
3ead 42			        DEFB    %01000010  
3eae 3c			        DEFB    %00111100  
3eaf 00			        DEFB    %00000000  
3eb0			  
3eb0			; $56 - Character: 'V'          CHR$(86)  
3eb0			  
3eb0 00			        DEFB    %00000000  
3eb1 42			        DEFB    %01000010  
3eb2 42			        DEFB    %01000010  
3eb3 42			        DEFB    %01000010  
3eb4 42			        DEFB    %01000010  
3eb5 24			        DEFB    %00100100  
3eb6 18			        DEFB    %00011000  
3eb7 00			        DEFB    %00000000  
3eb8			  
3eb8			; $57 - Character: 'W'          CHR$(87)  
3eb8			  
3eb8 00			        DEFB    %00000000  
3eb9 42			        DEFB    %01000010  
3eba 42			        DEFB    %01000010  
3ebb 42			        DEFB    %01000010  
3ebc 42			        DEFB    %01000010  
3ebd 5a			        DEFB    %01011010  
3ebe 24			        DEFB    %00100100  
3ebf 00			        DEFB    %00000000  
3ec0			  
3ec0			; $58 - Character: 'X'          CHR$(88)  
3ec0			  
3ec0 00			        DEFB    %00000000  
3ec1 42			        DEFB    %01000010  
3ec2 24			        DEFB    %00100100  
3ec3 18			        DEFB    %00011000  
3ec4 18			        DEFB    %00011000  
3ec5 24			        DEFB    %00100100  
3ec6 42			        DEFB    %01000010  
3ec7 00			        DEFB    %00000000  
3ec8			  
3ec8			; $59 - Character: 'Y'          CHR$(89)  
3ec8			  
3ec8 00			        DEFB    %00000000  
3ec9 82			        DEFB    %10000010  
3eca 44			        DEFB    %01000100  
3ecb 28			        DEFB    %00101000  
3ecc 10			        DEFB    %00010000  
3ecd 10			        DEFB    %00010000  
3ece 10			        DEFB    %00010000  
3ecf 00			        DEFB    %00000000  
3ed0			  
3ed0			; $5A - Character: 'Z'          CHR$(90)  
3ed0			  
3ed0 00			        DEFB    %00000000  
3ed1 7e			        DEFB    %01111110  
3ed2 04			        DEFB    %00000100  
3ed3 08			        DEFB    %00001000  
3ed4 10			        DEFB    %00010000  
3ed5 20			        DEFB    %00100000  
3ed6 7e			        DEFB    %01111110  
3ed7 00			        DEFB    %00000000  
3ed8			  
3ed8			; $5B - Character: '['          CHR$(91)  
3ed8			  
3ed8 00			        DEFB    %00000000  
3ed9 0e			        DEFB    %00001110  
3eda 08			        DEFB    %00001000  
3edb 08			        DEFB    %00001000  
3edc 08			        DEFB    %00001000  
3edd 08			        DEFB    %00001000  
3ede 0e			        DEFB    %00001110  
3edf 00			        DEFB    %00000000  
3ee0			  
3ee0			; $5C - Character: '\'          CHR$(92)  
3ee0			  
3ee0 00			        DEFB    %00000000  
3ee1 00			        DEFB    %00000000  
3ee2 40			        DEFB    %01000000  
3ee3 20			        DEFB    %00100000  
3ee4 10			        DEFB    %00010000  
3ee5 08			        DEFB    %00001000  
3ee6 04			        DEFB    %00000100  
3ee7 00			        DEFB    %00000000  
3ee8			  
3ee8			; $5D - Character: ']'          CHR$(93)  
3ee8			  
3ee8 00			        DEFB    %00000000  
3ee9 70			        DEFB    %01110000  
3eea 10			        DEFB    %00010000  
3eeb 10			        DEFB    %00010000  
3eec 10			        DEFB    %00010000  
3eed 10			        DEFB    %00010000  
3eee 70			        DEFB    %01110000  
3eef 00			        DEFB    %00000000  
3ef0			  
3ef0			; $5E - Character: '^'          CHR$(94)  
3ef0			  
3ef0 00			        DEFB    %00000000  
3ef1 10			        DEFB    %00010000  
3ef2 38			        DEFB    %00111000  
3ef3 54			        DEFB    %01010100  
3ef4 10			        DEFB    %00010000  
3ef5 10			        DEFB    %00010000  
3ef6 10			        DEFB    %00010000  
3ef7 00			        DEFB    %00000000  
3ef8			  
3ef8			; $5F - Character: '_'          CHR$(95)  
3ef8			  
3ef8 00			        DEFB    %00000000  
3ef9 00			        DEFB    %00000000  
3efa 00			        DEFB    %00000000  
3efb 00			        DEFB    %00000000  
3efc 00			        DEFB    %00000000  
3efd 00			        DEFB    %00000000  
3efe 00			        DEFB    %00000000  
3eff ff			        DEFB    %11111111  
3f00			  
3f00			; $60 - Character: 'ukp'        CHR$(96)  
3f00			  
3f00 00			        DEFB    %00000000  
3f01 1c			        DEFB    %00011100  
3f02 22			        DEFB    %00100010  
3f03 78			        DEFB    %01111000  
3f04 20			        DEFB    %00100000  
3f05 20			        DEFB    %00100000  
3f06 7e			        DEFB    %01111110  
3f07 00			        DEFB    %00000000  
3f08			  
3f08			; $61 - Character: 'a'          CHR$(97)  
3f08			  
3f08 00			        DEFB    %00000000  
3f09 00			        DEFB    %00000000  
3f0a 38			        DEFB    %00111000  
3f0b 04			        DEFB    %00000100  
3f0c 3c			        DEFB    %00111100  
3f0d 44			        DEFB    %01000100  
3f0e 3c			        DEFB    %00111100  
3f0f 00			        DEFB    %00000000  
3f10			  
3f10			; $62 - Character: 'b'          CHR$(98)  
3f10			  
3f10 00			        DEFB    %00000000  
3f11 20			        DEFB    %00100000  
3f12 20			        DEFB    %00100000  
3f13 3c			        DEFB    %00111100  
3f14 22			        DEFB    %00100010  
3f15 22			        DEFB    %00100010  
3f16 3c			        DEFB    %00111100  
3f17 00			        DEFB    %00000000  
3f18			  
3f18			; $63 - Character: 'c'          CHR$(99)  
3f18			  
3f18 00			        DEFB    %00000000  
3f19 00			        DEFB    %00000000  
3f1a 1c			        DEFB    %00011100  
3f1b 20			        DEFB    %00100000  
3f1c 20			        DEFB    %00100000  
3f1d 20			        DEFB    %00100000  
3f1e 1c			        DEFB    %00011100  
3f1f 00			        DEFB    %00000000  
3f20			  
3f20			; $64 - Character: 'd'          CHR$(100)  
3f20			  
3f20 00			        DEFB    %00000000  
3f21 04			        DEFB    %00000100  
3f22 04			        DEFB    %00000100  
3f23 3c			        DEFB    %00111100  
3f24 44			        DEFB    %01000100  
3f25 44			        DEFB    %01000100  
3f26 3c			        DEFB    %00111100  
3f27 00			        DEFB    %00000000  
3f28			  
3f28			; $65 - Character: 'e'          CHR$(101)  
3f28			  
3f28 00			        DEFB    %00000000  
3f29 00			        DEFB    %00000000  
3f2a 38			        DEFB    %00111000  
3f2b 44			        DEFB    %01000100  
3f2c 78			        DEFB    %01111000  
3f2d 40			        DEFB    %01000000  
3f2e 3c			        DEFB    %00111100  
3f2f 00			        DEFB    %00000000  
3f30			  
3f30			; $66 - Character: 'f'          CHR$(102)  
3f30			  
3f30 00			        DEFB    %00000000  
3f31 0c			        DEFB    %00001100  
3f32 10			        DEFB    %00010000  
3f33 18			        DEFB    %00011000  
3f34 10			        DEFB    %00010000  
3f35 10			        DEFB    %00010000  
3f36 10			        DEFB    %00010000  
3f37 00			        DEFB    %00000000  
3f38			  
3f38			; $67 - Character: 'g'          CHR$(103)  
3f38			  
3f38 00			        DEFB    %00000000  
3f39 00			        DEFB    %00000000  
3f3a 3c			        DEFB    %00111100  
3f3b 44			        DEFB    %01000100  
3f3c 44			        DEFB    %01000100  
3f3d 3c			        DEFB    %00111100  
3f3e 04			        DEFB    %00000100  
3f3f 38			        DEFB    %00111000  
3f40			  
3f40			; $68 - Character: 'h'          CHR$(104)  
3f40			  
3f40 00			        DEFB    %00000000  
3f41 40			        DEFB    %01000000  
3f42 40			        DEFB    %01000000  
3f43 78			        DEFB    %01111000  
3f44 44			        DEFB    %01000100  
3f45 44			        DEFB    %01000100  
3f46 44			        DEFB    %01000100  
3f47 00			        DEFB    %00000000  
3f48			  
3f48			; $69 - Character: 'i'          CHR$(105)  
3f48			  
3f48 00			        DEFB    %00000000  
3f49 10			        DEFB    %00010000  
3f4a 00			        DEFB    %00000000  
3f4b 30			        DEFB    %00110000  
3f4c 10			        DEFB    %00010000  
3f4d 10			        DEFB    %00010000  
3f4e 38			        DEFB    %00111000  
3f4f 00			        DEFB    %00000000  
3f50			  
3f50			; $6A - Character: 'j'          CHR$(106)  
3f50			  
3f50 00			        DEFB    %00000000  
3f51 04			        DEFB    %00000100  
3f52 00			        DEFB    %00000000  
3f53 04			        DEFB    %00000100  
3f54 04			        DEFB    %00000100  
3f55 04			        DEFB    %00000100  
3f56 24			        DEFB    %00100100  
3f57 18			        DEFB    %00011000  
3f58			  
3f58			; $6B - Character: 'k'          CHR$(107)  
3f58			  
3f58 00			        DEFB    %00000000  
3f59 20			        DEFB    %00100000  
3f5a 28			        DEFB    %00101000  
3f5b 30			        DEFB    %00110000  
3f5c 30			        DEFB    %00110000  
3f5d 28			        DEFB    %00101000  
3f5e 24			        DEFB    %00100100  
3f5f 00			        DEFB    %00000000  
3f60			  
3f60			; $6C - Character: 'l'          CHR$(108)  
3f60			  
3f60 00			        DEFB    %00000000  
3f61 10			        DEFB    %00010000  
3f62 10			        DEFB    %00010000  
3f63 10			        DEFB    %00010000  
3f64 10			        DEFB    %00010000  
3f65 10			        DEFB    %00010000  
3f66 0c			        DEFB    %00001100  
3f67 00			        DEFB    %00000000  
3f68			  
3f68			; $6D - Character: 'm'          CHR$(109)  
3f68			  
3f68 00			        DEFB    %00000000  
3f69 00			        DEFB    %00000000  
3f6a 68			        DEFB    %01101000  
3f6b 54			        DEFB    %01010100  
3f6c 54			        DEFB    %01010100  
3f6d 54			        DEFB    %01010100  
3f6e 54			        DEFB    %01010100  
3f6f 00			        DEFB    %00000000  
3f70			  
3f70			; $6E - Character: 'n'          CHR$(110)  
3f70			  
3f70 00			        DEFB    %00000000  
3f71 00			        DEFB    %00000000  
3f72 78			        DEFB    %01111000  
3f73 44			        DEFB    %01000100  
3f74 44			        DEFB    %01000100  
3f75 44			        DEFB    %01000100  
3f76 44			        DEFB    %01000100  
3f77 00			        DEFB    %00000000  
3f78			  
3f78			; $6F - Character: 'o'          CHR$(111)  
3f78			  
3f78 00			        DEFB    %00000000  
3f79 00			        DEFB    %00000000  
3f7a 38			        DEFB    %00111000  
3f7b 44			        DEFB    %01000100  
3f7c 44			        DEFB    %01000100  
3f7d 44			        DEFB    %01000100  
3f7e 38			        DEFB    %00111000  
3f7f 00			        DEFB    %00000000  
3f80			  
3f80			; $70 - Character: 'p'          CHR$(112)  
3f80			  
3f80 00			        DEFB    %00000000  
3f81 00			        DEFB    %00000000  
3f82 78			        DEFB    %01111000  
3f83 44			        DEFB    %01000100  
3f84 44			        DEFB    %01000100  
3f85 78			        DEFB    %01111000  
3f86 40			        DEFB    %01000000  
3f87 40			        DEFB    %01000000  
3f88			  
3f88			; $71 - Character: 'q'          CHR$(113)  
3f88			  
3f88 00			        DEFB    %00000000  
3f89 00			        DEFB    %00000000  
3f8a 3c			        DEFB    %00111100  
3f8b 44			        DEFB    %01000100  
3f8c 44			        DEFB    %01000100  
3f8d 3c			        DEFB    %00111100  
3f8e 04			        DEFB    %00000100  
3f8f 06			        DEFB    %00000110  
3f90			  
3f90			; $72 - Character: 'r'          CHR$(114)  
3f90			  
3f90 00			        DEFB    %00000000  
3f91 00			        DEFB    %00000000  
3f92 1c			        DEFB    %00011100  
3f93 20			        DEFB    %00100000  
3f94 20			        DEFB    %00100000  
3f95 20			        DEFB    %00100000  
3f96 20			        DEFB    %00100000  
3f97 00			        DEFB    %00000000  
3f98			  
3f98			; $73 - Character: 's'          CHR$(115)  
3f98			  
3f98 00			        DEFB    %00000000  
3f99 00			        DEFB    %00000000  
3f9a 38			        DEFB    %00111000  
3f9b 40			        DEFB    %01000000  
3f9c 38			        DEFB    %00111000  
3f9d 04			        DEFB    %00000100  
3f9e 78			        DEFB    %01111000  
3f9f 00			        DEFB    %00000000  
3fa0			  
3fa0			; $74 - Character: 't'          CHR$(116)  
3fa0			  
3fa0 00			        DEFB    %00000000  
3fa1 10			        DEFB    %00010000  
3fa2 38			        DEFB    %00111000  
3fa3 10			        DEFB    %00010000  
3fa4 10			        DEFB    %00010000  
3fa5 10			        DEFB    %00010000  
3fa6 0c			        DEFB    %00001100  
3fa7 00			        DEFB    %00000000  
3fa8			  
3fa8			; $75 - Character: 'u'          CHR$(117)  
3fa8			  
3fa8 00			        DEFB    %00000000  
3fa9 00			        DEFB    %00000000  
3faa 44			        DEFB    %01000100  
3fab 44			        DEFB    %01000100  
3fac 44			        DEFB    %01000100  
3fad 44			        DEFB    %01000100  
3fae 38			        DEFB    %00111000  
3faf 00			        DEFB    %00000000  
3fb0			  
3fb0			; $76 - Character: 'v'          CHR$(118)  
3fb0			  
3fb0 00			        DEFB    %00000000  
3fb1 00			        DEFB    %00000000  
3fb2 44			        DEFB    %01000100  
3fb3 44			        DEFB    %01000100  
3fb4 28			        DEFB    %00101000  
3fb5 28			        DEFB    %00101000  
3fb6 10			        DEFB    %00010000  
3fb7 00			        DEFB    %00000000  
3fb8			  
3fb8			; $77 - Character: 'w'          CHR$(119)  
3fb8			  
3fb8 00			        DEFB    %00000000  
3fb9 00			        DEFB    %00000000  
3fba 44			        DEFB    %01000100  
3fbb 54			        DEFB    %01010100  
3fbc 54			        DEFB    %01010100  
3fbd 54			        DEFB    %01010100  
3fbe 28			        DEFB    %00101000  
3fbf 00			        DEFB    %00000000  
3fc0			  
3fc0			; $78 - Character: 'x'          CHR$(120)  
3fc0			  
3fc0 00			        DEFB    %00000000  
3fc1 00			        DEFB    %00000000  
3fc2 44			        DEFB    %01000100  
3fc3 28			        DEFB    %00101000  
3fc4 10			        DEFB    %00010000  
3fc5 28			        DEFB    %00101000  
3fc6 44			        DEFB    %01000100  
3fc7 00			        DEFB    %00000000  
3fc8			  
3fc8			; $79 - Character: 'y'          CHR$(121)  
3fc8			  
3fc8 00			        DEFB    %00000000  
3fc9 00			        DEFB    %00000000  
3fca 44			        DEFB    %01000100  
3fcb 44			        DEFB    %01000100  
3fcc 44			        DEFB    %01000100  
3fcd 3c			        DEFB    %00111100  
3fce 04			        DEFB    %00000100  
3fcf 38			        DEFB    %00111000  
3fd0			  
3fd0			; $7A - Character: 'z'          CHR$(122)  
3fd0			  
3fd0 00			        DEFB    %00000000  
3fd1 00			        DEFB    %00000000  
3fd2 7c			        DEFB    %01111100  
3fd3 08			        DEFB    %00001000  
3fd4 10			        DEFB    %00010000  
3fd5 20			        DEFB    %00100000  
3fd6 7c			        DEFB    %01111100  
3fd7 00			        DEFB    %00000000  
3fd8			  
3fd8			; $7B - Character: '{'          CHR$(123)  
3fd8			  
3fd8 00			        DEFB    %00000000  
3fd9 0e			        DEFB    %00001110  
3fda 08			        DEFB    %00001000  
3fdb 30			        DEFB    %00110000  
3fdc 08			        DEFB    %00001000  
3fdd 08			        DEFB    %00001000  
3fde 0e			        DEFB    %00001110  
3fdf 00			        DEFB    %00000000  
3fe0			  
3fe0			; $7C - Character: '|'          CHR$(124)  
3fe0			  
3fe0 00			        DEFB    %00000000  
3fe1 08			        DEFB    %00001000  
3fe2 08			        DEFB    %00001000  
3fe3 08			        DEFB    %00001000  
3fe4 08			        DEFB    %00001000  
3fe5 08			        DEFB    %00001000  
3fe6 08			        DEFB    %00001000  
3fe7 00			        DEFB    %00000000  
3fe8			  
3fe8			; $7D - Character: '}'          CHR$(125)  
3fe8			  
3fe8 00			        DEFB    %00000000  
3fe9 70			        DEFB    %01110000  
3fea 10			        DEFB    %00010000  
3feb 0c			        DEFB    %00001100  
3fec 10			        DEFB    %00010000  
3fed 10			        DEFB    %00010000  
3fee 70			        DEFB    %01110000  
3fef 00			        DEFB    %00000000  
3ff0			  
3ff0			; $7E - Character: '~'          CHR$(126)  
3ff0			  
3ff0 00			        DEFB    %00000000  
3ff1 14			        DEFB    %00010100  
3ff2 28			        DEFB    %00101000  
3ff3 00			        DEFB    %00000000  
3ff4 00			        DEFB    %00000000  
3ff5 00			        DEFB    %00000000  
3ff6 00			        DEFB    %00000000  
3ff7 00			        DEFB    %00000000  
3ff8			  
3ff8			; $7F - Character: '(c)'        CHR$(127)  
3ff8			  
3ff8 3c			        DEFB    %00111100  
3ff9 42			        DEFB    %01000010  
3ffa 99			        DEFB    %10011001  
3ffb a1			        DEFB    %10100001  
3ffc a1			        DEFB    %10100001  
3ffd 99			        DEFB    %10011001  
3ffe 42			        DEFB    %01000010  
3fff 3c			        DEFB    %00111100  
4000			  
4000				END  
			

			

# End of file rom128_1.asm
4000
