# File rom128_0.asm
0000			; **************************************
0000			; *** SPECTRUM 128 ROM 0 DISASSEMBLY ***
0000			; **************************************
0000
0000			; The Spectrum ROMs are copyright Amstrad, who have kindly given permission
0000			; to reverse engineer and publish Spectrum ROM disassemblies.
0000
0000
0000			; =====
0000			; NOTES
0000			; =====
0000
0000			; ------------
0000			; Release Date
0000			; ------------
0000			; 4th August 2017
0000
0000			; ------------------------
0000			; Disassembly Contributors
0000			; ------------------------
0000			; Matthew Wilson  (www.matthew-wilson.net/spectrum/rom/)
0000			; Andrew Owen     (cheveron-AT-gmail.com)
0000			; Geoff Wearmouth (gwearmouth-AT-hotmail.com)
0000			; Rui Tunes
0000			; Paul Farrow     (www.fruitcake.plus.com)
0000
0000			; -------
0000			; Markers
0000			; -------
0000			; The following markers appear throughout the disassembly:
0000			;
0000			; [...] = Indicates a comment about the code.
0000			; ????  = Information to be determined.
0000			;
0000			; For bugs, the following marker format is used:
0000			;
0000			; [*BUG* - xxxx. Credit: yyyy]  = Indicates a confirmed bug, with a description 'xxxx' of it and the discoverer 'yyyy'.
0000			; [*BUG*? - xxxx. Credit: yyyy] = Indicates a suspected bug, with a description 'xxxx' of it and the discoverer 'yyyy'.
0000			;
0000			; Since many of the Spectrum 128 ROM routines were re-used in the Spectrum +2 and +3, where a bug was originally identified
0000			; in the Spectrum +2 or +3 the discoverer is acknowledged along with who located the corresponding bug in the Spectrum 128.
0000			;
0000			; For every bug identified, an example fix is provided and the author acknowledged. Some of these fixes can be made directly within the routines
0000			; affected since they do not increase the length of those routines. Others require the insertion of extra instructions and hence these cannot be
0000			; completely fitted within the routines affected. Instead a jump must be made to a patch routine located within a spare area of the ROM.
0000			; Fortunately there is 0.5K of unused routines located at $2336-$2536 (ROM 0) which are remnants of the original Spanish 128, and another unused routine
0000			; located at $3FC3-$3FCE (ROM 0). This is sufficient space to implement all of the bug fixes suggested.
0000
0000
0000			; =================
0000			; ASSEMBLER DEFINES
0000			; =================
0000
0000			;TASM directives:
0000
0000			;#DEFINE DEFB .BYTE
0000			;#DEFINE DEFW .WORD
0000			;#DEFINE DEFM .TEXT
0000			;#DEFINE DEFS .FILL
0000			;#DEFINE END  .END
0000			;#DEFINE EQU  .EQU
0000			;#DEFINE ORG  .ORG
0000
0000
0000			; ==============================
0000			; REFERENCE INFORMATION - PART 1
0000			; ==============================
0000
0000			; ==========================
0000			; 128 BASIC Mode Limitations
0000			; ==========================
0000			; There are a number of limitations when using 128 BASIC mode, some of which are not present when using the equivalent 48 BASIC mode operations.
0000			; These are more design decisions than bugs.
0000			;
0000			; - The RAM disk VERIFY command does not verify but simply performs a LOAD.
0000			; - The renumber facility will not renumber line numbers that are defined as an expression, e.g. GO TO VAL "10".
0000			; - The printer output routine cannot handle binary data and hence EPSON printer ESC codes cannot be sent.
0000			; - The Editor has the following limitations:
0000			;   - Variables cannot have the same name as a keyword. This only applies when entering a program and not when one is loaded in.
0000			;   - Line number 0 is not supported and will not list properly. It is not possible to directly insert such a line, not even in 48 BASIC mode,
0000			;     and so line number 0 is not officially supported.
0000			;   - There is a practical limitation on the size of lines that can be entered. It is limited to 20 indented rows, which is the size of the editing buffers.
0000			;     Typed lines greater than 20 rows get inserted into the BASIC program, but only the first 20 rows are shown on screen. Editing such a line causes
0000			;     it to be truncated to 20 rows. There is no warning when the 20 row limit is exceeded.
0000			;   - It is not possible to directly enter embedded control codes, or to correctly edit loaded in programs that contain them. Loaded programs that
0000			;     contain them will run correctly so long as the lines are not edited.
0000			;   - It is not possible to embed the string of characters ">=", "<=" or "<>" into a string or REM statement without them being tokenized
0000			;     (this is perhaps more an oversight than a design decision).
0000			;   - In 48 BASIC mode if the line '10 REM abc: PRINT xyz' is typed then the word PRINT is stored as a new keyword since the colon (arguably incorrectly)
0000			;     reverts to 'K' mode. In 128 BASIC mode, typing the same line stores each letter as a separate character.
0000
0000
0000			; ==================
0000			; Timing Information
0000			; ==================
0000			; Clock Speed   = 3.54690 MHz (48K Spectrum clock speed was 3.50000 MHz)
0000			; Scan line     = 228 T-states (48K Spectrum was 224 T-states).
0000			; TV scan lines = 311 total, 63 above picture (48K Spectrum had 312 total, 64 above picture).
0000
0000
0000			; ===========
0000			; I/O Details
0000			; ===========
0000
0000			; -------------
0000			; Memory Paging
0000			; -------------
0000			; Memory paging is controlled by I/O port:
0000			; $7FFD (Out) - Bits 0-2: RAM bank (0-7) to page into memory map at $C000.
0000			;               Bit 3   : 0=SCREEN 0 (normal display file in bank 5), 1=SCREEN 1 (shadow display file in bank 7).
0000			;               Bit 4   : 0=ROM 0 (128K Editor), 1=ROM 1 (48K BASIC).
0000			;               Bit 5   : 1=Disable further output to this port until a hard reset occurs.
0000			;               Bit 6-7 : Not used (always write 0).
0000			;
0000			; The Editor ROM (ROM 0) always places a copy of the last value written to port $7FFD
0000			; into new system variable BANK_M ($5B5C).
0000			;
0000			; ----------
0000			; Memory Map
0000			; ----------
0000			; ROM 0 or 1 resides at $0000-$3FFF.
0000			; RAM bank 5 resides at $4000-$7FFF always.
0000			; RAM bank 2 resides at $8000-$BFFF always.
0000			; Any RAM bank may reside at $C000-$FFFF.
0000			;
0000			; -------------------
0000			; Shadow Display File
0000			; -------------------
0000			; The shadow screen may be active even when not paged into the memory map.
0000			;
0000			; ----------------
0000			; Contended Memory
0000			; ----------------
0000			; Physical RAM banks 1, 3, 5 and 7 are contended with the ULA.
0000			;
0000			; -----------------
0000			; Logical RAM Banks
0000			; -----------------
0000			; Throughout ROM 0, memory banks are accessed using a logical numbering scheme, which
0000			; maps to physical RAM banks as follows:
0000			;
0000			; Logical Bank   Physical Bank
0000			; ------------   -------------
0000			;     $00             $01
0000			;     $01             $03
0000			;     $02             $04
0000			;     $03             $06
0000			;     $04             $07
0000			;     $05             $00
0000			;
0000			; This scheme makes the RAM disk code simpler than having to deal directly with physical RAM bank numbers.
0000
0000			; -------------------------
0000			; AY-3-8912 Sound Generator
0000			; -------------------------
0000			; The AY-3-8912 sound generator is controlled by two I/O ports:
0000			; $FFFD (Out)    - Select a register 0-14.
0000			; $FFFD (In)     - Read from the selected register.
0000			; $BFFD (In/Out) - Write to the selected register. The status of the register can also be read back.
0000			;
0000			; The AY-3-8912 I/O port A is used to drive the RS232 and Keypad sockets.
0000			;
0000			; Register       Function                        Range
0000			; --------       --------                        -----
0000			; 0              Channel A fine pitch            8-bit (0-255)
0000			; 1              Channel A course pitch          4-bit (0-15)
0000			; 2              Channel B fine pitch            8-bit (0-255)
0000			; 3              Channel B course pitch          4-bit (0-15)
0000			; 4              Channel C fine pitch            8-bit (0-255)
0000			; 5              Channel C course pitch          4-bit (0-15)
0000			; 6              Noise pitch                     5-bit (0-31)
0000			; 7              Mixer                           8-bit (see end of file for description)
0000			; 8              Channel A volume                4-bit (0-15, see end of file for description)
0000			; 9              Channel B volume                4-bit (0-15, see end of file for description)
0000			; 10             Channel C volume                4-bit (0-15, see end of file for description)
0000			; 11             Envelope fine duration          8-bit (0-255)
0000			; 12             Envelope course duration        8-bit (0-255)
0000			; 13             Envelope shape                  4-bit (0-15)
0000			; 14             I/O port A                      8-bit (0-255)
0000			;
0000			; See the end of this document for description on the sound generator registers.
0000			;
0000			; ----------------------------------
0000			; I/O Port A (AY-3-8912 Register 14)
0000			; ----------------------------------
0000			; This controls the RS232 and Keypad sockets.
0000			; Select the port via a write to port $FFFD with 14, then read via port $FFFD and write via port $BFFD. The state of port $BFFD can also be read back.
0000			;
0000			; Bit 0: KEYPAD CTS (out) - 0=Spectrum ready to receive, 1=Busy
0000			; Bit 1: KEYPAD RXD (out) - 0=Transmit high bit,         1=Transmit low bit
0000			; Bit 2: RS232  CTS (out) - 0=Spectrum ready to receive, 1=Busy
0000			; Bit 3: RS232  RXD (out) - 0=Transmit high bit,         1=Transmit low bit
0000			; Bit 4: KEYPAD DTR (in)  - 0=Keypad ready for data,     1=Busy
0000			; Bit 5: KEYPAD TXD (in)  - 0=Receive high bit,          1=Receive low bit
0000			; Bit 6: RS232  DTR (in)  - 0=Device ready for data,     1=Busy
0000			; Bit 7: RS232  TXD (in)  - 0=Receive high bit,          1=Receive low bit
0000			;
0000			; See the end of this document for the pinouts for the RS232 and KEYPAD sockets.
0000
0000			; ------------------
0000			; Standard I/O Ports
0000			; ------------------
0000			; See the end of this document for descriptions of the standard Spectrum I/O ports.
0000
0000
0000			; ==================
0000			; Error Report Codes
0000			; ==================
0000
0000			; ---------------------------
0000			; Standard Error Report Codes
0000			; ---------------------------
0000			; See the end of this document for descriptions of the standard error report codes.
0000
0000			; ----------------------
0000			; New Error Report Codes
0000			; ----------------------
0000			; a - MERGE error                      MERGE! would not execute for some reason - either size or file type wrong.
0000			; b - Wrong file type                  A file of an inappropriate type was specified during RAM disk operation, for instance a CODE file in LOAD!"name".
0000			; c - CODE error                       The size of the file would lead to an overrun of the top of memory.
0000			; d - Too many brackets                Too many brackets around a repeated phrase in one of the arguments.
0000			; e - File already exists              The file name specified has already been used.
0000			; f - Invalid name                     The file name specified is empty or above 10 characters in length.
0000			; g - File does not exist              [Never used by the ROM].
0000			; h - File does not exist              The specified file could not be found.
0000			; i - Invalid device                   The device name following the FORMAT command does not exist or correspond to a physical device.
0000			; j - Invalid baud rate                The baud rate for the RS232 was set to 0.
0000			; k - Invalid note name                PLAY came across a note or command it didn't recognise, or a command which was in lower case.
0000			; l - Number too big                   A parameter for a command is an order of magnitude too big.
0000			; m - Note out of range                A series of sharps or flats has taken a note beyond the range of the sound chip.
0000			; n - Out of range                     A parameter for a command is too big or too small. If the error is very large, error L results.
0000			; o - Too many tied notes              An attempt was made to tie too many notes together.
0000			; p - (c) 1986 Sinclair Research Ltd   This error is given when too many PLAY channel strings are specified. Up to 8 PLAY channel strings are supported
0000			;                                      by MIDI devices such as synthesisers, drum machines or sequencers. Note that a PLAY command with more than 8 strings
0000			;                                      cannot be entered directly from the Editor. The Spanish 128 produces "p Bad parameter" for this error. It could be
0000			;                                      that the intention was to save memory by using the existing error message of "Q Parameter error" but the change of report
0000			;                                      code byte was overlooked.
0000
0000
0000			; ================
0000			; System Variables
0000			; ================
0000
0000			; --------------------
0000			; New System Variables
0000			; --------------------
0000			; These are held in the old ZX Printer buffer at $5B00-$5BFF.
0000			; Note that some of these names conflict with the system variables used by the ZX Interface 1.
0000
0000	SWAP:        EQU $5B00  ; 20   Swap paging subroutine.
0000	YOUNGER:     EQU $5B14  ;  9   Return paging subroutine.
0000	ONERR:       EQU $5B1D  ; 18   Error handler paging subroutine.
0000	PIN:         EQU $5B2F  ;  5   RS232 input pre-routine.
0000	POUT:        EQU $5B34  ; 22   RS232 token output pre-routine. This can be patched to bypass the control code filter.
0000	POUT2:       EQU $5B4A  ; 14   RS232 character output pre-routine.
0000	TARGET:      EQU $5B58  ;  2   Address of subroutine to call in ROM 1.
0000	RETADDR:     EQU $5B5A  ;  2   Return address in ROM 0.
0000			BANK_M:      EQU $5B5C  ;  1   Copy of last byte output to I/O port $7FFD.
0000	RAMRST:      EQU $5B5D  ;  1   Stores instruction RST $08 and used to produce a standard ROM error.
0000	RAMERR:      EQU $5B5E  ;  1   Error number for use by RST $08 held in RAMRST.
0000	BAUD:        EQU $5B5F  ;  2   Baud rate timing constant for RS232 socket. Default value of 11. [Name clash with ZX Interface 1 system variable at $5CC3]
0000	SERFL:       EQU $5B61  ;  2   Second character received flag:
0000			;        Bit 0   : 1=Character in buffer.
0000			;        Bits 1-7: Not used (always hold 0).
0000			; $5B62  ;      Received Character.
0000	COL:         EQU $5B63  ;  1   Current column from 1 to WIDTH.
0000	WIDTH:       EQU $5B64  ;  1   Paper column width. Default value of 80. [Name clash with ZX Interface 1 Edition 2 system variable at $5CB1]
0000	TVPARS:      EQU $5B65  ;  1   Number of inline parameters expected by RS232 (e.g. 2 for AT).
0000	FLAGS3:      EQU $5B66  ;  1   Flags: [Name clashes with the ZX Interface 1 system variable at $5CB6]
0000			;        Bit 0: 1=BASIC/Calculator mode, 0=Editor/Menu mode.
0000			;        Bit 1: 1=Auto-run loaded BASIC program. [Set but never tested by the ROM]
0000			;        Bit 2: 1=Editing RAM disk catalogue.
0000			;        Bit 3: 1=Using RAM disk commands, 0=Using cassette commands.
0000			;        Bit 4: 1=Indicate LOAD.
0000			;        Bit 5: 1=Indicate SAVE.
0000			;        Bit 6; 1=Indicate MERGE.
0000			;        Bit 7: 1=Indicate VERIFY.
0000			N_STR1:      EQU $5B67  ; 10   Used by RAM disk to store a filename. [Name clash with ZX Interface 1 system variable at $5CDA]
0000			;      Used by the renumber routine to store the address of the BASIC line being examined.
0000			HD_00:       EQU $5B71  ;  1   Used by RAM disk to store file header information (see RAM disk Catalogue section below for details). [Name clash with ZX Interface 1 system variable at $5CE6]
0000			;      Used as column pixel counter in COPY routine.
0000			;      Used by FORMAT command to store specified baud rate.
0000			;      Used by renumber routine to store the number of digits in a pre-renumbered line number reference. [Name clash with ZX Interface 1 system variable at $5CE7]
0000			HD_0B:       EQU $5B72  ;  2   Used by RAM disk to store header info - length of block.
0000			;      Used as half row counter in COPY routine.
0000			;      Used by renumber routine to generate ASCII representation of a new line number.
0000			HD_0D:       EQU $5B74  ;  2   Used by RAM disk to store file header information (see RAM disk Catalogue section below for details). [Name clash with ZX Interface 1 system variable at $5CE9]
0000			HD_0F:       EQU $5B76  ;  2   Used by RAM disk to store file header information (see RAM disk Catalogue section below for details). [Name clash with ZX Interface 1 system variable at $5CEB]
0000			;      Used by renumber routine to store the address of a referenced BASIC line.
0000			HD_11:       EQU $5B78  ;  2   Used by RAM disk to store file header information (see RAM disk Catalogue section below for details). [Name clash with ZX Interface 1 system variable at $5CED]
0000			;      Used by renumber routine to store existing VARS address/current address within a line.
0000			SC_00:       EQU $5B7A  ;  1   Used by RAM disk to store alternate file header information (see RAM disk Catalogue section below for details).
0000			SC_0B:       EQU $5B7B  ;  2   Used by RAM disk to store alternate file header information (see RAM disk Catalogue section below for details).
0000			SC_0D:       EQU $5B7D  ;  2   Used by RAM disk to store alternate file header information (see RAM disk Catalogue section below for details).
0000			SC_0F:       EQU $5B7F  ;  2   Used by RAM disk to store alternate file header information (see RAM disk Catalogue section below for details).
0000	OLDSP:       EQU $5B81  ;  2   Stores old stack pointer when TSTACK in use.
0000	SFNEXT:      EQU $5B83  ;  2   End of RAM disk catalogue marker. Pointer to first empty catalogue entry.
0000	SFSPACE:     EQU $5B85  ;  3   Number of bytes free in RAM disk (3 bytes, 17 bit, LSB first).
0000	ROW01:       EQU $5B88  ;  1   Stores keypad data for row 3, and flags:
0000			;        Bit 0   : 1=Key '+' pressed.
0000			;        Bit 1   : 1=Key '6' pressed.
0000			;        Bit 2   : 1=Key '5' pressed.
0000			;        Bit 3   : 1=Key '4' pressed.
0000			;        Bits 4-5: Always 0.
0000			;        Bit 6   : 1=Indicates successful communications to the keypad.
0000			;        Bit 7   : 1=If communications to the keypad established.
0000	ROW23:       EQU $5B89  ;  1   Stores keypad key press data for rows 1 and 2:
0000			;        Bit 0: 1=Key ')' pressed.
0000			;        Bit 1: 1=Key '(' pressed.
0000			;        Bit 2: 1=Key '*' pressed.
0000			;        Bit 3: 1=Key '/' pressed.
0000			;        Bit 4: 1=Key '-' pressed.
0000			;        Bit 5: 1=Key '9' pressed.
0000			;        Bit 6: 1=Key '8' pressed.
0000			;        Bit 7: 1=Key '7' pressed.
0000	ROW45:       EQU $5B8A  ;  1   Stores keypad key press data for rows 4 and 5:
0000			;        Bit 0: Always 0.
0000			;        Bit 1: 1=Key '.' pressed.
0000			;        Bit 2: Always 0.
0000			;        Bit 3: 1=Key '0' pressed.
0000			;        Bit 4: 1=Key 'ENTER' pressed.
0000			;        Bit 5: 1=Key '3' pressed.
0000			;        Bit 6: 1=Key '2' pressed.
0000			;        Bit 7: 1=Key '1' pressed.
0000	SYNRET:      EQU $5B8B  ;  2   Return address for ONERR routine.
0000	LASTV:       EQU $5B8D  ;  5   Last value printed by calculator.
0000	RNLINE:      EQU $5B92  ;  2   Address of the length bytes in the line currently being renumbered.
0000	RNFIRST:     EQU $5B94  ;  2   Starting line number when renumbering. Default value of 10.
0000	RNSTEP:      EQU $5B96  ;  2   Step size when renumbering. Default value of 10.
0000	STRIP1:      EQU $5B98  ; 32   Used as RAM disk transfer buffer (32 bytes to $5BB7).
0000			;      Used to hold Sinclair stripe character patterns (16 bytes to $5BA7).
0000			;      ...
0000	TSTACK:      EQU $5BFF  ;  n   Temporary stack (grows downwards). The byte at $5BFF is not actually used.
0000
0000			; -------------------------
0000			; Standard System Variables
0000			; -------------------------
0000			; These occupy addresses $5C00-$5CB5.
0000			; See the end of this document for descriptions of the standard system variables.
0000
0000			; ------------------
0000			; RAM Disk Catalogue
0000			; ------------------
0000			; The catalogue can occupy addresses $C000-$EBFF in physical RAM bank 7, starting at $EBFF and growing downwards.
0000			;
0000			; Each entry contains 20 bytes:
0000			;   Bytes $00-$09: Filename.
0000			;   Bytes $0A-$0C: Start address of file in RAM disk area.
0000			;   Bytes $0D-$0F: Length of file in RAM disk area.
0000			;   Bytes $10-$12: End address of file in RAM disk area (used as current position indicator when loading/saving).
0000			;   Byte  $13    : Flags:
0000			;                     Bit 0   : 1=Entry requires updating.
0000			;                     Bits 1-7: Not used (always hold 0).
0000			;
0000			; The catalogue can store up to 562 entries, and hence the RAM disk can never hold more than 562 files no matter
0000			; how small the files themselves are. Note that filenames are case sensitive.
0000			;
0000			; The shadow screen (SCREEN 1) also resides in physical RAM bank 7 and so if more than 217 catalogue
0000			; entries are created then SCREEN 1 will become corrupted [Credit: Toni Baker, ZX Computing Monthly].
0000			; However, since screen 1 cannot be used from BASIC, it may have been a design decision to allow the
0000			; RAM disk to overwrite it.
0000			;
0000			; The actual files are stored in physical RAM banks 1, 3, 4 and 6 (logical banks 0, 1, 2, 3),
0000			; starting from $C000 in physical RAM bank 1 and growing upwards.
0000			;
0000			; A file consists of a 9 byte header followed by the data for the file. The header bytes
0000			; have the following meaning:
0000			;   Byte  $00    : File type - $00=Program, $01=Numeric array, $02=Character array, $03=Code/Screen$.
0000			;   Bytes $01-$02: Length of program/code block/screen$/array ($1B00 for screen$).
0000			;   Bytes $03-$04: Start of code block/screen$ ($4000 for screen$).
0000			;   Bytes $05-$06: Offset to the variables (i.e. length of program) if a program. For an array, $05 holds the variable name.
0000			;   Bytes $07-$08: Auto-run line number for a program ($80 in high byte if no auto-run).
0000
0000			; --------------------------
0000			; Editor Workspace Variables
0000			; --------------------------
0000			; These occupy addresses $EC00-$FFFF in physical RAM bank 7, and form a workspace used by 128 BASIC Editor.
0000			;
0000			; $EC00    3   Byte 0: Flags used when inserting a line into the BASIC program (first 4 bits are mutually exclusive).
0000			;                Bit 0: 1=First row of the BASIC line off top of screen.
0000			;                Bit 1: 1=On first row of the BASIC line.
0000			;                Bit 2: 1=Using lower screen and only first row of the BASIC line visible.
0000			;                Bit 3: 1=At the end of the last row of the BASIC line.
0000			;                Bit 4: Not used (always 0).
0000			;                Bit 5: Not used (always 0).
0000			;                Bit 6: Not used (always 0).
0000			;                Bit 7: 1=Column with cursor not yet found.
0000			;              Byte 1: Column number of current position within the BASIC line being inserted. Used when fetching characters.
0000			;              Byte 2: Row number of current position within the BASIC line is being inserted. Used when fetching characters.
0000			; $EC03    3   Byte 0: Flags used upon an error when inserting a line into the BASIC program (first 4 bits are mutually exclusive).
0000			;                Bit 0: 1=First row of the BASIC line off top of screen.
0000			;                Bit 1: 1=On first row of the BASIC line.
0000			;                Bit 2: 1=Using lower screen and only first row of the BASIC line visible.
0000			;                Bit 3: 1=At the end of the last row of the BASIC line.
0000			;                Bit 4: Not used (always 0).
0000			;                Bit 5: Not used (always 0).
0000			;                Bit 6: Not used (always 0).
0000			;                Bit 7: 1=Column with cursor not yet found.
0000			;              Byte 1: Start column number where BASIC line is being entered. Always holds 0.
0000			;              Byte 2: Start row number where BASIC line is being entered.
0000			; $EC06    2   Count of the number of editable characters in the BASIC line up to the cursor within the Screen Line Edit Buffer.
0000			; $EC08    2   Version of E_PPC used by BASIC Editor to hold last line number entered.
0000			; $EC0C    1   Current menu index.
0000			; $EC0D    1   Flags used by 128 BASIC Editor:
0000			;                Bit 0: 1=Screen Line Edit Buffer (including Below-Screen Line Edit Buffer) is full.
0000			;                Bit 1: 1=Menu is displayed.
0000			;                Bit 2: 1=Using RAM disk.
0000			;                Bit 3: 1=Current line has been altered.
0000			;                Bit 4: 1=Return to calculator, 0=Return to main menu.
0000			;                Bit 5: 1=Do not process the BASIC line (used by the Calculator).
0000			;                Bit 6: 1=Editing area is the lower screen, 0=Editing area is the main screen.
0000			;                Bit 7: 1=Waiting for key press, 0=Got key press.
0000			; $EC0E    1   Mode:
0000			;                $00 = Edit Menu mode.
0000			;                $04 = Calculator mode.
0000			;                $07 = Tape Loader mode. [Effectively not used as overwritten by $FF]
0000			;                $FF = Tape Loader mode.
0000			; $EC0F    1   Main screen colours used by the 128 BASIC Editor - alternate ATTR_P.
0000			; $EC10    1   Main screen colours used by the 128 BASIC Editor - alternate MASK_P.
0000			; $EC11    1   Temporary screen colours used by the 128 BASIC Editor - alternate ATTR_T.
0000			; $EC12    1   Temporary screen colours used by the 128 BASIC Editor - alternate MASK_T.
0000			; $EC13    1   Temporary store for P_FLAG:
0000			;                Bit 0: 1=OVER 1, 0=OVER 0.
0000			;                Bit 1: Not used (always 0).
0000			;                Bit 2: 1=INVERSE 1, INVERSE 0.
0000			;                Bit 3: Not used (always 0).
0000			;                Bit 4: 1=Using INK 9.
0000			;                Bit 5: Not used (always 0).
0000			;                Bit 6: 1=Using PAPER 9.
0000			;                Bit 7: Not used (always 0).
0000			; $EC14    1   Not used.
0000			; $EC15    1   Holds the number of editing lines: 20 for the main screen, 1 for the lower screen.
0000			; $EC16  735   Screen Line Edit Buffer. This represents the text on screen that can be edited. It holds 21 rows,
0000			;              with each row consisting of 32 characters followed by 3 data bytes. Areas of white
0000			;              space that do not contain any editable characters (e.g. the indent that starts subsequent
0000			;              rows of a BASIC line) contain the value $00.
0000			;                Data Byte 0:
0000			;                  Bit 0: 1=The first row of the BASIC line.
0000			;                  Bit 1: 1=Spans onto next row.
0000			;                  Bit 2: Not used (always 0).
0000			;                  Bit 3: 1=The last row of the BASIC line.
0000			;                  Bit 4: 1=Associated line number stored.
0000			;                  Bit 5: Not used (always 0).
0000			;                  Bit 6: Not used (always 0).
0000			;                  Bit 7: Not used (always 0).
0000			;                Data Bytes 1-2: Line number of corresponding BASIC line (stored for the first row of the BASIC line only, holds $0000).
0000			; $EEF5    1   Flags used when listing the BASIC program:
0000			;                Bit 0   : 0=Not on the current line, 1=On the current line.
0000			;                Bit 1   : 0=Previously found the current line, 1=Not yet found the current line.
0000			;                Bit 2   : 0=Enable display file updates, 1=Disable display file updates.
0000			;                Bits 3-7: Not used (always 0).
0000			; $EEF6    1   Store for temporarily saving the value of TVFLAG.
0000			; $EEF7    1   Store for temporarily saving the value of COORDS.
0000			; $EEF9    1   Store for temporarily saving the value of P_POSN.
0000			; $EEFA    2   Store for temporarily saving the value of PR_CC.
0000			; $EEFC    2   Store for temporarily saving the value of ECHO_E.
0000			; $EEFE    2   Store for temporarily saving the value of DF_CC.
0000			; $EF00    2   Store for temporarily saving the value of DF_CCL.
0000			; $EF01    1   Store for temporarily saving the value of S_POSN.
0000			; $EF03    2   Store for temporarily saving the value of SPOSNL.
0000			; $EF05    1   Store for temporarily saving the value of SCR_CT.
0000			; $EF06    1   Store for temporarily saving the value of ATTR_P.
0000			; $EF07    1   Store for temporarily saving the value of MASK_P.
0000			; $EF08    1   Store for temporarily saving the value of ATTR_T.
0000			; $EF09 1512   Used to store screen area (12 rows of 14 columns) where menu will be shown.
0000			;              The rows are stored one after the other, with each row consisting of the following:
0000			;                - 8 lines of 14 display file bytes.
0000			;                - 14 attribute file bytes.
0000			; $F4F1-$F6E9  Not used. 505 bytes.
0000			; $F6EA    2   The jump table address for the current menu.
0000			; $F6EC    2   The text table address for the current menu.
0000			; $F6EE    1   Cursor position info - Current row number.
0000			; $F6EF    1   Cursor position info - Current column number.
0000			; $F6F0    1   Cursor position info - Preferred column number. Holds the last user selected column position. The Editor will attempt to
0000			;              place the cursor on this column when the user moves up or down to a new line.
0000			; $F6F1    1   Edit area info - Top row threshold for scrolling up.
0000			; $F6F2    1   Edit area info - Bottom row threshold for scrolling down.
0000			; $F6F3    1   Edit area info - Number of rows in the editing area.
0000			; $F6F4    1   Flags used when deleting:
0000			;                Bit 0   : 1=Deleting on last row of the BASIC line, 0=Deleting on row other than the last row of the BASIC line.
0000			;                Bits 1-7: Not used (always 0).
0000			; $F6F5    1   Number of rows held in the Below-Screen Line Edit Buffer.
0000			; $F6F6    2   Intended to point to the next location to access within the Below-Screen Line Edit Buffer, but incorrectly initialised to $0000 by the routine at $30D6 (ROM 0) and then never used.
0000			; $F6F8  735   Below-Screen Line Edit Buffer. Holds the remainder of a BASIC line that has overflowed off the bottom of the Screen Line Edit Buffer. It can hold 21 rows, with each row
0000			;              consisting of 32 characters followed by 3 data bytes. Areas of white space that do not contain any editable characters (e.g. the indent that starts subsequent rows of a BASIC line)
0000			;              contain the value $00.
0000			;                Data Byte 0:
0000			;                  Bit 0: 1=The first row of the BASIC line.
0000			;                  Bit 1: 1=Spans onto next row.
0000			;                  Bit 2: Not used (always 0).
0000			;                  Bit 3: 1=The last row of the BASIC line.
0000			;                  Bit 4: 1=Associated line number stored.
0000			;                  Bit 5: Not used (always 0).
0000			;                  Bit 6: Not used (always 0).
0000			;                  Bit 7: Not used (always 0).
0000			;                Data Bytes 1-2: Line number of corresponding BASIC line (stored for the first row of the BASIC line only, holds $0000).
0000			; $F9D7    2   Line number of the BASIC line in the program area being edited (or $0000 for no line).
0000			; $F9DB    1   Number of rows held in the Above-Screen Line Edit Buffer.
0000			; $F9DC    2   Points to the next location to access within the Above-Screen Line Edit Buffer.
0000			; $F9DE  700   Above-Screen Line Edit Buffer. Holds the rows of a BASIC line that has overflowed off the top of the Screen Line Edit Buffer.
0000			;              It can hold 20 rows, with each row consisting of 32 characters followed by 3 data bytes. Areas of white space that do not
0000			;              contain any editable characters (e.g. the indent that starts subsequent rows of a BASIC line) contain the value $00.
0000			;                Data Byte 0:
0000			;                  Bit 0: 1=The first row of the BASIC line.
0000			;                  Bit 1: 1=Spans onto next row.
0000			;                  Bit 2: Not used (always 0).
0000			;                  Bit 3: 1=The last row of the BASIC line.
0000			;                  Bit 4: 1=Associated line number stored.
0000			;                  Bit 5: Not used (always 0).
0000			;                  Bit 6: Not used (always 0).
0000			;                  Bit 7: Not used (always 0).
0000			;                Data Bytes 1-2: Line number of corresponding BASIC line (stored for the first row of the BASIC line only, holds $0000).
0000			; $FC9A    2   The line number at the top of the screen, or $0000 for the first line.
0000			; $FC9E    1   $00=Print a leading space when constructing keyword.
0000			; $FC9F    2   Address of the next character to fetch within the BASIC line in the program area, or $0000 for no next character.
0000			; $FCA1    2   Address of the next character to fetch from the Keyword Construction Buffer, or $0000 for no next character.
0000			; $FCA3   11   Keyword Construction Buffer. Holds either a line number or keyword string representation.
0000			; $FCAE-$FCFC  Construct a BASIC Line routine.                       <<< RAM routine - See end of file for description >>>
0000			; $FCFD-$FD2D  Copy String Into Keyword Construction Buffer routine. <<< RAM routine - See end of file for description >>>
0000			; $FD2E-$FD69  Identify Character Code of Token String routine.      <<< RAM routine - See end of file for description >>>
0000			; $FD6A    1   Flags used when shifting BASIC lines within edit buffer rows [Redundant]:
0000			;                Bit 0  : 1=Set to 1 but never reset or tested. Possibly intended to indicate the start of a new BASIC line and hence whether indentation required.
0000			;                Bit 1-7: Not used (always 0).
0000			; $FD6B    1   The number of characters to indent subsequent rows of a BASIC line by.
0000			; $FD6C    1   Cursor settings (indexed by IX+$00) - initialised to $00, but never used.
0000			; $FD6D    1   Cursor settings (indexed by IX+$01) - number of rows above the editing area.
0000			; $FD6E    1   Cursor settings (indexed by IX+$02) - initialised to $00 (when using lower screen) or $14 (when using main screen), but never subsequently used.
0000			; $FD6F    1   Cursor settings (indexed by IX+$03) - initialised to $00, but never subsequently used.
0000			; $FD70    1   Cursor settings (indexed by IX+$04) - initialised to $00, but never subsequently used.
0000			; $FD71    1   Cursor settings (indexed by IX+$05) - initialised to $00, but never subsequently used.
0000			; $FD72    1   Cursor settings (indexed by IX+$06) - attribute colour.
0000			; $FD73    1   Cursor settings (indexed by IX+$07) - screen attribute where cursor is displayed.
0000			; $FD74    9   The Keyword Conversion Buffer holding text to examine to see if it is a keyword.
0000			; $FD7D    2   Address of next available location within the Keyword Conversion Buffer.
0000			; $FD7F    2   Address of the space character between words in the Keyword Conversion Buffer.
0000			; $FD81    1   Keyword Conversion Buffer flags, used when tokenizing a BASIC line:
0000			;                Bit 0   : 1=Buffer contains characters.
0000			;                Bit 1   : 1=Indicates within quotes.
0000			;                Bit 2   : 1=Indicates within a REM.
0000			;                Bits 3-7: Not used (always reset to 0).
0000			; $FD82    2   Address of the position to insert the next character within the BASIC line workspace. The BASIC line
0000			;              is created at the spare space pointed to by E_LINE.
0000			; $FD84    1   BASIC line insertion flags, used when inserting a characters into the BASIC line workspace:
0000			;                Bit 0   : 1=The last character was a token.
0000			;                Bit 1   : 1=The last character was a space.
0000			;                Bits 2-7: Not used (always 0).
0000			; $FD85    2   Count of the number of characters in the typed BASIC line being inserted.
0000			; $FD87    2   Count of the number of characters in the tokenized version of the BASIC line being inserted.
0000			; $FD89    1   Holds '<' or '>' if this was the previously examined character during tokenization of a BASIC line, else $00.
0000			; $FD8A    1   Locate Error Marker flag, holding $01 is a syntax error was detected on the BASIC line being inserted and the equivalent position within
0000			;              the typed BASIC line needs to be found with, else it holds $00 when tokenizing a BASIC line.
0000			; $FD8B    2   Stores the stack pointer for restoration upon an insertion error into the BASIC line workspace.
0000			; $FD8C-$FF23  Not used. 408 bytes.
0000			; $FF24    2   Never used. An attempt is made to set it to $EC00. This is a remnant from the Spanish 128, which stored the address of the Screen Buffer here.
0000			;              The value is written to RAM bank 0 instead of RAM bank 7, and the value never subsequently accessed.
0000			; $FF26    2   Not used.
0000			; $FF28-$FF60  Not used. On the Spanish 128 this memory holds a routine that copies a character into the display file. The code to copy to routine into RAM,
0000			;              and the routine itself are present in ROM 0 but are never executed. <<< RAM routine - See end of file for description >>>
0000			; $FF61-$FFFF  Not used. 159 bytes.
0000
0000
0000			; ========================
0000			; Called ROM 1 Subroutines
0000			; ========================
0000
0000			ERROR_1:     EQU $0008
0000			PRINT_A_1:   EQU $0010
0000			GET_CHAR:    EQU $0018
0000			NEXT_CHAR:   EQU $0020
0000			BC_SPACES:   EQU $0030
0000	TOKENS:      EQU $0095
0000	BEEPER:      EQU $03B5
0000	BEEP:        EQU $03F8
0000			SA_ALL:      EQU $075A
0000			ME_CONTRL:   EQU $08B6
0000			SA_CONTROL:  EQU $0970
0000			PRINT_OUT:   EQU $09F4
0000			PO_T_UDG:    EQU $0B52
0000			PO_MSG:      EQU $0C0A
0000	TEMPS:       EQU $0D4D
0000	CLS:         EQU $0D6B
0000			CLS_LOWER:   EQU $0D6E
0000			CL_ALL:      EQU $0DAF
0000			CL_ATTR:     EQU $0E88
0000			CL_ADDR:     EQU $0E9B
0000			CLEAR_PRB:   EQU $0EDF
0000			ADD_CHAR:    EQU $0F81
0000			ED_ERROR:    EQU $107F
0000			CLEAR_SP:    EQU $1097
0000			KEY_INPUT:   EQU $10A8
0000			KEY_M_CL:    EQU $10DB
0000			MAIN_4:      EQU $1303
0000			ERROR_MSGS:  EQU $1391
0000	MESSAGES:    EQU $1537
0000			REPORT_J:    EQU $15C4
0000			OUT_CODE:    EQU $15EF
0000			CHAN_OPEN:   EQU $1601
0000			CHAN_FLAG:   EQU $1615
0000	POINTERS:    EQU $1664
0000	CLOSE:       EQU $16E5
0000			MAKE_ROOM:   EQU $1655
0000			LINE_NO:     EQU $1695
0000			SET_MIN:     EQU $16B0
0000			SET_WORK:    EQU $16BF
0000			SET_STK:     EQU $16C5
0000	OPEN:        EQU $1736
0000			LIST_5:      EQU $1822
0000	NUMBER:      EQU $18B6
0000			LINE_ADDR:   EQU $196E
0000			EACH_STMT:   EQU $198B
0000			NEXT_ONE:    EQU $19B8
0000	RECLAIM:     EQU $19E5
0000			RECLAIM_2:   EQU $19E8
0000			E_LINE_NO:   EQU $19FB
0000			OUT_NUM_1:   EQU $1A1B
0000			CLASS_01:    EQU $1C1F
0000			VAL_FET_1:   EQU $1C56
0000			CLASS_04:    EQU $1C6C
0000			EXPT_2NUM:   EQU $1C7A
0000			EXPT_1NUM:   EQU $1C82
0000			EXPT_EXP:    EQU $1C8C
0000			CLASS_09:    EQU $1CBE
0000			FETCH_NUM:   EQU $1CDE
0000			USE_ZERO:    EQU $1CE6
0000	STOP:        EQU $1CEE
0000			F_REORDER:   EQU $1D16
0000			LOOK_PROG:   EQU $1D86
0000	NEXT:        EQU $1DAB
0000			PASS_BY:     EQU $1E39
0000	RESTORE:     EQU $1E42
0000			REST_RUN:    EQU $1E45
0000	RANDOMIZE:   EQU $1E4F
0000	CONTINUE:    EQU $1E5F
0000			GO_TO:       EQU $1E67
0000	COUT:        EQU $1E7A     ; Should be OUT but renamed since some assemblers detect this as an instruction.
0000	POKE:        EQU $1E80
0000			FIND_INT2:   EQU $1E99
0000			TEST_ROOM:   EQU $1F05
0000	PAUSE:       EQU $1F3A
0000			PRINT_2:     EQU $1FDF
0000			PR_ST_END:   EQU $2048
0000			STR_ALTER:   EQU $2070
0000			INPUT_1:     EQU $2096
0000			IN_ITEM_1:   EQU $20C1
0000			CO_TEMP_4:   EQU $21FC
0000	BORDER:      EQU $2294
0000			PIXEL_ADDR:  EQU $22AA
0000	PLOT:        EQU $22DC
0000			PLOT_SUB:    EQU $22E5
0000	CIRCLE:      EQU $2320
0000			DR_3_PRMS:   EQU $238D
0000			LINE_DRAW:   EQU $2477
0000	SCANNING:    EQU $24FB
0000			SYNTAX_Z:    EQU $2530
0000			LOOK_VARS:   EQU $28B2
0000			STK_VAR:     EQU $2996
0000			STK_FETCH:   EQU $2BF1
0000			D_RUN:       EQU $2C15
0000	ALPHA:       EQU $2C8D
0000	NUMERIC:     EQU $2D1B
0000			STACK_BC:    EQU $2D2B
0000			FP_TO_BC:    EQU $2DA2
0000			PRINT_FP:    EQU $2DE3
0000			HL_MULT_DE:  EQU $30A9
0000			STACK_NUM:   EQU $33B4
0000			TEST_ZERO:   EQU $34E9
0000			KP_SCAN:     EQU $3C01
0000			TEST_SCREEN: EQU $3C04
0000			CHAR_SET:    EQU $3D00
0000
0000
0000			;**************************************************
0000
0000			; =========================
0000			; RESTART ROUTINES - PART 1
0000			; =========================
0000			; RST $10, $18 and $20 call the equivalent subroutines in ROM 1, via RST $28.
0000			;
0000			; RST $00 - Reset the machine.
0000			; RST $08 - Not used. Would have invoked the ZX Interface 1 if fitted.
0000			; RST $10 - Print a character      (equivalent to RST $10 ROM 1).
0000			; RST $18 - Collect a character    (equivalent to RST $18 ROM 1).
0000			; RST $20 - Collect next character (equivalent to RST $20 ROM 1).
0000			; RST $28 - Call routine in ROM 1.
0000			; RST $30 - Not used.
0000			; RST $38 - Not used.
0000
0000			; -----------------------
0000			; RST $00 - Reset Machine
0000			; -----------------------
0000
0000			ORG $0000
0000
0000	L0000:  DI                ; Ensure interrupts are disabled.
0001			LD   BC,$692B     ;
0004
0004	L0004:  DEC  BC           ; Delay about 0.2s to allow screen switching mechanism to settle.
0005			LD   A,B          ;
0006			OR   C            ;
0007			JR   NZ,L0004     ; [There is no RST $08. No instruction fetch at $0008 hence ZX Interface 1 will not be paged in from this ROM. Credit: Paul Farrow].
0009
0009			JP   L00C7        ; to the main reset routine.
000c
000c	L000C:  DEFB $00, $00     ; [Spare bytes]
000e			DEFB $00, $00     ;
0010
0010			; ---------------------------
0010			; RST $10 - Print A Character
0010			; ---------------------------
0010
0010	L0010:  RST  28H          ; Call corresponding routine in ROM 1.
0011			DEFW PRINT_A_1    ; $0010.
0013			RET               ;
0014
0014	L0014:  DEFB $00, $00     ; [Spare bytes]
0016			DEFB $00, $00     ;
0018
0018			; -----------------------------
0018			; RST $18 - Collect A Character
0018			; -----------------------------
0018
0018	L0018:  RST  28H          ; Call corresponding routine in ROM 1.
0019			DEFW GET_CHAR     ; $0018.
001b			RET               ;
001c
001c	L001C:  DEFB $00, $00     ; [Spare bytes]
001e			DEFB $00, $00     ;
0020
0020			; --------------------------------
0020			; RST $20 - Collect Next Character
0020			; --------------------------------
0020
0020	L0020:  RST  28H          ; Call corresponding routine in ROM 1.
0021			DEFW NEXT_CHAR    ; $0020.
0023			RET               ;
0024
0024	L0024:  DEFB $00, $00     ; [Spare bytes]
0026			DEFB $00, $00     ;
0028
0028			; -------------------------------
0028			; RST $28 - Call Routine in ROM 1
0028			; -------------------------------
0028			; RST 28 calls a routine in ROM 1 (or alternatively a routine in RAM while
0028			; ROM 1 is paged in). Call as follows: RST 28 / DEFW address.
0028
0028	L0028:  EX   (SP),HL      ; Get the address after the RST $28 into HL,
0029			; saving HL on the stack.
0029			PUSH AF           ; Save the AF registers.
002a			LD   A,(HL)       ; Fetch the first address byte.
002b			INC  HL           ; Point HL to the byte after
002c			INC  HL           ; the required address.
002d			LD   (RETADDR),HL ; $5B5A. Store this in RETADDR.
0030			DEC  HL           ; (There is no RST $30)
0031			LD   H,(HL)       ; Fetch the second address byte.
0032			LD   L,A          ; HL=Subroutine to call.
0033			POP  AF           ; Restore AF.
0034			JP   L005C        ; Jump ahead to continue.
0037
0037	L0037:  DEFB $00          ; [Spare byte]
0038
0038
0038			; ==========================
0038			; MASKABLE INTERRUPT ROUTINE
0038			; ==========================
0038			; This routine preserves the HL register pair. It then performs the following:
0038			; - Execute the ROM switching code held in RAM to switch to ROM 1.
0038			; - Execute the maskable interrupt routine in ROM 1.
0038			; - Execute the ROM switching code held in RAM to return to ROM 0.
0038			; - Return to address $0048 (ROM 0).
0038
0038	L0038:  PUSH HL           ; Save HL register pair.
0039			LD   HL,L0048     ; Return address of $0048 (ROM 0).
003c			PUSH HL           ;
003d			LD   HL,SWAP      ; $5B00. Address of swap ROM routine held in RAM at $5B00.
0040			PUSH HL           ;
0041			LD   HL,L0038     ; Maskable interrupt routine address $0038 (ROM 0).
0044			PUSH HL           ;
0045			JP   SWAP         ; $5B00. Switch to other ROM (ROM 1) via routine held in RAM at $5B00.
0048
0048	L0048:  POP  HL           ; Restore the HL register pair.
0049			RET               ; End of interrupt routine.
004a
004a
004a			; ===============================
004a			; ERROR HANDLER ROUTINES - PART 1
004a			; ===============================
004a
004a			; ------------------
004a			; 128K Error Routine
004a			; ------------------
004a
004a	L004A:  LD   BC,$7FFD     ;
004d			XOR  A            ; ROM 0, Bank 0, Screen 0, 128K mode.
004e			DI                ; Ensure interrupts are disabled whilst paging.
004f			OUT  (C),A        ;
0051			LD   (BANK_M),A   ; $5B5C. Note the new paging status.
0054			EI                ; Re-enable interrupts.
0055			DEC  A            ; A=$FF.
0056			LD   (IY+$00),A   ; Set ERR_NR to no error ($FF).
0059			JP   L0321        ; Jump ahead to continue.
005c
005c
005c			; =========================
005c			; RESTART ROUTINES - PART 2
005c			; =========================
005c
005c			; -----------------------------------------
005c			; Call ROM 1 Routine (RST $28 Continuation)
005c			; -----------------------------------------
005c			; Continuation from routine at $0028 (ROM 0).
005c
005c	L005C:  LD   (TARGET),HL  ; $5B58. Save the address in ROM 0 to call.
005f			LD   HL,YOUNGER   ; $5B14. HL='Return to ROM 0' routine held in RAM.
0062			EX   (SP),HL      ; Stack HL.
0063			PUSH HL           ; Save previous stack address.
0064			LD   HL,(TARGET)  ; $5B58. HL=Retrieve address to call. [There is no NMI code. Credit: Andrew Owen].
0067			EX   (SP),HL      ; Stack HL.
0068			JP   SWAP         ; $5B00. Switch to other ROM (ROM 1) and return to address to call.
006b
006b
006b			; ============
006b			; RAM ROUTINES
006b			; ============
006b			; The following code will be copied to locations $5B00 to $5B57, within the old ZX Printer buffer.
006b
006b			; -----------------
006b			; Swap to Other ROM (copied to $5B00)
006b			; -----------------
006b			; Switch to the other ROM from that currently paged in.
006b
006b			; [The switching between the two ROMs invariably enables interrupts, which may not always be desired
006b			; (see the bug at $09CD (ROM 0) in the PLAY command). To overcome this issue would require a rewrite
006b			; of the SWAP routine as follows, but this is larger than the existing routine and so cannot simply be
006b			; used in direct replacement of it. A work-around solution is to poke a JP instruction at the start of
006b			; the SWAP routine in the ZX Printer buffer and direct control to the replacement routine held somewhere
006b			; else in RAM. Credit: Toni Baker, ZX Computing Monthly]
006b			;
006b			; [However, the PLAY commnad bug may be fixed in another manner within the PLAY command itself, in which
006b			; case there is no need to modify the SWAP routine.]
006b			;
006b			; SWAP:
006b			;       PUSH AF           ; Stack AF.
006b			;       PUSH BC           ; Stack BC.
006b			;
006b			;       LD   A,R          ; P/V flag=Interrupt status.
006b			;       PUSH AF           ; Stack interrupt status.
006b			;
006b			;       LD   BC,$7FFD     ; BC=Port number required for paging.
006b			;       LD   A,(BANK_M)   ; A=Current paging configuration.
006b			;       XOR  $10          ; Complement 'ROM' bit.
006b			;       DI                ; Disable interrupts (in case an interrupt occurs between the next two instructions).
006b			;       LD   (BANK_M),A   ; Store revised paging configuration.
006b			;       OUT  (C),A        ; Page ROM.
006b			;
006b			;       POP  AF           ; P/V flag=Former interrupt status.
006b			;       JP   PO,SWAP_EXIT ; Jump if interrupts were previously disabled.
006b			;
006b			;       EI                ; Re-enable interrupts.
006b			;
006b			; SWAP_EXIT:
006b			;       POP BC            ; Restore BC.
006b			;       POP AF            ; Restore AF.
006b			;       RET               ;
006b
006b			;SWAP
006b	L006B:  PUSH AF           ; Save AF and BC.
006c			PUSH BC           ;
006d			LD   BC,$7FFD     ;
0070			LD   A,(BANK_M)   ; $5B5C.
0073			XOR  $10          ; Select other ROM.
0075			DI                ; Disable interrupts whilst switching ROMs.
0076			LD   (BANK_M),A   ; $5B5C.
0079			OUT  (C),A        ; Switch to the other ROM.
007b			EI                ;
007c			POP  BC           ; Restore BC and AF.
007d			POP  AF           ;
007e			RET               ;
007f
007f			; ---------------------------
007f			; Return to Other ROM Routine (copied to $5B14)
007f			; ---------------------------
007f			; Switch to the other ROM from that currently paged in
007f			; and then return to the address held in RETADDR.
007f
007f			;YOUNGER
007f	L007F:  CALL SWAP         ; $5B00. Toggle to the other ROM.
0082			PUSH HL           ;
0083			LD   HL,(RETADDR) ; $5B5A.
0086			EX   (SP),HL      ;
0087			RET               ; Return to the address held in RETADDR.
0088
0088			; ---------------------
0088			; Error Handler Routine (copied to $5B1D)
0088			; ---------------------
0088			; This error handler routine switches back to ROM 0 and then
0088			; executes the routine pointed to by system variable TARGET.
0088
0088			;ONERR
0088	L0088:  DI                ; Ensure interrupts are disabled whilst paging.
0089			LD   A,(BANK_M)   ; $5B5C. Fetch current paging configuration.
008c			AND  $EF          ; Select ROM 0.
008e			LD   (BANK_M),A   ; $5B5C. Save the new configuration
0091			LD   BC,$7FFD     ;
0094			OUT  (C),A        ; Switch to ROM 0.
0096			EI                ;
0097			JP   L00C3        ; Jump to $00C3 (ROM 0) to continue.
009a
009a			; -------------------------
009a			; 'P' Channel Input Routine (copied to $5B2F)
009a			; -------------------------
009a			; Called when data is read from channel 'P'.
009a			; It causes ROM 0 to be paged in so that the new RS232 routines
009a			; can be accessed.
009a
009a			;PIN
009a	L009A:  LD   HL,L06D8     ; RS232 input routine within ROM 0.
009d			JR   L00A2        ;
009f
009f			; --------------------------
009f			; 'P' Channel Output Routine (copied to $5B34)
009f			; --------------------------
009f			; Called when data is written to channel 'P'.
009f			; It causes ROM 0 to be paged in so that the new RS232 routines
009f			; can be accessed.
009f			; Entry: A=Byte to send.
009f
009f			;POUT
009f	L009F:  LD   HL,L07CA     ; RS232 output routine within ROM 0.
00a2
00a2	L00A2:  EX   AF,AF'       ; Save AF registers.
00a3			LD   BC,$7FFD     ;
00a6			LD   A,(BANK_M)   ; $5B5C. Fetch the current paging configuration
00a9			PUSH AF           ; and save it.
00aa			AND  $EF          ; Select ROM 0.
00ac			DI                ; Ensure interrupts are disabled whilst paging.
00ad			LD   (BANK_M),A   ; $5B5C. Store the new paging configuration.
00b0			OUT  (C),A        ; Switch to ROM 0.
00b2			JP   L05E6        ; Jump to the RS232 channel input/output handler routine.
00b5
00b5			; ------------------------
00b5			; 'P' Channel Exit Routine (copied to $5B4A)
00b5			; ------------------------
00b5			; Used when returning from a channel 'P' read or write operation.
00b5			; It causes the original ROM to be paged back in and returns back to
00b5			; the calling routine.
00b5
00b5			;POUT2
00b5	L00B5:  EX   AF,AF'       ; Save AF registers. For a read, A holds the byte read and the flags the success status.
00b6			POP  AF           ; Retrieve original paging configuration.
00b7			LD   BC,$7FFD     ;
00ba			DI                ; Ensure interrupts are disabled whilst paging.
00bb			LD   (BANK_M),A   ; $5B5C. Store original paging configuration.
00be			OUT  (C),A        ; Switch back to original paging configuration.
00c0			EI                ;
00c1			EX   AF,AF'       ; Restore AF registers. For a read, A holds the byte read and the flags the success status.
00c2			RET               ; <<< End of RAM Routines >>>
00c3
00c3
00c3			; ===============================
00c3			; ERROR HANDLER ROUTINES - PART 2
00c3			; ===============================
00c3
00c3			; ---------------
00c3			; Call Subroutine
00c3			; ---------------
00c3			; Called from ONERR ($5B1D) to execute the routine pointed
00c3			; to by system variable SYNRET.
00c3
00c3	L00C3:  LD   HL,(SYNRET)  ; $5B8B. Fetch the address to call.
00c6			JP   (HL)         ; and execute it.
00c7
00c7
00c7			; ================================
00c7			; INITIALISATION ROUTINES - PART 1
00c7			; ================================
00c7
00c7			; --------------------------------------------
00c7			; Reset Routine (RST $00 Continuation, Part 1)
00c7			; --------------------------------------------
00c7			; Continuation from routine at $0000 (ROM 0). It performs a test on all RAM banks.
00c7			; This test is crude and can fail to detect a variety of RAM errors.
00c7
00c7	L00C7:  LD   B,$08        ; Loop through all RAM banks.
00c9
00c9	L00C9:  LD   A,B          ;
00ca			EXX               ; Save B register.
00cb			DEC  A            ; RAM bank number 0 to 7. 128K mode, ROM 0, Screen 0.
00cc			LD   BC,$7FFD     ;
00cf			OUT  (C),A        ; Switch RAM bank.
00d1
00d1			LD   HL,$C000     ; Start of the current RAM bank.
00d4			LD   DE,$C001     ;
00d7			LD   BC,$3FFF     ; All 16K of RAM bank.
00da			LD   A,$FF        ;
00dc			LD   (HL),A       ; Store $FF into RAM location.
00dd			CP   (HL)         ; Check RAM integrity.
00de			JR   NZ,L0131     ; Jump if RAM error found.
00e0
00e0			XOR  A            ;
00e1			LD   (HL),A       ; Store $00 into RAM location.
00e2			CP   (HL)         ; Check RAM integrity.
00e3			JR   NZ,L0131     ; Jump if difference found.
00e5
00e5			LDIR              ; Clear the whole page
00e7			EXX               ; Restore B registers.
00e8			DJNZ L00C9        ; Repeat for other RAM banks.
00ea
00ea			LD   (ROW01),A    ; $5B88. Signal no communications in progress to the keypad.
00ed
00ed			LD   C,$FD        ;
00ef			LD   D,$FF        ;
00f1			LD   E,$BF        ;
00f3			LD   B,D          ; BC=$FFFD, DE=$FFBF.
00f4			LD   A,$0E        ;
00f6			OUT  (C),A        ; Select AY register 14.
00f8			LD   B,E          ; BC=$BFFD.
00f9			LD   A,$FF        ;
00fb			OUT  (C),A        ; Set AY register 14 to $FF. This will force a communications reset to the keypad if present.
00fd			JR   L0137        ; Jump ahead to continue.
00ff
00ff	L00FF:  DEFB $00          ; [Spare byte]
0100
0100
0100			; ====================
0100			; ROUTINE VECTOR TABLE
0100			; ====================
0100
0100	L0100:  JP   L17AF        ; BASIC interpreter parser.
0103	L0103:  JP   L1838        ; 'Line Run' entry point.
0106	L0106:  JP   L1ECF        ; Transfer bytes to logical RAM bank 4.
0109	L0109:  JP   L1F04        ; Transfer bytes from logical RAM bank 4.
010c	L010C:  JP   L004A        ; 128K error routine.
010f	L010F:  JP   L03A2        ; Error routine.               Called from patch at $3B3B in ROM 1.
0112	L0112:  JP   L182A        ; 'Statement Return' routine.  Called from patch at $3B4D in ROM 1.
0115	L0115:  JP   L18A8        ; 'Statement Next' routine.    Called from patch at $3B5D in ROM 1.
0118	L0118:  JP   L012D        ; Scan the keypad.
011b	L011B:  JP   L0A05        ; Play music strings.
011e	L011E:  JP   L11A3        ; MIDI byte output routine.
0121	L0121:  JP   L06D8        ; RS232 byte input routine.
0124	L0124:  JP   L07CA        ; RS232 text output routine.
0127	L0127:  JP   L08A3        ; RS232 byte output routine.
012a	L012A:  JP   L08F0        ; COPY (screen dump) routine.
012d	L012D:  RST  28H          ; Call keypad scan routine in ROM 1.
012e			DEFW KP_SCAN-$0100 ; $3B01. [*BUG* - The address jumps into the middle of the keypad decode routine in ROM 1. It
0130			RET               ;                  looks like it is supposed to deal with the keypad and so the most likely
0131			;                  addresses are $3A42 (read keypad) or $39A0 (scan keypad). At $3C01 in
0131			;                  ROM 1 is a vector jump command to $39A0 to scan the keypad and this is
0131			;                  similar enough to the $3B01 to imply a simple error in one of the bytes. Credit: Paul Farrow]
0131
0131
0131			; ================================
0131			; INITIALISATION ROUTINES - PART 2
0131			; ================================
0131
0131			; ---------------
0131			; Fatal RAM Error
0131			; ---------------
0131			; Set the border colour to indicate which RAM bank was found faulty:
0131			; RAM bank 7 - Black.
0131			; RAM bank 6 - White.
0131			; RAM bank 5 - Yellow.
0131			; RAM bank 4 - Cyan.
0131			; RAM bank 3 - Green.
0131			; RAM bank 2 - Magenta.
0131			; RAM bank 1 - Red.
0131			; RAM bank 0 - Blue.
0131
0131	L0131:  EXX               ; Retrieve RAM bank number + 1 in B.
0132			LD   A,B          ; Indicate which RAM bank failed by
0133			OUT  ($FE),A      ; setting the border colour.
0135
0135	L0135:  JR   L0135        ; Infinite loop.
0137
0137			; --------------------------------------------
0137			; Reset Routine (RST $00 Continuation, Part 2)
0137			; --------------------------------------------
0137			; Continuation from routine at $00C7 (ROM 0).
0137
0137	L0137:  LD   B,D          ; Complete setting up the sound chip registers.
0138			LD   A,$07        ;
013a			OUT  (C),A        ; Select AY register 7.
013c			LD   B,E          ;
013d			LD   A,$FF        ; Disable AY-3-8912 sound channels.
013f			OUT  (C),A        ;
0141
0141			LD   DE,SWAP      ; $5B00. Copy the various paging routines to the old printer buffer.
0144			LD   HL,L006B     ; The source is in this ROM.
0147			LD   BC,$0058     ; There are eighty eight bytes to copy.
014a			LDIR              ; Copy the block of bytes.
014c
014c			LD   A,$CF        ; Load A with the code for the Z80 instruction 'RST $08'.
014e			LD   (RAMRST),A   ; $5B5D. Insert into new System Variable RAMRST.
0151			LD   SP,TSTACK    ; $5BFF. Set the stack pointer to last location of old buffer.
0154
0154			LD   A,$04        ;
0156			CALL L1C64        ; Page in logical RAM bank 4 (physical RAM bank 7).
0159
0159			LD   IX,$EBEC     ; First free entry in RAM disk.
015d			LD   (SFNEXT),IX  ; $5B83.
0161			LD   (IX+$0A),$00 ;
0165			LD   (IX+$0B),$C0 ;
0169			LD   (IX+$0C),$00 ;
016d			LD   HL,$2BEC     ;
0170			LD   A,$01        ; AHL=Free space in RAM disk.
0172			LD   (SFSPACE),HL ; $5B85. Current address.
0175			LD   (SFSPACE+2),A ; $5B87. Current RAM bank.
0178
0178			LD   A,$05        ;
017a			CALL L1C64        ; Page in logical RAM bank 5 (physical RAM bank 0).
017d
017d			LD   HL,$FFFF     ; Load HL with known last working byte - 65535.
0180			LD   ($5CB4),HL   ; P_RAMT. Set physical RAM top to 65535.
0183
0183			LD   DE,CHAR_SET+$01AF ; $3EAF. Set DE to address of the last bitmap of 'U' in ROM 1.
0186			LD   BC,$00A8     ; There are 21 User Defined Graphics to copy.
0189			EX   DE,HL        ; Swap so destination is $FFFF.
018a			RST  28H          ;
018b			DEFW MAKE_ROOM+$000C ; Calling this address (LDDR/RET) in the main ROM
018d			; cleverly copies the 21 characters to the end of RAM.
018d
018d			EX   DE,HL        ; Transfer DE to HL.
018e			INC  HL           ; Increment to address first byte of UDG 'A'.
018f			LD   ($5C7B),HL   ; UDG. Update standard System Variable UDG.
0192
0192			DEC  HL           ;
0193			LD   BC,$0040     ; Set values 0 for PIP and 64 for RASP.
0196			LD   ($5C38),BC   ; RASP. Update standard System Variables RASP and PIP.
019a			LD   ($5CB2),HL   ; RAMTOP. Update standard System Variable RAMTOP - the last
019d			; byte of the BASIC system area. Any machine code and
019d			; graphics above this address are protected from NEW.
019d
019d			; Entry point for NEW with interrupts disabled and physical RAM bank 0 occupying
019d			; the upper RAM region $C000 - $FFFF, i.e. the normal BASIC memory configuration.
019d
019d	L019D:  LD   HL,CHAR_SET-$0100 ; $3C00. Set HL to where, in theory character zero would be.
01a0			LD   ($5C36),HL   ; CHARS. Update standard System Variable CHARS.
01a3
01a3			LD   HL,($5CB2)   ; RAMTOP. Load HL with value of System Variable RAMTOP.
01a6			INC  HL           ; Address next location.
01a7			LD   SP,HL        ; Set the Stack Pointer.
01a8			IM   1            ; Select Interrupt Mode 1.
01aa			LD   IY,$5C3A     ; Set the IY register to address the standard System
01ae			; Variables and many of the new System Variables and
01ae			; even those of ZX Interface 1 in some cases.
01ae			SET  4,(IY+$01)   ; FLAGS. Signal 128K mode.
01b2			; [This bit was unused and therefore never set by 48K BASIC]
01b2
01b2			EI                ; With a stack and the IY register set, interrupts can
01b3			; be enabled.
01b3
01b3			LD   HL,$000B     ; Set HL to eleven, timing constant for 9600 baud.
01b6			LD   (BAUD),HL    ; $5B5F. Select default RS232 baud rate of 9600 baud.
01b9
01b9			XOR  A            ; Clear accumulator.
01ba			LD   (SERFL),A    ; $5B61. Indicate no byte waiting in RS232 receive buffer.
01bd			LD   (COL),A      ; $5B63. Set RS232 output column position to 0.
01c0			LD   (TVPARS),A   ; $5B65. Indicate no control code parameters expected.
01c3
01c3			LD   HL,$EC00     ; [*BUG* - Should write to RAM bank 7. Main RAM has now been corrupted. The value stored is subsequently never used. Credit: Geoff Wearmouth]
01c6			LD   ($FF24),HL   ; This is a remnant from the Spanish 128, which used this workspace variable to hold the location of the Screen Buffer, but
01c9			; it also suffered from this bug. In fact there was never a need to write to the value at this point since it is written again later
01c9			; during the initialisation process.
01c9			; [The 1985 Sinclair Research ESPAGNOL source code says that this instruction will write to the (previously cleared)
01c9			; main BASIC RAM during initialization but that a different page of RAM will be present during NEW.
01c9			; Stuff and Nonsense! Assemblers and other utilities present above RAMTOP will be corrupted by the BASIC NEW command
01c9			; since $FF24, and later $EC13, will be written to even if they are above RAMTOP.]
01c9
01c9			LD   A,$50        ; Default to a printer width of 80 columns.
01cb			LD   (WIDTH),A    ; $5B64. Set RS232 printer output width.
01ce
01ce			LD   HL,$000A     ; Use 10 as the initial renumber line and increment.
01d1			LD   (RNFIRST),HL ; $5B94. Store the initial line number when renumbering.
01d4			LD   (RNSTEP),HL  ; $5B96. Store the renumber line increment.
01d7
01d7			LD   HL,$5CB6     ; Address after the System Variables.
01da			LD   ($5C4F),HL   ; CHANS. Set the default location for the channel area.
01dd
01dd			LD   DE,L0589     ; Point to Initial Channel Information in this ROM.
01e0			; This is similar to that in main ROM but
01e0			; channel 'P' has input and output addresses in the
01e0			; new $5Bxx region.
01e0			LD   BC,$0015     ; There are 21 bytes to copy.
01e3			EX   DE,HL        ; Switch pointer so destination is CHANS.
01e4			LDIR              ; Copy the block of bytes.
01e6
01e6			EX   DE,HL        ;
01e7			DEC  HL           ; Decrement to point to channel information end-marker.
01e8			LD   ($5C57),HL   ; DATADD. Set the default address of the terminator for the last DATA item.
01eb
01eb			INC  HL           ;
01ec			LD   ($5C53),HL   ; PROG. Set the default address of the BASIC program area.
01ef			LD   ($5C4B),HL   ; VARS. Set the default address of the BASIC variables area.
01f2			LD   (HL),$80     ; Insert the Variables end-marker.
01f4
01f4			INC  HL           ;
01f5			LD   ($5C59),HL   ; E_LINE. Set the default address of the editing line area.
01f8			LD   (HL),$0D     ; Insert a carriage return.
01fa			INC  HL           ;
01fb			LD   (HL),$80     ; Insert the editing line end-marker.
01fd
01fd			INC  HL           ;
01fe			LD   ($5C61),HL   ; WORKSP. Set the address of the workspace.
0201			LD   ($5C63),HL   ; STKBOT. Set the address of the start of the calculator stack.
0204			LD   ($5C65),HL   ; STKEND. Set the address of the end of the calculator stack.
0207
0207			LD   A,$38        ; Attribute colour of black ink on white paper.
0209			LD   ($5C8D),A    ; ATTR_P. Set the permanent attribute colour.
020c			LD   ($5C8F),A    ; MASK_P. Set the permanent attribute mask.
020f			LD   ($5C48),A    ; BORDCR. Set the default border colour.
0212
0212			XOR  A            ;
0213			LD   ($EC13),A    ; Temporary P_FLAG. Clear the temporary store for P-FLAG.
0216			; [*BUG* - Should write this to RAM bank 7. Main RAM has now been corrupted again. The effect
0216			;  of the bug can be seen by typing INVERSE 1: PRINT "Hello", followed by NEW, followed by
0216			;  PRINT "World", and will cause the second word to also be printed in inverse. Credit: Geoff Wearmouth]
0216
0216			LD   A,$07        ;
0218			OUT  ($FE),A      ; Set the border white.
021a
021a			LD   HL,$0523     ; The values five and thirty five.
021d			LD   ($5C09),HL   ; REPDEL. Set the default values for key delay and key repeat.
0220
0220			DEC  (IY-$3A)     ; Set KSTATE+0 to $FF.
0223			DEC  (IY-$36)     ; Set KSTATE+4 to $FF.
0226
0226			LD   HL,L059E     ; Address of the Initial Stream Data within this ROM (which is identical to that in main ROM).
0229			LD   DE,$5C10     ; STRMS. Address of the system variable holding the channels attached to streams data.
022c			LD   BC,$000E     ;
022f			LDIR              ; Initialise the streams system variables.
0231
0231			RES  1,(IY+$01)   ; FLAGS. Signal printer not is use.
0235			LD   (IY+$00),$FF ; ERR_NR. Signal no error.
0239			LD   (IY+$31),$02 ; DF_SZ. Set the lower screen size to two rows.
023d
023d			RST  28H          ;
023e			DEFW CLS          ; $0D6B. Clear the screen.
0240			RST  28H          ; Attempt to display TV tuning test screen.
0241			DEFW TEST_SCREEN  ; $3C04. Will return if BREAK is not being pressed.
0243
0243			LD   DE,L0561     ; Address of the Sinclair copyright message.
0246			CALL L057D        ; Display the copyright message.
0249
0249			LD   (IY+$31),$02 ; DF_SZ. Set the lower screen size to two rows.
024d			SET  5,(IY+$02)   ; TV_FLAG. Signal lower screen will require clearing.
0251
0251			LD   HL,TSTACK    ; $5BFF.
0254			LD   (OLDSP),HL   ; $5B81. Use the temporary stack as the previous stack.
0257
0257			CALL L1F45        ; Use Workspace RAM configuration (physical RAM bank 7).
025a
025a			LD   A,$38        ; Set colours to black ink on white paper.
025c			LD   ($EC11),A    ; Temporary ATTR_T used by the 128 BASIC Editor.
025f			LD   ($EC0F),A    ; Temporary ATTR_P used by the 128 BASIC Editor.
0262
0262			; [Note this is where $EC13 (temporary P_FLAG) and $FF24 should be set]
0262
0262			CALL L2584        ; Initialise mode and cursor settings. IX will point at editing settings information.
0265
0265			CALL L1F20        ; Use Normal RAM Configuration (physical RAM bank 0).
0268			JP   L259F        ; Jump to show the Main menu.
026b
026b
026b			; ===================================
026b			; COMMAND EXECUTION ROUTINES - PART 1
026b			; ===================================
026b
026b			; --------------------
026b			; Execute Command Line
026b			; --------------------
026b			; A typed in command resides in the editing workspace. Execute it.
026b			; The command could either be a new line to insert, or a line number to delete, or a numerical expression to evaluate.
026b
026b	L026B:  LD   HL,FLAGS3    ; $5B66.
026e			SET  0,(HL)       ; Select BASIC/Calculator mode.
0270
0270			LD   (IY+$00),$FF ; ERR_NR. Set to '0 OK' status.
0274			LD   (IY+$31),$02 ; DF_SZ. Reset the number of rows in the lower screen.
0278
0278			LD   HL,ONERR     ; $5B1D. Return address should an error occur.
027b			PUSH HL           ; Stack it.
027c
027c			LD   ($5C3D),SP   ; Save the stack pointer in ERR_SP.
0280
0280			LD   HL,L02BA     ; Return address in ROM 0 after syntax checking.
0283			LD   (SYNRET),HL  ; $5B8B. Store it in SYNRET.
0286
0286			CALL L228E        ; Point to start of typed in BASIC command.
0289			CALL L22CB        ; Is the first character a function token, i.e. the start of a numerical expression?
028c			JP   Z,L21F8      ; Jump if so to evaluate it.
028f
028f			CP   '('          ; $28. Is the first character the start of an expression?
0291			JP   Z,L21F8      ; Jump if so to evaluate it.
0294
0294			CP   '-'          ; $2D. Is the first character the start of an expression?
0296			JP   Z,L21F8      ; Jump if so to evaluate it.
0299
0299			CP   '+'          ; $2B. Is the first character the start of an expression?
029b			JP   Z,L21F8      ; Jump if so to evaluate it.
029e
029e			CALL L22E0        ; Is text just a number or a numerical expression?
02a1			JP   Z,L21F8      ; Jump if a numerical expression to evaluate it.
02a4
02a4			CALL L1F45        ; Use Workspace RAM configuration (physical RAM bank 7).
02a7			LD   A,($EC0E)    ; Fetch mode.
02aa			CALL L1F20        ; Use Normal RAM Configuration (physical RAM bank 0).
02ad
02ad			CP   $04          ; Calculator mode?
02af			JP   NZ,L17AF     ; Jump if not to parse and execute the BASIC command line, returning to $02BA (ROM 0).
02b2
02b2			;Calculator mode
02b2
02b2			CALL L2297        ; Is it a single LET command?
02b5			JP   Z,L17AF      ; Jump if so to parse and execute the BASIC command line, returning to $02BA (ROM 0).
02b8
02b8			;Otherwise ignore the command
02b8
02b8			POP  HL           ; Drop ONERR return address.
02b9			RET               ;
02ba
02ba			; -----------------------------------
02ba			; Return from BASIC Line Syntax Check
02ba			; -----------------------------------
02ba			; This routine is returned to when a BASIC line has been syntax checked.
02ba
02ba	L02BA:  BIT  7,(IY+$00)   ; Test ERR_NR.
02be			JR   NZ,L02C1     ; Jump ahead if no error.
02c0
02c0			RET               ; Simply return if an error.
02c1
02c1			;The syntax check was successful, so now proceed to parse the line for insertion or execution
02c1
02c1	L02C1:  LD   HL,($5C59)   ; ELINE. Point to start of editing area.
02c4			LD   ($5C5D),HL   ; Store in CH_ADD.
02c7			RST  28H          ;
02c8			DEFW E_LINE_NO    ; $19FB. Call E_LINE_NO in ROM 1 to read the line number into editing area.
02ca			LD   A,B          ;
02cb			OR   C            ;
02cc			JP   NZ,L03F7     ; Jump ahead if there was a line number.
02cf
02cf			; --------------------------------------
02cf			; Parse a BASIC Line with No Line Number
02cf			; --------------------------------------
02cf
02cf			RST  18H          ; Get character.
02d0			CP   $0D          ; End of the line reached, i.e. no BASIC statement?
02d2			RET  Z            ; Return if so.
02d3
02d3			CALL L21EF        ; Clear screen if it requires it.
02d6
02d6			BIT  6,(IY+$02)   ; TVFLAG. Clear lower screen?
02da			JR   NZ,L02DF     ; Jump ahead if no need to clear lower screen.
02dc
02dc			RST  28H          ;
02dd			DEFW CLS_LOWER    ; $0D6E. Clear the lower screen.
02df
02df	L02DF:  RES  6,(IY+$02)   ; TVFLAG. Signal to clear lower screen.
02e3
02e3			CALL L1F45        ; Use Workspace RAM configuration (physical RAM bank 7).
02e6
02e6			LD   HL,$EC0D     ; Editor flags.
02e9			BIT  6,(HL)       ; Using lower screen area for editing?
02eb			JR   NZ,L02F4     ; Jump ahead if so.
02ed
02ed			INC  HL           ;
02ee			LD   A,(HL)       ; Fetch the mode.
02ef			CP   $00          ; In Edit Menu mode?
02f1			CALL Z,L3881      ; If so then clear lower editing area display.
02f4
02f4	L02F4:  CALL L1F20        ; Use Normal RAM Configuration (physical RAM bank 0).
02f7
02f7			LD   HL,$5C3C     ; TVFLAG.
02fa			RES  3,(HL)       ; Signal mode has not changed.
02fc
02fc			LD   A,$19        ; 25.
02fe			SUB  (IY+$4F)     ; S_POSN+1. Subtract the current print row position.
0301			LD   ($5C8C),A    ; SCR_CT. Set the number of scrolls.
0304
0304			SET  7,(IY+$01)   ; FLAGS. Not syntax checking.
0308
0308			LD   (IY+$0A),$01 ; NSPPC. Set line to be jumped to as line 1.
030c
030c			; [*BUG* - Whenever a typed in command is executed directly from the editing workspace, a new GO SUB marker is set up on the
030c			;          stack. Any existing GO SUB calls that were on the stack are lost and as a result attempting to continue the program
030c			;          (without the use of CLEAR or RUN) will likely lead to a "7 RETURN without GOSUB" error report message being displayed.
030c			;          However, the stack marker will already have been lost due to the error handler routine at $0321. The first action it
030c			;          does is to reset the stack pointer to point to the location of RAMTOP, i.e. after the GO SUB marker. This is why it is
030c			;          necessary for a new GO SUB marker needs to be set up. Credit: Michal Skrzypek]
030c
030c			LD   HL,$3E00     ; The end of GO SUB stack marker.
030f			PUSH HL           ; Place it on the stack.
0310
0310			LD   HL,ONERR     ; $5B1D. The return address should an error occur.
0313			PUSH HL           ; Place it on the stack.
0314
0314			LD   ($5C3D),SP   ; ERR_SP. Store error routine address.
0318
0318			LD   HL,L0321     ; Address of error handler routine in ROM 0.
031b			LD   (SYNRET),HL  ; $5B8B. Store it in SYNRET.
031e
031e			JP   L1838        ; Jump ahead to the main parser routine to execute the line.
0321
0321
0321			; ===============================
0321			; ERROR HANDLER ROUTINES - PART 3
0321			; ===============================
0321
0321			; ---------------------
0321			; Error Handler Routine
0321			; ---------------------
0321
0321			; [*BUG* - Upon terminating a BASIC program, either via reaching the end of the program or due to an error occurring,
0321			;          execution is passed to this routine. The first action it does is to reset the stack pointer to point to the
0321			;          location of RAMTOP, i.e. after the GO SUB marker. However, this means that any existing GO SUB calls that
0321			;          were on the stack are lost and so attempting to continue the program (without the use of CLEAR or RUN) will
0321			;          likely lead to a "7 RETURN without GOSUB" error report message being displayed. When a new typed in command
0321			;          is executed, the code at $030C sets up a new GO SUB marker on the stack. Credit: Michal Skrzypek]
0321
0321	L0321:  LD   SP,($5CB2)   ; RAMTOP.
0325			INC  SP           ; Reset SP to top of memory map.
0326
0326			LD   HL,TSTACK    ; $5BFF.
0329			LD   (OLDSP),HL   ; $5B81. Use the temporary stack as the previous stack.
032c
032c			HALT              ; Trap error conditions where interrupts are disabled.
032d
032d			RES  5,(IY+$01)   ; FLAGS. Signal no new key.
0331			LD   HL,FLAGS3    ; $5B66.
0334			BIT  2,(HL)       ; Editing RAM disk catalogue?
0336			JR   Z,L034A      ; Jump if not.
0338
0338			CALL L1F45        ; Use Workspace RAM configuration (physical RAM bank 7).
033b
033b			LD   IX,(SFNEXT)  ; $5B83.
033f			LD   BC,$0014     ; Catalogue entry size.
0342			ADD  IX,BC        ; Remove last entry.
0344			CALL L1D56        ; Update catalogue entry (leaves logical RAM bank 4 paged in).
0347
0347			CALL L1F20        ; Use Normal RAM Configuration (physical RAM bank 0).
034a
034a			;Display error code held in ERR_NR
034a
034a	L034A:  LD   A,($5C3A)    ; Fetch error number from ERR_NR.
034d			INC  A            ; Increment to give true error code.
034e
034e	L034E:  PUSH AF           ; Save the error code.
034f
034f			LD   HL,$0000     ;
0352			LD   (IY+$37),H   ; FLAGX. Ensure not INPUT mode.
0355			LD   (IY+$26),H   ; X_PTR_hi. Clear to suppress error '?' marker.
0358			LD   ($5C0B),HL   ; DEFADD. Clear to signal no defined function is currently being evaluated.
035b
035b			LD   HL,$0001     ; [Could have saved 2 bytes by using INC L].
035e			LD   ($5C16),HL   ; STRMS+$0006. Ensure STRMS-00 specifies the keyboard.
0361
0361			RST  28H          ;
0362			DEFW SET_MIN      ; $16B0. Clears editing area and areas after it.
0364			RES  5,(IY+$37)   ; FLAGX. Signal not INPUT mode. [Redundant since all flags were reset earlier]
0368
0368			RST  28H          ;
0369			DEFW CLS_LOWER    ; $0D6E. Clear lower editing screen.
036b			SET  5,(IY+$02)   ; TVFLAG. Signal lower screen requires clearing.
036f
036f			POP  AF           ; Retrieve error code.
0370			LD   B,A          ; Store error code in B.
0371			CP   $0A          ; Is it a numeric error code (1-9), i.e. suitable for immediate display?
0373			JR   C,L037F      ; If so jump ahead to display it.
0375
0375			CP   $1D          ; Is it one of the standard errors (A-R)?
0377			JR   C,L037D      ; If so jump ahead to convert it into an upper case letter.
0379
0379			ADD  A,$14        ; Otherwise convert it into a lower case letter.
037b			JR   L037F        ; Jump ahead to display it.
037d			; [Could have saved 2 bytes by using ADD A,$0C instead of these two instructions]
037d
037d	L037D:  ADD  A,$07        ; Increase code to point to upper case letters.
037f
037f	L037F:  RST  28H          ;
0380			DEFW OUT_CODE     ; $15EF. Display the character held in the A register.
0382
0382			LD   A,$20        ; Display a space.
0384			RST  10H          ;
0385			LD   A,B          ; Retrieve the error code.
0386			CP   $1D          ; Is it one of the standard errors (A-R)?
0388			JR   C,L039C      ; Jump if an standard error message (A-R).
038a
038a			;Display a new error message
038a
038a			; [Note that there is no test to range check the error code value and therefore whether a message exists for it.
038a			; Poking directly to system variable ERR_NR with an invalid code (43 or above) will more than likely cause a crash]
038a
038a			SUB  $1D          ; A=Code $00 - $0E.
038c			LD   B,$00        ;
038e			LD   C,A          ; Pass code to BC.
038f			LD   HL,L046C     ; Error message vector table.
0392			ADD  HL,BC        ;
0393			ADD  HL,BC        ; Find address in error message vector table.
0394
0394			LD   E,(HL)       ;
0395			INC  HL           ;
0396			LD   D,(HL)       ; DE=Address of message to print.
0397
0397			CALL L057D        ; Print error message.
039a			JR   L03A2        ; Jump ahead.
039c
039c			;Display a standard error message.
039c
039c	L039C:  LD   DE,ERROR_MSGS ; $1391. Position of the error messages in ROM 1.
039f			RST  28H          ; A holds the error code.
03a0			DEFW PO_MSG       ; $0C0A. Call message printing routine.
03a2
03a2			;Continue to display the line and statement number
03a2
03a2	L03A2:  XOR  A            ; Select the first message ", " (a 'comma' and a 'space').
03a3			LD   DE,MESSAGES-1 ; $1536. Message base address in ROM 1.
03a6			RST  28H          ;
03a7			DEFW PO_MSG       ; Print a comma followed by a space.
03a9
03a9			LD   BC,($5C45)   ; PPC. Fetch current line number.
03ad			RST  28H          ;
03ae			DEFW OUT_NUM_1    ; $1A1B. Print the line number.
03b0
03b0			LD   A,$3A        ; Print ':'.
03b2			RST  10H          ;
03b3
03b3			LD   C,(IY+$0D)   ; SUBPPC. Fetch current statement number.
03b6			LD   B,$00        ;
03b8			RST  28H          ;
03b9			DEFW OUT_NUM_1    ; $1A1B. Print the statement number.
03bb
03bb			RST  28H          ;
03bc			DEFW CLEAR_SP     ; $1097. Clear editing and workspace areas.
03be
03be			LD   A,($5C3A)    ; ERR_NR. Fetch the error code.
03c1			INC  A
03c2			JR   Z,L03DF      ; Jump ahead for "0 OK".
03c4
03c4			CP   $09          ;
03c6			JR   Z,L03CC      ; Jump for "A Invalid argument", thereby advancing to the next statement.
03c8
03c8			CP   $15          ;
03ca			JR   NZ,L03CF     ; Jump unless "M Ramtop no good".
03cc
03cc	L03CC:  INC  (IY+$0D)     ; SUBPPC. Advance to the next statement.
03cf
03cf	L03CF:  LD   BC,$0003     ;
03d2			LD   DE,$5C70     ; OSPPC. Continue statement number.
03d5			LD   HL,$5C44     ; NSPPC. Next statement number.
03d8			BIT  7,(HL)       ; Is there a statement number?
03da			JR   Z,L03DD      ; Jump if so.
03dc
03dc			ADD  HL,BC        ; HL=SUBPPC. The current statement number.
03dd
03dd	L03DD:  LDDR              ; Copy SUBPPC and PPC to OSPPC and OLDPPC, for use by CONTINUE.
03df
03df	L03DF:  LD   (IY+$0A),$FF ; NSPPC. Signal no current statement number.
03e3			RES  3,(IY+$01)   ; FLAGS. Select K-Mode.
03e7			LD   HL,FLAGS3    ; $5B66.
03ea			RES  0,(HL)       ; Select 128 Editor mode.
03ec			JP   L25CB        ; Jump ahead to return control to the Editor.
03ef
03ef			; ---------------------------------------------
03ef			; Error Handler Routine When Parsing BASIC Line
03ef			; ---------------------------------------------
03ef
03ef	L03EF:  LD   A,$10        ; Error code 'G - No room for line'.
03f1			LD   BC,$0000     ;
03f4			JP   L034E        ; Jump to print the error code.
03f7
03f7
03f7			; ===================================
03f7			; COMMAND EXECUTION ROUTINES - PART 2
03f7			; ===================================
03f7
03f7			; -------------------------------------
03f7			; Parse a BASIC Line with a Line Number
03f7			; -------------------------------------
03f7			; This routine handles insertion of a BASIC line specified with a line number, or just a line number
03f7			; specified on its own, i.e. delete the line.
03f7
03f7	L03F7:  LD   ($5C49),BC   ; E_PPC. Store the line as the current line number with the program cursor.
03fb
03fb			CALL L1F45        ; Use Workspace RAM configuration (physical RAM bank 7).
03fe
03fe			LD   A,B          ; [This test could have been performed before paging in bank 7 and hence could have benefited from a slight speed improvement.
03ff			OR   C            ; The test is redundant since BC holds a non-zero line number]
0400			JR   Z,L040A      ; Jump if no line number.
0402
0402			LD   ($5C49),BC   ; E_PPC. Current edit line number. [Redundant instruction - Line number has already been stored]
0406			LD   ($EC08),BC   ; Temporary E_PPC used by BASIC Editor.
040a
040a	L040A:  CALL L1F20        ; Use Normal RAM Configuration (physical RAM bank 0).
040d
040d			LD   HL,($5C5D)   ; CH_ADD. Point to the next character in the BASIC line.
0410			EX   DE,HL        ;
0411
0411			LD   HL,L03EF     ; Address of error handler routine should there be no room for the line.
0414			PUSH HL           ; Stack it.
0415
0415			LD   HL,($5C61)   ; WORKSP.
0418			SCF               ;
0419			SBC  HL,DE        ; HL=Length of BASIC line.
041b			PUSH HL           ; Stack it.
041c
041c			LD   H,B          ;
041d			LD   L,C          ; Transfer edit line number to HL.
041e			RST  28H          ;
041f			DEFW LINE_ADDR    ; $196E. Returns address of the line in HL.
0421			JR   NZ,L0429     ; Jump if the line does not exist.
0423
0423			;The line already exists so delete it
0423
0423			RST  28H          ;
0424			DEFW NEXT_ONE     ; $19B8. Find the address of the next line.
0426			RST  28H          ;
0427			DEFW RECLAIM_2    ; $19E8. Delete the line.
0429
0429	L0429:  POP  BC           ; BC=Length of the BASIC line.
042a			LD   A,C          ;
042b			DEC  A            ; Is it 1, i.e. just an 'Enter' character, and hence only
042c			OR   B            ; a line number was entered?
042d			JR   NZ,L0442     ; Jump if there is a BASIC statement.
042f
042f			;Just a line number entered. The requested line has already been deleted so move the program cursor to the next line
042f
042f			CALL L1F45        ; Use Workspace RAM configuration (physical RAM bank 7).
0432			PUSH HL           ; Save the address of the line.
0433
0433			LD   HL,($5C49)   ; E_PPC. Fetch current edit line number.
0436			CALL L334A        ; Find closest line number (or $0000 if no line).
0439			LD   ($5C49),HL   ; E_PPC. Store current edit line number. Effectively refresh E_PPC.
043c
043c			POP  HL           ; HL=Address of the line.
043d			CALL L1F20        ; Use Normal RAM Configuration (physical RAM bank 0).
0440			JR   L046A        ; Jump ahead to exit.
0442
0442	L0442:  PUSH BC           ; BC=Length of the BASIC line. Stack it.
0443
0443			INC  BC           ;
0444			INC  BC           ;
0445			INC  BC           ;
0446			INC  BC           ; BC=BC+4. Allow for line number and length bytes.
0447
0447			DEC  HL           ; Point to before the current line, i.e. the location to insert bytes at.
0448
0448			LD   DE,($5C53)   ; PROG. Get start address of the BASIC program.
044c			PUSH DE           ; Stack it.
044d
044d			RST  28H          ;
044e			DEFW MAKE_ROOM    ; $1655. Insert BC spaces at address HL.
0450
0450			POP  HL           ; HL=Start address of BASIC program.
0451			LD   ($5C53),HL   ; PROG. Save start address of BASIC program.
0454
0454			POP  BC           ; BC=Length of the BASIC line.
0455			PUSH BC           ;
0456
0456			INC  DE           ; Point to the first location of the newly created space.
0457			LD   HL,($5C61)   ; WORKSP. Address of end of the BASIC line in the workspace.
045a			DEC  HL           ;
045b			DEC  HL           ; Skip over the newline and terminator bytes.
045c			LDDR              ; Copy the BASIC line from the workspace into the program area.
045e			LD   HL,($5C49)   ; E_PPC. Current edit line number.
0461			EX   DE,HL        ;
0462
0462			POP  BC           ; BC=Length of BASIC line.
0463			LD   (HL),B       ; Store the line length.
0464			DEC  HL           ;
0465			LD   (HL),C       ;
0466			DEC  HL           ;
0467			LD   (HL),E       ; DE=line number.
0468			DEC  HL           ;
0469			LD   (HL),D       ; Store the line number.
046a
046a	L046A:  POP  AF           ; Drop item (address of error handler routine).
046b			RET               ; Exit with HL=Address of the line.
046c
046c
046c			; ===============================
046c			; ERROR HANDLER ROUTINES - PART 4
046c			; ===============================
046c
046c			; ------------------------------
046c			; New Error Message Vector Table
046c			; ------------------------------
046c			; Pointers into the new error message table.
046c
046c	L046C:  DEFW L048C        ; Error report 'a'.
046e			DEFW L0497        ; Error report 'b'.
0470			DEFW L04A6        ; Error report 'c'.
0472			DEFW L04B0        ; Error report 'd'.
0474			DEFW L04C1        ; Error report 'e'.
0476			DEFW L04D4        ; Error report 'f'.
0478			DEFW L04E0        ; Error report 'g'.
047a			DEFW L04E0        ; Error report 'h'.
047c			DEFW L04F3        ; Error report 'i'.
047e			DEFW L0501        ; Error report 'j'.
0480			DEFW L0512        ; Error report 'k'.
0482			DEFW L0523        ; Error report 'l'
0484			DEFW L0531        ; Error report 'm'.
0486			DEFW L0542        ; Error report 'n'.
0488			DEFW L054E        ; Error report 'o'.
048a			DEFW L0561        ; Error report 'p'.
048c
048c			; -----------------------
048c			; New Error Message Table
048c			; -----------------------
048c
048c	L048C:  DEFM "MERGE erro"                  ; Report 'a'.
0496			DEFB $80+'r'
0497	L0497:  DEFM "Wrong file typ"              ; Report 'b'.
04a5			DEFB $80+'e'
04a6	L04A6:  DEFM "CODE erro"                   ; Report 'c'.
04af			DEFB $80+'r'
04b0	L04B0:  DEFM "Too many bracket"            ; Report 'd'.
04c0			DEFB $80+'s'
04c1	L04C1:  DEFM "File already exist"          ; Report 'e'.
04d3			DEFB $80+'s'
04d4	L04D4:  DEFM "Invalid nam"                 ; Report 'f'.
04df			DEFB $80+'e'
04e0	L04E0:  DEFM "File does not exis"          ; Report 'g' & 'h'.
04f2			DEFB $80+'t'
04f3	L04F3:  DEFM "Invalid devic"               ; Report 'i'.
0500			DEFB $80+'e'
0501	L0501:  DEFM "Invalid baud rat"            ; Report 'j'.
0511			DEFB $80+'e'
0512	L0512:  DEFM "Invalid note nam"            ; Report 'k'.
0522			DEFB $80+'e'
0523	L0523:  DEFM "Number too bi"               ; Report 'l'.
0530			DEFB $80+'g'
0531	L0531:  DEFM "Note out of rang"            ; Report 'm'.
0541			DEFB $80+'e'
0542	L0542:  DEFM "Out of rang"                 ; Report 'n'.
054d			DEFB $80+'e'
054e	L054E:  DEFM "Too many tied note"          ; Report 'o'.
0560			DEFB $80+'s'
0561	L0561:  DEFB $7F                           ; '(c)'.
0562			DEFM " 1986 Sinclair Research Lt"  ; Copyright. [There should have been an error report "p Bad parameterr" here as there was in the Spanish 128,
057c			DEFB $80+'d'                       ; or the error code byte at $232F (ROM 0) should have been $19 for "Q Parameter error"]
057d
057d			; -------------
057d			; Print Message
057d			; -------------
057d			; Print a message which is terminated by having bit 7 set, pointed at by DE.
057d
057d	L057D:  LD   A,(DE)       ; Fetch next byte.
057e			AND  $7F          ; Mask off top bit.
0580			PUSH DE           ; Save address of current message byte.
0581			RST  10H          ; Print character.
0582			POP  DE           ; Restore message byte pointer.
0583			LD   A,(DE)       ;
0584			INC  DE           ;
0585			ADD  A,A          ; Carry flag will be set if byte is $FF.
0586			JR   NC,L057D     ; Else print next character.
0588
0588			RET               ;
0589
0589			; ================================
0589			; INITIALISATION ROUTINES - PART 3
0589			; ================================
0589
0589			; ---------------------------------
0589			; The 'Initial Channel Information'
0589			; ---------------------------------
0589			; Initially there are four channels ('K', 'S', 'R', & 'P') for communicating with the 'keyboard', 'screen', 'work space' and 'printer'.
0589			; For each channel the output routine address comes before the input routine address and the channel's code.
0589			; This table is almost identical to that in ROM 1 at $15AF but with changes to the channel P routines to use the RS232 port
0589			; instead of the ZX Printer.
0589			; Used at $01DD (ROM 0).
0589
0589	L0589:  DEFW PRINT_OUT    ; $09F4 - K channel output routine.
058b			DEFW KEY_INPUT    ; $10A8 - K channel input routine.
058d			DEFB 'K'          ; $4B   - Channel identifier 'K'.
058e			DEFW PRINT_OUT    ; $09F4 - S channel output routine.
0590			DEFW REPORT_J     ; $15C4 - S channel input routine.
0592			DEFB 'S'          ; $53   - Channel identifier 'S'.
0593			DEFW ADD_CHAR     ; $0F81 - R channel output routine.
0595			DEFW REPORT_J     ; $15C4 - R channel input routine.
0597			DEFB 'R'          ; $52   - Channel identifier 'R'.
0598			DEFW POUT         ; $5B34 - P Channel output routine.
059a			DEFW PIN          ; $5B2F - P Channel input routine.
059c			DEFB 'P'          ; $50   - Channel identifier 'P'.
059d			DEFB $80          ; End marker.
059e
059e			; -------------------------
059e			; The 'Initial Stream Data'
059e			; -------------------------
059e			; Initially there are seven streams - $FD to $03.
059e			; This table is identical to that in ROM 1 at $15C6.
059e			; Used at $0226 (ROM 0).
059e
059e	L059E:  DEFB $01, $00     ; Stream $FD leads to channel 'K'.
05a0			DEFB $06, $00     ; Stream $FE leads to channel 'S'.
05a2			DEFB $0B, $00     ; Stream $FF leads to channel 'R'.
05a4			DEFB $01, $00     ; Stream $00 leads to channel 'K'.
05a6			DEFB $01, $00     ; Stream $01 leads to channel 'K'.
05a8			DEFB $06, $00     ; Stream $02 leads to channel 'S'.
05aa			DEFB $10, $00     ; Stream $03 leads to channel 'P'.
05ac
05ac
05ac			; ===============================
05ac			; ERROR HANDLER ROUTINES - PART 5
05ac			; ===============================
05ac
05ac			; --------------------
05ac			; Produce Error Report
05ac			; --------------------
05ac
05ac	L05AC:  POP  HL           ; Point to the error byte.
05ad			LD   BC,$7FFD     ;
05b0			XOR  A            ; ROM 0, Screen 0, Bank 0, 128 mode.
05b1			DI                ; Ensure interrupts disable whilst paging.
05b2			LD   (BANK_M),A   ; $5B5C. Store new state in BANK_M.
05b5			OUT  (C),A        ; Switch to ROM 0.
05b7			EI                ;
05b8
05b8			LD   SP,($5C3D)   ; Restore SP from ERR_SP.
05bc			LD   A,(HL)       ; Fetch the error number.
05bd			LD   (RAMERR),A   ; $5B5E. Store the error number.
05c0			INC  A            ;
05c1			CP   $1E          ; [*BUG* - This should be $1D. As such, error code 'a' will be diverted to ROM 1 for handling. Credit: Paul Farrow]
05c3			JR   NC,L05C8     ; Jump if not a standard error code.
05c5
05c5			;Handle a standard error code
05c5
05c5			RST  28H          ;
05c6			DEFW RAMRST       ; $5B5D. Call the error handler routine in ROM 1.
05c8
05c8			;Handle a new error code
05c8
05c8	L05C8:  DEC  A            ;
05c9			LD   (IY+$00),A   ; Store in ERR_NR.
05cc			LD   HL,($5C5D)   ; CH_ADD.
05cf			LD   ($5C5F),HL   ; X_PTR. Set up the address of the character after the '?' marker.
05d2
05d2			RST  28H          ;
05d3			DEFW SET_STK      ; $16C5. Set the calculator stack.
05d5			RET               ; Return to the error routine.
05d6
05d6			; ----------------------------
05d6			; Check for BREAK into Program
05d6			; ----------------------------
05d6
05d6	L05D6:  LD   A,$7F        ; Read keyboard row B - SPACE.
05d8			IN   A,($FE)      ;
05da			RRA               ; Extract the SPACE key.
05db			RET  C            ; Return if SPACE not pressed.
05dc
05dc			LD   A,$FE        ; Read keyboard row CAPS SHIFT - V.
05de			IN   A,($FE)      ;
05e0			RRA               ; Extract the CAPS SHIFT key.
05e1			RET  C            ; Return if CAPS SHIFT not pressed.
05e2
05e2			CALL L05AC        ; Produce an error.
05e5			DEFB $14          ; "L Break into program"
05e6
05e6
05e6			; ======================
05e6			; RS232 PRINTER ROUTINES
05e6			; ======================
05e6
05e6			; ------------------------------
05e6			; RS232 Channel Handler Routines
05e6			; ------------------------------
05e6			; This routine handles input and output RS232 requested. It is similar to the
05e6			; routine in the ZX Interface 1 ROM at $0D5A, but in that ROM the routine is only used
05e6			; for input.
05e6
05e6	L05E6:  EI                ; Enabled interrupts.
05e7			EX   AF,AF'       ; Save AF registers.
05e8			LD   DE,POUT2     ; $5B4A. Address of the RS232 exit routine held in RAM.
05eb			PUSH DE           ; Stack it.
05ec
05ec			RES  3,(IY+$02)   ; TVFLAG. Indicate not automatic listing.
05f0			PUSH HL           ; Save the input/output routine address.
05f1
05f1			LD   HL,($5C3D)   ; Fetch location of error handler routine from ERR_SP.
05f4			LD   E,(HL)       ;
05f5			INC  HL           ;
05f6			LD   D,(HL)       ; DE=Address of error handler routine.
05f7			AND  A            ;
05f8			LD   HL,ED_ERROR  ; $107F in ROM 1.
05fb			SBC  HL,DE        ;
05fd			JR   NZ,L0637     ; Jump if error handler address is different, i.e. due to INKEY$# or PRINT#.
05ff
05ff			; Handle INPUT#
05ff			; -------------
05ff
05ff			POP  HL           ; Retrieve the input/output routine address.
0600			LD   SP,($5C3D)   ; ERR_SP.
0604			POP  DE           ; Discard the error handler routine address.
0605			POP  DE           ; Fetch the original address of ERR_SP (this was stacked at the beginning of the INPUT routine in ROM 1).
0606			LD   ($5C3D),DE   ; ERR_SP.
060a
060a	L060A:  PUSH HL           ; Save the input/output routine address.
060b			LD   DE,L0610     ; Address to return to.
060e			PUSH DE           ; Stack the address.
060f			JP   (HL)         ; Jump to the RS232 input/output routine.
0610
0610			;Return here from the input/output routine
0610
0610	L0610:  JR   C,L061B      ; Jump if a character was received.
0612			JR   Z,L0618      ; Jump if a character was not received.
0614
0614	L0614:  CALL L05AC        ; Produce an error "8 End of file".
0617			DEFB $07          ;
0618
0618			;A character was not received
0618
0618	L0618:  POP  HL           ; Retrieve the input routine address.
0619			JR   L060A        ; Jump back to await another character.
061b
061b			;A character was received
061b
061b	L061B:  CP   $0D          ; Is it a carriage return?
061d			JR   Z,L062D      ; Jump ahead if so.
061f
061f			LD   HL,(RETADDR) ; $5B5A. Fetch the return address.
0622			PUSH HL           ;
0623
0623			RST  28H          ;
0624			DEFW ADD_CHAR+4   ; $0F85. Insert the character into the INPUT line.
0626
0626			POP  HL           ;
0627			LD   (RETADDR),HL ; $5B5A. Restore the return address.
062a
062a			POP  HL           ; Retrieve the input routine address.
062b			JR   L060A        ; Jump back to await another character.
062d
062d			;Enter was received so end reading the stream
062d
062d	L062D:  POP  HL           ; Discard the input routine address.
062e			LD   A,(BANK_M)   ; $5B5C. Fetch current paging configuration.
0631			OR   $10          ; Select ROM 1.
0633			PUSH AF           ; Stack the required paging configuration.
0634			JP   POUT2        ; $5B4A. Exit.
0637
0637			; Handle INKEY$# and PRINT#
0637			; -------------------------
0637
0637	L0637:  POP  HL           ; Retrieve the input/output routine address.
0638			LD   DE,L063D     ;
063b			PUSH DE           ; Stack the return address.
063c			JP   (HL)         ; Jump to input or output routine.
063d
063d			;Return here from the input/output routine. When returning from the output routine, either the carry or zero flags should always
063d			;be set to avoid the false generation of error report "8 End of file" [though this is not always the case - see bugs starting at $086C (ROM 0)].
063d
063d	L063D:  RET  C            ; Return if a character was received.
063e			RET  Z            ; Return if a character was not received or was written.
063f
063f			JR   L0614        ; Produce error report "8 End of file".
0641
0641			; --------------
0641			; FORMAT Routine
0641			; --------------
0641			; The format command sets the RS232 baud rate, e.g. FORMAT "P"; 9600.
0641			; It attempts to match against one of the supported baud rates, or uses the next
0641			; higher baud rate if a non-standard value is requested. The maximum baud rate supported
0641			; is 9600, and this is used for any rates specified that are higher than this.
0641
0641	L0641:  RST  28H          ; [Could just do RST $18]
0642			DEFW GET_CHAR     ; $0018.
0644			RST  28H          ; Get an expression.
0645			DEFW EXPT_EXP     ; $1C8C.
0647			BIT  7,(IY+$01)   ; FLAGS.
064b			JR   Z,L0661      ; Jump ahead if syntax checking.
064d
064d			RST  28H          ;
064e			DEFW STK_FETCH    ; $2BF1. Fetch the expression.
0650			LD   A,C          ;
0651			DEC  A            ;
0652			OR   B            ;
0653			JR   Z,L0659      ; Jump ahead if string is 1 character long.
0655
0655			CALL L05AC        ; Produce error report.
0658			DEFB $24          ; "i Invalid device".
0659
0659	L0659:  LD   A,(DE)       ; Get character.
065a			AND  $DF          ; Convert to upper case.
065c			CP   'P'          ; $50. Is it channel 'P'?
065e			JP   NZ,L1912     ; Jump if not to produce error report "C Nonsense in BASIC".
0661
0661	L0661:  LD   HL,($5C5D)   ; CH_ADD. Next character to be interpreted.
0664			LD   A,(HL)       ;
0665			CP   $3B          ; Next character must be ';'.
0667			JP   NZ,L1912     ; Jump if not to produce error report "C Nonsense in BASIC".
066a
066a			RST  28H          ; Skip past the ';' character.
066b			DEFW NEXT_CHAR    ; $0020. [Could just do RST $20]
066d			RST  28H          ; Get a numeric expression from the line.
066e			DEFW EXPT_1NUM    ; $1C82.
0670			BIT  7,(IY+$01)   ; FLAGS. Checking syntax mode?
0674			JR   Z,L067D      ; Jump ahead if so.
0676
0676			RST  28H          ; Get the result as an integer.
0677			DEFW FIND_INT2    ; $1E99.
0679			LD   (HD_00),BC   ; $5B71. Store the result temporarily for use later.
067d
067d	L067D:  RST  28H          ; [Could just do RST $18]
067e			DEFW GET_CHAR     ; $0018. Get the next character in the BASIC line.
0680			CP   $0D          ; It should be ENTER.
0682			JR   Z,L0689      ; Jump ahead if it is.
0684
0684			CP   ':'          ; $3A. Or the character is allowed to be ':'.
0686			JP   NZ,L1912     ; Jump if not to produce error report "C Nonsense in BASIC".
0689
0689	L0689:  CALL L18A1        ; Check for end of line.
068c			LD   BC,(HD_00)   ; $5B71. Get the baud rate saved earlier.
0690			LD   A,B          ; Is it zero?
0691			OR   C            ;
0692			JR   NZ,L0698     ; Jump if not, i.e. a numeric value was specified.
0694
0694			CALL L05AC        ; Produce error report.
0697			DEFB $25          ; "j invalid baud rate"
0698
0698			;Lookup the timing constant to use for the specified baud rate
0698
0698	L0698:  LD   HL,L06B8     ; Table of supported baud rates.
069b
069b	L069B:  LD   E,(HL)       ;
069c			INC  HL           ;
069d			LD   D,(HL)       ;
069e			INC  HL           ;
069f			EX   DE,HL        ; HL=Supported baud rate value.
06a0			LD   A,H          ;
06a1			CP   $25          ; Reached the last baud rate value in the table?
06a3			JR   NC,L06AF     ; Jump is so to use a default baud rate of 9600.
06a5
06a5			AND  A            ;
06a6			SBC  HL,BC        ; Table entry matches or is higher than requested baud rate?
06a8			JR   NC,L06AF     ; Jump ahead if so to use this baud rate.
06aa
06aa			EX   DE,HL        ;
06ab			INC  HL           ; Skip past the timing constant value
06ac			INC  HL           ; for this baud rate entry.
06ad			JR   L069B        ;
06af
06af			;The baud rate has been matched
06af
06af	L06AF:  EX   DE,HL        ; HL points to timing value for the baud rate.
06b0			LD   E,(HL)       ;
06b1			INC  HL           ;
06b2			LD   D,(HL)       ; DE=Timing value for the baud rate.
06b3			LD   (BAUD),DE    ; $5B71. Store new value in system variable BAUD.
06b7			RET               ;
06b8
06b8			; ---------------
06b8			; Baud Rate Table
06b8			; ---------------
06b8			; Consists of entries of baud rate value followed by timing constant to use in the RS232 routines.
06b8
06b8	L06B8:  DEFW $0032, $0AA5  ; Baud=50.
06bc			DEFW $006E, $04D4  ; Baud=110.
06c0			DEFW $012C, $01C3  ; Baud=300.
06c4			DEFW $0258, $00E0  ; Baud=600.
06c8			DEFW $04B0, $006E  ; Baud=1200.
06cc			DEFW $0960, $0036  ; Baud=2400.
06d0			DEFW $12C0, $0019  ; Baud=4800.
06d4			DEFW $2580, $000B  ; Baud=9600.
06d8
06d8			; -------------------
06d8			; RS232 Input Routine
06d8			; -------------------
06d8			; Exit: Carry flag set if a byte was read with the byte in A. Carry flag reset upon error.
06d8
06d8	L06D8:  LD   HL,SERFL     ; $5B61. SERFL holds second char that can be received
06db			LD   A,(HL)       ; Is the second-character received flag set?
06dc			AND  A            ; i.e. have we already received data?
06dd			JR   Z,L06E5      ; Jump ahead if not.
06df
06df			LD   (HL),$00     ; Otherwise clear the flag
06e1			INC  HL           ;
06e2			LD   A,(HL)       ; and return the data which we received earlier.
06e3			SCF               ; Set carry flag to indicate success
06e4			RET               ;
06e5
06e5			; -------------------------
06e5			; Read Byte from RS232 Port
06e5			; -------------------------
06e5			; The timing of the routine is achieved using the timing constant held in system variable BAUD.
06e5			; Exit: Carry flag set if a byte was read, or reset upon error.
06e5			;       A=Byte read in.
06e5
06e5	L06E5:  CALL L05D6        ; Check the BREAK key, and produce error message if it is being pressed.
06e8
06e8			DI                ; Ensure interrupts are disabled to achieve accurate timing.
06e9
06e9			EXX               ;
06ea
06ea			LD   DE,(BAUD)    ; $5B71. Fetch the baud rate timing constant.
06ee			LD   HL,(BAUD)    ; $5B71.
06f1			SRL  H            ;
06f3			RR   L            ; HL=BAUD/2. So that will sync to half way point in each bit.
06f5
06f5			OR   A            ; [Redundant byte]
06f6
06f6			LD   B,$FA        ; Waiting time for start bit.
06f8			EXX               ; Save B.
06f9			LD   C,$FD        ;
06fb			LD   D,$FF        ;
06fd			LD   E,$BF        ;
06ff			LD   B,D          ;
0700			LD   A,$0E        ;
0702			OUT  (C),A        ; Selects register 14, port I/O of AY-3-8912.
0704
0704			IN   A,(C)        ; Read the current state of the I/O lines.
0706			OR   $F0          ; %11110000. Default all input lines to 1.
0708			AND  $FB          ; %11111011. Force CTS line to 0.
070a			LD   B,E          ; B=$BF.
070b			OUT  (C),A        ; Make CTS (Clear To Send) low to indicate ready to receive.
070d
070d			LD   H,A          ; Store status of other I/O lines.
070e
070e			;Look for the start bit
070e
070e	L070E:  LD   B,D          ;
070f			IN   A,(C)        ; Read the input line.
0711			AND  $80          ; %10000000. Test TXD (input) line.
0713			JR   Z,L071E      ; Jump if START BIT found.
0715
0715	L0715:  EXX               ; Fetch timeout counter
0716			DEC  B            ; and decrement it.
0717			EXX               ; Store it.
0718			JR   NZ,L070E     ; Continue to wait for start bit if not timed out.
071a
071a			XOR  A            ; Reset carry flag to indicate no byte read.
071b			PUSH AF           ; Save the failure flag.
071c			JR   L0757        ; Timed out waiting for START BIT.
071e
071e	L071E:  IN   A,(C)        ; Second test of START BIT - it should still be 0.
0720			AND  $80          ; Test TXD (input) line.
0722			JR   NZ,L0715     ; Jump back if it is no longer 0.
0724
0724			IN   A,(C)        ; Third test of START BIT - it should still be 0.
0726			AND  $80          ; Test TXD (input) line.
0728			JR   NZ,L0715     ; Jump back if it is no longer 0.
072a
072a			;A start bit has been found, so the 8 data bits are now read in.
072a			;As each bit is read in, it is shifted into the msb of A. Bit 7 of A is preloaded with a 1
072a			;to represent the start bit and when this is shifted into the carry flag it signifies that 8
072a			;data bits have been read in.
072a
072a			EXX               ;
072b			LD   BC,$FFFD     ;
072e			LD   A,$80        ; Preload A with the START BIT. It forms a shift counter used to count
0730			EX   AF,AF'       ; the number of bits to read in.
0731
0731	L0731:  ADD  HL,DE        ; HL=1.5*(BAUD).
0732
0732			NOP               ; (4) Fine tune the following delay.
0733			NOP               ;
0734			NOP               ;
0735			NOP               ;
0736
0736			;BD-DELAY
0736	L0736:  DEC  HL           ; (6) Delay for 26*BAUD.
0737			LD   A,H          ; (4)
0738			OR   L            ; (4)
0739			JR   NZ,L0736     ; (12) Jump back to until delay completed.
073b
073b			IN   A,(C)        ; Read a bit.
073d			AND  $80          ; Test TXD (input) line.
073f			JP   Z,L074B      ; Jump if a 0 received.
0742
0742			;Received one 1
0742
0742			EX   AF,AF'       ; Fetch the bit counter.
0743			SCF               ; Set carry flag to indicate received a 1.
0744			RRA               ; Shift received bit into the byte (C->76543210->C).
0745			JR   C,L0754      ; Jump if START BIT has been shifted out indicating all data bits have been received.
0747
0747			EX   AF,AF'       ; Save the bit counter.
0748			JP   L0731        ; Jump back to read the next bit.
074b
074b			;Received one 0
074b
074b	L074B:  EX   AF,AF'       ; Fetch the bit counter.
074c			OR   A            ; Clear carry flag to indicate received a 0.
074d			RRA               ; Shift received bit into the byte (C->76543210->C).
074e			JR   C,L0754      ; Jump if START BIT has been shifted out indicating all data bits have been received.
0750
0750			EX   AF,AF'       ; Save the bit counter.
0751			JP   L0731        ; Jump back to read next bit.
0754
0754			;After looping 8 times to read the 8 data bits, the start bit in the bit counter will be shifted out
0754			;and hence A will contain a received byte.
0754
0754	L0754:  SCF               ; Signal success.
0755			PUSH AF           ; Push success flag.
0756			EXX
0757
0757			;The success and failure paths converge here
0757
0757	L0757:  LD   A,H          ;
0758			OR   $04          ; A=%1111x1xx. Force CTS line to 1.
075a
075a			LD   B,E          ; B=$BF.
075b			OUT  (C),A        ; Make CTS (Clear To Send) high to indicate not ready to receive.
075d			EXX
075e
075e			LD   H,D          ;
075f			LD   L,E          ; HL=(BAUD).
0760			LD   BC,$0007     ;
0763			OR   A            ;
0764			SBC  HL,BC        ; HL=(BAUD)-7.
0766
0766	L0766:  DEC  HL           ; Delay for the stop bit.
0767			LD   A,H          ;
0768			OR   L            ;
0769			JR   NZ,L0766     ; Jump back until delay completed.
076b
076b			LD   BC,$FFFD     ; HL will be $0000.
076e			ADD  HL,DE        ; DE=(BAUD).
076f			ADD  HL,DE        ;
0770			ADD  HL,DE        ; HL=3*(BAUD). This is how long to wait for the next start bit.
0771
0771			;The device at the other end of the cable may send a second byte even though
0771			;CTS is low. So repeat the procedure to read another byte.
0771
0771	L0771:  IN   A,(C)        ; Read the input line.
0773			AND  $80          ; %10000000. Test TXD (input) line.
0775			JR   Z,L077F      ; Jump if START BIT found.
0777
0777			DEC  HL           ; Decrement timeout counter.
0778			LD   A,H          ;
0779			OR   L            ;
077a			JR   NZ,L0771     ; Jump back looping for a start bit until a timeout occurs.
077c
077c			;No second byte incoming so return status of the first byte read attempt
077c
077c			POP  AF           ; Return status of first byte read attempt - carry flag reset for no byte received or
077d			EI                ; carry flag set and A holds the received byte.
077e			RET
077f
077f	L077F:  IN   A,(C)        ; Second test of START BIT - it should still be 0.
0781			AND  $80          ; Test TXD (input) line.
0783			JR   NZ,L0771     ; Jump back if it is no longer 0.
0785
0785			IN   A,(C)        ; Third test of START BIT - it should still be 0.
0787			AND  $80          ; Test TXD (input) line.
0789			JR   NZ,L0771     ; Jump back if it is no longer 0.
078b
078b			;A second byte is on its way and is received exactly as before
078b
078b			LD   H,D          ;
078c			LD   L,E          ; HL=(BAUD).
078d			LD   BC,$0002     ;
0790			SRL  H            ;
0792			RR   L            ; HL=(BAUD)/2.
0794			OR   A            ;
0795			SBC  HL,BC        ; HL=(BAUD)/2 - 2.
0797
0797			LD   BC,$FFFD     ;
079a			LD   A,$80        ; Preload A with the START BIT. It forms a shift counter used to count
079c			EX   AF,AF'       ; the number of bits to read in.
079d
079d	L079D:  NOP               ; Fine tune the following delay.
079e			NOP               ;
079f			NOP               ;
07a0			NOP               ;
07a1
07a1			ADD  HL,DE        ; HL=1.5*(BAUD).
07a2
07a2	L07A2:  DEC  HL           ; Delay for 26*(BAUD).
07a3			LD   A,H          ;
07a4			OR   L            ;
07a5			JR   NZ,L07A2     ; Jump back to until delay completed.
07a7
07a7			IN   A,(C)        ; Read a bit.
07a9			AND  $80          ; Test TXD (input) line.
07ab			JP   Z,L07B7      ; Jump if a 0 received.
07ae
07ae			;Received one 1
07ae
07ae			EX   AF,AF'       ; Fetch the bit counter.
07af			SCF               ; Set carry flag to indicate received a 1.
07b0			RRA               ; Shift received bit into the byte (C->76543210->C).
07b1			JR   C,L07C0      ; Jump if START BIT has been shifted out indicating all data bits have been received.
07b3
07b3			EX   AF,AF'       ; Save the bit counter.
07b4			JP   L079D        ; Jump back to read the next bit.
07b7
07b7			;Received one 0
07b7
07b7	L07B7:  EX   AF,AF'       ; Fetch the bit counter.
07b8			OR   A            ; Clear carry flag to indicate received a 0.
07b9			RRA               ; Shift received bit into the byte (C->76543210->C).
07ba			JR   C,L07C0      ; Jump if START BIT has been shifted out indicating all data bits have been received.
07bc
07bc			EX   AF,AF'       ; Save the bit counter.
07bd			JP   L079D        ; Jump back to read next bit.
07c0
07c0			;Exit with the byte that was read in
07c0
07c0	L07C0:  LD   HL,SERFL     ; $5B61.
07c3			LD   (HL),$01     ; Set the flag indicating a second byte is in the buffer.
07c5			INC  HL           ;
07c6			LD   (HL),A       ; Store the second byte read in the buffer.
07c7			POP  AF           ; Return the first byte.
07c8
07c8			EI                ; Re-enable interrupts.
07c9			RET
07ca
07ca			; --------------------
07ca			; RS232 Output Routine
07ca			; --------------------
07ca			; This routine handles control codes, token expansion, graphics and UDGs. It therefore cannot send binary data and hence cannot support
07ca			; EPSON format ESC control codes [Credit: Andrew Owen].
07ca			; The routine suffers from a number of bugs as described in the comments below. It also suffers from a minor flaw in the design, which prevents
07ca			; interlacing screen and printer control codes and their parameters. For example, the following will not work correctly:
07ca			;
07ca			; 10 LPRINT CHR$ 16;
07ca			; 20 PRINT AT 0,0;
07ca			; 30 LPRINT CHR$ 0;"ABC"
07ca			;
07ca			; The control byte 16 gets stored in TVDATA so that the system knows how to interpret its parameter byte. However, the AT control code 22
07ca			; in line 20 will overwrite it. When line 30 is executed, TVDATA still holds the control code for 'AT' and so this line is interpreted as
07ca			; PRINT AT instead of PRINT INK. [Credit: Ian Collier (+3)]
07ca			;
07ca			; Entry: A=character to output.
07ca			; Exit : Carry flag reset indicates success.
07ca
07ca	L07CA:  PUSH AF           ; Save the character to print.
07cb			LD   A,(TVPARS)   ; $5B65. Number of parameters expected.
07ce			OR   A            ;
07cf			JR   Z,L07E0      ; Jump if no parameters.
07d1
07d1			DEC  A            ; Ignore the parameter.
07d2			LD   (TVPARS),A   ; $5B65.
07d5			JR   NZ,L07DB     ; Jump ahead if we have not processed all parameters.
07d7
07d7			;All parameters processed
07d7
07d7			POP  AF           ; Retrieve character to print.
07d8			JP   L0872        ; Jump ahead to continue.
07db
07db	L07DB:  POP  AF           ; Retrieve character to print.
07dc			LD   ($5C0F),A    ; TVDATA+1. Store it for use later.
07df			RET               ;
07e0
07e0	L07E0:  POP  AF           ; Retrieve character to print.
07e1			CP   $A3          ; Test against code for 'SPECTRUM'.
07e3			JR   C,L07F2      ; Jump ahead if not a token.
07e5
07e5			;Process tokens
07e5
07e5			LD   HL,(RETADDR) ; $5B5A. Save RETADDR temporarily.
07e8			PUSH HL           ;
07e9			RST  28H          ;
07ea			DEFW PO_T_UDG     ; $0B52. Print tokens via call to ROM 1 routine PO-T&UDG.
07ec			POP  HL           ;
07ed			LD   (RETADDR),HL ; $5B5A. Restore the original contents of RETADDR.
07f0			SCF               ;
07f1			RET               ;
07f2
07f2	L07F2:  LD   HL,$5C3B     ; FLAGS.
07f5			RES  0,(HL)       ; Suppress printing a leading space.
07f7			CP   ' '          ; $20. Is character to output a space?
07f9			JR   NZ,L07FD     ; Jump ahead if not a space.
07fb
07fb			SET  0,(HL)       ; Signal leading space required.
07fd
07fd	L07FD:  CP   $7F          ; Compare against copyright symbol.
07ff			JR   C,L0803      ; Jump ahead if not a graphic or UDG character.
0801
0801			LD   A,'?'        ; $3F. Print a '?' for all graphic and UDG characters.
0803
0803	L0803:  CP   $20          ; Is it a control character?
0805			JR   C,L081E      ; Jump ahead if so.
0807
0807			;Printable character
0807
0807	L0807:  PUSH AF           ; Save the character to print.
0808			LD   HL,COL       ; $5B63. Point to the column number.
080b			INC  (HL)         ; Increment the column number.
080c			LD   A,(WIDTH)    ; $5B64. Fetch the number of columns.
080f			CP   (HL)         ;
0810			JR   NC,L081A     ; Jump if end of row not reached.
0812
0812			CALL L0822        ; Print a carriage return and line feed.
0815
0815			LD   A,$01        ;
0817			LD   (COL),A      ; $5B63. Set the print position to column 1.
081a
081a	L081A:  POP  AF           ; Retrieve character to print.
081b			JP   L08A3        ; Jump ahead to print the character.
081e
081e			;Process control codes
081e
081e	L081E:  CP   $0D          ; Is it a carriage return?
0820			JR   NZ,L0830     ; Jump ahead if not.
0822
0822			;Handle a carriage return
0822
0822	L0822:  XOR  A            ;
0823			LD   (COL),A      ; $5B63. Set the print position back to column 0.
0826
0826			LD   A,$0D        ;
0828			CALL L08A3        ; Print a carriage return.
082b
082b			LD   A,$0A        ;
082d			JP   L08A3        ; Print a line feed.
0830
0830	L0830:  CP   $06          ; Is it a comma?
0832			JR   NZ,L0853     ; Jump ahead if not.
0834
0834			;Handle a comma
0834
0834			LD   BC,(COL)     ; $5B63. Fetch the column position.
0838			LD   E,$00        ; Will count number of columns to move across to reach next comma position.
083a
083a	L083A:  INC  E            ; Increment column counter.
083b			INC  C            ; Increment column position.
083c			LD   A,C          ;
083d			CP   B            ; End of row reached?
083e			JR   Z,L0848      ; Jump if so.
0840
0840	L0840:  SUB  $08          ;
0842			JR   Z,L0848      ; Jump if column 8, 16 or 32 reached.
0844
0844			JR   NC,L0840     ; Column position greater so subtract another 8.
0846
0846			JR   L083A        ; Jump back and increment column position again.
0848
0848			;Column 8, 16 or 32 reached. Output multiple spaces until the desired column position is reached.
0848
0848	L0848:  PUSH DE           ; Save column counter in E.
0849			LD   A,$20        ;
084b			CALL L07CA        ; Output a space via a recursive call.
084e			POP  DE           ; Retrieve column counter to E.
084f			DEC  E            ; More spaces to output?
0850			RET  Z            ; Return if no more to output.
0851
0851			JR   L0848        ; Repeat for the next space to output.
0853
0853	L0853:  CP   $16          ; Is it AT?
0855			JR   Z,L0860      ; Jump ahead to handle AT.
0857
0857			CP   $17          ; Is it TAB?
0859			JR   Z,L0860      ; Jump ahead to handle TAB.
085b
085b			CP   $10          ; Check for INK, PAPER, FLASH, BRIGHT, INVERSE, OVER.
085d			RET  C            ; Ignore if not one of these.
085e
085e			JR   L0869        ; Jump ahead to handle INK, PAPER, FLASH, BRIGHT, INVERSE, OVER.
0860
0860			;Handle AT and TAB
0860
0860	L0860:  LD   ($5C0E),A    ; TV_DATA. Store the control code for use later, $16 (AT) or $17 (TAB).
0863			LD   A,$02        ; Two parameters expected (even for TAB).
0865			LD   (TVPARS),A   ; $5B65.
0868			RET               ; Return with zero flag set.
0869
0869			;Handle INK, PAPER, FLASH, BRIGHT, INVERSE, OVER
0869
0869	L0869:  LD   ($5C0E),A    ; TV_DATA. Store the control code for use later.
086c			LD   A,$02        ; Two parameters expected. [*BUG* - Should be 1 parameter. 'LPRINT INK 4' will produce error report 'C Nonsense in BASIC'. Credit: Toni Baker, ZX Computing Monthly].
086e			LD   (TVPARS),A   ; $5B65.
0871			RET               ; [*BUG* - Should return with the carry flag reset and the zero flag set. It causes a statement such as 'LPRINT INK 1;' to produce error report '8 End of file'.
0872			; It is due to the main RS232 processing loop using the state of the flags to determine the success/failure response of the RS232 output routine. Credit: Ian Collier (+3), Andrew Owen (128)]
0872			; [The bug can be fixed by inserting a XOR A instruction before the RET instruction. Credit: Paul Farrow]
0872
0872			;All parameters processed
0872
0872	L0872:  LD   D,A          ; D=Character to print.
0873			LD   A,($5C0E)    ; TV_DATA. Fetch the control code.
0876			CP   $16          ; Is it AT?
0878			JR   Z,L0882      ; Jump ahead to handle AT parameter.
087a
087a			CP   $17          ; Is it TAB?
087c			CCF               ; [*BUG* - Should return with the carry flag reset and the zero flag set. It causes a statement such as 'LPRINT INK 1;' to produce error report '8 End of file'.
087d			; It is due to the main RS232 processing loop using the state of the flags to determine the success/failure response of the RS232 output routine. Credit: Toni Baker, ZX Computing Monthly]
087d			RET  NZ           ; Ignore if not TAB.
087e
087e			; [The bug can be fixed by replacing the instructions CCF and RET NZ with the following. Credit: Paul Farrow.
087e			;
087e			;       JR   Z,NOT_TAB
087e			;
087e			;       XOR  A
087e			;       RET
087e			;
087e			;NOT_TAB:                 ; ]
087e
087e			;Handle TAB parameter
087e
087e			LD   A,($5C0F)    ; TV_DATA+1. Fetch the saved parameter.
0881			LD   D,A          ; Fetch parameter to D.
0882
0882			;Process AT and TAB
0882
0882	L0882:  LD   A,(WIDTH)    ; $5B64.
0885			CP   D            ; Reached end of row?
0886			JR   Z,L088A      ; Jump ahead if so.
0888
0888			JR   NC,L0890     ; Jump ahead if before end of row.
088a
088a			;Column position equal or greater than length of row requested
088a
088a	L088A:  LD   B,A          ; (WIDTH).
088b			LD   A,D          ; TAB/AT column position.
088c			SUB  B            ; TAB/AT position - WIDTH.
088d			LD   D,A          ; The new required column position.
088e			JR   L0882        ; Handle the new TAB/AT position.
0890
0890	L0890:  LD   A,D          ; Fetch the desired column number.
0891			OR   A            ;
0892			JP   Z,L0822      ; Jump to output a carriage return if column 0 required.
0895
0895	L0895:  LD   A,(COL)      ; $5B63. Fetch the current column position.
0898			CP   D            ; Compare against desired column position.
0899			RET  Z            ; Done if reached requested column.
089a
089a			PUSH DE           ; Save the number of spaces to output.
089b			LD   A,$20        ;
089d			CALL L07CA        ; Output a space via a recursive call.
08a0			POP  DE           ; Retrieve number of spaces to output.
08a1			JR   L0895        ; Keep outputting spaces until desired column reached.
08a3
08a3			; ------------------------
08a3			; Write Byte to RS232 Port
08a3			; ------------------------
08a3			; The timing of the routine is achieved using the timing constant held in system variable BAUD.
08a3			; Entry: A holds character to send.
08a3			; Exit:  Carry and zero flags reset.
08a3
08a3	L08A3:  PUSH AF           ; Save the byte to send.
08a4
08a4			LD   C,$FD        ;
08a6			LD   D,$FF        ;
08a8
08a8			LD   E,$BF        ;
08aa			LD   B,D          ;
08ab			LD   A,$0E        ;
08ad			OUT  (C),A        ; Select AY register 14 to control the RS232 port.
08af
08af	L08AF:  CALL L05D6        ; Check the BREAK key, and produce error message if it is being pressed.
08b2
08b2			IN   A,(C)        ; Read status of data register.
08b4			AND  $40          ; %01000000. Test the DTR line.
08b6			JR   NZ,L08AF     ; Jump back until device is ready for data.
08b8
08b8			LD   HL,(BAUD)    ; $5B5F. HL=Baud rate timing constant.
08bb			LD   DE,$0002     ;
08be			OR   A            ;
08bf			SBC  HL,DE        ;
08c1			EX   DE,HL        ; DE=(BAUD)-2.
08c2
08c2			POP  AF           ; Retrieve the byte to send.
08c3			CPL               ; Invert the bits of the byte (RS232 logic is inverted).
08c4			SCF               ; Carry is used to send START BIT.
08c5			LD   B,$0B        ; B=Number of bits to send (1 start + 8 data + 2 stop).
08c7
08c7			DI                ; Disable interrupts to ensure accurate timing.
08c8
08c8			;Transmit each bit
08c8
08c8	L08C8:  PUSH BC           ; Save the number of bits to send.
08c9			PUSH AF           ; Save the data bits.
08ca
08ca			LD   A,$FE        ;
08cc			LD   H,D          ;
08cd			LD   L,E          ; HL=(BAUD)-2.
08ce			LD   BC,$BFFD     ; AY-3-8912 data register.
08d1
08d1			JP   NC,L08DA     ; Branch to transmit a 1 or a 0 (initially sending a 0 for the start bit).
08d4
08d4			;Transmit a 0
08d4
08d4			AND  $F7          ; Clear the RXD (out) line.
08d6			OUT  (C),A        ; Send out a 0 (high level).
08d8			JR   L08E0        ; Jump ahead to continue with next bit.
08da
08da			;Transmit a 1
08da
08da	L08DA:  OR   $08          ; Set the RXD (out) line.
08dc			OUT  (C),A        ; Send out a 1 (low level).
08de			JR   L08E0        ; Jump ahead to continue with next bit.
08e0
08e0			;Delay the length of a bit
08e0
08e0	L08E0:  DEC  HL           ; (6) Delay 26*BAUD cycles.
08e1			LD   A,H          ; (4)
08e2			OR   L            ; (4)
08e3			JR   NZ,L08E0     ; (12) Jump back until delay is completed.
08e5
08e5			NOP               ; (4) Fine tune the timing.
08e6			NOP               ; (4)
08e7			NOP               ; (4)
08e8
08e8			POP  AF           ; Retrieve the data bits to send.
08e9			POP  BC           ; Retrieve the number of bits left to send.
08ea			OR   A            ; Clear carry flag.
08eb			RRA               ; Shift the next bit to send into the carry flag.
08ec			DJNZ L08C8        ; Jump back to send next bit until all bits sent.
08ee
08ee			EI                ; Re-enable interrupts.
08ef			RET               ; Return with carry and zero flags reset.
08f0
08f0			; --------------------
08f0			; COPY Command Routine
08f0			; --------------------
08f0			; This routine copies 22 rows of the screen, outputting them to the printer a
08f0			; half row at a time. It is designed for EPSON compatible printers supporting
08f0			; double density bit graphics and 7/72 inch line spacing.
08f0			; Only the pixel information is processed; the attributes are ignored.
08f0
08f0	L08F0:  LD   HL,HD_0B     ; Half row counter.
08f3			LD   (HL),$2B     ; Set the half row counter to 43 half rows (will output 44 half rows in total).
08f5
08f5	L08F5:  LD   HL,L0979     ; Point to printer configuration data (7/72 inch line spacing, double density bit graphics).
08f8			CALL L095F        ; Send the configuration data to printer.
08fb
08fb			CALL L0915        ; Output a half row, at double height.
08fe
08fe			LD   HL,L0980     ; Table holds a line feed only.
0901			CALL L095F        ; Send a line feed to printer.
0904
0904			LD   HL,HD_0B     ; $5B72. The half row counter is tested to see if it is zero
0907			XOR  A            ; and if so then the line spacing is reset to its
0908			CP   (HL)         ; original value.
0909			JR   Z,L090E      ; Jump if done, resetting printer line spacing.
090b
090b			DEC  (HL)         ; Decrement half row counter.
090c			JR   L08F5        ; Repeat for the next half row.
090e
090e			;Copy done so reset printer line spacing before exiting
090e
090e	L090E:  LD   HL,L0982     ; Point to printer configuration data (1/6 inch line spacing).
0911			CALL L095F        ; Send the configuration data to printer.
0914			RET               ; [Could have saved 1 byte by using JP $095F (ROM 0)]
0915
0915			; ---------------
0915			; Output Half Row
0915			; ---------------
0915
0915	L0915:  LD   HL,HD_00     ; $5B71. Pixel column counter.
0918			LD   (HL),$FF     ; Set pixel column counter to 255 pixels.
091a
091a	L091A:  CALL L0926        ; Output a column of pixels, at double height.
091d
091d			LD   HL,HD_00     ; $5B71. Pixel column counter.
0920			XOR  A            ;
0921			CP   (HL)         ; Check if all pixels in this row have been output.
0922			RET  Z            ; Return if so.
0923
0923			DEC  (HL)         ; Decrement pixel column counter.
0924			JR   L091A        ; Repeat for all pixels in this row.
0926
0926			;Output a column of pixels (at double height)
0926
0926	L0926:  LD   DE,$C000     ; D=%11000000. Used to hold the double height pixel.
0929			LD   BC,(HD_00)   ; $5B71. C=Pixel column counter, B=Half row counter.
092d			SCF               ;
092e			RL   B            ; B=2xB+1
0930			SCF               ;
0931			RL   B            ; B=4xB+3. The pixel row coordinate.
0933
0933			LD   A,C          ; Pixel column counter.
0934			CPL               ;
0935			LD   C,A          ; C=255-C. The pixel column coordinate.
0936
0936			XOR  A            ; Clear A. Used to generate double height nibble of pixels to output.
0937			PUSH AF           ;
0938
0938			PUSH DE           ;
0939			PUSH BC           ; Save registers.
093a
093a	L093A:  CALL L096D        ; Test whether pixel (B,C) is set
093d
093d			POP  BC           ;
093e			POP  DE           ; Restore registers.
093f
093f			LD   E,$00        ; Set double height pixel = 0.
0941			JR   Z,L0944      ; Jump if pixel is reset.
0943
0943			LD   E,D          ; The double height pixel to output (%11000000, %00110000, %00001100 or %00000011).
0944
0944	L0944:  POP  AF           ;
0945			OR   E            ; Add the double height pixel value to the byte to output.
0946			PUSH AF           ;
0947
0947			DEC  B            ; Decrement half row coordinate.
0948			SRL  D            ;
094a			SRL  D            ; Create next double height pixel value (%00110000, %00001100 or %00000011).
094c
094c			PUSH DE           ;
094d			PUSH BC           ;
094e			JR   NC,L093A     ; Repeat for all four pixels in the half row.
0950
0950			POP  BC           ;
0951			POP  DE           ; Unload the stack.
0952
0952			POP  AF           ;
0953			LD   B,$03        ; Send double height nibble of pixels output 3 times.
0955
0955			; -----------------------
0955			; Output Nibble of Pixels
0955			; -----------------------
0955			; Send each nibble of pixels (i.e. column of 4 pixels) output 3 times so that
0955			; the width of a pixel is the same size as its height.
0955
0955	L0955:  PUSH BC           ;
0956			PUSH AF           ;
0957			CALL L08A3        ; Send byte to RS232 port.
095a			POP  AF           ;
095b			POP  BC           ;
095c			DJNZ L0955        ;
095e
095e			RET               ;
095f
095f			; ----------------------------
095f			; Output Characters from Table
095f			; ----------------------------
095f			; This routine is used to send a sequence of EPSON printer control codes out to the RS232 port.
095f			; It sends (HL) characters starting from HL+1.
095f
095f	L095F:  LD   B,(HL)       ; Get number of bytes to send.
0960			INC  HL           ; Point to the data to send.
0961
0961	L0961:  LD   A,(HL)       ; Retrieve value.
0962			PUSH HL           ;
0963			PUSH BC           ;
0964			CALL L08A3        ; Send byte to RS232 port.
0967			POP  BC           ;
0968			POP  HL           ;
0969			INC  HL           ; Point to next data byte to send.
096a			DJNZ L0961        ; Repeat for all bytes.
096c
096c			RET               ;
096d
096d			; -------------------------------
096d			; Test Whether Pixel (B,C) is Set
096d			; -------------------------------
096d			; Entry: B=Pixel line
096d			;        C=Pixel column.
096d			; Exit : A=$00 if pixel is reset
096d			;        A>$00 if pixel is set (actually the value of the bit corresponding to the pixel within the byte).
096d
096d	L096D:  RST  28H          ; Get address of (B,C) pixel into HL and pixel position within byte into A.
096e			DEFW PIXEL_ADDR   ; $22AA.
0970			LD   B,A          ; B=Pixel position within byte (0-7).
0971			INC  B            ;
0972
0972			XOR  A            ; Pixel mask.
0973			SCF               ; Carry flag holds bit to be rotated into the mask.
0974
0974	L0974:  RRA               ; Shift the mask bit into the required bit position.
0975			DJNZ L0974        ;
0977
0977			AND  (HL)         ; Isolate this pixel from A.
0978			RET               ;
0979
0979			; ---------------------------------
0979			; EPSON Printer Control Code Tables
0979			; ---------------------------------
0979
0979	L0979:  DEFB $06                 ; 6 characters follow.
097a			DEFB $1B, $31            ; ESC '1'     - 7/72 inch line spacing.
097c			DEFB $1B, $4C, $00, $03  ; ESC 'L' 0 3 - Double density (768 bytes per row).
0980
0980	L0980:  DEFB $01                 ; 1 character follows.
0981			DEFB $0A                 ; Line feed.
0982
0982	L0982:  DEFB $02                 ; 2 characters follow.
0983			DEFB $1B, $32            ; ESC '2' - 1/6 inch line spacing.
0985
0985
0985			; =====================
0985			; PLAY COMMAND ROUTINES
0985			; =====================
0985			; Up to 3 channels of music/noise are supported by the AY-3-8912 sound generator.
0985			; Up to 8 channels of music can be sent to support synthesisers, drum machines or sequencers via the MIDI interface,
0985			; with the first 3 channels also played by the AY-3-8912 sound generator. For each channel of music, a MIDI channel
0985			; can be assigned to it using the 'Y' command.
0985			;
0985			; The PLAY command reserves and initialises space for the PLAY command. This comprises a block of $003C bytes
0985			; used to manage the PLAY command (IY points to this command data block) and a block of $0037 bytes for each
0985			; channel string (IX is used to point to the channel data block for the current channel). [Note that the command
0985			; data block is $04 bytes larger than it needs to be, and each channel data block is $11 bytes larger than it
0985			; needs to be]
0985			;
0985			; Entry: B=The number of strings in the PLAY command (1..8).
0985
0985			; -------------------------
0985			; Command Data Block Format
0985			; -------------------------
0985			; IY+$00 / IY+$01 = Channel 0 data block pointer. Points to the data for channel 0 (string 1).
0985			; IY+$02 / IY+$03 = Channel 1 data block pointer. Points to the data for channel 1 (string 2).
0985			; IY+$04 / IY+$05 = Channel 2 data block pointer. Points to the data for channel 2 (string 3).
0985			; IY+$06 / IY+$07 = Channel 3 data block pointer. Points to the data for channel 3 (string 4).
0985			; IY+$08 / IY+$09 = Channel 4 data block pointer. Points to the data for channel 4 (string 5).
0985			; IY+$0A / IY+$0B = Channel 5 data block pointer. Points to the data for channel 5 (string 6).
0985			; IY+$0C / IY+$0D = Channel 6 data block pointer. Points to the data for channel 6 (string 7).
0985			; IY+$0E / IY+$0F = Channel 7 data block pointer. Points to the data for channel 7 (string 8).
0985			; IY+$10          = Channel bitmap. Initialised to $FF and a 0 rotated in to the left for each string parameters
0985			;                   of the PLAY command, thereby indicating the channels in use.
0985			; IY+$11 / IY+$12 = Channel data block duration pointer. Points to duration length store in channel 0 data block (string 1).
0985			; IY+$13 / IY+$14 = Channel data block duration pointer. Points to duration length store in channel 1 data block (string 2).
0985			; IY+$15 / IY+$16 = Channel data block duration pointer. Points to duration length store in channel 2 data block (string 3).
0985			; IY+$17 / IY+$18 = Channel data block duration pointer. Points to duration length store in channel 3 data block (string 4).
0985			; IY+$19 / IY+$1A = Channel data block duration pointer. Points to duration length store in channel 4 data block (string 5).
0985			; IY+$1B / IY+$1C = Channel data block duration pointer. Points to duration length store in channel 5 data block (string 6).
0985			; IY+$1D / IY+$1E = Channel data block duration pointer. Points to duration length store in channel 6 data block (string 7).
0985			; IY+$1F / IY+$20 = Channel data block duration pointer. Points to duration length store in channel 7 data block (string 8).
0985			; IY+$21          = Channel selector. It is used as a shift register with bit 0 initially set and then shift to the left
0985			;                   until a carry occurs, thereby indicating all 8 possible channels have been processed.
0985			; IY+$22          = Temporary channel bitmap, used to hold a working copy of the channel bitmap at IY+$10.
0985			; IY+$23 / IY+$24 = Address of the channel data block pointers, or address of the channel data block duration pointers
0985			;                   (allows the routine at $0A6E (ROM 0) to be used with both set of pointers).
0985			; IY+$25 / IY+$26 = Stores the smallest duration length of all currently playing channel notes.
0985			; IY+$27 / IY+$28 = The current tempo timing value (derived from the tempo parameter 60..240 beats per second).
0985			; IY+$29          = The current effect waveform value.
0985			; IY+$2A          = Temporary string counter selector.
0985			; IY+$2B..IY+$37  = Holds a floating point calculator routine.
0985			; IY+$38..IY+$3B  = Not used.
0985
0985			; -------------------------
0985			; Channel Data Block Format
0985			; -------------------------
0985			; IX+$00          = The note number being played on this channel (equivalent to index offset into the note table).
0985			; IX+$01          = MIDI channel assigned to this string (range 0 to 15).
0985			; IX+$02          = Channel number (range 0 to 7), i.e. index position of the string within the PLAY command.
0985			; IX+$03          = 12*Octave number (0, 12, 24, 36, 48, 60, 72, 84 or 96).
0985			; IX+$04          = Current volume (range 0 to 15, or if bit 4 set then using envelope).
0985			; IX+$05          = Last note duration value as specified in the string (range 1 to 9).
0985			; IX+$06 / IX+$07 = Address of current position in the string.
0985			; IX+$08 / IX+$09 = Address of byte after the end of the string.
0985			; IX+$0A          = Flags:
0985			;                     Bit 0   : 1=Single closing bracket found (repeat string indefinitely).
0985			;                     Bits 1-7: Not used (always 0).
0985			; IX+$0B          = Open bracket nesting level (range $00 to $04).
0985			; IX+$0C / IX+$0D = Return address for opening bracket nesting level 0 (points to character after the bracket).
0985			; IX+$0E / IX+$0F = Return address for opening bracket nesting level 1 (points to character after the bracket).
0985			; IX+$10 / IX+$11 = Return address for opening bracket nesting level 2 (points to character after the bracket).
0985			; IX+$12 / IX+$13 = Return address for opening bracket nesting level 3 (points to character after the bracket).
0985			; IX+$14 / IX+$15 = Return address for opening bracket nesting level 4 (points to character after the bracket).
0985			; IX+$16          = Closing bracket nesting level (range $FF to $04).
0985			; IX+$17...IX+$18 = Return address for closing bracket nesting level 0 (points to character after the bracket).
0985			; IX+$19...IX+$1A = Return address for closing bracket nesting level 1 (points to character after the bracket).
0985			; IX+$1B...IX+$1C = Return address for closing bracket nesting level 2 (points to character after the bracket).
0985			; IX+$1D...IX+$1E = Return address for closing bracket nesting level 3 (points to character after the bracket).
0985			; IX+$1F...IX+$20 = Return address for closing bracket nesting level 4 (points to character after the bracket).
0985			; IX+$21          = Tied notes counter (for a single note the value is 1).
0985			; IX+$22 / IX+$23 = Duration length, specified in 96ths of a note.
0985			; IX+$24...IX+$25 = Subsequent note duration length (used only with triplets), specified in 96ths of a note.
0985			; IX+$26...IX+$36 = Not used.
0985
0985	L0985:  DI                ; Disable interrupts to ensure accurate timing.
0986
0986			;Create a workspace for the play channel command strings
0986
0986			PUSH BC           ; B=Number of channel string (range 1 to 8). Also used as string index number in the following loop.
0987
0987			LD   DE,$0037     ;
098a			LD   HL,$003C     ;
098d
098d	L098D:  ADD  HL,DE        ; Calculate HL=$003C + ($0037 * B).
098e			DJNZ L098D        ;
0990
0990			LD   C,L          ;
0991			LD   B,H          ; BC=Space required (maximum = $01F4).
0992			RST  28H          ;
0993			DEFW BC_SPACES    ; $0030. Make BC bytes of space in the workspace.
0995
0995			DI                ; Interrupts get re-enabled by the call mechanism to ROM 1 so disable them again.
0996
0996			PUSH DE           ;
0997			POP  IY           ; IY=Points at first new byte - the command data block.
0999
0999			PUSH HL           ;
099a			POP  IX           ; IX=Points at last new byte - byte after all channel information blocks.
099c
099c			LD   (IY+$10),$FF ; Initial channel bitmap with value meaning 'zero strings'
09a0
09a0			;Loop over each string to be played
09a0
09a0	L09A0:  LD   BC,$FFC9     ; $-37 ($37 bytes is the size of a play channel string information block).
09a3			ADD  IX,BC        ; IX points to start of space for the last channel.
09a5			LD   (IX+$03),$3C ; Default octave is 5.
09a9			LD   (IX+$01),$FF ; No MIDI channel assigned.
09ad			LD   (IX+$04),$0F ; Default volume is 15.
09b1			LD   (IX+$05),$05 ; Default note duration.
09b5			LD   (IX+$21),$00 ; Count of the number of tied notes.
09b9			LD   (IX+$0A),$00 ; Signal not to repeat the string indefinitely.
09bd			LD   (IX+$0B),$00 ; No opening bracket nesting level.
09c1			LD   (IX+$16),$FF ; No closing bracket nesting level.
09c5			LD   (IX+$17),$00 ; Return address for closing bracket nesting level 0.
09c9			LD   (IX+$18),$00 ; [No need to initialise this since it is written to before it is ever tested]
09cd
09cd			; [*BUG* - At this point interrupts are disabled and IY is now being used as a pointer to the master
09cd			;          PLAY information block. Unfortunately, interrupts are enabled during the STK_FETCH call and
09cd			;          IY is left containing the wrong value. This means that if an interrupt were to occur during
09cd			;          execution of the subroutine then there would be a one in 65536 chance that (IY+$40) will be
09cd			;          corrupted - this corresponds to the volume setting for music channel A.
09cd			;          Rewriting the SWAP routine to only re-enable interrupts if they were originally enabled
09cd			;          would cure this bug (see end of file for description of her suggested fix). Credit: Toni Baker, ZX Computing Monthly]
09cd
09cd			; [An alternative and simpler solution to the fix Toni Baker describes would be to stack IY, set IY to point
09cd			; to the system variables at $5C3A, call STK_FETCH, disable interrupts, then pop the stacked value back to IY. Credit: Paul Farrow]
09cd
09cd			RST  28H          ; Get the details of the string from the stack.
09ce			DEFW STK_FETCH    ; $2BF1.
09d0
09d0			DI                ; Interrupts get re-enabled by the call mechanism to ROM 1 so disable them again.
09d1
09d1			LD   (IX+$06),E   ; Store the current position within in the string, i.e. the beginning of it.
09d4			LD   (IX+$07),D   ;
09d7			LD   (IX+$0C),E   ; Store the return position within the string for a closing bracket,
09da			LD   (IX+$0D),D   ; which is initially the start of the string in case a single closing bracket is found.
09dd
09dd			EX   DE,HL        ; HL=Points to start of string. BC=Length of string.
09de			ADD  HL,BC        ; HL=Points to address of byte after the string.
09df			LD   (IX+$08),L   ; Store the address of the character just
09e2			LD   (IX+$09),H   ; after the string.
09e5
09e5			POP  BC           ; B=String index number (range 1 to 8).
09e6			PUSH BC           ; Save it on the stack again.
09e7			DEC  B            ; Reduce the index so it ranges from 0 to 7.
09e8
09e8			LD   C,B          ;
09e9			LD   B,$00        ;
09eb			SLA  C            ; BC=String index*2.
09ed
09ed			PUSH IY           ;
09ef			POP  HL           ; HL=Address of the command data block.
09f0			ADD  HL,BC        ; Skip 8 channel data pointer words.
09f1
09f1			PUSH IX           ;
09f3			POP  BC           ; BC=Address of current channel information block.
09f4
09f4			LD   (HL),C       ; Store the pointer to the channel information block.
09f5			INC  HL           ;
09f6			LD   (HL),B       ;
09f7
09f7			OR   A            ; Clear the carry flag.
09f8			RL   (IY+$10)     ; Rotate one zero-bit into the least significant bit of the channel bitmap.
09fc			; This initially holds $FF but once this loop is over, this byte has
09fc			; a zero bit for each string parameter of the PLAY command.
09fc
09fc			POP  BC           ; B=Current string index.
09fd			DEC  B            ; Decrement string index so it ranges from 0 to 7.
09fe			PUSH BC           ; Save it for future use on the next iteration.
09ff			LD   (IX+$02),B   ; Store the channel number.
0a02
0a02			JR   NZ,L09A0     ; Jump back while more channel strings to process.
0a04
0a04			POP  BC           ; Drop item left on the stack.
0a05
0a05			;Entry point here from the vector table at $011B
0a05
0a05	L0A05:  LD   (IY+$27),$1A ; Set the initial tempo timing value.
0a09			LD   (IY+$28),$0B ; Corresponds to a 'T' command value of 120, and gives two crotchets per second.
0a0d
0a0d			PUSH IY           ;
0a0f			POP  HL           ; HL=Points to the command data block.
0a10
0a10			LD   BC,$002B     ;
0a13			ADD  HL,BC        ;
0a14			EX   DE,HL        ; DE=Address to store RAM routine.
0a15			LD   HL,L0A31     ; HL=Address of the RAM routine bytes.
0a18			LD   BC,$000D     ;
0a1b			LDIR              ; Copy the calculator routine to RAM.
0a1d
0a1d			LD   D,$07        ; Register 7 - Mixer.
0a1f			LD   E,$F8        ; I/O ports are inputs, noise output off, tone output on.
0a21			CALL L0E7C        ; Write to sound generator register.
0a24
0a24			LD   D,$0B        ; Register 11 - Envelope Period (Fine).
0a26			LD   E,$FF        ; Set period to maximum.
0a28			CALL L0E7C        ; Write to sound generator register.
0a2b
0a2b			INC  D            ; Register 12 - Envelope Period (Coarse).
0a2c			CALL L0E7C        ; Write to sound generator register.
0a2f
0a2f			JR   L0A7D        ; Jump ahead to continue.
0a31			; [Could have saved these 2 bytes by having the code at $0A7D (ROM 0) immediately follow]
0a31
0a31			; -------------------------------------------------
0a31			; Calculate Timing Loop Counter <<< RAM Routine >>>
0a31			; -------------------------------------------------
0a31			; This routine is copied into the command data block (offset $2B..$37) by
0a31			; the routine at $0A05 (ROM 0).
0a31			; It uses the floating point calculator found in ROM 1, which is usually
0a31			; invoked via a RST $28 instruction. Since ROM 0 uses RST $28 to call a
0a31			; routine in ROM 1, it is unable to invoke the floating point calculator
0a31			; this way. It therefore copies the following routine to RAM and calls it
0a31			; with ROM 1 paged in.
0a31			;
0a31			; The routine calculates (10/x)/7.33e-6, where x is the tempo 'T' parameter value
0a31			; multiplied by 4. The result is used an inner loop counter in the wait routine at $0F76 (ROM 0).
0a31			; Each iteration of this loop takes 26 T-states. The time taken by 26 T-states
0a31			; is 7.33e-6 seconds. So the total time for the loop to execute is 2.5/TEMPO seconds.
0a31			;
0a31			; Entry: The value 4*TEMPO exists on the calculator stack (where TEMPO is in the range 60..240).
0a31			; Exit : The calculator stack holds the result.
0a31
0a31	L0A31:  RST 28H           ; Invoke the floating point calculator.
0a32			DEFB $A4          ; stk-ten.   = x, 10
0a33			DEFB $01          ; exchange.  = 10, x
0a34			DEFB $05          ; division.  = 10/x
0a35			DEFB $34          ; stk-data.  = 10/x, 7.33e-6
0a36			DEFB $DF          ; - exponent $6F (floating point number 7.33e-6).
0a37			DEFB $75          ; - mantissa byte 1
0a38			DEFB $F4          ; - mantissa byte 2
0a39			DEFB $38          ; - mantissa byte 3
0a3a			DEFB $75          ; - mantissa byte 4
0a3b			DEFB $05          ; division.  = (10/x)/7.33e-6
0a3c			DEFB $38          ; end-calc.
0a3d			RET               ;
0a3e
0a3e			; --------------
0a3e			; Test BREAK Key
0a3e			; --------------
0a3e			; Test for BREAK being pressed.
0a3e			; Exit: Carry flag reset if BREAK is being pressed.
0a3e
0a3e	L0A3E:  LD   A,$7F        ;
0a40			IN   A,($FE)      ;
0a42			RRA               ;
0a43			RET  C            ; Return with carry flag set if SPACE not pressed.
0a44
0a44			LD   A,$FE        ;
0a46			IN   A,($FE)      ;
0a48			RRA               ;
0a49			RET               ; Return with carry flag set if CAPS not pressed.
0a4a
0a4a			; -------------------------------------------
0a4a			; Select Channel Data Block Duration Pointers
0a4a			; -------------------------------------------
0a4a			; Point to the start of the channel data block duration pointers within the command data block.
0a4a			; Entry: IY=Address of the command data block.
0a4a			; Exit : HL=Address of current channel pointer.
0a4a
0a4a	L0A4A:  LD   BC,$0011     ; Offset to the channel data block duration pointers table.
0a4d			JR   L0A52        ; Jump ahead to continue.
0a4f
0a4f			; ----------------------------------
0a4f			; Select Channel Data Block Pointers
0a4f			; ----------------------------------
0a4f			; Point to the start of the channel data block pointers within the command data block.
0a4f			; Entry: IY=Address of the command data block.
0a4f			; Exit : HL=Address of current channel pointer.
0a4f
0a4f	L0A4F:  LD   BC,$0000     ; Offset to the channel data block pointers table.
0a52
0a52	L0A52:  PUSH IY           ;
0a54			POP  HL           ; HL=Point to the command data block.
0a55
0a55			ADD  HL,BC        ; Point to the desired channel pointers table.
0a56
0a56			LD   (IY+$23),L   ;
0a59			LD   (IY+$24),H   ; Store the start address of channels pointer table.
0a5c
0a5c			LD   A,(IY+$10)   ; Fetch the channel bitmap.
0a5f			LD   (IY+$22),A   ; Initialise the working copy.
0a62
0a62			LD   (IY+$21),$01 ; Channel selector. Set the shift register to indicate the first channel.
0a66			RET               ;
0a67
0a67			; -------------------------------------------------
0a67			; Get Channel Data Block Address for Current String
0a67			; -------------------------------------------------
0a67			; Entry: HL=Address of channel data block pointer.
0a67			; Exit : IX=Address of current channel data block.
0a67
0a67	L0A67:  LD   E,(HL)       ;
0a68			INC  HL           ;
0a69			LD   D,(HL)       ; Fetch the address of the current channel data block.
0a6a
0a6a			PUSH DE           ;
0a6b			POP  IX           ; Return it in IX.
0a6d			RET               ;
0a6e
0a6e			; -------------------------
0a6e			; Next Channel Data Pointer
0a6e			; -------------------------
0a6e
0a6e	L0A6E:  LD   L,(IY+$23)   ; The address of current channel data pointer.
0a71			LD   H,(IY+$24)   ;
0a74			INC  HL           ;
0a75			INC  HL           ; Advance to the next channel data pointer.
0a76			LD   (IY+$23),L   ;
0a79			LD   (IY+$24),H   ; The address of new channel data pointer.
0a7c			RET               ;
0a7d
0a7d			; ---------------------------
0a7d			; PLAY Command (Continuation)
0a7d			; ---------------------------
0a7d			; This section is responsible for processing the PLAY command and is a continuation of the routine
0a7d			; at $0985 (ROM 0). It begins by determining the first note to play on each channel and then enters
0a7d			; a loop to play these notes, fetching the subsequent notes to play at the appropriate times.
0a7d
0a7d	L0A7D:  CALL L0A4F        ; Select channel data block pointers.
0a80
0a80	L0A80:  RR   (IY+$22)     ; Working copy of channel bitmap. Test if next string present.
0a84			JR   C,L0A8C      ; Jump ahead if there is no string for this channel.
0a86
0a86			;HL=Address of channel data pointer.
0a86
0a86			CALL L0A67        ; Get address of channel data block for the current string into IX.
0a89			CALL L0B5C        ; Find the first note to play for this channel from its play string.
0a8c
0a8c	L0A8C:  SLA  (IY+$21)     ; Have all channels been processed?
0a90			JR   C,L0A97      ; Jump ahead if so.
0a92
0a92			CALL L0A6E        ; Advance to the next channel data block pointer.
0a95			JR   L0A80        ; Jump back to process the next channel.
0a97
0a97			;The first notes to play for each channel have now been determined. A loop is entered that coordinates playing
0a97			;the notes and fetching subsequent notes when required. Notes across channels may be of different lengths and
0a97			;so the shortest one is determined, the tones for all channels set and then a waiting delay entered for the shortest
0a97			;note delay. This delay length is then subtracted from all channel note lengths to leave the remaining lengths that
0a97			;each note needs to be played for. For the channel with the smallest note length, this will now have completely played
0a97			;and so a new note is fetched for it. The smallest length of the current notes is then determined again and the process
0a97			;described above repeated. A test is made on each iteration to see if all channels have run out of data to play, and if
0a97			;so this ends the PLAY command.
0a97
0a97	L0A97:  CALL L0F91        ; Find smallest duration length of the current notes across all channels.
0a9a
0a9a			PUSH DE           ; Save the smallest duration length.
0a9b			CALL L0F42        ; Play a note on each channel.
0a9e			POP  DE           ; DE=The smallest duration length.
0a9f
0a9f	L0A9F:  LD   A,(IY+$10)   ; Channel bitmap.
0aa2			CP   $FF          ; Is there anything to play?
0aa4			JR   NZ,L0AAB     ; Jump if there is.
0aa6
0aa6			CALL L0E93        ; Turn off all sound and restore IY.
0aa9			EI                ; Re-enable interrupts.
0aaa			RET               ; End of play command.
0aab
0aab	L0AAB:  DEC  DE           ; DE=Smallest channel duration length, i.e. duration until the next channel state change.
0aac			CALL L0F76        ; Perform a wait.
0aaf			CALL L0FC1        ; Play a note on each channel and update the channel duration lengths.
0ab2
0ab2			CALL L0F91        ; Find smallest duration length of the current notes across all channels.
0ab5			JR   L0A9F        ; Jump back to see if there is more to process.
0ab7
0ab7			; ----------------------------
0ab7			; PLAY Command Character Table
0ab7			; ----------------------------
0ab7			; Recognised characters in PLAY commands.
0ab7
0ab7	L0AB7:  DEFM "HZYXWUVMT)(NO!"
0ac5
0ac5			; ------------------
0ac5			; Get Play Character
0ac5			; ------------------
0ac5			; Get the current character from the PLAY string and then increment the
0ac5			; character pointer within the string.
0ac5			; Exit: Carry flag set if string has been fully processed.
0ac5			;       Carry flag reset if character is available.
0ac5			;       A=Character available.
0ac5
0ac5	L0AC5:  CALL L0EE3        ; Get the current character from the play string for this channel.
0ac8			RET  C            ; Return if no more characters.
0ac9
0ac9			INC  (IX+$06)     ; Increment the low byte of the string pointer.
0acc			RET  NZ           ; Return if it has not overflowed.
0acd
0acd			INC  (IX+$07)     ; Else increment the high byte of the string pointer.
0ad0			RET               ; Returns with carry flag reset.
0ad1
0ad1			; --------------------------
0ad1			; Get Next Note in Semitones
0ad1			; --------------------------
0ad1			; Finds the number of semitones above C for the next note in the string,
0ad1			; Entry: IX=Address of the channel data block.
0ad1			; Exit : A=Number of semitones above C, or $80 for a rest.
0ad1
0ad1	L0AD1:  PUSH HL           ; Save HL.
0ad2
0ad2			LD   C,$00        ; Default is for a 'natural' note, i.e. no adjustment.
0ad4
0ad4	L0AD4:  CALL L0AC5        ; Get the current character from the PLAY string, and advance the position pointer.
0ad7			JR   C,L0AE1      ; Jump if at the end of the string.
0ad9
0ad9			CP   '&'          ; $26. Is it a rest?
0adb			JR   NZ,L0AEC     ; Jump ahead if not.
0add
0add			LD   A,$80        ; Signal that it is a rest.
0adf
0adf	L0ADF:  POP  HL           ; Restore HL.
0ae0			RET               ;
0ae1
0ae1	L0AE1:  LD   A,(IY+$21)   ; Fetch the channel selector.
0ae4			OR   (IY+$10)     ; Clear the channel flag for this string.
0ae7			LD   (IY+$10),A   ; Store the new channel bitmap.
0aea			JR   L0ADF        ; Jump back to return.
0aec
0aec	L0AEC:  CP   '#'          ; $23. Is it a sharpen?
0aee			JR   NZ,L0AF3     ; Jump ahead if not.
0af0
0af0			INC  C            ; Increment by a semitone.
0af1			JR   L0AD4        ; Jump back to get the next character.
0af3
0af3	L0AF3:  CP   '$'          ; $24. Is it a flatten?
0af5			JR   NZ,L0AFA     ; Jump ahead if not.
0af7
0af7			DEC  C            ; Decrement by a semitone.
0af8			JR   L0AD4        ; Jump back to get the next character.
0afa
0afa	L0AFA:  BIT  5,A          ; Is it a lower case letter?
0afc			JR   NZ,L0B04     ; Jump ahead if lower case.
0afe
0afe			PUSH AF           ; It is an upper case letter so
0aff			LD   A,$0C        ; increase an octave
0b01			ADD  A,C          ; by adding 12 semitones.
0b02			LD   C,A          ;
0b03			POP  AF           ;
0b04
0b04	L0B04:  AND  $DF          ; Convert to upper case.
0b06			SUB  $41          ; Reduce to range 'A'->0 .. 'G'->6.
0b08			JP   C,L0F22      ; Jump if below 'A' to produce error report "k Invalid note name".
0b0b
0b0b			CP   $07          ; Is it 7 or above?
0b0d			JP   NC,L0F22     ; Jump if so to produce error report "k Invalid note name".
0b10
0b10			PUSH BC           ; C=Number of semitones.
0b11
0b11			LD   B,$00        ;
0b13			LD   C,A          ; BC holds 0..6 for 'a'..'g'.
0b14			LD   HL,L0DF9     ; Look up the number of semitones above note C for the note.
0b17			ADD  HL,BC        ;
0b18			LD   A,(HL)       ; A=Number of semitones above note C.
0b19
0b19			POP  BC           ; C=Number of semitones due to sharpen/flatten characters.
0b1a			ADD  A,C          ; Adjust number of semitones above note C for the sharpen/flatten characters.
0b1b
0b1b			POP  HL           ; Restore HL.
0b1c			RET               ;
0b1d
0b1d			; ----------------------------------
0b1d			; Get Numeric Value from Play String
0b1d			; ----------------------------------
0b1d			; Get a numeric value from a PLAY string, returning 0 if no numeric value present.
0b1d			; Entry: IX=Address of the channel data block.
0b1d			; Exit : BC=Numeric value, or 0 if no numeric value found.
0b1d
0b1d	L0B1D:  PUSH HL           ; Save registers.
0b1e			PUSH DE           ;
0b1f
0b1f			LD   L,(IX+$06)   ; Get the pointer into the PLAY string.
0b22			LD   H,(IX+$07)   ;
0b25
0b25			LD   DE,$0000     ; Initialise result to 0.
0b28
0b28	L0B28:  LD   A,(HL)       ;
0b29			CP   '0'          ; $30. Is character numeric?
0b2b			JR   C,L0B45      ; Jump ahead if not.
0b2d
0b2d			CP   ':'          ; $3A. Is character numeric?
0b2f			JR   NC,L0B45     ; Jump ahead if not.
0b31
0b31			INC  HL           ; Advance to the next character.
0b32			PUSH HL           ; Save the pointer into the string.
0b33
0b33			CALL L0B50        ; Multiply result so far by 10.
0b36			SUB  '0'          ; $30. Convert ASCII digit to numeric value.
0b38			LD   H,$00        ;
0b3a			LD   L,A          ; HL=Numeric digit value.
0b3b			ADD  HL,DE        ; Add the numeric value to the result so far.
0b3c			JR   C,L0B42      ; Jump ahead if an overflow to produce error report "l number too big".
0b3e
0b3e			EX   DE,HL        ; Transfer the result into DE.
0b3f
0b3f			POP  HL           ; Retrieve the pointer into the string.
0b40			JR   L0B28        ; Loop back to handle any further numeric digits.
0b42
0b42	L0B42:  JP   L0F1A        ; Jump to produce error report "l number too big".
0b45			; [Could have saved 1 byte by directly using JP C,$0F1A (ROM 0) instead of using this JP and
0b45			; the two JR C,$0B42 (ROM 0) instructions that come here]
0b45
0b45			;The end of the numeric value was reached
0b45
0b45	L0B45:  LD   (IX+$06),L   ; Store the new pointer position into the string.
0b48			LD   (IX+$07),H   ;
0b4b
0b4b			PUSH DE           ;
0b4c			POP  BC           ; Return the result in BC.
0b4d
0b4d			POP  DE           ; Restore registers.
0b4e			POP  HL           ;
0b4f			RET               ;
0b50
0b50			; -----------------
0b50			; Multiply DE by 10
0b50			; -----------------
0b50			; Entry: DE=Value to multiple by 10.
0b50			; Exit : DE=Value*10.
0b50
0b50	L0B50:  LD   HL,$0000     ;
0b53			LD   B,$0A        ; Add DE to HL ten times.
0b55
0b55	L0B55:  ADD  HL,DE        ;
0b56			JR   C,L0B42      ; Jump ahead if an overflow to produce error report "l number too big".
0b58
0b58			DJNZ L0B55        ;
0b5a
0b5a			EX   DE,HL        ; Transfer the result into DE.
0b5b			RET               ;
0b5c
0b5c			; ----------------------------------
0b5c			; Find Next Note from Channel String
0b5c			; ----------------------------------
0b5c			; Entry: IX=Address of channel data block.
0b5c
0b5c	L0B5C:  CALL L0A3E        ; Test for BREAK being pressed.
0b5f			JR   C,L0B69      ; Jump ahead if not pressed.
0b61
0b61			CALL L0E93        ; Turn off all sound and restore IY.
0b64			EI                ; Re-enable interrupts.
0b65
0b65			CALL L05AC        ; Produce error report. [Could have saved 1 byte by using JP $05D6 (ROM 0)]
0b68			DEFB $14          ; "L Break into program"
0b69
0b69	L0B69:  CALL L0AC5        ; Get the current character from the PLAY string, and advance the position pointer.
0b6c			JP   C,L0DA2      ; Jump if at the end of the string.
0b6f
0b6f			CALL L0DF0        ; Find the handler routine for the PLAY command character.
0b72
0b72			LD   B,$00        ;
0b74			SLA  C            ; Generate the offset into the
0b76			LD   HL,L0DCA     ; command vector table.
0b79			ADD  HL,BC        ; HL points to handler routine for this command character.
0b7a
0b7a			LD   E,(HL)       ;
0b7b			INC  HL           ;
0b7c			LD   D,(HL)       ; Fetch the handler routine address.
0b7d
0b7d			EX   DE,HL        ; HL=Handler routine address for this command character.
0b7e			CALL L0B84        ; Make an indirect call to the handler routine.
0b81			JR   L0B5C        ; Jump back to handle the next character in the string.
0b83
0b83			;Comes here after processing a non-numeric digit that does not have a specific command routine handler
0b83			;Hence the next note to play has been determined and so a return is made to process the other channels.
0b83
0b83	L0B83:  RET               ; Just make a return.
0b84
0b84	L0B84:  JP   (HL)         ; Jump to the command handler routine.
0b85
0b85			; --------------------------
0b85			; Play Command '!' (Comment)
0b85			; --------------------------
0b85			; A comment is enclosed within exclamation marks, e.g. "! A comment !".
0b85			; Entry: IX=Address of the channel data block.
0b85
0b85	L0B85:  CALL L0AC5        ; Get the current character from the PLAY string, and advance the position pointer.
0b88			JP   C,L0DA1      ; Jump if at the end of the string.
0b8b
0b8b			CP   '!'          ; $21. Is it the end-of-comment character?
0b8d			RET  Z            ; Return if it is.
0b8e
0b8e			JR   L0B85        ; Jump back to test the next character.
0b90
0b90			; -------------------------
0b90			; Play Command 'O' (Octave)
0b90			; -------------------------
0b90			; The 'O' command is followed by a numeric value within the range 0 to 8,
0b90			; although due to loose range checking the value MOD 256 only needs to be
0b90			; within 0 to 8. Hence O256 operates the same as O0.
0b90			; Entry: IX=Address of the channel data block.
0b90
0b90	L0B90:  CALL L0B1D        ; Get following numeric value from the string into BC.
0b93
0b93			LD   A,C          ; Is it between 0 and 8?
0b94			CP   $09          ;
0b96			JP   NC,L0F12     ; Jump if above 8 to produce error report "n Out of range".
0b99
0b99			SLA  A            ; Multiply A by 12.
0b9b			SLA  A            ;
0b9d			LD   B,A          ;
0b9e			SLA  A            ;
0ba0			ADD  A,B          ;
0ba1
0ba1			LD   (IX+$03),A   ; Store the octave value.
0ba4			RET               ;
0ba5
0ba5			; ----------------------------
0ba5			; Play Command 'N' (Separator)
0ba5			; ----------------------------
0ba5			; The 'N' command is simply a separator marker and so is ignored.
0ba5			; Entry: IX=Address of the channel data block.
0ba5
0ba5	L0BA5:  RET               ; Nothing to do so make an immediate return.
0ba6
0ba6			; ----------------------------------
0ba6			; Play Command '(' (Start of Repeat)
0ba6			; ----------------------------------
0ba6			; A phrase can be enclosed within brackets causing it to be repeated, i.e. played twice.
0ba6			; Entry: IX=Address of the channel data block.
0ba6
0ba6	L0BA6:  LD   A,(IX+$0B)   ; A=Current level of open bracket nesting.
0ba9			INC  A            ; Increment the count.
0baa			CP   $05          ; Only 4 levels supported.
0bac			JP   Z,L0F2A      ; Jump if this is the fifth to produce error report "d Too many brackets".
0baf
0baf			LD   (IX+$0B),A   ; Store the new open bracket nesting level.
0bb2
0bb2			LD   DE,$000C     ; Offset to the bracket level return position stores.
0bb5			CALL L0C27        ; HL=Address of the pointer in which to store the return location of the bracket.
0bb8
0bb8			LD   A,(IX+$06)   ; Store the current string position as the return address of the open bracket.
0bbb			LD   (HL),A       ;
0bbc			INC  HL           ;
0bbd			LD   A,(IX+$07)   ;
0bc0			LD   (HL),A       ;
0bc1			RET               ;
0bc2
0bc2			; --------------------------------
0bc2			; Play Command ')' (End of Repeat)
0bc2			; --------------------------------
0bc2			; A phrase can be enclosed within brackets causing it to be repeated, i.e. played twice.
0bc2			; Brackets can also be nested within each other, to 4 levels deep.
0bc2			; If a closing bracket if used without a matching opening bracket then the whole string up
0bc2			; until that point is repeated indefinitely.
0bc2			; Entry: IX=Address of the channel data block.
0bc2
0bc2	L0BC2:  LD   A,(IX+$16)   ; Fetch the nesting level of closing brackets.
0bc5			LD   DE,$0017     ; Offset to the closing bracket return address store.
0bc8			OR   A            ; Is there any bracket nesting so far?
0bc9			JP   M,L0BF0      ; Jump if none. [Could have been faster by jumping to $0BF3 (ROM 0)]
0bcc
0bcc			;Has the bracket level been repeated, i.e. re-reached the same position in the string as the closing bracket return address?
0bcc
0bcc			CALL L0C27        ; HL=Address of the pointer to the corresponding closing bracket return address store.
0bcf			LD   A,(IX+$06)   ; Fetch the low byte of the current address.
0bd2			CP   (HL)         ; Re-reached the closing bracket?
0bd3			JR   NZ,L0BF0     ; Jump ahead if not.
0bd5
0bd5			INC  HL           ; Point to the high byte.
0bd6			LD   A,(IX+$07)   ; Fetch the high byte address of the current address.
0bd9			CP   (HL)         ; Re-reached the closing bracket?
0bda			JR   NZ,L0BF0     ; Jump ahead if not.
0bdc
0bdc			;The bracket level has been repeated. Now check whether this was the outer bracket level.
0bdc
0bdc			DEC  (IX+$16)     ; Decrement the closing bracket nesting level since this level has been repeated.
0bdf			LD   A,(IX+$16)   ; [There is no need for the LD A,(IX+$16) and OR A instructions since the DEC (IX+$16) already set the flags]
0be2			OR   A            ; Reached the outer bracket nesting level?
0be3			RET  P            ; Return if not the outer bracket nesting level such that the character
0be4			; after the closing bracket is processed next.
0be4
0be4			;The outer bracket level has been repeated
0be4
0be4			BIT  0,(IX+$0A)   ; Was this a single closing bracket?
0be8			RET  Z            ; Return if it was not.
0be9
0be9			;The repeat was caused by a single closing bracket so re-initialise the repeat
0be9
0be9			LD   (IX+$16),$00 ; Restore one level of closing bracket nesting.
0bed			XOR  A            ; Select closing bracket nesting level 0.
0bee			JR   L0C0B        ; Jump ahead to continue.
0bf0
0bf0			;A new level of closing bracket nesting
0bf0
0bf0	L0BF0:  LD   A,(IX+$16)   ; Fetch the nesting level of closing brackets.
0bf3			INC  A            ; Increment the count.
0bf4			CP   $05          ; Only 5 levels supported (4 to match up with opening brackets and a 5th to repeat indefinitely).
0bf6			JP   Z,L0F2A      ; Jump if this is the fifth to produce error report "d Too many brackets".
0bf9
0bf9			LD   (IX+$16),A   ; Store the new closing bracket nesting level.
0bfc
0bfc			CALL L0C27        ; HL=Address of the pointer to the appropriate closing bracket return address store.
0bff
0bff			LD   A,(IX+$06)   ; Store the current string position as the return address for the closing bracket.
0c02			LD   (HL),A       ;
0c03			INC  HL           ;
0c04			LD   A,(IX+$07)   ;
0c07			LD   (HL),A       ;
0c08
0c08			LD   A,(IX+$0B)   ; Fetch the nesting level of opening brackets.
0c0b
0c0b	L0C0B:  LD   DE,$000C     ;
0c0e			CALL L0C27        ; HL=Address of the pointer to the opening bracket nesting level return address store.
0c11
0c11			LD   A,(HL)       ; Set the return address of the nesting level's opening bracket
0c12			LD   (IX+$06),A   ; as new current position within the string.
0c15			INC  HL           ;
0c16			LD   A,(HL)       ; For a single closing bracket only, this will be the start address of the string.
0c17			LD   (IX+$07),A   ;
0c1a
0c1a			DEC  (IX+$0B)     ; Decrement level of open bracket nesting.
0c1d			RET  P            ; Return if the closing bracket matched an open bracket.
0c1e
0c1e			;There is one more closing bracket then opening brackets, i.e. repeat string indefinitely
0c1e
0c1e			LD   (IX+$0B),$00 ; Set the opening brackets nesting level to 0.
0c22			SET  0,(IX+$0A)   ; Signal a single closing bracket only, i.e. to repeat the string indefinitely.
0c26			RET               ;
0c27
0c27			; ------------------------------------
0c27			; Get Address of Bracket Pointer Store
0c27			; ------------------------------------
0c27			; Entry: IX=Address of the channel data block.
0c27			;        DE=Offset to the bracket pointer stores.
0c27			;        A=Index into the bracket pointer stores.
0c27			; Exit : HL=Address of the specified pointer store.
0c27
0c27	L0C27:  PUSH IX           ;
0c29			POP  HL           ; HL=IX.
0c2a
0c2a			ADD  HL,DE        ; HL=IX+DE.
0c2b			LD   B,$00        ;
0c2d			LD   C,A          ;
0c2e			SLA  C            ;
0c30			ADD  HL,BC        ; HL=IX+DE+2*A.
0c31			RET               ;
0c32
0c32			; ------------------------
0c32			; Play Command 'T' (Tempo)
0c32			; ------------------------
0c32			; A temp command must be specified in the first play string and is followed by a numeric
0c32			; value in the range 60 to 240 representing the number of beats (crotchets) per minute.
0c32			; Entry: IX=Address of the channel data block.
0c32
0c32	L0C32:  CALL L0B1D        ; Get following numeric value from the string into BC.
0c35			LD   A,B          ;
0c36			OR   A            ;
0c37			JP   NZ,L0F12     ; Jump if 256 or above to produce error report "n Out of range".
0c3a
0c3a			LD   A,C          ;
0c3b			CP   $3C          ;
0c3d			JP   C,L0F12      ; Jump if 59 or below to produce error report "n Out of range".
0c40
0c40			CP   $F1          ;
0c42			JP   NC,L0F12     ; Jump if 241 or above to produce error report "n Out of range".
0c45
0c45			;A holds a value in the range 60 to 240
0c45
0c45			LD   A,(IX+$02)   ; Fetch the channel number.
0c48			OR   A            ; Tempo 'T' commands have to be specified in the first string.
0c49			RET  NZ           ; If it is in a later string then ignore it.
0c4a
0c4a			LD   B,$00        ; [Redundant instruction - B is already zero]
0c4c			PUSH BC           ; C=Tempo value.
0c4d			POP  HL           ;
0c4e			ADD  HL,HL        ;
0c4f			ADD  HL,HL        ; HL=Tempo*4.
0c50
0c50			PUSH HL           ;
0c51			POP  BC           ; BC=Tempo*4. [Would have been quicker to use the combination LD B,H and LD C,L]
0c52
0c52			PUSH IY           ; Save the pointer to the play command data block.
0c54			RST  28H          ;
0c55			DEFW STACK_BC     ; $2D2B. Place the contents of BC onto the stack. The call restores IY to $5C3A.
0c57			DI                ; Interrupts get re-enabled by the call mechanism to ROM 1 so disable them again.
0c58			POP  IY           ; Restore IY to point at the play command data block.
0c5a
0c5a			PUSH IY           ; Save the pointer to the play command data block.
0c5c
0c5c			PUSH IY           ;
0c5e			POP  HL           ; HL=pointer to the play command data block.
0c5f
0c5f			LD   BC,$002B     ;
0c62			ADD  HL,BC        ; HL =IY+$002B.
0c63			LD   IY,$5C3A     ; Reset IY to $5C3A since this is required by the floating point calculator.
0c67			PUSH HL           ; HL=Points to the calculator RAM routine.
0c68
0c68			LD   HL,L0C76     ;
0c6b			LD   (RETADDR),HL ; $5B5A. Set up the return address.
0c6e
0c6e			LD   HL,YOUNGER   ;
0c71			EX   (SP),HL      ; Stack the address of the swap routine used when returning to this ROM.
0c72			PUSH HL           ; Re-stack the address of the calculator RAM routine.
0c73
0c73			JP   SWAP         ; $5B00. Toggle to other ROM and make a return to the calculator RAM routine.
0c76
0c76			; --------------------
0c76			; Tempo Command Return
0c76			; --------------------
0c76			; The calculator stack now holds the value (10/(Tempo*4))/7.33e-6 and this is stored as the tempo value.
0c76			; The result is used an inner loop counter in the wait routine at $0F76 (ROM 0). Each iteration of this loop
0c76			; takes 26 T-states. The time taken by 26 T-states is 7.33e-6 seconds. So the total time for the loop
0c76			; to execute is 2.5/TEMPO seconds.
0c76
0c76	L0C76:  DI                ; Interrupts get re-enabled by the call mechanism to ROM 1 so disable them again.
0c77
0c77			RST  28H          ;
0c78			DEFW FP_TO_BC     ; $2DA2. Fetch the value on the top of the calculator stack.
0c7a
0c7a			DI                ; Interrupts get re-enabled by the call mechanism to ROM 1 so disable them again.
0c7b
0c7b			POP  IY           ; Restore IY to point at the play command data block.
0c7d
0c7d			LD   (IY+$27),C   ; Store tempo timing value.
0c80			LD   (IY+$28),B   ;
0c83			RET               ;
0c84
0c84			; ------------------------
0c84			; Play Command 'M' (Mixer)
0c84			; ------------------------
0c84			; This command is used to select whether to use tone and/or noise on each of the 3 channels.
0c84			; It is followed by a numeric value in the range 1 to 63, although due to loose range checking the
0c84			; value MOD 256 only needs to be within 0 to 63. Hence M256 operates the same as M0.
0c84			; Entry: IX=Address of the channel data block.
0c84
0c84	L0C84:  CALL L0B1D        ; Get following numeric value from the string into BC.
0c87			LD   A,C          ; A=Mixer value.
0c88			CP   $40          ; Is it 64 or above?
0c8a			JP   NC,L0F12     ; Jump if so to produce error report "n Out of range".
0c8d
0c8d			;Bit 0: 1=Enable channel A tone.
0c8d			;Bit 1: 1=Enable channel B tone.
0c8d			;Bit 2: 1=Enable channel C tone.
0c8d			;Bit 3: 1=Enable channel A noise.
0c8d			;Bit 4: 1=Enable channel B noise.
0c8d			;Bit 5: 1=Enable channel C noise.
0c8d
0c8d			CPL               ; Invert the bits since the sound generator's mixer register uses active low enable.
0c8e			; This also sets bit 6 1, which selects the I/O port as an output.
0c8e			LD   E,A          ; E=Mixer value.
0c8f			LD   D,$07        ; D=Register 7 - Mixer.
0c91			CALL L0E7C        ; Write to sound generator register to set the mixer.
0c94			RET               ; [Could have saved 1 byte by using JP $0E7C (ROM 0)]
0c95
0c95			; -------------------------
0c95			; Play Command 'V' (Volume)
0c95			; -------------------------
0c95			; This sets the volume of a channel and is followed by a numeric value in the range
0c95			; 0 (minimum) to 15 (maximum), although due to loose range checking the value MOD 256
0c95			; only needs to be within 0 to 15. Hence V256 operates the same as V0.
0c95			; Entry: IX=Address of the channel data block.
0c95
0c95	L0C95:  CALL L0B1D        ; Get following numeric value from the string into BC.
0c98
0c98			LD   A,C          ;
0c99			CP   $10          ; Is it 16 or above?
0c9b			JP   NC,L0F12     ; Jump if so to produce error report "n Out of range".
0c9e
0c9e			LD   (IX+$04),A   ; Store the volume level.
0ca1
0ca1			; [*BUG* - An attempt to set the volume for a sound chip channel is now made. However, this routine fails to take into account
0ca1			;          that it is also called to set the volume for a MIDI only channel, i.e. play strings 4 to 8. As a result, corruption
0ca1			;          occurs to various sound generator registers, causing spurious sound output. There is in fact no need for this routine
0ca1			;          to set the volume for any channels since this is done every time a new note is played - see routine at $0A97 (ROM 0).
0ca1			;          the bug fix is to simply to make a return at this point. This routine therefore contains 11 surplus bytes. Credit: Ian Collier (+3), Paul Farrow (128)]
0ca1
0ca1			LD   E,(IX+$02)   ; E=Channel number.
0ca4			LD   A,$08        ; Offset by 8.
0ca6			ADD  A,E          ; A=8+index.
0ca7			LD   D,A          ; D=Sound generator register number for the channel.
0ca8
0ca8			LD   E,C          ; E=Volume level.
0ca9			CALL L0E7C        ; Write to sound generator register to set the volume for the channel.
0cac			RET               ; [Could have saved 1 byte by using JP $0E7C (ROM 0)]
0cad
0cad			; ------------------------------------
0cad			; Play Command 'U' (Use Volume Effect)
0cad			; ------------------------------------
0cad			; This command turns on envelope waveform effects for a particular sound chip channel. The volume level is now controlled by
0cad			; the selected envelope waveform for the channel, as defined by the 'W' command. MIDI channels do not support envelope waveforms
0cad			; and so the routine has the effect of setting the volume of a MIDI channel to maximum, i.e. 15. It might seem odd that the volume
0cad			; for MIDI channels is set to 15 rather than just filtered out. However, the three sound chip channels can also drive three MIDI
0cad			; channels and so it would be inconsistent for these MIDI channels to have their volume set to 15 but have the other MIDI channels
0cad			; behave differently. However, it could be argued that all MIDI channels should be unaffected by the 'U' command.
0cad			; There are no parameters to this command.
0cad			; Entry: IX=Address of the channel data block.
0cad
0cad	L0CAD:  LD   E,(IX+$02)   ; Get the channel number.
0cb0			LD   A,$08        ; Offset by 8.
0cb2			ADD  A,E          ; A=8+index.
0cb3			LD   D,A          ; D=Sound generator register number for the channel. [This is not used and so there is no need to generate it. It was probably a left
0cb4			; over from copying and modifying the 'V' command routine. Deleting it would save 7 bytes. Credit: Ian Collier (+3), Paul Farrow (128)]
0cb4
0cb4			LD   E,$1F        ; E=Select envelope defined by register 13, and reset volume bits to maximum (though these are not used with the envelope).
0cb6			LD   (IX+$04),E   ; Store that the envelope is being used (along with the reset volume level).
0cb9			RET               ;
0cba
0cba			; ------------------------------------------
0cba			; Play command 'W' (Volume Effect Specifier)
0cba			; ------------------------------------------
0cba			; This command selects the envelope waveform to use and is followed by a numeric value in the range
0cba			; 0 to 7, although due to loose range checking the value MOD 256 only needs to be within 0 to 7.
0cba			; Hence W256 operates the same as W0.
0cba			; Entry: IX=Address of the channel data block.
0cba
0cba	L0CBA:  CALL L0B1D        ; Get following numeric value from the string into BC.
0cbd
0cbd			LD   A,C          ;
0cbe			CP   $08          ; Is it 8 or above?
0cc0			JP   NC,L0F12     ; Jump if so to produce error report "n Out of range".
0cc3
0cc3			LD   B,$00        ;
0cc5			LD   HL,L0DE8     ; Envelope waveform lookup table.
0cc8			ADD  HL,BC        ; HL points to the corresponding value in the table.
0cc9			LD   A,(HL)       ;
0cca			LD   (IY+$29),A   ; Store new effect waveform value.
0ccd			RET               ;
0cce
0cce			; -----------------------------------------
0cce			; Play Command 'X' (Volume Effect Duration)
0cce			; -----------------------------------------
0cce			; This command allows the duration of a waveform effect to be specified, and is followed by a numeric
0cce			; value in the range 0 to 65535. A value of 1 corresponds to the minimum duration, increasing up to 65535
0cce			; and then maximum duration for a value of 0. If no numeric value is specified then the maximum duration is used.
0cce			; Entry: IX=Address of the channel data block.
0cce
0cce	L0CCE:  CALL L0B1D        ; Get following numeric value from the string into BC.
0cd1
0cd1			LD   D,$0B        ; Register 11 - Envelope Period Fine.
0cd3			LD   E,C          ;
0cd4			CALL L0E7C        ; Write to sound generator register to set the envelope period (low byte).
0cd7
0cd7			INC  D            ; Register 12 - Envelope Period Coarse.
0cd8			LD   E,B          ;
0cd9			CALL L0E7C        ; Write to sound generator register to set the envelope period (high byte).
0cdc			RET               ; [Could have saved 1 byte by using JP $0E7C (ROM 0)]
0cdd
0cdd			; -------------------------------
0cdd			; Play Command 'Y' (MIDI Channel)
0cdd			; -------------------------------
0cdd			; This command sets the MIDI channel number that the string is assigned to and is followed by a numeric
0cdd			; value in the range 1 to 16, although due to loose range checking the value MOD 256 only needs to be within 1 to 16.
0cdd			; Hence Y257 operates the same as Y1.
0cdd			; Entry: IX=Address of the channel data block.
0cdd
0cdd	L0CDD:  CALL L0B1D        ; Get following numeric value from the string into BC.
0ce0
0ce0			LD   A,C          ;
0ce1			DEC  A            ; Is it 0?
0ce2			JP   M,L0F12      ; Jump if so to produce error report "n Out of range".
0ce5
0ce5			CP   $10          ; Is it 10 or above?
0ce7			JP   NC,L0F12     ; Jump if so to produce error report "n Out of range".
0cea
0cea			LD   (IX+$01),A   ; Store MIDI channel number that this string is assigned to.
0ced			RET               ;
0cee
0cee			; ----------------------------------------
0cee			; Play Command 'Z' (MIDI Programming Code)
0cee			; ----------------------------------------
0cee			; This command is used to send a programming code to the MIDI port. It is followed by a numeric
0cee			; value in the range 0 to 255, although due to loose range checking the value MOD 256 only needs
0cee			; to be within 0 to 255. Hence Z256 operates the same as Z0.
0cee			; Entry: IX=Address of the channel data block.
0cee
0cee	L0CEE:  CALL L0B1D        ; Get following numeric value from the string into BC.
0cf1
0cf1			LD   A,C          ; A=(low byte of) the value.
0cf2			CALL L11A3        ; Write byte to MIDI device.
0cf5			RET               ; [Could have saved 1 byte by using JP $0E7C (ROM 0)]
0cf6
0cf6			; -----------------------
0cf6			; Play Command 'H' (Stop)
0cf6			; -----------------------
0cf6			; This command stops further processing of a play command. It has no parameters.
0cf6			; Entry: IX=Address of the channel data block.
0cf6
0cf6	L0CF6:  LD   (IY+$10),$FF ; Indicate no channels to play, thereby causing
0cfa			RET               ; the play command to terminate.
0cfb
0cfb			; --------------------------------------------------------
0cfb			; Play Commands 'a'..'g', 'A'..'G', '1'.."12", '&' and '_'
0cfb			; --------------------------------------------------------
0cfb			; This handler routine processes commands 'a'..'g', 'A'..'G', '1'.."12", '&' and '_',
0cfb			; and determines the length of the next note to play. It provides the handling of triplet and tied notes.
0cfb			; It stores the note duration in the channel data block's duration length entry, and sets a pointer in the command
0cfb			; data block's duration lengths pointer table to point at it. A single note letter is deemed to be a tied
0cfb			; note count of 1. Triplets are deemed a tied note count of at least 2.
0cfb			; Entry: IX=Address of the channel data block.
0cfb			;        A=Current character from play string.
0cfb
0cfb	L0CFB:  CALL L0E19        ; Is the current character a number?
0cfe			JP   C,L0D81      ; Jump if not number digit.
0d01
0d01			;The character is a number digit
0d01
0d01			CALL L0DAC        ; HL=Address of the duration length within the channel data block.
0d04			CALL L0DB4        ; Store address of duration length in command data block's channel duration length pointer table.
0d07
0d07			XOR  A            ;
0d08			LD   (IX+$21),A   ; Set no tied notes.
0d0b
0d0b			CALL L0EC8        ; Get the previous character in the string, the note duration.
0d0e			CALL L0B1D        ; Get following numeric value from the string into BC.
0d11			LD   A,C          ;
0d12			OR   A            ; Is the value 0?
0d13			JP   Z,L0F12      ; Jump if so to produce error report "n Out of range".
0d16
0d16			CP   $0D          ; Is it 13 or above?
0d18			JP   NC,L0F12     ; Jump if so to produce error report "n Out of range".
0d1b
0d1b			CP   $0A          ; Is it below 10?
0d1d			JR   C,L0D32      ; Jump if so.
0d1f
0d1f			;It is a triplet semi-quaver (10), triplet quaver (11) or triplet crotchet (12)
0d1f
0d1f			CALL L0E00        ; DE=Note duration length for the duration value.
0d22			CALL L0D74        ; Increment the tied notes counter.
0d25			LD   (HL),E       ; HL=Address of the duration length within the channel data block.
0d26			INC  HL           ;
0d27			LD   (HL),D       ; Store the duration length.
0d28
0d28	L0D28:  CALL L0D74        ; Increment the counter of tied notes.
0d2b
0d2b			INC  HL           ;
0d2c			LD   (HL),E       ;
0d2d			INC  HL           ; Store the subsequent note duration length in the channel data block.
0d2e			LD   (HL),D       ;
0d2f			INC  HL           ;
0d30			JR   L0D38        ; Jump ahead to continue.
0d32
0d32			;The note duration was in the range 1 to 9
0d32
0d32	L0D32:  LD   (IX+$05),C   ; C=Note duration value (1..9).
0d35			CALL L0E00        ; DE=Duration length for this duration value.
0d38
0d38	L0D38:  CALL L0D74        ; Increment the tied notes counter.
0d3b
0d3b	L0D3B:  CALL L0EE3        ; Get the current character from the play string for this channel.
0d3e
0d3e			CP   '_'          ; $5F. Is it a tied note?
0d40			JR   NZ,L0D6E     ; Jump ahead if not.
0d42
0d42			CALL L0AC5        ; Get the current character from the PLAY string, and advance the position pointer.
0d45			CALL L0B1D        ; Get following numeric value from the string into BC.
0d48			LD   A,C          ; Place the value into A.
0d49			CP   $0A          ; Is it below 10?
0d4b			JR   C,L0D5F      ; Jump ahead for 1 to 9 (semiquaver ... semibreve).
0d4d
0d4d			;A triplet note was found as part of a tied note
0d4d
0d4d			PUSH HL           ; HL=Address of the duration length within the channel data block.
0d4e			PUSH DE           ; DE=First tied note duration length.
0d4f			CALL L0E00        ; DE=Note duration length for this new duration value.
0d52			POP  HL           ; HL=Current tied note duration length.
0d53			ADD  HL,DE        ; HL=Current+new tied note duration lengths.
0d54			LD   C,E          ;
0d55			LD   B,D          ; BC=Note duration length for the duration value.
0d56			EX   DE,HL        ; DE=Current+new tied note duration lengths.
0d57			POP  HL           ; HL=Address of the duration length within the channel data block.
0d58
0d58			LD   (HL),E       ;
0d59			INC  HL           ;
0d5a			LD   (HL),D       ; Store the combined note duration length in the channel data block.
0d5b
0d5b			LD   E,C          ;
0d5c			LD   D,B          ; DE=Note duration length for the second duration value.
0d5d			JR   L0D28        ; Jump back.
0d5f
0d5f			;A non-triplet tied note
0d5f
0d5f	L0D5F:  LD   (IX+$05),C   ; Store the note duration value.
0d62
0d62			PUSH HL           ; HL=Address of the duration length within the channel data block.
0d63			PUSH DE           ; DE=First tied note duration length.
0d64			CALL L0E00        ; DE=Note duration length for this new duration value.
0d67			POP  HL           ; HL=Current tied note duration length.
0d68			ADD  HL,DE        ; HL=Current+new tied not duration lengths.
0d69			EX   DE,HL        ; DE=Current+new tied not duration lengths.
0d6a			POP  HL           ; HL=Address of the duration length within the channel data block.
0d6b
0d6b			JP   L0D3B        ; Jump back to process the next character in case it is also part of a tied note.
0d6e
0d6e			;The number found was not part of a tied note, so store the duration value
0d6e
0d6e	L0D6E:  LD   (HL),E       ; HL=Address of the duration length within the channel data block.
0d6f			INC  HL           ; (For triplet notes this could be the address of the subsequent note duration length)
0d70			LD   (HL),D       ; Store the duration length.
0d71			JP   L0D9C        ; Jump forward to make a return.
0d74
0d74			; This subroutine is called to increment the tied notes counter
0d74
0d74	L0D74:  LD   A,(IX+$21)   ; Increment counter of tied notes.
0d77			INC  A            ;
0d78			CP   $0B          ; Has it reached 11?
0d7a			JP   Z,L0F3A      ; Jump if so to produce to error report "o too many tied notes".
0d7d
0d7d			LD   (IX+$21),A   ; Store the new tied notes counter.
0d80			RET               ;
0d81
0d81			;The character is not a number digit so is 'A'..'G', '&' or '_'
0d81
0d81	L0D81:  CALL L0EC8        ; Get the previous character from the string.
0d84
0d84			LD   (IX+$21),$01 ; Set the number of tied notes to 1.
0d88
0d88			;Store a pointer to the channel data block's duration length into the command data block
0d88
0d88			CALL L0DAC        ; HL=Address of the duration length within the channel data block.
0d8b			CALL L0DB4        ; Store address of duration length in command data block's channel duration length pointer table.
0d8e
0d8e			LD   C,(IX+$05)   ; C=The duration value of the note (1 to 9).
0d91			PUSH HL           ; [Not necessary]
0d92			CALL L0E00        ; Find the duration length for the note duration value.
0d95			POP  HL           ; [Not necessary]
0d96
0d96			LD   (HL),E       ; Store it in the channel data block.
0d97			INC  HL           ;
0d98			LD   (HL),D       ;
0d99			JP   L0D9C        ; Jump to the instruction below. [Redundant instruction]
0d9c
0d9c	L0D9C:  POP  HL           ;
0d9d			INC  HL           ;
0d9e			INC  HL           ; Modify the return address to point to the RET instruction at $0B83 (ROM 0).
0d9f			PUSH HL           ;
0da0			RET               ; [Over elaborate when a simple POP followed by RET would have sufficed, saving 3 bytes]
0da1
0da1			; -------------------
0da1			; End of String Found
0da1			; -------------------
0da1			;This routine is called when the end of string is found within a comment. It marks the
0da1			;string as having been processed and then returns to the main loop to process the next string.
0da1
0da1	L0DA1:  POP  HL           ; Drop the return address of the call to the comment command.
0da2
0da2			;Enter here if the end of the string is found whilst processing a string.
0da2
0da2	L0DA2:  LD   A,(IY+$21)   ; Fetch the channel selector.
0da5			OR   (IY+$10)     ; Clear the channel flag for this string.
0da8			LD   (IY+$10),A   ; Store the new channel bitmap.
0dab			RET               ;
0dac
0dac			; --------------------------------------------------
0dac			; Point to Duration Length within Channel Data Block
0dac			; --------------------------------------------------
0dac			; Entry: IX=Address of the channel data block.
0dac			; Exit : HL=Address of the duration length within the channel data block.
0dac
0dac	L0DAC:  PUSH IX           ;
0dae			POP  HL           ; HL=Address of the channel data block.
0daf			LD   BC,$0022     ;
0db2			ADD  HL,BC        ; HL=Address of the store for the duration length.
0db3			RET               ;
0db4
0db4			; -------------------------------------------------------------------------
0db4			; Store Entry in Command Data Block's Channel Duration Length Pointer Table
0db4			; -------------------------------------------------------------------------
0db4			; Entry: IY=Address of the command data block.
0db4			;        IX=Address of the channel data block for the current string.
0db4			;        HL=Address of the duration length store within the channel data block.
0db4			; Exit : HL=Address of the duration length store within the channel data block.
0db4			;        DE=Channel duration.
0db4
0db4	L0DB4:  PUSH HL           ; Save the address of the duration length within the channel data block.
0db5
0db5			PUSH IY           ;
0db7			POP  HL           ; HL=Address of the command data block.
0db8
0db8			LD   BC,$0011     ;
0dbb			ADD  HL,BC        ; HL=Address within the command data block of the channel duration length pointer table.
0dbc
0dbc			LD   B,$00        ;
0dbe			LD   C,(IX+$02)   ; BC=Channel number.
0dc1
0dc1			SLA  C            ; BC=2*Index number.
0dc3			ADD  HL,BC        ; HL=Address within the command data block of the pointer to the current channel's data block duration length.
0dc4
0dc4			POP  DE           ; DE=Address of the duration length within the channel data block.
0dc5
0dc5			LD   (HL),E       ; Store the pointer to the channel duration length in the command data block's channel duration pointer table.
0dc6			INC  HL           ;
0dc7			LD   (HL),D       ;
0dc8			EX   DE,HL        ;
0dc9			RET               ;
0dca
0dca			; -----------------------
0dca			; PLAY Command Jump Table
0dca			; -----------------------
0dca			; Handler routine jump table for all PLAY commands.
0dca
0dca	L0DCA:  DEFW L0CFB        ; Command handler routine for all other characters.
0dcc			DEFW L0B85        ; '!' command handler routine.
0dce			DEFW L0B90        ; 'O' command handler routine.
0dd0			DEFW L0BA5        ; 'N' command handler routine.
0dd2			DEFW L0BA6        ; '(' command handler routine.
0dd4			DEFW L0BC2        ; ')' command handler routine.
0dd6			DEFW L0C32        ; 'T' command handler routine.
0dd8			DEFW L0C84        ; 'M' command handler routine.
0dda			DEFW L0C95        ; 'V' command handler routine.
0ddc			DEFW L0CAD        ; 'U' command handler routine.
0dde			DEFW L0CBA        ; 'W' command handler routine.
0de0			DEFW L0CCE        ; 'X' command handler routine.
0de2			DEFW L0CDD        ; 'Y' command handler routine.
0de4			DEFW L0CEE        ; 'Z' command handler routine.
0de6			DEFW L0CF6        ; 'H' command handler routine.
0de8
0de8			; ------------------------------
0de8			; Envelope Waveform Lookup Table
0de8			; ------------------------------
0de8			; Table used by the play 'W' command to find the corresponding envelope value
0de8			; to write to the sound generator envelope shape register (register 13). This
0de8			; filters out the two duplicate waveforms possible from the sound generator and
0de8			; allows the order of the waveforms to be arranged in a more logical fashion.
0de8
0de8	L0DE8:  DEFB $00          ; W0 - Single decay then off.   (Continue off, attack off, alternate off, hold off)
0de9			DEFB $04          ; W1 - Single attack then off.  (Continue off, attack on,  alternate off, hold off)
0dea			DEFB $0B          ; W2 - Single decay then hold.  (Continue on,  attack off, alternate on,  hold on)
0deb			DEFB $0D          ; W3 - Single attack then hold. (Continue on,  attack on,  alternate off, hold on)
0dec			DEFB $08          ; W4 - Repeated decay.          (Continue on,  attack off, alternate off, hold off)
0ded			DEFB $0C          ; W5 - Repeated attack.         (Continue on,  attack on,  alternate off, hold off)
0dee			DEFB $0E          ; W6 - Repeated attack-decay.   (Continue on,  attack on,  alternate on,  hold off)
0def			DEFB $0A          ; W7 - Repeated decay-attack.   (Continue on,  attack off, alternate on,  hold off)
0df0
0df0			; --------------------------
0df0			; Identify Command Character
0df0			; --------------------------
0df0			; This routines attempts to match the command character to those in a table.
0df0			; The index position of the match indicates which command handler routine is required
0df0			; to process the character. Note that commands are case sensitive.
0df0			; Entry: A=Command character.
0df0			; Exit : Zero flag set if a match was found.
0df0			;        BC=Indentifying the character matched, 1 to 15 for match and 0 for no match.
0df0
0df0	L0DF0:  LD   BC,$000F     ; Number of characters + 1 in command table.
0df3			LD   HL,L0AB7     ; Start of command table.
0df6			CPIR              ; Search for a match.
0df8			RET               ;
0df9
0df9			; ---------------
0df9			; Semitones Table
0df9			; ---------------
0df9			; This table contains an entry for each note of the scale, A to G,
0df9			; and is the number of semitones above the note C.
0df9
0df9	L0DF9:  DEFB $09          ; 'A'
0dfa			DEFB $0B          ; 'B'
0dfb			DEFB $00          ; 'C'
0dfc			DEFB $02          ; 'D'
0dfd			DEFB $04          ; 'E'
0dfe			DEFB $05          ; 'F'
0dff			DEFB $07          ; 'G'
0e00
0e00			; -------------------------
0e00			; Find Note Duration Length
0e00			; -------------------------
0e00			; Entry: C=Duration value (0 to 12, although a value of 0 is never used).
0e00			; Exit : DE=Note duration length.
0e00
0e00	L0E00:  PUSH HL           ; Save HL.
0e01
0e01			LD   B,$00        ;
0e03			LD   HL,L0E0C     ; Note duration table.
0e06			ADD  HL,BC        ; Index into the table.
0e07			LD   D,$00        ;
0e09			LD   E,(HL)       ; Fetch the length from the table.
0e0a
0e0a			POP  HL           ; Restore HL.
0e0b			RET               ;
0e0c
0e0c			; -------------------
0e0c			; Note Duration Table
0e0c			; -------------------
0e0c			; A whole note is given by a value of 96d and other notes defined in relation to this.
0e0c			; The value of 96d is the lowest common denominator from which all note durations
0e0c			; can be defined.
0e0c
0e0c	L0E0C:  DEFB $80          ; Rest                 [Not used since table is always indexed into with a value of 1 or more]
0e0d			DEFB $06          ; Semi-quaver          (sixteenth note).
0e0e			DEFB $09          ; Dotted semi-quaver   (3/32th note).
0e0f			DEFB $0C          ; Quaver               (eighth note).
0e10			DEFB $12          ; Dotted quaver        (3/16th note).
0e11			DEFB $18          ; Crotchet             (quarter note).
0e12			DEFB $24          ; Dotted crotchet      (3/8th note).
0e13			DEFB $30          ; Minim                (half note).
0e14			DEFB $48          ; Dotted minim         (3/4th note).
0e15			DEFB $60          ; Semi-breve           (whole note).
0e16			DEFB $04          ; Triplet semi-quaver  (1/24th note).
0e17			DEFB $08          ; Triplet quaver       (1/12th note).
0e18			DEFB $10          ; Triplet crochet      (1/6th note).
0e19
0e19			; -----------------
0e19			; Is Numeric Digit?
0e19			; -----------------
0e19			; Tests whether a character is a number digit.
0e19			; Entry: A=Character.
0e19			; Exit : Carry flag reset if a number digit.
0e19
0e19	L0E19:  CP   '0'          ; $30. Is it '0' or less?
0e1b			RET  C            ; Return with carry flag set if so.
0e1c
0e1c			CP   ':'          ; $3A. Is it more than '9'?
0e1e			CCF               ;
0e1f			RET               ; Return with carry flag set if so.
0e20
0e20			; -----------------------------------
0e20			; Play a Note On a Sound Chip Channel
0e20			; -----------------------------------
0e20			; This routine plays the note at the current octave and current volume on a sound chip channel. For play strings 4 to 8,
0e20			; it simply stores the note number and this is subsequently played later.
0e20			; Entry: IX=Address of the channel data block.
0e20			;        A=Note value as number of semitones above C (0..11).
0e20
0e20	L0E20:  LD   C,A          ; C=The note value.
0e21			LD   A,(IX+$03)   ; Octave number * 12.
0e24			ADD  A,C          ; Add the octave number and the note value to form the note number.
0e25			CP   $80          ; Is note within range?
0e27			JP   NC,L0F32     ; Jump if not to produce error report "m Note out of range".
0e2a
0e2a			LD   C,A          ; C=Note number.
0e2b			LD   A,(IX+$02)   ; Get the channel number.
0e2e			OR   A            ; Is it the first channel?
0e2f			JR   NZ,L0E3F     ; Jump ahead if not.
0e31
0e31			;Only set the noise generator frequency on the first channel
0e31
0e31			LD   A,C          ; A=Note number (0..107), in ascending audio frequency.
0e32			CPL               ; Invert since noise register value is in descending audio frequency.
0e33			AND  $7F          ; Mask off bit 7.
0e35			SRL  A            ;
0e37			SRL  A            ; Divide by 4 to reduce range to 0..31.
0e39			LD   D,$06        ; Register 6 - Noise pitch.
0e3b			LD   E,A          ;
0e3c			CALL L0E7C        ; Write to sound generator register.
0e3f
0e3f	L0E3F:  LD   (IX+$00),C   ; Store the note number.
0e42			LD   A,(IX+$02)   ; Get the channel number.
0e45			CP   $03          ; Is it channel 0, 1 or 2, i.e. a sound chip channel?
0e47			RET  NC           ; Do not output anything for play strings 4 to 8.
0e48
0e48			;Channel 0, 1 or 2
0e48
0e48			LD   HL,L1096     ; Start of note lookup table.
0e4b			LD   B,$00        ; BC=Note number.
0e4d			LD   A,C          ; A=Note number.
0e4e			SUB  $15          ; A=Note number - 21.
0e50			JR   NC,L0E57     ; Jump if note number was 21 or above.
0e52
0e52			LD   DE,$0FBF     ; Note numbers $00 to $14 use the lowest note value.
0e55			JR   L0E5E        ; [Could have saved 4 bytes by using XOR A and dropping through to $0E57 (ROM 0)]
0e57
0e57			;Note number 21 to 107 (range 0 to 86)
0e57
0e57	L0E57:  LD   C,A          ;
0e58			SLA  C            ; Generate offset into the table.
0e5a			ADD  HL,BC        ; Point to the entry in the table.
0e5b			LD   E,(HL)       ;
0e5c			INC  HL           ;
0e5d			LD   D,(HL)       ; DE=Word to write to the sound chip registers to produce this note.
0e5e
0e5e	L0E5E:  EX   DE,HL        ; HL=Register word value to produce the note.
0e5f
0e5f			LD   D,(IX+$02)   ; Get the channel number.
0e62			SLA  D            ; D=2*Channel number, to give the tone channel register (fine control) number 0, 2, or 4.
0e64			LD   E,L          ; E=The low value byte.
0e65			CALL L0E7C        ; Write to sound generator register.
0e68
0e68			INC  D            ; D=Tone channel register (coarse control) number 1, 3, or 5.
0e69			LD   E,H          ; E=The high value byte.
0e6a			CALL L0E7C        ; Write to sound generator register.
0e6d
0e6d			BIT  4,(IX+$04)   ; Is the envelope waveform being used?
0e71			RET  Z            ; Return if it is not.
0e72
0e72			LD   D,$0D        ; Register 13 - Envelope Shape.
0e74			LD   A,(IY+$29)   ; Get the effect waveform value.
0e77			LD   E,A          ;
0e78			CALL L0E7C        ; Write to sound generator register.
0e7b			RET               ; [Could have saved 4 bytes by dropping down into the routine below.]
0e7c
0e7c			; ----------------------------
0e7c			; Set Sound Generator Register
0e7c			; ----------------------------
0e7c			; Entry: D=Register to write.
0e7c			;        E=Value to set register to.
0e7c
0e7c	L0E7C:  PUSH BC           ;
0e7d
0e7d			LD   BC,$FFFD     ;
0e80			OUT  (C),D        ; Select the register.
0e82			LD   BC,$BFFD     ;
0e85			OUT  (C),E        ; Write out the value.
0e87
0e87			POP  BC           ;
0e88			RET               ;
0e89
0e89			; -----------------------------
0e89			; Read Sound Generator Register
0e89			; -----------------------------
0e89			; Entry: A=Register to read.
0e89			; Exit : A=Value of currently selected sound generator register.
0e89
0e89	L0E89:  PUSH BC           ;
0e8a
0e8a			LD   BC,$FFFD     ;
0e8d			OUT  (C),A        ; Select the register.
0e8f			IN   A,(C)        ; Read the register's value.
0e91
0e91			POP  BC           ;
0e92			RET               ;
0e93
0e93			; ------------------
0e93			; Turn Off All Sound
0e93			; ------------------
0e93
0e93	L0E93:  LD   D,$07        ; Register 7 - Mixer.
0e95			LD   E,$FF        ; I/O ports are inputs, noise output off, tone output off.
0e97			CALL L0E7C        ; Write to sound generator register.
0e9a
0e9a			;Turn off the sound from the AY-3-8912
0e9a
0e9a			LD   D,$08        ; Register 8 - Channel A volume.
0e9c			LD   E,$00        ; Volume of 0.
0e9e			CALL L0E7C        ; Write to sound generator register to set the volume to 0.
0ea1
0ea1			INC  D            ; Register 9 - Channel B volume.
0ea2			CALL L0E7C        ; Write to sound generator register to set the volume to 0.
0ea5
0ea5			INC  D            ; Register 10 - Channel C volume.
0ea6			CALL L0E7C        ; Write to sound generator register to set the volume to 0.
0ea9
0ea9			CALL L0A4F        ; Select channel data block pointers.
0eac
0eac			;Now reset all MIDI channels in use
0eac
0eac	L0EAC:  RR   (IY+$22)     ; Working copy of channel bitmap. Test if next string present.
0eb0			JR   C,L0EB8      ; Jump ahead if there is no string for this channel.
0eb2
0eb2			CALL L0A67        ; Get address of channel data block for the current string into IX.
0eb5			CALL L118D        ; Turn off the MIDI channel sound assigned to this play string.
0eb8
0eb8	L0EB8:  SLA  (IY+$21)     ; Have all channels been processed?
0ebc			JR   C,L0EC3      ; Jump ahead if so.
0ebe
0ebe			CALL L0A6E        ; Advance to the next channel data block pointer.
0ec1			JR   L0EAC        ; Jump back to process the next channel.
0ec3
0ec3	L0EC3:  LD   IY,$5C3A     ; Restore IY.
0ec7			RET               ;
0ec8
0ec8			; ---------------------------------------
0ec8			; Get Previous Character from Play String
0ec8			; ---------------------------------------
0ec8			; Get the previous character from the PLAY string, skipping over spaces and 'Enter' characters.
0ec8			; Entry: IX=Address of the channel data block.
0ec8
0ec8	L0EC8:  PUSH HL           ; Save registers.
0ec9			PUSH DE           ;
0eca
0eca			LD   L,(IX+$06)   ; Get the current pointer into the PLAY string.
0ecd			LD   H,(IX+$07)   ;
0ed0
0ed0	L0ED0:  DEC  HL           ; Point to previous character.
0ed1			LD   A,(HL)       ; Fetch the character.
0ed2			CP   ' '          ; $20. Is it a space?
0ed4			JR   Z,L0ED0      ; Jump back if a space.
0ed6
0ed6			CP   $0D          ; Is it an 'Enter'?
0ed8			JR   Z,L0ED0      ; Jump back if an 'Enter'.
0eda
0eda			LD   (IX+$06),L   ; Store this as the new current pointer into the PLAY string.
0edd			LD   (IX+$07),H   ;
0ee0
0ee0			POP  DE           ; Restore registers.
0ee1			POP  HL           ;
0ee2			RET               ;
0ee3
0ee3			; --------------------------------------
0ee3			; Get Current Character from Play String
0ee3			; --------------------------------------
0ee3			; Get the current character from the PLAY string, skipping over spaces and 'Enter' characters.
0ee3			; Exit: Carry flag set if string has been fully processed.
0ee3			;       Carry flag reset if character is available.
0ee3			;       A=Character available.
0ee3
0ee3	L0EE3:  PUSH HL           ; Save registers.
0ee4			PUSH DE           ;
0ee5			PUSH BC           ;
0ee6
0ee6			LD   L,(IX+$06)   ; HL=Pointer to next character to process within the PLAY string.
0ee9			LD   H,(IX+$07)   ;
0eec
0eec	L0EEC:  LD   A,H          ;
0eed			CP   (IX+$09)     ; Reached end-of-string address high byte?
0ef0			JR   NZ,L0EFB     ; Jump forward if not.
0ef2
0ef2			LD   A,L          ;
0ef3			CP   (IX+$08)     ; Reached end-of-string address low byte?
0ef6			JR   NZ,L0EFB     ; Jump forward if not.
0ef8
0ef8			SCF               ; Indicate string all processed.
0ef9			JR   L0F05        ; Jump forward to return.
0efb
0efb	L0EFB:  LD   A,(HL)       ; Get the next play character.
0efc			CP   ' '          ; $20. Is it a space?
0efe			JR   Z,L0F09      ; Ignore the space by jumping ahead to process the next character.
0f00
0f00			CP   $0D          ; Is it 'Enter'?
0f02			JR   Z,L0F09      ; Ignore the 'Enter' by jumping ahead to process the next character.
0f04
0f04			OR   A            ; Clear the carry flag to indicate a new character has been returned.
0f05
0f05	L0F05:  POP  BC           ; Restore registers.
0f06			POP  DE           ;
0f07			POP  HL           ;
0f08			RET               ;
0f09
0f09	L0F09:  INC  HL           ; Point to the next character.
0f0a			LD   (IX+$06),L   ;
0f0d			LD   (IX+$07),H   ; Update the pointer to the next character to process with the PLAY string.
0f10			JR   L0EEC        ; Jump back to get the next character.
0f12
0f12			; --------------------------
0f12			; Produce Play Error Reports
0f12			; --------------------------
0f12
0f12	L0F12:  CALL L0E93        ; Turn off all sound and restore IY.
0f15			EI                ;
0f16			CALL L05AC        ; Produce error report.
0f19			DEFB $29          ; "n Out of range"
0f1a
0f1a	L0F1A:  CALL L0E93        ; Turn off all sound and restore IY.
0f1d			EI                ;
0f1e			CALL L05AC        ; Produce error report.
0f21			DEFB $27          ; "l Number too big"
0f22
0f22	L0F22:  CALL L0E93        ; Turn off all sound and restore IY.
0f25			EI                ;
0f26			CALL L05AC        ; Produce error report.
0f29			DEFB $26          ; "k Invalid note name"
0f2a
0f2a	L0F2A:  CALL L0E93        ; Turn off all sound and restore IY.
0f2d			EI                ;
0f2e			CALL L05AC        ; Produce error report.
0f31			DEFB $1F          ; "d Too many brackets"
0f32
0f32	L0F32:  CALL L0E93        ; Turn off all sound and restore IY.
0f35			EI                ;
0f36			CALL L05AC        ; Produce error report.
0f39			DEFB $28          ; "m Note out of range"
0f3a
0f3a	L0F3A:  CALL L0E93        ; Turn off all sound and restore IY.
0f3d			EI                ;
0f3e			CALL L05AC        ; Produce error report.
0f41			DEFB $2A          ; "o Too many tied notes"
0f42
0f42			; -------------------------
0f42			; Play Note on Each Channel
0f42			; -------------------------
0f42			; Play a note and set the volume on each channel for which a play string exists.
0f42
0f42	L0F42:  CALL L0A4F        ; Select channel data block pointers.
0f45
0f45	L0F45:  RR   (IY+$22)     ; Working copy of channel bitmap. Test if next string present.
0f49			JR   C,L0F6C      ; Jump ahead if there is no string for this channel.
0f4b
0f4b			CALL L0A67        ; Get address of channel data block for the current string into IX.
0f4e
0f4e			CALL L0AD1        ; Get the next note in the string as number of semitones above note C.
0f51			CP   $80          ; Is it a rest?
0f53			JR   Z,L0F6C      ; Jump ahead if so and do nothing to the channel.
0f55
0f55			CALL L0E20        ; Play the note if a sound chip channel.
0f58
0f58			LD   A,(IX+$02)   ; Get channel number.
0f5b			CP   $03          ; Is it channel 0, 1 or 2, i.e. a sound chip channel?
0f5d			JR   NC,L0F69     ; Jump if not to skip setting the volume.
0f5f
0f5f			;One of the 3 sound chip generator channels so set the channel's volume for the new note
0f5f
0f5f			LD   D,$08        ;
0f61			ADD  A,D          ; A=0 to 2.
0f62			LD   D,A          ; D=Register (8 + string index), i.e. channel A, B or C volume register.
0f63			LD   E,(IX+$04)   ; E=Volume for the current channel.
0f66			CALL L0E7C        ; Write to sound generator register to set the output volume.
0f69
0f69	L0F69:  CALL L116E        ; Play a note and set the volume on the assigned MIDI channel.
0f6c
0f6c	L0F6C:  SLA  (IY+$21)     ; Have all channels been processed?
0f70			RET  C            ; Return if so.
0f71
0f71			CALL L0A6E        ; Advance to the next channel data block pointer.
0f74			JR   L0F45        ; Jump back to process the next channel.
0f76
0f76			; ------------------
0f76			; Wait Note Duration
0f76			; ------------------
0f76			; This routine is the main timing control of the PLAY command.
0f76			; It waits for the specified length of time, which will be the
0f76			; lowest note duration of all active channels.
0f76			; The actual duration of the wait is dictated by the current tempo.
0f76			; Entry: DE=Note duration, where 96d represents a whole note.
0f76
0f76			;Enter a loop waiting for (135+ ((26*(tempo-100))-5) )*DE+5 T-states
0f76
0f76	L0F76:  PUSH HL           ; (11) Save HL.
0f77
0f77			LD   L,(IY+$27)   ; (19) Get the tempo timing value.
0f7a			LD   H,(IY+$28)   ; (19)
0f7d
0f7d			LD   BC,$0064     ; (10) BC=100
0f80			OR   A            ; (4)
0f81			SBC  HL,BC        ; (15) HL=tempo timing value - 100.
0f83
0f83			PUSH HL           ; (11)
0f84			POP  BC           ; (10) BC=tempo timing value - 100.
0f85
0f85			POP  HL           ; (10) Restore HL.
0f86
0f86			;Tempo timing value = (10/(TEMPO*4))/7.33e-6, where 7.33e-6 is the time for 26 T-states.
0f86			;The loop below takes 26 T-states per iteration, where the number of iterations is given by the tempo timing value.
0f86			;So the time for the loop to execute is 2.5/TEMPO seconds.
0f86			;
0f86			;For a TEMPO of 60 beats (crotchets) per second, the time per crotchet is 1/24 second.
0f86			;The duration of a crotchet is defined as 24 from the table at $0E0C, therefore the loop will get executed 24 times
0f86			;and hence the total time taken will be 1 second.
0f86			;
0f86			;The tempo timing value above has 100 subtracted from it, presumably to approximately compensate for the overhead time
0f86			;previously taken to prepare the notes for playing. This reduces the total time by 2600 T-states, or 733us.
0f86
0f86	L0F86:  DEC  BC           ; (6)  Wait for tempo-100 loops.
0f87			LD   A,B          ; (4)
0f88			OR   C            ; (4)
0f89			JR   NZ,L0F86     ; (12/7)
0f8b
0f8b			DEC  DE           ; (6) Repeat DE times
0f8c			LD   A,D          ; (4)
0f8d			OR   E            ; (4)
0f8e			JR   NZ,L0F76     ; (12/7)
0f90
0f90			RET               ; (10)
0f91
0f91			; -----------------------------
0f91			; Find Smallest Duration Length
0f91			; -----------------------------
0f91			; This routine finds the smallest duration length for all current notes
0f91			; being played across all channels.
0f91			; Exit: DE=Smallest duration length.
0f91
0f91	L0F91:  LD   DE,$FFFF     ; Set smallest duration length to 'maximum'.
0f94
0f94			CALL L0A4A        ; Select channel data block duration pointers.
0f97
0f97	L0F97:  RR   (IY+$22)     ; Working copy of channel bitmap. Test if next string present.
0f9b			JR   C,L0FAF      ; Jump ahead if there is no string for this channel.
0f9d
0f9d			;HL=Address of channel data pointer. DE holds the smallest duration length found so far.
0f9d
0f9d			PUSH DE           ; Save the smallest duration length.
0f9e
0f9e			LD   E,(HL)       ;
0f9f			INC  HL           ;
0fa0			LD   D,(HL)       ;
0fa1			EX   DE,HL        ; DE=Channel data block duration length.
0fa2
0fa2			LD   E,(HL)       ;
0fa3			INC  HL           ;
0fa4			LD   D,(HL)       ; DE=Channel duration length.
0fa5
0fa5			PUSH DE           ;
0fa6			POP  HL           ; HL=Channel duration length.
0fa7
0fa7			POP  BC           ; Last channel duration length.
0fa8			OR   A            ;
0fa9			SBC  HL,BC        ; Is current channel's duration length smaller than the smallest so far?
0fab			JR   C,L0FAF      ; Jump ahead if so, with the new smallest value in DE.
0fad
0fad			;The current channel's duration was not smaller so restore the last smallest into DE.
0fad
0fad			PUSH BC           ;
0fae			POP  DE           ; DE=Smallest duration length.
0faf
0faf	L0FAF:  SLA  (IY+$21)     ; Have all channel strings been processed?
0fb3			JR   C,L0FBA      ; Jump ahead if so.
0fb5
0fb5			CALL L0A6E        ; Advance to the next channel data block duration pointer.
0fb8			JR   L0F97        ; Jump back to process the next channel.
0fba
0fba	L0FBA:  LD   (IY+$25),E   ;
0fbd			LD   (IY+$26),D   ; Store the smallest channel duration length.
0fc0			RET               ;
0fc1
0fc1			; ---------------------------------------------------------------
0fc1			; Play a Note on Each Channel and Update Channel Duration Lengths
0fc1			; ---------------------------------------------------------------
0fc1			; This routine is used to play a note and set the volume on all channels.
0fc1			; It subtracts an amount of time from the duration lengths of all currently
0fc1			; playing channel note durations. The amount subtracted is equivalent to the
0fc1			; smallest note duration length currently being played, and as determined earlier.
0fc1			; Hence one channel's duration will go to 0 on each call of this routine, and the
0fc1			; others will show the remaining lengths of their corresponding notes.
0fc1			; Entry: IY=Address of the command data block.
0fc1
0fc1	L0FC1:  XOR  A            ;
0fc2			LD   (IY+$2A),A   ; Holds a temporary channel bitmap.
0fc5
0fc5			CALL L0A4F        ; Select channel data block pointers.
0fc8
0fc8	L0FC8:  RR   (IY+$22)     ; Working copy of channel bitmap. Test if next string present.
0fcc			JP   C,L105A      ; Jump ahead if there is no string for this channel.
0fcf
0fcf			CALL L0A67        ; Get address of channel data block for the current string into IX.
0fd2
0fd2			PUSH IY           ;
0fd4			POP  HL           ; HL=Address of the command data block.
0fd5
0fd5			LD   BC,$0011     ;
0fd8			ADD  HL,BC        ; HL=Address of channel data block duration pointers.
0fd9
0fd9			LD   B,$00        ;
0fdb			LD   C,(IX+$02)   ; BC=Channel number.
0fde			SLA  C            ; BC=2*Channel number.
0fe0			ADD  HL,BC        ; HL=Address of channel data block duration pointer for this channel.
0fe1
0fe1			LD   E,(HL)       ;
0fe2			INC  HL           ;
0fe3			LD   D,(HL)       ; DE=Address of duration length within the channel data block.
0fe4
0fe4			EX   DE,HL        ; HL=Address of duration length within the channel data block.
0fe5			PUSH HL           ; Save it.
0fe6
0fe6			LD   E,(HL)       ;
0fe7			INC  HL           ;
0fe8			LD   D,(HL)       ; DE=Duration length for this channel.
0fe9
0fe9			EX   DE,HL        ; HL=Duration length for this channel.
0fea
0fea			LD   E,(IY+$25)   ;
0fed			LD   D,(IY+$26)   ; DE=Smallest duration length of all current channel notes.
0ff0
0ff0			OR   A            ;
0ff1			SBC  HL,DE        ; HL=Duration length - smallest duration length.
0ff3			EX   DE,HL        ; DE=Duration length - smallest duration length.
0ff4
0ff4			POP  HL           ; HL=Address of duration length within the channel data block.
0ff5			JR   Z,L0FFC      ; Jump if this channel uses the smallest found duration length.
0ff7
0ff7			LD   (HL),E       ;
0ff8			INC  HL           ; Update the duration length for this channel with the remaining length.
0ff9			LD   (HL),D       ;
0ffa
0ffa			JR   L105A        ; Jump ahead to update the next channel.
0ffc
0ffc			;The current channel uses the smallest found duration length
0ffc
0ffc			; [A note has been completed and so the channel volume is set to 0 prior to the next note being played.
0ffc			; This occurs on both sound chip channels and MIDI channels. When a MIDI channel is assigned to more than
0ffc			; one play string and a rest is used in one of those strings. As soon as the end of the rest period is
0ffc			; encountered, the channel's volume is set to off even though one of the other play strings controlling
0ffc			; the MIDI channel may still be playing. This can be seen using the command PLAY "Y1a&", "Y1N9a". Here,
0ffc			; string 1 starts playing 'a' for the period of a crotchet (1/4 of a note), where as string 2 starts playing
0ffc			; 'a' for nine periods of a crotchet (9/4 of a note). When string 1 completes its crotchet, it requests
0ffc			; to play a period of silence via the rest '&'. This turns the volume of the MIDI channel off even though
0ffc			; string 2 is still timing its way through its nine crotchets. The play command will therefore continue for
0ffc			; a further seven crotchets but in silence. This is because the volume for note is set only at its start
0ffc			; and no coordination occurs between strings to turn the volume back on for the second string. It is arguably
0ffc			; what the correct behaviour should be in such a circumstance where the strings are providing conflicting instructions,
0ffc			; but having the latest command or note take precedence seems a logical approach. Credit: Ian Collier (+3), Paul Farrow (128)]
0ffc
0ffc	L0FFC:  LD   A,(IX+$02)   ; Get the channel number.
0fff			CP   $03          ; Is it channel 0, 1 or 2, i.e. a sound chip channel?
1001			JR   NC,L100C     ; Jump ahead if not a sound generator channel.
1003
1003			LD   D,$08        ;
1005			ADD  A,D          ;
1006			LD   D,A          ; D=Register (8+channel number) - Channel volume.
1007			LD   E,$00        ; E=Volume level of 0.
1009			CALL L0E7C        ; Write to sound generator register to turn the volume off.
100c
100c	L100C:  CALL L118D        ; Turn off the assigned MIDI channel sound.
100f
100f			PUSH IX           ;
1011			POP  HL           ; HL=Address of channel data block.
1012
1012			LD   BC,$0021     ;
1015			ADD  HL,BC        ; HL=Points to the tied notes counter.
1016
1016			DEC  (HL)         ; Decrement the tied notes counter. [This contains a value of 1 for a single note]
1017			JR   NZ,L1026     ; Jump ahead if there are more tied notes.
1019
1019			CALL L0B5C        ; Find the next note to play for this channel from its play string.
101c
101c			LD   A,(IY+$21)   ; Fetch the channel selector.
101f			AND  (IY+$10)     ; Test whether this channel has further data in its play string.
1022			JR   NZ,L105A     ; Jump to process the next channel if this channel does not have a play string.
1024
1024			JR   L103D        ; The channel has more data in its play string so jump ahead.
1026
1026			;The channel has more tied notes
1026
1026	L1026:  PUSH IY           ;
1028			POP  HL           ; HL=Address of the command data block.
1029
1029			LD   BC,$0011     ;
102c			ADD  HL,BC        ; HL=Address of channel data block duration pointers.
102d
102d			LD   B,$00        ;
102f			LD   C,(IX+$02)   ; BC=Channel number.
1032			SLA  C            ; BC=2*Channel number.
1034			ADD  HL,BC        ; HL=Address of channel data block duration pointer for this channel.
1035
1035			LD   E,(HL)       ;
1036			INC  HL           ;
1037			LD   D,(HL)       ; DE=Address of duration length within the channel data block.
1038
1038			INC  DE           ;
1039			INC  DE           ; Point to the subsequent note duration length.
103a
103a			LD   (HL),D       ;
103b			DEC  HL           ;
103c			LD   (HL),E       ; Store the new duration length.
103d
103d	L103D:  CALL L0AD1        ; Get next note in the string as number of semitones above note C.
1040			LD   C,A          ; C=Number of semitones.
1041
1041			LD   A,(IY+$21)   ; Fetch the channel selector.
1044			AND  (IY+$10)     ; Test whether this channel has a play string.
1047			JR   NZ,L105A     ; Jump to process the next channel if this channel does not have a play string.
1049
1049			LD   A,C          ; A=Number of semitones.
104a			CP   $80          ; Is it a rest?
104c			JR   Z,L105A      ; Jump to process the next channel if it is.
104e
104e			CALL L0E20        ; Play the new note on this channel at the current volume if a sound chip channel, or simply store the note for play strings 4 to 8.
1051
1051			LD   A,(IY+$21)   ; Fetch the channel selector.
1054			OR   (IY+$2A)     ; Insert a bit in the temporary channel bitmap to indicate this channel has more to play.
1057			LD   (IY+$2A),A   ; Store it.
105a
105a			;Check whether another channel needs its duration length updated
105a
105a	L105A:  SLA  (IY+$21)     ; Have all channel strings been processed?
105e			JR   C,L1066      ; Jump ahead if so.
1060
1060			CALL L0A6E        ; Advance to the next channel data pointer.
1063			JP   L0FC8        ; Jump back to update the duration length for the next channel.
1066
1066			; [*BUG* - By this point, the volume for both sound chip and MIDI channels has been set to 0, i.e. off. So although the new notes have been
1066			;          set playing on the sound chip channels, no sound is audible. For MIDI channels, no new notes have yet been output and hence these
1066			;          are also silent. If the time from turning the volume off for the current note to the time to turn the volume on for the next note
1066			;          is short enough, then it will not be noticeable. However, the code at $1066 (ROM 0) introduces a 1/96th of a note delay and as a result a
1066			;          1/96th of a note period of silence between notes. The bug can be resolved by simply deleting the two instructions below that introduce
1066			;          the delay. A positive side effect of the bug in the 'V' volume command at $0C95 (ROM 0) is that it can be used to overcome the gaps of silence
1066			;          between notes for sound chip channels. By interspersing volume commands between notes, a new volume level is immediately set before
1066			;          the 1/96th of a note delay is introduced for the new note. Therefore, the delay occurs when the new note is audible instead of when it
1066			;          is silent. For example, PLAY "cV15cV15c" instead of PLAY "ccc". The note durations are still 1/96th of a note longer than they should
1066			;          be though. This technique will only work on the sound chip channels and not for any MIDI channels. Credit: Ian Collier (+3), Paul Farrow (128)]
1066
1066	L1066:  LD   DE,$0001     ; Delay for 1/96th of a note.
1069			CALL L0F76        ;
106c
106c			CALL L0A4F        ; Select channel data block pointers.
106f
106f			;All channel durations have been updated. Update the volume on each sound chip channel, and the volume and note on each MIDI channel
106f
106f	L106F:  RR   (IY+$2A)     ; Temporary channel bitmap. Test if next string present.
1073			JR   NC,L108C     ; Jump ahead if there is no string for this channel.
1075
1075			CALL L0A67        ; Get address of channel data block for the current string into IX.
1078
1078			LD   A,(IX+$02)   ; Get the channel number.
107b			CP   $03          ; Is it channel 0, 1 or 2, i.e. a sound chip channel?
107d			JR   NC,L1089     ; Jump ahead if so to process the next channel.
107f
107f			LD   D,$08        ;
1081			ADD  A,D          ;
1082			LD   D,A          ; D=Register (8+channel number) - Channel volume.
1083			LD   E,(IX+$04)   ; Get the current volume.
1086			CALL L0E7C        ; Write to sound generator register to set the volume of the channel.
1089
1089	L1089:  CALL L116E        ; Play a note and set the volume on the assigned MIDI channel.
108c
108c	L108C:  SLA  (IY+$21)     ; Have all channels been processed?
1090			RET  C            ; Return if so.
1091
1091			CALL L0A6E        ; Advance to the next channel data pointer.
1094			JR   L106F        ; Jump back to process the next channel.
1096
1096			; -----------------
1096			; Note Lookup Table
1096			; -----------------
1096			; Each word gives the value of the sound generator tone registers for a given note.
1096			; There are 9 octaves, containing a total of 108 notes. These represent notes 21 to
1096			; 128. Notes 0 to 20 cannot be reproduced on the sound chip and so note 21 will be
1096			; used for all of these (they will however be sent to a MIDI device if one is assigned
1096			; to a channel). [Note that both the sound chip and the MIDI port can not play note 128
1096			; and so its inclusion in the table is a waste of 2 bytes]. The PLAY command does not allow
1096			; octaves higher than 8 to be selected directly. Using PLAY "O8G" will select note 115. To
1096			; select higher notes, sharps must be included, e.g. PLAY "O8#G" for note 116, PLAY "O8##G"
1096			; for note 117, etc, up to PLAY "O8############G" for note 127. Attempting to access note
1096			; 128 using PLAY "O8#############G" will lead to error report "m Note out of range".
1096
1096	L1096:  DEFW $0FBF        ; Octave  1, Note  21 - A  (27.50 Hz, Ideal=27.50 Hz, Error=-0.01%) C0
1098			DEFW $0EDC        ; Octave  1, Note  22 - A# (29.14 Hz, Ideal=29.16 Hz, Error=-0.08%)
109a			DEFW $0E07        ; Octave  1, Note  23 - B  (30.87 Hz, Ideal=30.87 Hz, Error=-0.00%)
109c
109c			DEFW $0D3D        ; Octave  2, Note  24 - C  (32.71 Hz, Ideal=32.70 Hz, Error=+0.01%) C1
109e			DEFW $0C7F        ; Octave  2, Note  25 - C# (34.65 Hz, Ideal=34.65 Hz, Error=-0.00%)
10a0			DEFW $0BCC        ; Octave  2, Note  26 - D  (36.70 Hz, Ideal=36.71 Hz, Error=-0.01%)
10a2			DEFW $0B22        ; Octave  2, Note  27 - D# (38.89 Hz, Ideal=38.89 Hz, Error=+0.01%)
10a4			DEFW $0A82        ; Octave  2, Note  28 - E  (41.20 Hz, Ideal=41.20 Hz, Error=+0.00%)
10a6			DEFW $09EB        ; Octave  2, Note  29 - F  (43.66 Hz, Ideal=43.65 Hz, Error=+0.00%)
10a8			DEFW $095D        ; Octave  2, Note  30 - F# (46.24 Hz, Ideal=46.25 Hz, Error=-0.02%)
10aa			DEFW $08D6        ; Octave  2, Note  31 - G  (49.00 Hz, Ideal=49.00 Hz, Error=+0.00%)
10ac			DEFW $0857        ; Octave  2, Note  32 - G# (51.92 Hz, Ideal=51.91 Hz, Error=+0.01%)
10ae			DEFW $07DF        ; Octave  2, Note  33 - A  (55.01 Hz, Ideal=55.00 Hz, Error=+0.01%)
10b0			DEFW $076E        ; Octave  2, Note  34 - A# (58.28 Hz, Ideal=58.33 Hz, Error=-0.08%)
10b2			DEFW $0703        ; Octave  2, Note  35 - B  (61.75 Hz, Ideal=61.74 Hz, Error=+0.02%)
10b4
10b4			DEFW $069F        ; Octave  3, Note  36 - C  ( 65.39 Hz, Ideal= 65.41 Hz, Error=-0.02%) C2
10b6			DEFW $0640        ; Octave  3, Note  37 - C# ( 69.28 Hz, Ideal= 69.30 Hz, Error=-0.04%)
10b8			DEFW $05E6        ; Octave  3, Note  38 - D  ( 73.40 Hz, Ideal= 73.42 Hz, Error=-0.01%)
10ba			DEFW $0591        ; Octave  3, Note  39 - D# ( 77.78 Hz, Ideal= 77.78 Hz, Error=+0.01%)
10bc			DEFW $0541        ; Octave  3, Note  40 - E  ( 82.41 Hz, Ideal= 82.41 Hz, Error=+0.00%)
10be			DEFW $04F6        ; Octave  3, Note  41 - F  ( 87.28 Hz, Ideal= 87.31 Hz, Error=-0.04%)
10c0			DEFW $04AE        ; Octave  3, Note  42 - F# ( 92.52 Hz, Ideal= 92.50 Hz, Error=+0.02%)
10c2			DEFW $046B        ; Octave  3, Note  43 - G  ( 98.00 Hz, Ideal= 98.00 Hz, Error=+0.00%)
10c4			DEFW $042C        ; Octave  3, Note  44 - G# (103.78 Hz, Ideal=103.83 Hz, Error=-0.04%)
10c6			DEFW $03F0        ; Octave  3, Note  45 - A  (109.96 Hz, Ideal=110.00 Hz, Error=-0.04%)
10c8			DEFW $03B7        ; Octave  3, Note  46 - A# (116.55 Hz, Ideal=116.65 Hz, Error=-0.08%)
10ca			DEFW $0382        ; Octave  3, Note  47 - B  (123.43 Hz, Ideal=123.47 Hz, Error=-0.03%)
10cc
10cc			DEFW $034F        ; Octave  4, Note  48 - C  (130.86 Hz, Ideal=130.82 Hz, Error=+0.04%) C3
10ce			DEFW $0320        ; Octave  4, Note  49 - C# (138.55 Hz, Ideal=138.60 Hz, Error=-0.04%)
10d0			DEFW $02F3        ; Octave  4, Note  50 - D  (146.81 Hz, Ideal=146.83 Hz, Error=-0.01%)
10d2			DEFW $02C8        ; Octave  4, Note  51 - D# (155.68 Hz, Ideal=155.55 Hz, Error=+0.08%)
10d4			DEFW $02A1        ; Octave  4, Note  52 - E  (164.70 Hz, Ideal=164.82 Hz, Error=-0.07%)
10d6			DEFW $027B        ; Octave  4, Note  53 - F  (174.55 Hz, Ideal=174.62 Hz, Error=-0.04%)
10d8			DEFW $0257        ; Octave  4, Note  54 - F# (185.04 Hz, Ideal=185.00 Hz, Error=+0.02%)
10da			DEFW $0236        ; Octave  4, Note  55 - G  (195.83 Hz, Ideal=196.00 Hz, Error=-0.09%)
10dc			DEFW $0216        ; Octave  4, Note  56 - G# (207.57 Hz, Ideal=207.65 Hz, Error=-0.04%)
10de			DEFW $01F8        ; Octave  4, Note  57 - A  (219.92 Hz, Ideal=220.00 Hz, Error=-0.04%)
10e0			DEFW $01DC        ; Octave  4, Note  58 - A# (232.86 Hz, Ideal=233.30 Hz, Error=-0.19%)
10e2			DEFW $01C1        ; Octave  4, Note  59 - B  (246.86 Hz, Ideal=246.94 Hz, Error=-0.03%)
10e4
10e4			DEFW $01A8        ; Octave  5, Note  60 - C  (261.42 Hz, Ideal=261.63 Hz, Error=-0.08%) C4 Middle C
10e6			DEFW $0190        ; Octave  5, Note  61 - C# (277.10 Hz, Ideal=277.20 Hz, Error=-0.04%)
10e8			DEFW $0179        ; Octave  5, Note  62 - D  (294.01 Hz, Ideal=293.66 Hz, Error=+0.12%)
10ea			DEFW $0164        ; Octave  5, Note  63 - D# (311.35 Hz, Ideal=311.10 Hz, Error=+0.08%)
10ec			DEFW $0150        ; Octave  5, Note  64 - E  (329.88 Hz, Ideal=329.63 Hz, Error=+0.08%)
10ee			DEFW $013D        ; Octave  5, Note  65 - F  (349.65 Hz, Ideal=349.23 Hz, Error=+0.12%)
10f0			DEFW $012C        ; Octave  5, Note  66 - F# (369.47 Hz, Ideal=370.00 Hz, Error=-0.14%)
10f2			DEFW $011B        ; Octave  5, Note  67 - G  (391.66 Hz, Ideal=392.00 Hz, Error=-0.09%)
10f4			DEFW $010B        ; Octave  5, Note  68 - G# (415.13 Hz, Ideal=415.30 Hz, Error=-0.04%)
10f6			DEFW $00FC        ; Octave  5, Note  69 - A  (439.84 Hz, Ideal=440.00 Hz, Error=-0.04%)
10f8			DEFW $00EE        ; Octave  5, Note  70 - A# (465.72 Hz, Ideal=466.60 Hz, Error=-0.19%)
10fa			DEFW $00E0        ; Octave  5, Note  71 - B  (494.82 Hz, Ideal=493.88 Hz, Error=+0.19%)
10fc
10fc			DEFW $00D4        ; Octave  6, Note  72 - C  (522.83 Hz, Ideal=523.26 Hz, Error=-0.08%) C5
10fe			DEFW $00C8        ; Octave  6, Note  73 - C# (554.20 Hz, Ideal=554.40 Hz, Error=-0.04%)
1100			DEFW $00BD        ; Octave  6, Note  74 - D  (586.46 Hz, Ideal=587.32 Hz, Error=-0.15%)
1102			DEFW $00B2        ; Octave  6, Note  75 - D# (622.70 Hz, Ideal=622.20 Hz, Error=+0.08%)
1104			DEFW $00A8        ; Octave  6, Note  76 - E  (659.77 Hz, Ideal=659.26 Hz, Error=+0.08%)
1106			DEFW $009F        ; Octave  6, Note  77 - F  (697.11 Hz, Ideal=698.46 Hz, Error=-0.19%)
1108			DEFW $0096        ; Octave  6, Note  78 - F# (738.94 Hz, Ideal=740.00 Hz, Error=-0.14%)
110a			DEFW $008D        ; Octave  6, Note  79 - G  (786.10 Hz, Ideal=784.00 Hz, Error=+0.27%)
110c			DEFW $0085        ; Octave  6, Note  80 - G# (833.39 Hz, Ideal=830.60 Hz, Error=+0.34%)
110e			DEFW $007E        ; Octave  6, Note  81 - A  (879.69 Hz, Ideal=880.00 Hz, Error=-0.04%)
1110			DEFW $0077        ; Octave  6, Note  82 - A# (931.43 Hz, Ideal=933.20 Hz, Error=-0.19%)
1112			DEFW $0070        ; Octave  6, Note  83 - B  (989.65 Hz, Ideal=987.76 Hz, Error=+0.19%)
1114
1114			DEFW $006A        ; Octave  7, Note  84 - C  (1045.67 Hz, Ideal=1046.52 Hz, Error=-0.08%) C6
1116			DEFW $0064        ; Octave  7, Note  85 - C# (1108.41 Hz, Ideal=1108.80 Hz, Error=-0.04%)
1118			DEFW $005E        ; Octave  7, Note  86 - D  (1179.16 Hz, Ideal=1174.64 Hz, Error=+0.38%)
111a			DEFW $0059        ; Octave  7, Note  87 - D# (1245.40 Hz, Ideal=1244.40 Hz, Error=+0.08%)
111c			DEFW $0054        ; Octave  7, Note  88 - E  (1319.53 Hz, Ideal=1318.52 Hz, Error=+0.08%)
111e			DEFW $004F        ; Octave  7, Note  89 - F  (1403.05 Hz, Ideal=1396.92 Hz, Error=+0.44%)
1120			DEFW $004B        ; Octave  7, Note  90 - F# (1477.88 Hz, Ideal=1480.00 Hz, Error=-0.14%)
1122			DEFW $0047        ; Octave  7, Note  91 - G  (1561.14 Hz, Ideal=1568.00 Hz, Error=-0.44%)
1124			DEFW $0043        ; Octave  7, Note  92 - G# (1654.34 Hz, Ideal=1661.20 Hz, Error=-0.41%)
1126			DEFW $003F        ; Octave  7, Note  93 - A  (1759.38 Hz, Ideal=1760.00 Hz, Error=-0.04%)
1128			DEFW $003B        ; Octave  7, Note  94 - A# (1878.65 Hz, Ideal=1866.40 Hz, Error=+0.66%)
112a			DEFW $0038        ; Octave  7, Note  95 - B  (1979.30 Hz, Ideal=1975.52 Hz, Error=+0.19%)
112c
112c			DEFW $0035        ; Octave  8, Note  96 - C  (2091.33 Hz, Ideal=2093.04 Hz, Error=-0.08%) C7
112e			DEFW $0032        ; Octave  8, Note  97 - C# (2216.81 Hz, Ideal=2217.60 Hz, Error=-0.04%)
1130			DEFW $002F        ; Octave  8, Note  98 - D  (2358.31 Hz, Ideal=2349.28 Hz, Error=+0.38%)
1132			DEFW $002D        ; Octave  8, Note  99 - D# (2463.13 Hz, Ideal=2488.80 Hz, Error=-1.03%)
1134			DEFW $002A        ; Octave  8, Note 100 - E  (2639.06 Hz, Ideal=2637.04 Hz, Error=+0.08%)
1136			DEFW $0028        ; Octave  8, Note 101 - F  (2771.02 Hz, Ideal=2793.84 Hz, Error=-0.82%)
1138			DEFW $0025        ; Octave  8, Note 102 - F# (2995.69 Hz, Ideal=2960.00 Hz, Error=+1.21%)
113a			DEFW $0023        ; Octave  8, Note 103 - G  (3166.88 Hz, Ideal=3136.00 Hz, Error=+0.98%)
113c			DEFW $0021        ; Octave  8, Note 104 - G# (3358.81 Hz, Ideal=3322.40 Hz, Error=+1.10%)
113e			DEFW $001F        ; Octave  8, Note 105 - A  (3575.50 Hz, Ideal=3520.00 Hz, Error=+1.58%)
1140			DEFW $001E        ; Octave  8, Note 106 - A# (3694.69 Hz, Ideal=3732.80 Hz, Error=-1.02%)
1142			DEFW $001C        ; Octave  8, Note 107 - B  (3958.59 Hz, Ideal=3951.04 Hz, Error=+0.19%)
1144
1144			DEFW $001A        ; Octave  9, Note 108 - C  (4263.10 Hz, Ideal=4186.08 Hz, Error=+1.84%) C8
1146			DEFW $0019        ; Octave  9, Note 109 - C# (4433.63 Hz, Ideal=4435.20 Hz, Error=-0.04%)
1148			DEFW $0018        ; Octave  9, Note 110 - D  (4618.36 Hz, Ideal=4698.56 Hz, Error=-1.71%)
114a			DEFW $0016        ; Octave  9, Note 111 - D# (5038.21 Hz, Ideal=4977.60 Hz, Error=+1.22%)
114c			DEFW $0015        ; Octave  9, Note 112 - E  (5278.13 Hz, Ideal=5274.08 Hz, Error=+0.08%)
114e			DEFW $0014        ; Octave  9, Note 113 - F  (5542.03 Hz, Ideal=5587.68 Hz, Error=-0.82%)
1150			DEFW $0013        ; Octave  9, Note 114 - F# (5833.72 Hz, Ideal=5920.00 Hz, Error=-1.46%)
1152			DEFW $0012        ; Octave  9, Note 115 - G  (6157.81 Hz, Ideal=6272.00 Hz, Error=-1.82%)
1154			DEFW $0011        ; Octave  9, Note 116 - G# (6520.04 Hz, Ideal=6644.80 Hz, Error=-1.88%)
1156			DEFW $0010        ; Octave  9, Note 117 - A  (6927.54 Hz, Ideal=7040.00 Hz, Error=-1.60%)
1158			DEFW $000F        ; Octave  9, Note 118 - A# (7389.38 Hz, Ideal=7465.60 Hz, Error=-1.02%)
115a			DEFW $000E        ; Octave  9, Note 119 - B  (7917.19 Hz, Ideal=7902.08 Hz, Error=+0.19%)
115c
115c			DEFW $000D        ; Octave 10, Note 120 - C  ( 8526.20 Hz, Ideal= 8372.16 Hz, Error=+1.84%) C9
115e			DEFW $000C        ; Octave 10, Note 121 - C# ( 9236.72 Hz, Ideal= 8870.40 Hz, Error=+4.13%)
1160			DEFW $000C        ; Octave 10, Note 122 - D  ( 9236.72 Hz, Ideal= 9397.12 Hz, Error=-1.71%)
1162			DEFW $000B        ; Octave 10, Note 123 - D# (10076.42 Hz, Ideal= 9955.20 Hz, Error=+1.22%)
1164			DEFW $000B        ; Octave 10, Note 124 - E  (10076.42 Hz, Ideal=10548.16 Hz, Error=-4.47%)
1166			DEFW $000A        ; Octave 10, Note 125 - F  (11084.06 Hz, Ideal=11175.36 Hz, Error=-0.82%)
1168			DEFW $0009        ; Octave 10, Note 126 - F# (12315.63 Hz, Ideal=11840.00 Hz, Error=+4.02%)
116a			DEFW $0009        ; Octave 10, Note 127 - G  (12315.63 Hz, Ideal=12544.00 Hz, Error=-1.82%)
116c			DEFW $0008        ; Octave 10, Note 128 - G# (13855.08 Hz, Ideal=13289.60 Hz, Error=+4.26%)
116e
116e			; -------------------------
116e			; Play Note on MIDI Channel
116e			; -------------------------
116e			; This routine turns on a note on the MIDI channel and sets its volume, if MIDI channel is assigned to the current string.
116e			; Three bytes are sent, and have the following meaning:
116e			;   Byte 1: Channel number $00..$0F, with bits 4 and 7 set.
116e			;   Byte 2: Note number $00..$7F.
116e			;   Byte 3: Note velocity $00..$78.
116e			; Entry: IX=Address of the channel data block.
116e
116e	L116E:  LD   A,(IX+$01)   ; Is a MIDI channel assigned to this string?
1171			OR   A            ;
1172			RET  M            ; Return if not.
1173
1173			;A holds the assigned channel number ($00..$0F)
1173
1173			OR   $90          ; Set bits 4 and 7 of the channel number. A=$90..$9F.
1175			CALL L11A3        ; Write byte to MIDI device.
1178
1178			LD   A,(IX+$00)   ; The note number.
117b			CALL L11A3        ; Write byte to MIDI device.
117e
117e			LD   A,(IX+$04)   ; Fetch the channel's volume.
1181			RES  4,A          ; Ensure the 'using envelope' bit is reset so
1183			SLA  A            ; that A holds a value between $00 and $0F.
1185			SLA  A            ; Multiply by 8 to increase the range to $00..$78.
1187			SLA  A            ; A=Note velocity.
1189			CALL L11A3        ; Write byte to MIDI device.
118c			RET               ; [Could have saved 1 byte by using JP $11A3 (ROM 0)]
118d
118d			; ---------------------
118d			; Turn MIDI Channel Off
118d			; ---------------------
118d			; This routine turns off a note on the MIDI channel, if a MIDI channel is assigned to the current string.
118d			; Three bytes are sent, and have the following meaning:
118d			;   Byte 1: Channel number $00..$0F, with bit 7 set.
118d			;   Byte 2: Note number $00..$7F.
118d			;   Byte 3: Note velocity $40.
118d			; Entry: IX=Address of the channel data block.
118d
118d	L118D:  LD   A,(IX+$01)   ; Is a MIDI channel assigned to this string?
1190			OR   A            ;
1191			RET  M            ; Return if not.
1192
1192			;A holds the assigned channel number ($00..$0F)
1192
1192			OR   $80          ; Set bit 7 of the channel number. A=$80..$8F.
1194			CALL L11A3        ; Write byte to MIDI device.
1197
1197			LD   A,(IX+$00)   ; The note number.
119a			CALL L11A3        ; Write byte to MIDI device.
119d
119d			LD   A,$40        ; The note velocity.
119f			CALL L11A3        ; Write byte to MIDI device.
11a2			RET               ; [Could have saved 1 byte by using JP $11A3 (ROM 0)]
11a3
11a3			; ------------------------
11a3			; Send Byte to MIDI Device
11a3			; ------------------------
11a3			; This routine sends a byte to the MIDI port. MIDI devices communicate at 31250 baud,
11a3			; although this routine actually generates a baud rate of 31388, which is within the 1%
11a3			; tolerance supported by MIDI devices.
11a3			; Entry: A=Byte to send.
11a3
11a3	L11A3:  LD   L,A          ; Store the byte to send.
11a4
11a4			LD   BC,$FFFD     ;
11a7			LD   A,$0E        ;
11a9			OUT  (C),A        ; Select register 14 - I/O port.
11ab
11ab			LD   BC,$BFFD     ;
11ae			LD   A,$FA        ; Set RS232 'RXD' transmit line to 0. (Keep KEYPAD 'CTS' output line low to prevent the keypad resetting)
11b0			OUT  (C),A        ; Send out the START bit.
11b2
11b2			LD   E,$03        ; (7) Introduce delays such that the next bit is output 113 T-states from now.
11b4
11b4	L11B4:  DEC  E            ; (4)
11b5			JR   NZ,L11B4     ; (12/7)
11b7
11b7			NOP               ; (4)
11b8			NOP               ; (4)
11b9			NOP               ; (4)
11ba			NOP               ; (4)
11bb
11bb			LD   A,L          ; (4) Retrieve the byte to send.
11bc
11bc			LD   D,$08        ; (7) There are 8 bits to send.
11be
11be	L11BE:  RRA               ; (4) Rotate the next bit to send into the carry.
11bf			LD   L,A          ; (4) Store the remaining bits.
11c0			JP   NC,L11C9     ; (10) Jump if it is a 0 bit.
11c3
11c3			LD   A,$FE        ; (7) Set RS232 'RXD' transmit line to 1. (Keep KEYPAD 'CTS' output line low to prevent the keypad resetting)
11c5			OUT  (C),A        ; (11)
11c7			JR   L11CF        ; (12) Jump forward to process the next bit.
11c9
11c9	L11C9:  LD   A,$FA        ; (7) Set RS232 'RXD' transmit line to 0. (Keep KEYPAD 'CTS' output line low to prevent the keypad resetting)
11cb			OUT  (C),A        ; (11)
11cd			JR   L11CF        ; (12) Jump forward to process the next bit.
11cf
11cf	L11CF:  LD   E,$02        ; (7) Introduce delays such that the next data bit is output 113 T-states from now.
11d1
11d1	L11D1:  DEC  E            ; (4)
11d2			JR   NZ,L11D1     ; (12/7)
11d4
11d4			NOP               ; (4)
11d5			ADD  A,$00        ; (7)
11d7
11d7			LD   A,L          ; (4) Retrieve the remaining bits to send.
11d8			DEC  D            ; (4) Decrement the bit counter.
11d9			JR   NZ,L11BE     ; (12/7) Jump back if there are further bits to send.
11db
11db			NOP               ; (4) Introduce delays such that the stop bit is output 113 T-states from now.
11dc			NOP               ; (4)
11dd			ADD  A,$00        ; (7)
11df			NOP               ; (4)
11e0			NOP               ; (4)
11e1
11e1			LD   A,$FE        ; (7) Set RS232 'RXD' transmit line to 0. (Keep KEYPAD 'CTS' output line low to prevent the keypad resetting)
11e3			OUT  (C),A        ; (11) Send out the STOP bit.
11e5
11e5			LD   E,$06        ; (7) Delay for 101 T-states (28.5us).
11e7
11e7	L11E7:  DEC  E            ; (4)
11e8			JR   NZ,L11E7     ; (12/7)
11ea
11ea			RET               ; (10)
11eb
11eb
11eb			; =============================================
11eb			; CASSETTE / RAM DISK COMMAND ROUTINES - PART 1
11eb			; =============================================
11eb
11eb			; ------------
11eb			; SAVE Routine
11eb			; ------------
11eb
11eb	L11EB:  LD   HL,FLAGS3    ; $5B66.
11ee			SET  5,(HL)       ; Indicate SAVE.
11f0			JR   L1205
11f2
11f2			; ------------
11f2			; LOAD Routine
11f2			; ------------
11f2
11f2	L11F2:  LD   HL,FLAGS3    ; $5B66.
11f5			SET  4,(HL)       ; Indicate LOAD.
11f7			JR   L1205
11f9
11f9			; --------------
11f9			; VERIFY Routine
11f9			; --------------
11f9
11f9	L11F9:  LD   HL,FLAGS3    ; $5B66.
11fc			SET  7,(HL)       ; Indicate VERIFY.
11fe			JR   L1205
1200
1200			; -------------
1200			; MERGE Routine
1200			; -------------
1200
1200	L1200:  LD   HL,FLAGS3    ; $5B66.
1203			SET  6,(HL)       ; Indicate MERGE.
1205
1205	L1205:  LD   HL,FLAGS3    ; $5B66.
1208			RES  3,(HL)       ; Indicate using cassette.
120a			RST  18H          ; Get current character.
120b			CP   '!'          ; $21. '!'
120d			JP   NZ,L13BE     ; Jump ahead to handle cassette command.
1210
1210			;RAM disk operation
1210
1210			LD   HL,FLAGS3    ; $5B66.
1213			SET  3,(HL)       ; Indicate using RAM disk.
1215			RST  20H          ; Move on to next character.
1216			JP   L13BE        ; Jump ahead to handle RAM disk command.
1219
1219	L1219:  CALL L05AC        ; Produce error report.
121c			DEFB $0B          ; "C Nonsense in BASIC"
121d
121d			; -------------------------
121d			; RAM Disk Command Handling
121d			; -------------------------
121d			; The information relating to the file is copied into memory in $5B66 (FLAGS3)
121d			; to ensure that it is available once other RAM banks are switched in.
121d			; This code is very similar to that in the ZX Interface 1 ROM at $08F6.
121d			; Entry: HL=Start address.
121d			;        IX=File header descriptor.
121d
121d	L121D:  LD   (HD_0D),HL   ; $5B74. Save start address.
1220
1220			LD   A,(IX+$00)   ; Transfer header file information
1223			LD   (HD_00),A    ; $5B71.  from IX to HD_00 onwards.
1226			LD   L,(IX+$0B)   ;
1229			LD   H,(IX+$0C)   ;
122c			LD   (HD_0B),HL   ; $5B72.
122f			LD   L,(IX+$0D)   ;
1232			LD   H,(IX+$0E)   ;
1235			LD   (HD_11),HL   ; $5B78.
1238			LD   L,(IX+$0F)   ;
123b			LD   H,(IX+$10)   ;
123e			LD   (HD_0F),HL   ; $5B76.
1241
1241			;A copy of the header information has now been copied from IX+$00 onwards to HD_00 onwards
1241
1241			OR   A            ; Test file type.
1242			JR   Z,L124E      ; Jump ahead for a program file.
1244
1244			CP   $03          ;
1246			JR   Z,L124E      ; Jump ahead for a CODE/SCREEN$ file.
1248
1248			;An array type
1248
1248			LD   A,(IX+$0E)   ;
124b			LD   (HD_0F),A    ; $5B76. Store array name.
124e
124e	L124E:  PUSH IX           ; IX points to file header.
1250			POP  HL           ; Retrieve into HL.
1251
1251			INC  HL           ; HL points to filename.
1252			LD   DE,N_STR1    ; $5B67.
1255			LD   BC,$000A     ;
1258			LDIR              ; Copy the filename.
125a
125a			LD   HL,FLAGS3    ; $5B66.
125d			BIT  5,(HL)       ; SAVE operation?
125f			JP   NZ,L1BAD     ; Jump ahead if SAVE.
1262
1262			; Load / Verify or Merge
1262			; ----------------------
1262
1262			LD   HL,HD_00     ; $5B71.
1265			LD   DE,SC_00     ; $5B7A.
1268			LD   BC,$0007     ;
126b			LDIR              ; Transfer requested details from HD_00 onwards into SC_00 onwards.
126d
126d			CALL L1C2E        ; Find and load requested file header into HD_00 ($5B71).
1270
1270			;The file exists else the call above would have produced an error "h file does not exist"
1270
1270			LD   A,(SC_00)    ; $5B7A. Requested file type.
1273			LD   B,A          ;
1274			LD   A,(HD_00)    ; $5B71. Loaded file type.
1277			CP   B            ;
1278			JR   NZ,L1280     ; Error 'b' if file types do not match.
127a
127a			CP   $03          ; Is it a CODE file type?
127c			JR   Z,L1290      ; Jump ahead to avoid MERGE program/array check.
127e
127e			JR   C,L1284      ; Only file types 0, 1 and 2 are OK.
1280
1280	L1280:  CALL L05AC        ; Produce error report.
1283			DEFB $1D          ; "b Wrong file type"
1284
1284	L1284:  LD   A,(FLAGS3)   ; $5B66.
1287			BIT  6,A          ; Is it a MERGE program/array operation?
1289			JR   NZ,L12C5     ; Jump ahead if so.
128b
128b			BIT  7,A          ; Is it a VERIFY program/array operation?
128d			JP   Z,L12DB      ; Jump ahead if LOAD.
1290
1290			;Either a verify program/array or a load/verify CODE/SCREEN$ type file
1290
1290	L1290:  LD   A,(FLAGS3)   ; $5B66.
1293			BIT  6,A          ; MERGE operation?
1295			JR   Z,L129B      ; Jump ahead if VERIFY.
1297
1297			;Cannot merge CODE/SCREEN$
1297
1297			CALL L05AC        ; Produce error report.
129a			DEFB $1C          ; "a MERGE error"
129b
129b			; ------------------------
129b			; RAM Disk VERIFY! Routine
129b			; ------------------------
129b
129b	L129B:  LD   HL,(SC_0B)   ; $5B7B. Length requested.
129e			LD   DE,(HD_0B)   ; $5B72. File length.
12a2			LD   A,H          ;
12a3			OR   L            ;
12a4			JR   Z,L12AE      ; Jump ahead if requested length is 0, i.e. not specified.
12a6
12a6			SBC  HL,DE        ; Is file length <= requested length?
12a8			JR   NC,L12AE     ; Jump ahead if so; requested length is OK.
12aa
12aa			;File was smaller than requested
12aa
12aa			CALL L05AC        ; Produce error report.
12ad			DEFB $1E          ; "c CODE error"
12ae
12ae	L12AE:  LD   HL,(SC_0D)   ; $5B7D. Fetch start address.
12b1			LD   A,H          ;
12b2			OR   L            ; Is length 0, i.e. not provided?
12b3			JR   NZ,L12B8     ; Jump ahead if start address was provided.
12b5
12b5			LD   HL,(HD_0D)   ; $5B74. Not provided so use file's start address.
12b8
12b8	L12B8:  LD   A,(HD_00)    ; $5B71. File type.
12bb			AND  A            ; Is it a program?
12bc			JR   NZ,L12C1     ; Jump ahead if not.
12be
12be			LD   HL,($5C53)   ; PROG. Set start address as start of program area.
12c1
12c1	L12C1:  CALL L137E        ; Load DE bytes at address pointed to by HL.
12c4			; [The Spectrum 128 manual states that the VERIFY keyword is not used with the RAM disk yet it clearly is,
12c4			; although verifying a RAM disk file simply loads it in just as LOAD would do. To support verifying, the routine
12c4			; at $1E37 (ROM 0) which loads blocks of data would need to be able to load or verify a block. The success status would
12c4			; then need to be propagated back to here via routines at $137E (ROM 0), $1C4B (ROM 0) and $1E37 (ROM 0)]
12c4			RET               ; [Could have saved 1 byte by using JP $137E (ROM 0), although could have saved a lot more by not supporting the
12c5			; VERIFY keyword at all]
12c5
12c5			; -----------------------
12c5			; RAM Disk MERGE! Routine
12c5			; -----------------------
12c5
12c5	L12C5:  LD   BC,(HD_0B)   ; $5B72. File length.
12c9			PUSH BC           ; Save the length.
12ca			INC  BC           ; Increment for terminator $80 (added later).
12cb			RST  28H          ;
12cc			DEFW BC_SPACES    ; $0030. Create room in the workspace for the file.
12ce			LD   (HL),$80     ; Insert terminator.
12d0
12d0			EX   DE,HL        ; HL=Start address.
12d1			POP  DE           ; DE=File length.
12d2			PUSH HL           ; Save start address.
12d3			CALL L137E        ; Load DE bytes to address pointed to by HL.
12d6			POP  HL           ; Retrieve start address.
12d7
12d7			RST  28H          ;
12d8			DEFW ME_CONTRL+$0018 ;$08CE. Delegate actual merge handling to ROM 1.
12da			RET               ;
12db
12db			; ----------------------
12db			; RAM Disk LOAD! Routine
12db			; ----------------------
12db
12db	L12DB:  LD   DE,(HD_0B)   ; $5B72. File length.
12df			LD   HL,(SC_0D)   ; $5B7D. Requested start address.
12e2			PUSH HL           ; Save requested start address.
12e3			LD   A,H          ;
12e4			OR   L            ; Was start address specified? (0 if not).
12e5			JR   NZ,L12ED     ; Jump ahead if start address specified.
12e7
12e7			;Start address was not specified
12e7
12e7			INC  DE           ; Allow for variable overhead.
12e8			INC  DE           ;
12e9			INC  DE           ;
12ea			EX   DE,HL        ; HL=File Length+3.
12eb			JR   L12F6        ; Jump ahead to test if there is room.
12ed
12ed			;A start address was specified
12ed
12ed	L12ED:  LD   HL,(SC_0B)   ; $5B7B. Requested length.
12f0			EX   DE,HL        ; DE=Requested length. HL=File length.
12f1			SCF               ;
12f2			SBC  HL,DE        ; File length-Requested Length-1
12f4			JR   C,L12FF      ; Jump if file is smaller than requested.
12f6
12f6			;Test if there is room since file is bigger than requested
12f6
12f6	L12F6:  LD   DE,$0005     ;
12f9			ADD  HL,DE        ;
12fa			LD   B,H          ;
12fb			LD   C,L          ; Space required in BC.
12fc			RST  28H          ;
12fd			DEFW TEST_ROOM    ; $1F05. Will automatically produce error '4' if out of memory.
12ff
12ff			;Test file type
12ff
12ff	L12FF:  POP  HL           ; Requested start address.
1300			LD   A,(HD_00)    ; $5B71. Get requested file type.
1303
1303	L1303:  AND  A            ; Test file type.
1304			JR   Z,L1335      ; Jump if program file type.
1306
1306			; Array type
1306			; ----------
1306
1306			LD   A,H          ;
1307			OR   L            ; Was start address of existing array specified?
1308			JR   Z,L1315      ; Jump ahead if not.
130a
130a			;Start address of existing array was specified
130a
130a			DEC  HL           ;
130b			LD   B,(HL)       ;
130c			DEC  HL           ;
130d			LD   C,(HL)       ; Fetch array length.
130e			DEC  HL           ;
130f			INC  BC           ;
1310			INC  BC           ;
1311			INC  BC           ; Allow for variable header.
1312			RST  28H          ;
1313			DEFW RECLAIM_2    ; $19E8. Delete old array.
1315
1315			;Insert new array entry into variables area
1315
1315	L1315:  LD   HL,($5C59)   ; E_LINE.
1318			DEC  HL           ; Point to end
1319			LD   BC,(HD_0B)   ; $5B72. Array length.
131d			PUSH BC           ; Save array length.
131e			INC  BC           ; Allow for variable header.
131f			INC  BC           ;
1320			INC  BC           ;
1321			LD   A,(SC_0F)    ; $5B7F. Get array name.
1324			PUSH AF           ; Save array name.
1325			RST  28H          ;
1326			DEFW MAKE_ROOM    ; $1655. Create room for new array.
1328			INC HL
1329			POP  AF           ;
132a			LD   (HL),A       ; Store array name.
132b			POP  DE           ;
132c			INC  HL           ;
132d			LD   (HL),E       ;
132e			INC  HL           ;
132f			LD   (HL),D       ; Store array length.
1330			INC  HL           ;
1331
1331	L1331:  CALL L137E        ; Load DE bytes to address pointed to by HL.
1334			RET               ; [Could have saved 1 byte by using JP $137E (ROM 0)]
1335
1335			; Program type
1335			; ------------
1335
1335	L1335:  LD   HL,FLAGS3    ; $5B66.
1338			RES  1,(HL)       ; Signal do not auto-run BASIC program.
133a
133a			LD   DE,($5C53)   ; PROG. Address of start of BASIC program.
133e			LD   HL,($5C59)   ; E_LINE. Address of end of program area.
1341			DEC  HL           ; Point before terminator.
1342			RST  28H          ;
1343			DEFW RECLAIM      ; $19E5. Delete current BASIC program.
1345
1345			LD   BC,(HD_0B)   ; $5B72. Fetch file length.
1349			LD   HL,($5C53)   ; PROG. Address of start of BASIC program.
134c			RST  28H          ;
134d			DEFW MAKE_ROOM    ; $1655. Create room for the file.
134f			INC HL            ; Allow for terminator.
1350
1350			LD   BC,(HD_0F)   ; $5B76. Length of variables.
1354			ADD  HL,BC        ; Determine new address of variables.
1355			LD   ($5C4B),HL   ; VARS.
1358
1358			LD   A,(HD_11+1)  ; $5B79. Fetch high byte of auto-run line number.
135b			LD   H,A          ;
135c			AND  $C0          ;
135e			JR   NZ,L1370     ; If holds $80 then no auto-run line number specified.
1360
1360			LD   A,(HD_11)    ; $5B78. Low byte of auto-run line number.
1363			LD   L,A          ;
1364			LD   ($5C42),HL   ; NEWPPC. Set line number to run.
1367			LD   (IY+$0A),$00 ; NSPPC. Statement 0.
136b
136b			LD   HL,FLAGS3    ; $5B66.
136e			SET  1,(HL)       ; Signal auto-run BASIC program.
1370
1370	L1370:  LD   HL,($5C53)   ; PROG. Address of start of BASIC program.
1373			LD   DE,(HD_0B)   ; $5B72. Program length.
1377			DEC  HL           ;
1378			LD   ($5C57),HL   ; NXTLIN. Set the address of next line to the end of the program.
137b			INC  HL           ;
137c			JR   L1331        ; Jump back to load program bytes.
137e
137e			; -------------------
137e			; RAM Disk Load Bytes
137e			; -------------------
137e			; Make a check that the requested length is not zero before proceeding to perform
137e			; the LOAD, MERGE or VERIFY. Note that VERIFY simply performs a LOAD.
137e			; Entry: HL=Destination address.
137e			;        DE=Length.
137e			;        IX=Address of catalogue entry.
137e			;        HD_00-HD_11 holds file header information.
137e
137e	L137E:  LD   A,D          ;
137f			OR   E            ;
1380			RET  Z            ; Return if length is zero.
1381
1381			CALL L1C4B        ; Load bytes
1384			RET               ; [Could have used JP $1C4B (ROM 0) to save 1 byte]
1385
1385			; ------------------------------
1385			; Get Expression from BASIC Line
1385			; ------------------------------
1385			; Returns in BC.
1385
1385	L1385:  RST  28H          ; Expect an expression on the BASIC line.
1386			DEFW EXPT_EXP     ; $1C8C.
1388			BIT  7,(IY+$01)   ; Return early if syntax checking.
138c			RET  Z            ;
138d
138d			PUSH AF           ; Get the item off the calculator stack
138e			RST  28H          ;
138f			DEFW STK_FETCH    ; $2BF1.
1391			POP  AF           ;
1392			RET               ;
1393
1393			; -----------------------
1393			; Check Filename and Copy
1393			; -----------------------
1393			; Called to check a filename for validity and to copy it into N_STR1 ($5B67).
1393
1393	L1393:  RST  20H          ; Advance the pointer into the BASIC line.
1394			CALL L1385        ; Get expression from BASIC line.
1397			RET  Z            ; Return if syntax checking.
1398
1398			PUSH AF           ; [No need to save AF - see comment below]
1399
1399			LD   A,C          ; Check for zero length.
139a			OR   B            ;
139b			JR   Z,L13BA      ; Jump if so to produce error report "f Invalid name".
139d
139d			LD   HL,$000A     ; Check for length greater than 10.
13a0			SBC  HL,BC        ;
13a2			JR   C,L13BA      ; Jump if so to produce error report "f Invalid name".
13a4
13a4			PUSH DE           ; Save the filename start address.
13a5			PUSH BC           ; Save the filename length.
13a6
13a6			LD   HL,N_STR1    ; $5B67. HL points to filename buffer.
13a9			LD   B,$0A        ;
13ab			LD   A,$20        ;
13ad
13ad	L13AD:  LD   (HL),A       ; Fill it with 10 spaces.
13ae			INC  HL           ;
13af			DJNZ L13AD        ;
13b1
13b1			POP  BC           ; Restore filename length.
13b2			POP  HL           ; Restore filename start address.
13b3
13b3			LD   DE,N_STR1    ; $5B67. DE points to where to store the filename.
13b6			LDIR              ; Perform the copy.
13b8
13b8			POP  AF           ; [No need to have saved AF as not subsequently used]
13b9			RET               ;
13ba
13ba	L13BA:  CALL L05AC        ; Produce error report.
13bd			DEFB $21          ; "f Invalid name"
13be
13be			; ------------------------------------
13be			; Cassette / RAM Disk Command Handling
13be			; ------------------------------------
13be			; Handle SAVE, LOAD, MERGE, VERIFY commands.
13be			; Bit 3 of FLAGS3 indicates whether a cassette or RAM disk command.
13be			; This code is very similar to that in ROM 1 at $0605.
13be
13be	L13BE:  RST 28H
13bf			DEFW EXPT_EXP     ; $1C8C. Pass the parameters of the 'name' to the calculator stack.
13c1
13c1			BIT  7,(IY+$01)   ;
13c5			JR   Z,L1407      ; Jump ahead if checking syntax.
13c7
13c7			LD   BC,$0011     ; Size of save header, 17 bytes.
13ca			LD   A,($5C74)    ; T_ADDR. Indicates which BASIC command.
13cd			AND  A            ; Is it SAVE?
13ce			JR   Z,L13D2      ; Jump ahead if so.
13d0
13d0			LD   C,$22        ; Otherwise need 34d bytes for LOAD, MERGE and VERIFY commands.
13d2			; 17 bytes for the header of the requested file, and 17 bytes for the files tested from tape.
13d2
13d2	L13D2:  RST  28H          ;
13d3			DEFW BC_SPACES    ; $0030. Create space in workspace.
13d5
13d5			PUSH DE           ; Get start of the created space into IX.
13d6			POP  IX           ;
13d8
13d8			LD   B,$0B        ; Clear the filename.
13da			LD   A,$20        ;
13dc
13dc	L13DC:  LD   (DE),A       ; Set all characters to spaces.
13dd			INC  DE           ;
13de			DJNZ L13DC        ;
13e0
13e0			LD   (IX+$01),$FF ; Indicate a null name.
13e4			RST  28H          ; The parameters of the name are fetched.
13e5			DEFW STK_FETCH    ; $2BF1.
13e7
13e7			LD   HL,$FFF6     ; = -10.
13ea			DEC  BC           ;
13eb			ADD  HL,BC        ;
13ec			INC  BC           ;
13ed			JR   NC,L1400     ; Jump ahead if filename length within 10 characters.
13ef
13ef			LD   A,($5C74)    ; T_ADDR. Indicates which BASIC command.
13f2			AND  A            ; Is it SAVE?
13f3			JR   NZ,L13F9     ; Jump ahead if not since LOAD, MERGE and VERIFY can have null filenames.
13f5
13f5			CALL L05AC        ; Produce error report.
13f8			DEFB $0E          ; "F Invalid file name"
13f9
13f9			;Continue to handle the name of the program.
13f9
13f9	L13F9:  LD   A,B
13fa			OR   C            ;
13fb			JR   Z,L1407      ; Jump forward if the name has a null length.
13fd
13fd			LD   BC,$000A     ; Truncate longer filenames.
1400
1400			;The name is now transferred to the work space (second location onwards)
1400
1400	L1400:  PUSH IX           ;
1402			POP  HL           ; Transfer address of the workspace to HL.
1403			INC  HL           ; Step to the second location.
1404			EX   DE,HL        ;
1405			LDIR              ; Copy the filename.
1407
1407			;The many different parameters, if any, that follow the command are now considered.
1407			;Start by handling 'xxx "name" DATA'.
1407
1407	L1407:  RST  18H          ; Get character from BASIC line.
1408			CP   $E4          ; Is it 'DATA'?
140a			JR   NZ,L145F     ; Jump if not DATA.
140c
140c			; 'xxx "name" DATA'
140c			; -----------------
140c
140c			LD   A,($5C74)    ; T_ADDR. Check the BASIC command.
140f			CP   $03          ; Is it MERGE?
1411			JP   Z,L1219      ; "C Nonsense in BASIC" if so.
1414
1414			RST  20H          ; Get next character from BASIC line.
1415			RST  28H          ;
1416			DEFW LOOK_VARS    ; $28B2. Look in the variables area for the array.
1418			JR NC,L142F       ; Jump if handling an existing array.
141a
141a			LD   HL,$0000     ; Signal 'using a new array'.
141d			BIT  6,(IY+$01)   ; FLAGS. Is it a string Variable?
1421			JR   Z,L1425      ; Jump forward if so.
1423
1423			SET  7,C          ; Set bit 7 of the array's name.
1425
1425	L1425:  LD   A,($5C74)    ; T_ADDR.
1428			DEC  A            ; Give an error if trying to
1429			JR   Z,L1444      ; SAVE or VERIFY a new array.
142b
142b			CALL L05AC        ; Produce error report.
142e			DEFB $01          ; "2 Variable not found"
142f
142f			;Continue with the handling of an existing array
142f
142f	L142F:  JP   NZ,L1219     ; Jump if not an array to produce "C Nonsense in BASIC".
1432
1432			BIT  7,(IY+$01)   ; FLAGS.
1436			JR   Z,L1451      ; Jump forward if checking syntax.
1438
1438			LD   C,(HL)       ;
1439			INC  HL           ; Point to the 'low length' of the variable.
143a			LD   A,(HL)       ; The low length byte goes into
143b			LD   (IX+$0B),A   ; the work space.
143e			INC  HL           ;
143f			LD   A,(HL)       ; The high length byte goes into
1440			LD   (IX+$0C),A   ; the work space.
1443			INC  HL           ; Step past the length bytes.
1444
1444			;The next part is common to both 'old' and 'new' arrays
1444
1444	L1444:  LD   (IX+$0E),C   ; Copy the array's name.
1447			LD   A,$01        ; Assume an array of numbers - Code $01.
1449			BIT  6,C          ;
144b			JR   Z,L144E      ; Jump if it is so.
144d
144d			INC  A            ; Indicate it is an array of characters - Code $02.
144e
144e	L144E:  LD   (IX+$00),A   ; Save the 'type' in the first location of the header area.
1451
1451			;The last part of the statement is examined before joining the other pathways
1451
1451	L1451:  EX   DE,HL        ; Save the pointer in DE.
1452			RST  20H          ;
1453			CP   ')'          ; $29. Is the next character a ')'?
1455			JR   NZ,L142F     ; Give report C if it is not.
1457
1457			RST  20H          ; Advance to next character.
1458			CALL L18A1        ; Move on to the next statement if checking syntax.
145b			EX   DE,HL        ; Return the pointer to the HL.
145c			; (The pointer indicates the start of an existing array's contents).
145c			JP   L1519        ; Jump forward.
145f
145f			; Now Consider 'SCREEN$'
145f
145f	L145F:  CP   $AA          ; Is the present code the token 'SCREEN$'?
1461			JR   NZ,L1482     ; Jump ahead if not.
1463
1463			; 'xxx "name" SCREEN$'
1463			; --------------------
1463
1463			LD   A,($5C74)    ; T_ADDR_lo. Check the BASIC command.
1466			CP   $03          ; Is it MERGE?
1468			JP   Z,L1219      ; Jump to "C Nonsense in BASIC" if so since it is not possible to have 'MERGE name SCREEN$'.
146b
146b			RST  20H          ; Advance pointer into BASIC line.
146c			CALL L18A1        ; Move on to the next statement if checking syntax.
146f
146f			LD   (IX+$0B),$00 ; Length of the block.
1473			LD   (IX+$0C),$1B ; The display area and the attribute area occupy $1800 locations.
1477
1477			LD   HL,$4000     ; Start of the block, beginning of the display file $4000.
147a			LD   (IX+$0D),L   ;
147d			LD   (IX+$0E),H   ; Store in the workspace.
1480			JR   L14CF        ; Jump forward.
1482
1482			; Now consider 'CODE'
1482
1482	L1482:  CP   $AF          ; Is the present code the token 'CODE'?
1484			JR   NZ,L14D5     ; Jump ahead if not.
1486
1486			; 'xxx "name" CODE'
1486			; -----------------
1486
1486			LD   A,($5C74)    ; T_ADDR_lo. Check the BASIC command.
1489			CP   $03          ; Is it MERGE?
148b			JP   Z,L1219      ; Jump to "C Nonsense in BASIC" if so since it is not possible to have 'MERGE name CODE'.
148e
148e			RST  20H          ; Advance pointer into BASIC line.
148f			RST  28H          ;
1490			DEFW PR_ST_END    ; $2048.
1492			JR   NZ,L14A0     ; Jump forward if the statement has not finished
1494
1494			LD   A,($5C74)    ; T_ADDR_lo.
1497			AND  A            ; It is not possible to have 'SAVE name CODE' by itself.
1498			JP   Z,L1219      ; Jump if so to produce "C Nonsense in BASIC".
149b
149b			RST  28H          ;
149c			DEFW USE_ZERO     ; $1CE6. Put a zero on the calculator stack - for the 'start'.
149e			JR   L14AF        ; Jump forward.
14a0
14a0			;Look for a 'starting address'
14a0
14a0	L14A0:  RST  28H          ;
14a1			DEFW EXPT_1NUM    ; $1C82. Fetch the first number.
14a3			RST  18H          ;
14a4			CP   ','          ; $2C. Is the present character a ','?
14a6			JR   Z,L14B4      ; Jump if it is - the number was a 'starting address'
14a8
14a8			LD   A,($5C74)    ; T_ADDR_lo.
14ab			AND  A            ; Refuse 'SAVE name CODE' that does not have a 'start' and a 'length'.
14ac			JP   Z,L1219      ; Jump if so to produce "C Nonsense in BASIC".
14af
14af	L14AF:  RST  28H          ;
14b0			DEFW USE_ZERO     ; $1CE6. Put a zero on the calculator stack - for the 'length'.
14b2			JR   L14B8        ; Jump forward.
14b4
14b4			;Fetch the 'length' as it was specified
14b4
14b4	L14B4:  RST  20H          ; Advance to next character.
14b5			RST  28H          ;
14b6			DEFW EXPT_1NUM    ; $1C82. Fetch the 'length'.
14b8
14b8			;The parameters are now stored in the header area of the work space
14b8
14b8	L14B8:  CALL L18A1        ; But move on to the next statement now if checking syntax.
14bb			RST  28H          ;
14bc			DEFW FIND_INT2    ; $1E99. Compress the 'length' into BC.
14be			LD   (IX+$0B),C   ; Store the length of the CODE block.
14c1			LD   (IX+$0C),B   ;
14c4			RST  28H          ;
14c5			DEFW FIND_INT2    ; $1E99. Compress the 'starting address' into BC.
14c7			LD   (IX+$0D),C   ; Store the start address of the CODE block.
14ca			LD   (IX+$0E),B   ;
14cd			LD   H,B          ; Transfer start address pointer to HL.
14ce			LD   L,C          ;
14cf
14cf			;'SCREEN$' and 'CODE' are both of type 3
14cf
14cf	L14CF:  LD   (IX+$00),$03 ; Store file type = $03 (CODE).
14d3			JR   L1519        ; Rejoin the other pathways.
14d5
14d5			; 'xxx "name"' / 'SAVE "name" LINE'
14d5			; ---------------------------------
14d5
14d5			;Now consider 'LINE' and 'no further parameters'
14d5
14d5	L14D5:  CP   $CA          ; Is the present code the token 'LINE'?
14d7			JR   Z,L14E2      ; Jump ahead if so.
14d9
14d9			CALL L18A1        ; Move on to the next statement if checking syntax.
14dc			LD   (IX+$0E),$80 ; Indicate no LINE number.
14e0			JR   L14F9        ; Jump forward.
14e2
14e2			;Fetch the 'line number' that must follow 'LINE'
14e2
14e2	L14E2:  LD   A,($5C74)    ; T_ADDR_lo. Only allow 'SAVE name LINE number'.
14e5			AND  A            ; Is it SAVE?
14e6			JP   NZ,L1219     ; Produce "C Nonsense in BASIC" if not.
14e9
14e9			RST  20H          ; Advance pointer into BASIC line.
14ea			RST  28H          ; Get LINE number onto calculator stack
14eb			DEFW EXPT_1NUM    ; $1C82. Pass the number to the calculator stack.
14ed			CALL L18A1        ; Move on to the next statement if checking syntax.
14f0			RST  28H          ; Retrieve LINE number from calculator stack
14f1			DEFW FIND_INT2    ; $1E99. Compress the 'line number' into BC.
14f3			LD   (IX+$0D),C   ; Store the LINE number.
14f6			LD   (IX+$0E),B   ;
14f9
14f9			;'LINE' and 'no further parameters' are both of type 0
14f9
14f9	L14F9:  LD   (IX+$00),$00 ; Store file type = $00 (program).
14fd			LD   HL,($5C59)   ; E_LINE. The pointer to the end of the variables area.
1500			LD   DE,($5C53)   ; PROG. The pointer to the start of the BASIC program.
1504			SCF               ;
1505			SBC  HL,DE        ; Perform the subtraction to find the length of the 'program + variables'.
1507			LD   (IX+$0B),L   ;
150a			LD   (IX+$0C),H   ; Store the length.
150d
150d			LD   HL,($5C4B)   ; VARS. Repeat the operation but this
1510			SBC  HL,DE        ; time storing the length of the
1512			LD   (IX+$0F),L   ; 'program' only.
1515			LD   (IX+$10),H   ;
1518			EX   DE,HL        ; Transfer pointer to HL.
1519
1519			;In all cases the header information has now been prepared:
1519			;- The location 'IX+00' holds the type number.
1519			;- Locations 'IX+01 to IX+0A' holds the name ($FF in 'IX+01' if null).
1519			;- Locations 'IX+0B & IX+0C' hold the number of bytes that are to be found in the 'data block'.
1519			;- Locations 'IX+0D to IX+10' hold a variety of parameters whose exact interpretation depends on the 'type'.
1519
1519			;The routine continues with the first task being to separate SAVE from LOAD, VERIFY and MERGE.
1519
1519	L1519:  LD   A,(FLAGS3)   ; $5B66.
151c			BIT  3,A          ; Using RAM disk?
151e			JP   NZ,L121D     ; Jump if the operation is on the RAM disk.
1521
1521			LD   A,($5C74)    ; T_ADDR_lo. Get the BASIC command.
1524			AND  A            ; Is it SAVE?
1525			JR   NZ,L152B     ; Jump ahead if not.
1527
1527			RST  28H          ;
1528			DEFW SA_CONTROL   ; $0970. Run the save routine in ROM 1.
152a			RET               ;
152b
152b			;In the case of a LOAD, VERIFY or MERGE command the first seventeen bytes of the 'header area'
152b			;in the work space hold the prepared information, as detailed above;
152b			;and it is now time to fetch a 'header' from the tape.
152b
152b	L152B:  RST  28H          ;
152c			DEFW SA_ALL+$0007 ; $0761. Run the load/merge/verify routine in ROM 1.
152e			RET               ;
152f
152f
152f			; ========================
152f			; EDITOR ROUTINES - PART 1
152f			; ========================
152f
152f			; ----------------------------------------------
152f			; Relist the BASIC Program from the Current Line
152f			; ----------------------------------------------
152f			; This routine lists the BASIC program from the current line number. It initially shows the last line displayed but rows may subsequently
152f			; be scrolled up until the required BASIC line has been found. The structure of the ROM program only supports listing BASIC lines that are
152f			; 20 rows or less; larger lines are shown truncated to 20 rows.
152f
152f	L152F:  LD   HL,$EEF5     ; Flags.
1532			RES  0,(HL)       ; Signal this is not the current line.
1534			SET  1,(HL)       ; Signal not yet located the current line.
1536
1536			;A loop is entered to display a screenful of program listing. If the current line number is not found in the lines displayed then all
1536			;lines are scrolled up and the listing reproduced. This procedure repeats until the current line number has been found and displayed.
1536
1536	L1536:  LD   HL,($5C49)   ; E_PPC. Fetch current line number.
1539			LD   A,H          ;
153a			OR   L            ; Is there a currently selected line?
153b			JR   NZ,L1540     ; Jump ahead if so.
153d
153d			LD   ($EC06),HL   ; Set to $0000 to indicate no editable characters before the cursor.
1540
1540	L1540:  LD   A,($F9DB)    ; Fetch the number of rows of the BASIC line that are in the Above-Screen Line Edit Buffer,
1543			PUSH AF           ; i.e. that are off the top of the screen.
1544
1544			LD   HL,($FC9A)   ; Line number of the BASIC line at the top of the screen (or 0 for the first line).
1547			CALL L334A        ; Find closest line number (or $0000 if no subsequent line exists).
154a			LD   ($F9D7),HL   ; Store the line number of the BASIC line being edited in the buffer.
154d
154d			CALL L3222        ; Set default Above-Screen Line Edit Buffer settings.
1550			CALL L30D6        ; Set default Below-Screen Line Edit Buffer settings.
1553
1553			POP  AF           ; A=Number of rows of the BASIC line that are in the Above-Screen Line Edit Buffer.
1554
1554	L1554:  OR   A            ; Are there any rows off the top of the screen?
1555			JR   Z,L1563      ; Jump ahead if not.
1557
1557			;The current settings indicate that the top BASIC line straggles into the Above-Screen Line Edit Buffer. It is therefore necessary to insert the current
1557			;BASIC line into the Below-Screen Line Edit Buffer and then shift the appropriate number of rows into the Above-Screen Line Edit Buffer.
1557
1557			PUSH AF           ; Save the number of rows off the top of the screen.
1558			CALL L30DF        ; Copy a BASIC line from the program area into the Below-Screen Line Edit Buffer.
155b			EX   DE,HL        ; DE=Address of the Below-Screen Line Edit Buffer.
155c			CALL L326A        ; Shift up a row into the Above-Screen Line Edit Buffer.
155f			POP  AF           ; Retrieve the number of rows off the top of the screen.
1560			DEC  A            ; Decrement the number of rows.
1561			JR   L1554        ; Jump back to shift up another row if required.
1563
1563			;Either there the top BASI Cline does not straggle off the top of the the screen or the appropriate number of rows have been copied into the
1563			;Above-Screen Line Edit Buffer. In the latter case, the Below-Screen Line Edit Buffer contains the remaining rows of the BASIC line and which
1563			;be copied into the top of the Screen Line Edit Buffer.
1563
1563	L1563:  LD   C,$00        ; C=Row 0.
1565			CALL L30B4        ; DE=Start address in Screen Line Edit Buffer of the first row, as specified in C.
1568
1568			LD   B,C          ; B=Row 0.
1569			LD   A,($EC15)    ; The number of editing rows on screen.
156c			LD   C,A          ; C=Number of editing rows on screen.
156d			PUSH BC           ; B=Row number, C=Number of editing rows on screen.
156e			PUSH DE           ; DE=Start address in Screen Line Edit Buffer of the first row.
156f
156f			;Enter a loop to copy BASIC line rows into the Screen Line Edit Buffer. The Below-Screen Line Edit Buffer is used as a temporary store for holding each BASIC line
156f			;as it is copied into the Screen Line Edit Buffer. If the top BASIC line straggles above the screen then this loop is entered with the remains of the line
156f			;already in the Below-Screen Line Edit Buffer.
156f
156f	L156F:  CALL L30DF        ; Shift up all rows of the BASIC line in the Below-Screen Line Edit Buffer, or if empty then copy a BASIC line from the program area into it.
1572			; If no BASIC line available then empty the first row of the Below-Screen Line Edit Buffer.
1572
1572			LD   A,($EEF5)    ; Listing flags.
1575			BIT  1,A          ; Has the current line been previously found?
1577			JR   Z,L1596      ; Jump if so.
1579
1579			;The current line has not yet been found so examine the current row in case it is the current line
1579
1579			PUSH DE           ; DE=Start address in Screen Line Edit Buffer of the current row.
157a			PUSH HL           ; HL=Address of the first row in the Below-Screen Line Edit Buffer.
157b
157b			LD   DE,$0020     ;
157e			ADD  HL,DE        ; Point to the flag byte for the first row.
157f			BIT  0,(HL)       ; Is it the first row of a BASIC line?
1581			JR   Z,L1594      ; Jump if not.
1583
1583			;The Below-Screen Line Edit Buffer contains a complete BASIC line so determine whether this is the current line
1583
1583			INC  HL           ;
1584			LD   D,(HL)       ; Get line number into DE.
1585			INC  HL           ;
1586			LD   E,(HL)       ;
1587			OR   A            ;
1588			LD   HL,($5C49)   ; E_PPC. Current line number.
158b			SBC  HL,DE        ;
158d			JR   NZ,L1594     ; Jump ahead unless this is the current line.
158f
158f			LD   HL,$EEF5     ;
1592			SET  0,(HL)       ; Signal this is the current line.
1594
1594	L1594:  POP  HL           ; HL=Address of the current row in the Below-Screen Line Edit Buffer.
1595			POP  DE           ; DE=Start address in Screen Line Edit Buffer of the current row.
1596
1596			;Copy the row of the BASIC line from the Below-Screen Line Edit Buffer into the Screen Line Edit Buffer
1596
1596	L1596:  PUSH BC           ; B=Row number, C=Number of editing rows on screen.
1597			PUSH HL           ; HL=Address of the current row in the Below-Screen Line Edit Buffer.
1598			LD   BC,$0023     ;
159b			LDIR              ; Copy the first row of the BASIC line in the Below-Screen Line Edit Buffer into the next row of the Screen Line Edit Buffer.
159d			POP  HL           ; HL=Address of the current row in the Below-Screen Line Edit Buffer.
159e			POP  BC           ; B=Row number, C=Number of editing rows on screen.
159f
159f			PUSH DE           ; DE=Start address in Screen Line Edit Buffer of the next row.
15a0			PUSH BC           ; B=Row number, C=Number of editing rows on screen.
15a1			EX   DE,HL        ; DE=Address of the current row in the Below-Screen Line Edit Buffer.
15a2
15a2			LD   HL,$EEF5     ; Flags.
15a5			BIT  0,(HL)       ; Is this the current line?
15a7			JR   Z,L15D3      ; Jump if not.
15a9
15a9			;This is the current line so scan across the BASIC line to locate the cursor column position
15a9
15a9			LD   B,$00        ; Column 0.
15ab
15ab	L15AB:  LD   HL,($EC06)   ; HL=Count of the number of editable characters in the BASIC line up to the cursor within the Screen Line Edit Buffer.
15ae			LD   A,H          ;
15af			OR   L            ; Are there any editable characters in this row prior to the cursor?
15b0			JR   Z,L15C0      ; Jump if there are none, i.e. cursor at start of the row.
15b2
15b2			;There are editable characters on this row prior to the cursor
15b2
15b2			; [*BUG* - Entering '  10 REM' or '0010 REM' will insert the line into the program area but instead of placing the cursor on the following row it is placed after the following
15b2			;          BASIC line, or if the line inserted was the last in the program then the cursor is placed on row 20. The bug occurs due to the leading spaces or zeros, and hence will apply
15b2			;          to every BASIC command. When the line is inserted into the Screen Line Edit Buffer, the leading spaces are discarded and hence the line length is shorter than that typed
15b2			;          in. However, it is the typed in line length that is used when parsing the BASIC line in the Screen Line Edit Buffer and as a result this causes an
15b2			;          attempt to find the remaining characters on the following row of the Screen Line Edit Buffer. If another BASIC line is on the following Screen Line Edit Buffer
15b2			;          row then the search completes and the cursor is placed on the row after this BASIC line. If there is not a BASIC line on the following
15b2			;          row then the search continues on the next row. Since this will also be empty, the search advances onto the next row, and then the next, and so
15b2			;          on until row 20 is reached. To fix the bug, the typed in character count until the cursor (held in $EC06) ideally needs to be adjusted to match the actual number of characters stored
15b2			;          in the Screen Line Edit Buffer. However, this is not a trivial change to implement. A simpler solution to fix the bug is to intercept when a move to the next row is made and
15b2			;          to determine whether the BASIC line actually continues on this row. Credit: Paul Farrow]
15b2
15b2			; [To fix the bug, the POP HL and JR NC,$15CB (ROM 0) instructions following the call to $2E41 (ROM 0) should be replaced with the following. Credit: Paul Farrow.
15b2			;
15b2			;       PUSH DE           ; DE=Address of the start of the row of the BASIC line in the Screen Line Edit Buffer.
15b2			;       PUSH AF           ; Save the flags.
15b2			;
15b2			;       LD   HL,$0020     ;
15b2			;       ADD  HL,DE        ;
15b2			;       EX   DE,HL        ; DE=Address of the flag byte for the row in the Screen Line Edit Buffer.
15b2			;
15b2			;       POP  AF           ; Restore the flags.
15b2			;       JR   C,CHAR_FOUND ; Jump if editable column found.
15b2			;
15b2			;       LD   A,(DE)       ; Fetch the flag byte.
15b2			;       BIT  1,A          ; Does the BASIC line span onto the next row?
15b2			;       JR   NZ,SPANS_ROW ; Jump if it does.
15b2			;
15b2			;       POP  DE           ; DE=Address of the start of the BASIC row in the Screen Line Edit Buffer.
15b2			;       POP  HL
15b2			;       LD   HL,$0000     ; Signal no editable characters left on the row.
15b2			;       LD   ($EC06),HL   ;
15b2			;       JP   $15C0 (ROM 0) ; Jump since all characters on the row have been scanned through.
15b2			;
15b2			;SPANS_ROW:
15b2			;       POP  DE           ; DE=Address of the start of the BASIC row in the Screen Line Edit Buffer.
15b2			;       POP  HL           ;
15b2			;       JP   $15CB (ROM 0) ; Jump if no editable columns left on the row.
15b2			;
15b2			;CHAR_FOUND:
15b2			;       POP  DE           ; DE=Address of the start of the BASIC row in the Screen Line Edit Buffer.
15b2			;       POP  HL           ; ]
15b2
15b2			PUSH HL           ;
15b3			CALL L2E41        ; Find editable position on this row from the previous column to the right, returning column number in B.
15b6			POP  HL           ;
15b7			JR   NC,L15CB     ; Jump if no editable character found on this row, i.e. there must be more characters on the next row.
15b9
15b9			;An editable character was found to the right on the current row
15b9
15b9			DEC  HL           ; Decrement the count of characters prior to the cursor.
15ba			INC  B            ; Advance to next column.
15bb			LD   ($EC06),HL   ; Update the count of the number of editable characters up to the cursor.
15be			JR   L15AB        ; Jump back to test next column.
15c0
15c0			;Column position of cursor located, find the closest editable character
15c0
15c0	L15C0:  CALL L2E41        ; Find editable position on this row from the previous column to the right, returning column number in B.
15c3			CALL NC,L2E63     ; If no editable character found then find editable position to the left, returning column number in B.
15c6
15c6			LD   HL,$EEF5     ; Flags.
15c9			LD   (HL),$00     ; Signal 'not the current line', 'current line has previously been found' and 'update display file enabled'.
15cb
15cb			;Store the current cursor position
15cb
15cb	L15CB:  LD   A,B          ; A=Column number. This will be the preferred column number.
15cc			POP  BC           ; B=Row number, C=Number of editing rows on screen.
15cd			PUSH BC           ;
15ce			LD   C,B          ; C=Row number.
15cf			LD   B,A          ; B=Column number.
15d0			CALL L2A11        ; Store this as the current cursor editing position.
15d3
15d3			;Move to next row
15d3
15d3	L15D3:  POP  BC           ; B=Row number, C=Number of editing rows on screen.
15d4			POP  DE           ; DE=Start address in Screen Line Edit Buffer of the next row.
15d5			LD   A,C          ; A=Number of editing rows on screen.
15d6			INC  B            ; Next row.
15d7			CP   B            ; Reached the bottom screen row?
15d8			JR   NC,L156F     ; Jump back if not to display the next row.
15da
15da			;The bottom screen row has been exceeded
15da
15da			LD   A,($EEF5)    ; Listing flags.
15dd			BIT  1,A          ; Has the current line been previously found?
15df			JR   Z,L1602      ; Jump if so.
15e1
15e1			;Current line has not yet been found
15e1
15e1			BIT  0,A          ; Is this the current line?
15e3			JR   NZ,L1602     ; Jump if so.
15e5
15e5			;This is not the current line
15e5
15e5			LD   HL,($5C49)   ; E_PPC. Current line number.
15e8			LD   A,H          ;
15e9			OR   L            ;
15ea			JR   Z,L15F4      ; Jump if there is no current line number.
15ec
15ec			LD   ($FC9A),HL   ; Store it as the line number at top of the screen.
15ef
15ef			CALL L3222        ; Set default Above-Screen Line Edit Buffer settings to clear the count of the number of rows it contains.
15f2			JR   L15FD        ; Jump forward.
15f4
15f4			;There is no current line number
15f4
15f4	L15F4:  LD   ($FC9A),HL   ; Set the line number at top of the screen to $0000, i.e. first available.
15f7			CALL L3352        ; Create line number representation in the Keyword Construction Buffer of the next BASIC line.
15fa			LD   ($5C49),HL   ; E_PPC. Current line number is the first in the BASIC program.
15fd
15fd	L15FD:  POP  DE           ; DE=Start address in Screen Line Edit Buffer of the first row.
15fe			POP  BC           ; B=Row number, C=Number of editing rows on screen.
15ff			JP   L1536        ; Jump back to continue listing the program until the current line is found.
1602
1602			;The bottom line is the current line
1602
1602	L1602:  POP  DE           ; DE=Start address in Screen Line Edit Buffer of the first row.
1603			POP  BC           ; B=Row number, C=Number of editing rows on screen.
1604			CP   A            ; Set the zero flag if current line has yet to be found, hence signal do not update cursor position settings.
1605
1605			; ----------------------------------------------------------
1605			; Print All Screen Line Edit Buffer Rows to the Display File
1605			; ----------------------------------------------------------
1605			; Print all rows of the edit buffer to the display file, and updating the cursor position settings if required.
1605			; Entry: Zero flag reset if update of cursor position settings required.
1605			;        B=Row number.
1605			;        C=Number of editing rows on screen.
1605
1605	L1605:  PUSH AF           ; Save the zero flag.
1606
1606			LD   A,C          ; Save the number of editing rows on screen.
1607			LD   C,B          ; C=Row number.
1608			CALL L30B4        ; DE=Start address in Screen Line Edit Buffer of row held in C
160b			EX   DE,HL        ; and transfer into HL.
160c
160c	L160C:  PUSH AF           ; A=Number of editing rows on screen.
160d			CALL L3604        ; Print a row of the edit buffer to the screen.
1610			POP  AF           ;
1611
1611			LD   DE,$0023     ;
1614			ADD  HL,DE        ; Point to the start of the next row.
1615
1615	L1615:  INC  C            ; Advance to the next row.
1616			CP   C            ; All rows printed?
1617			JR   NC,L160C     ; Jump back if not to print next row.
1619
1619			;All rows printed
1619
1619			POP  AF           ; Retrieve the zero flag.
161a			RET  Z            ; Return if 'not the current line' and 'current line has previously been found'.
161b
161b			;Find the new cursor column position
161b
161b			CALL L2A07        ; Get current cursor position (C=row, B=column, A=preferred column).
161e
161e	L161E:  CALL L2B78        ; Find next Screen Line Edit Buffer editable position to right, moving to next row if necessary. Returns column number in B.
1621
1621			LD   HL,($EC06)   ; Fetch the number of editable characters on this row prior to the cursor.
1624			DEC  HL           ; Decrement the count.
1625			LD   A,H          ; Are there any characters?
1626			OR   L            ;
1627			LD   ($EC06),HL   ; Store the new count.
162a			JR   NZ,L161E     ; Jump if there are some characters prior to the cursor.
162c
162c			JP   L2A11        ; Store cursor editing position, with preferred column of 0.
162f
162f			RET               ; [Redundant byte]
1630
1630			; ---------------------
1630			; Clear Editing Display
1630			; ---------------------
1630
1630	L1630:  LD   B,$00        ; Top row of editing area.
1632			LD   A,($EC15)    ; The number of editing rows on screen.
1635			LD   D,A          ; D=Number of rows in editing area.
1636			JP   L3B5E        ; Clear specified display rows.
1639
1639			; -----------------------------------------------------------------
1639			; Shift All Edit Buffer Rows Up and Update Display File if Required
1639			; -----------------------------------------------------------------
1639			; This routine shifts all edit buffer rows up, updating the display file if required.
1639			; Entry: HL=Address of the 'Bottom Row Scroll Threshold' within the editing area information.
1639			; Exit : Carry flag set if edit buffer rows were shifted.
1639
1639	L1639:  LD   B,$00        ; Row number to start shifting from.
163b			PUSH HL           ; Save the address of the 'Bottom Row Scroll Threshold' within the editing area information.
163c
163c			;Attempt to shift a row into the Above-Screen Line Edit Buffer
163c
163c			LD   C,B          ; Find the address of row 0.
163d			CALL L30B4        ; DE=Start address in Screen Line Edit Buffer of the row specified in C.
1640			CALL L326A        ; Attempt to shift the top row of the Screen Line Edit Buffer into the Above-Screen Line Edit Buffer.
1643
1643			POP  HL           ; Retrieve the address of the 'Bottom Row Scroll Threshold' within the editing area information.
1644			RET  NC           ; Return if the Above-Screen Line Edit Buffer is full, i.e. no edit buffer rows shifted.
1645
1645			;A change to the number of rows in the Above-Screen Line Edit Buffer occurred
1645
1645			CALL L30DF        ; Shift up rows of the BASIC line in Below-Screen Line Edit Buffer, inserting the next line BASIC line if the buffer becomes empty.
1648			; Returns with HL holding the address of the first row in the Below-Screen Line Edit Buffer.
1648
1648			; Shift All Screen Line Edit Buffer Rows Up and Update Display File if Required
1648			; -----------------------------------------------------------------------------
1648
1648	L1648:  PUSH BC           ; B=Row counter.
1649			PUSH HL           ; HL=Address of first row in the Below-Screen Line Edit Buffer.
164a
164a			LD   HL,$0023     ; DE=Address of the current row in the Screen Line Edit Buffer.
164d			ADD  HL,DE        ; HL=Address of the next row in the Screen Line Edit Buffer.
164e
164e			LD   A,($EC15)    ;
1651			LD   C,A          ; C=Number of editing rows on screen.
1652			CP   B            ; Any rows to shift?
1653			JR   Z,L1663      ; Jump if not.
1655
1655			;Shift all Screen Line Edit Buffer rows up
1655
1655			PUSH BC           ; C=Number of editing rows on screen.
1656
1656	L1656:  PUSH BC           ; C=Number of editing rows on screen.
1657			LD   BC,$0023     ; DE=Current Screen Line Edit Buffer row, HL=Next Screen Line Edit Buffer row.
165a			LDIR              ; Shift one row of the Screen Line Edit Buffer up.
165c			POP  BC           ; C=Number of editing rows on screen.
165d
165d			LD   A,C          ; Fetch the number of editing rows on screen.
165e			INC  B            ; Next row.
165f			CP   B            ; All rows shifted?
1660			JR   NZ,L1656     ; Repeat for all edit buffer rows to shift.
1662
1662			;All Screen Line Edit Buffer rows have been shifted up
1662
1662			POP  BC           ; C=Number of editing rows on screen, B=Row number, i.e. 0.
1663
1663	L1663:  POP  HL           ; HL=Address of the first row in the Below-Screen Line Edit Buffer.
1664
1664	L1664:  CALL L3618        ; Shift up all edit rows in the display file if updating required.
1667
1667			LD   BC,$0023     ; HL=Address of the first row in the Below-Screen Line Edit Buffer, DE=Address of last row in Screen Line Edit Buffer.
166a			LDIR              ; Copy the first row of the Below-Screen Line Edit Buffer into the last row of the Screen Line Edit Buffer.
166c
166c			SCF               ; Signal that edit buffer rows were shifted.
166d			POP  BC           ; B=Row counter.
166e			RET               ;
166f
166f			; -------------------------------------------------------------------
166f			; Shift All Edit Buffer Rows Down and Update Display File if Required
166f			; -------------------------------------------------------------------
166f			; This routine shifts all edit buffer rows down, updating the display file if required.
166f			; Exit : Carry flag set if edit buffer rows were shifted.
166f			;        B=Last row number to shift.
166f
166f			;Shift all rows in the Above-Screen Line Edit Buffer, shifting in a new BASIC line if applicable
166f
166f	L166F:  LD   B,$00        ; Last row number to shift.
1671			CALL L322B        ; Attempt to shift down the Above-Screen Line Edit Buffer, loading in a new BASIC line if it is empty.
1674			RET  NC           ; Return if Above-Screen Line Edit Buffer is empty, i.e. no edit buffer rows were shifted.
1675
1675			;Entry point from routine at $2ED3 (ROM 0) to insert a blank row
1675
1675	L1675:  PUSH BC           ; B=Last row number to shift.
1676			PUSH HL           ; HL=Address of next row to use within the Above-Screen Line Edit Buffer.
1677
1677			;Shift all rows in the Below-Screen Line Edit Buffer down, shifting in a new BASIC line if applicable
1677
1677			LD   A,($EC15)    ; A=Number of editing rows on screen.
167a			LD   C,A          ; C=Number of editing rows on screen.
167b			CALL L30B4        ; DE=Start address in Screen Line Edit Buffer of the last editing row.
167e
167e			CALL L311E        ; Shift down all rows in the Below-Screen Line Edit Buffer, or empty the buffer a row does not straggle off the bottom of the screen.
1681			JR   NC,L16A9     ; Jump if the Below-Screen Line Edit Buffer is full.
1683
1683			DEC  DE           ; DE=Address of the last flag byte of the penultimate editing row in the Screen Line Edit Buffer.
1684			LD   HL,$0023     ; Length of an edit buffer row.
1687			ADD  HL,DE        ; HL=Address of the last flag byte of the last editing row in the Screen Line Edit Buffer.
1688			EX   DE,HL        ; DE=Address of last flag byte of last editing row in Screen Line Edit Buffer, HL=Address of last flag byte of penultimate editing row in Screen Line Edit Buffer.
1689
1689			PUSH BC           ; C=Number of editing rows on screen, B=Last row number to shift.
168a			LD   A,B          ;
168b			CP   C            ; Any rows to shift?
168c			JR   Z,L169A      ; Jump if not.
168e
168e	L168E:  PUSH BC           ; C=Row number to shift, B=Last row number to shift.
168f			LD   BC,$0023     ;
1692			LDDR              ; Copy one row of the Screen Line Edit Buffer down.
1694			POP  BC           ; C=Number of editing rows on screen, B=Row shift counter.
1695
1695	L1695:  LD   A,B          ; A=Row shift counter.
1696			DEC  C            ;
1697			CP   C            ;
1698			JR   C,L168E      ; Repeat for all edit buffer rows to shift.
169a
169a			;All Screen Line Edit Buffer rows have been shifted down
169a
169a	L169A:  EX   DE,HL        ; HL=Address of last flag byte of first editing row in Screen Line Edit Buffer, DE=Address of byte before start of first editing row in Screen Line Edit Buffer.
169b			INC  DE           ; DE=Start of first row in Screen Line Edit Buffer.
169c
169c			POP  BC           ; C=Number of editing rows on screen, B=Last row number to shift.
169d			POP  HL           ; HL=Address of next row to use within the Above-Screen Line Edit Buffer.
169e
169e			CALL L362C        ; Shift down all edit rows in the display file if updating required.
16a1
16a1			LD   BC,$0023     ;
16a4			LDIR              ; Copy the next row of the Above-Screen Line Edit Buffer into the first row of the Screen Line Edit Buffer.
16a6
16a6			SCF               ; Signal Below-Screen Line Edit Buffer is not full.
16a7			POP  BC           ; B=Last row number to shift.
16a8			RET               ;
16a9
16a9			;The Below-Screen Line Edit Buffer is full
16a9
16a9	L16A9:  POP  HL           ; Restore registers.
16aa			POP  BC           ; B=Last row number to shift.
16ab			RET               ;
16ac
16ac			; ---------------------------------------------------------
16ac			; Insert Character into Edit Buffer Row, Shifting Row Right
16ac			; ---------------------------------------------------------
16ac			; This routine shifts a byte into an edit buffer row, shifting all existing
16ac			; characters right until either the end of the row is reached or the specified
16ac			; end column is reached.
16ac			; Entry: DE=Start address of an edit buffer row.
16ac			;        A=Character to shift into left of row.
16ac			;        B=Column to start shifting at.
16ac			; Exit : A=Byte shifted out from last column.
16ac			;        HL=Points byte after row (i.e. flag byte).
16ac			;        Zero flag set if the character shifted out was a null ($00).
16ac
16ac	L16AC:  PUSH DE           ; Save DE.
16ad
16ad			LD   H,$00        ;
16af			LD   L,B          ; HL=Start column number.
16b0
16b0	L16B0:  ADD  HL,DE        ; HL=Address of the starting column.
16b1			LD   D,A          ; Store the character to shift in.
16b2			LD   A,B          ; A=Start column number.
16b3
16b3			;Shift all bytes in the row to the right.
16b3
16b3	L16B3:  LD   E,(HL)       ; Fetch a character from the row.
16b4			LD   (HL),D       ; Replace it with the character to shift in.
16b5			LD   D,E          ; Store the old character for use next time.
16b6
16b6			INC  HL           ; Point to the next column.
16b7			INC  A            ;
16b8			CP   $20          ; End of row reached?
16ba			JR   C,L16B3      ; Jump if not to shift the next character.
16bc
16bc			LD   A,E          ; A=Character that was shifted out.
16bd			CP   $00          ; Return with zero flag set if the character was $00.
16bf
16bf			POP  DE           ; Restore DE
16c0			RET               ;
16c1
16c1			; --------------------------------------------------------
16c1			; Insert Character into Edit Buffer Row, Shifting Row Left
16c1			; --------------------------------------------------------
16c1			; This routine shifts a byte into an edit buffer row, shifting all existing
16c1			; characters left until either the beginning of the row is reached or the specified
16c1			; end column is reached.
16c1			; Entry: DE=Start address of an edit buffer row.
16c1			;        A=Character to shift into right of row.
16c1			;        B=Column to stop shifting at.
16c1			; Exit : A=Byte shifted out.
16c1			;        HL=Points byte before row.
16c1			;        Zero flag set if the character shifted out was a null ($00).
16c1
16c1	L16C1:  PUSH DE           ; Save DE.
16c2
16c2			LD   HL,$0020     ; 32 columns.
16c5
16c5	L16C5:  ADD  HL,DE        ; Point to the flag byte for this row.
16c6			PUSH HL           ; Save it.
16c7
16c7			LD   D,A          ; Store the character to shift in.
16c8			LD   A,$1F        ; Maximum of 31 shifts.
16ca			JR   L16D3        ; Jump ahead to start shifting.
16cc
16cc	L16CC:  LD   E,(HL)       ; Fetch a character from the row.
16cd			LD   (HL),D       ; Replace it with the character to shift in.
16ce			LD   D,E          ; Store the old character for use next time.
16cf			CP   B            ; End column reached?
16d0			JR   Z,L16D6      ; Jump if so to exit.
16d2
16d2			DEC  A            ; Decrement column counter.
16d3
16d3	L16D3:  DEC  HL           ; Point back a column.
16d4			JR   L16CC        ; Loop back to shift the next character.
16d6
16d6	L16D6:  LD   A,E          ; A=Character that was shifted out.
16d7			CP   $00          ; Return with zero flag set if the character was $00.
16d9
16d9			POP  HL           ; Fetch address of next flag byte for the row.
16da			POP  DE           ; Restore DE.
16db			RET               ;
16dc
16dc
16dc			; =======================================================
16dc			; BASIC LINE AND COMMAND INTERPRETATION ROUTINES - PART 1
16dc			; =======================================================
16dc
16dc			; -----------------------
16dc			; The Syntax Offset Table
16dc			; -----------------------
16dc			; Similar in construction to the table in ROM 1 at $1A48.
16dc			; [No instruction fetch at $1708 hence ZX Interface 1 will not be paged in by this ROM. Credit: Paul Farrow].
16dc
16dc	L16DC:  DEFB $B1          ; DEF FN    -> $178D (ROM 0)
16dd			DEFB $C9          ; CAT       -> $17A6 (ROM 0)
16de			DEFB $BC          ; FORMAT    -> $179A (ROM 0)
16df			DEFB $BE          ; MOVE      -> $179D (ROM 0)
16e0			DEFB $C3          ; ERASE     -> $17A3 (ROM 0)
16e1			DEFB $AF          ; OPEN #    -> $1790 (ROM 0)
16e2			DEFB $B4          ; CLOSE #   -> $1796 (ROM 0)
16e3			DEFB $93          ; MERGE     -> $1776 (ROM 0)
16e4			DEFB $91          ; VERIFY    -> $1775 (ROM 0)
16e5			DEFB $92          ; BEEP      -> $1777 (ROM 0)
16e6			DEFB $95          ; CIRCLE    -> $177B (ROM 0)
16e7			DEFB $98          ; INK       -> $177F (ROM 0)
16e8			DEFB $98          ; PAPER     -> $1780 (ROM 0)
16e9			DEFB $98          ; FLASH     -> $1781 (ROM 0)
16ea			DEFB $98          ; BRIGHT    -> $1782 (ROM 0)
16eb			DEFB $98          ; INVERSE   -> $1783 (ROM 0)
16ec			DEFB $98          ; OVER      -> $1784 (ROM 0)
16ed			DEFB $98          ; OUT       -> $1785 (ROM 0)
16ee			DEFB $7F          ; LPRINT    -> $176D (ROM 0)
16ef			DEFB $81          ; LLIST     -> $1770 (ROM 0)
16f0			DEFB $2E          ; STOP      -> $171E (ROM 0)
16f1			DEFB $6C          ; READ      -> $175D (ROM 0)
16f2			DEFB $6E          ; DATA      -> $1760 (ROM 0)
16f3			DEFB $70          ; RESTORE   -> $1763 (ROM 0)
16f4			DEFB $48          ; NEW       -> $173C (ROM 0)
16f5			DEFB $94          ; BORDER    -> $1789 (ROM 0)
16f6			DEFB $56          ; CONTINUE  -> $174C (ROM 0)
16f7			DEFB $3F          ; DIM       -> $1736 (ROM 0)
16f8			DEFB $41          ; REM       -> $1739 (ROM 0)
16f9			DEFB $2B          ; FOR       -> $1724 (ROM 0)
16fa			DEFB $17          ; GO TO     -> $1711 (ROM 0)
16fb			DEFB $1F          ; GO SUB    -> $171A (ROM 0)
16fc			DEFB $37          ; INPUT     -> $1733 (ROM 0)
16fd			DEFB $77          ; LOAD      -> $1774 (ROM 0)
16fe			DEFB $44          ; LIST      -> $1742 (ROM 0)
16ff			DEFB $0F          ; LET       -> $170E (ROM 0)
1700			DEFB $59          ; PAUSE     -> $1759 (ROM 0)
1701			DEFB $2B          ; NEXT      -> $172C (ROM 0)
1702			DEFB $43          ; POKE      -> $1745 (ROM 0)
1703			DEFB $2D          ; PRINT     -> $1730 (ROM 0)
1704			DEFB $51          ; PLOT      -> $1755 (ROM 0)
1705			DEFB $3A          ; RUN       -> $173F (ROM 0)
1706			DEFB $6D          ; SAVE      -> $1773 (ROM 0)
1707			DEFB $42          ; RANDOMIZE -> $1749 (ROM 0)
1708			DEFB $0D          ; IF        -> $1715 (ROM 0)
1709			DEFB $49          ; CLS       -> $1752 (ROM 0)
170a			DEFB $5C          ; DRAW      -> $1766 (ROM 0)
170b			DEFB $44          ; CLEAR     -> $174F (ROM 0)
170c			DEFB $15          ; RETURN    -> $1721 (ROM 0)
170d			DEFB $5D          ; COPY      -> $176A (ROM 0)
170e
170e			; --------------------------
170e			; The Syntax Parameter Table
170e			; --------------------------
170e			; Similar to the parameter table in ROM 1 at $1A7A.
170e
170e	L170E:  DEFB $01          ; CLASS-01    LET
170f			DEFB '='          ; $3D. '='
1710			DEFB $02          ; CLASS-02
1711
1711	L1711:  DEFB $06          ; CLASS-06    GO TO
1712			DEFB $00          ; CLASS-00
1713			DEFW GO_TO        ; $1E67. GO TO routine in ROM 1.
1715
1715	L1715:  DEFB $06          ; CLASS-06    IF
1716			DEFB $CB          ; 'THEN'
1717			DEFB $0E          ; CLASS-0E
1718			DEFW L1967        ; New IF routine in ROM 0.
171a
171a	L171A:  DEFB $06          ; CLASS-06    GO SUB
171b			DEFB $0C          ; CLASS-0C
171c			DEFW L1A53        ; New GO SUB routine in ROM 0.
171e
171e	L171E:  DEFB $00          ; CLASS-00    STOP
171f			DEFW STOP         ; $1CEE. STOP routine in ROM 1.
1721
1721	L1721:  DEFB $0C          ; CLASS-0C    RETURN
1722			DEFW L1A6F        ; New RETURN routine in ROM 0.
1724
1724	L1724:  DEFB $04          ; CLASS-04    FOR
1725			DEFB '='          ; $3D. '='
1726			DEFB $06          ; CLASS-06
1727			DEFB $CC          ; 'TO'
1728			DEFB $06          ; CLASS-06
1729			DEFB $0E          ; CLASS-0E
172a			DEFW L1981        ; New FOR routine in ROM 0.
172c
172c	L172C:  DEFB $04          ; CLASS-04    NEXT
172d			DEFB $00          ; CLASS-00
172e			DEFW NEXT         ; $1DAB. NEXT routine in ROM 1.
1730
1730	L1730:  DEFB $0E          ; CLASS-0E    PRINT
1731			DEFW L2178        ; New PRINT routine in ROM 0.
1733
1733	L1733:  DEFB $0E          ; CLASS-0E    INPUT
1734			DEFW L218C        ; New INPUT routine in ROM 0.
1736
1736	L1736:  DEFB $0E          ; CLASS-0E    DIM
1737			DEFW L21D5        ; New DIM routine in ROM 0.
1739
1739	L1739:  DEFB $0E          ; CLASS-0E    REM
173a			DEFW L1862        ; New REM routine in ROM 0.
173c
173c	L173C:  DEFB $0C          ; CLASS-0C    NEW
173d			DEFW L21AA        ; New NEW routine in ROM 0.
173f
173f	L173F:  DEFB $0D          ; CLASS-0D    RUN
1740			DEFW L1A02        ; New RUN routine in ROM 0.
1742
1742	L1742:  DEFB $0E          ; CLASS-0E    LIST
1743			DEFW L1B75        ; New LIST routine in ROM 0.
1745
1745	L1745:  DEFB $08          ; CLASS-08    POKE
1746			DEFB $00          ; CLASS-00
1747			DEFW POKE         ; $1E80. POKE routine in ROM 1.
1749
1749	L1749:  DEFB $03          ; CLASS-03    RANDOMIZE
174a			DEFW RANDOMIZE    ; $1E4F. RANDOMIZE routine in ROM 1.
174c
174c	L174C:  DEFB $00          ; CLASS-00    CONTINUE
174d			DEFW CONTINUE     ; $1E5F. CONTINUE routine in ROM 1.
174f
174f	L174F:  DEFB $0D          ; CLASS-0D    CLEAR
1750			DEFW L1A0D        ; New CLEAR routine in ROM 0.
1752
1752	L1752:  DEFB $00          ; CLASS-00    CLS
1753			DEFW CLS          ; $0D6B. CLS routine in ROM 1.
1755
1755	L1755:  DEFB $09          ; CLASS-09    PLOT
1756			DEFB $00          ; CLASS-00
1757			DEFW PLOT         ; $22DC. PLOT routine in ROM 1
1759
1759	L1759:  DEFB $06          ; CLASS-06    PAUSE
175a			DEFB $00          ; CLASS-00
175b			DEFW PAUSE        ; $1F3A. PAUSE routine in ROM 1.
175d
175d	L175D:  DEFB $0E          ; CLASS-0E    READ
175e			DEFW L19AB        ; New READ routine in ROM 0.
1760
1760	L1760:  DEFB $0E          ; CLASS-0E    DATA
1761			DEFW L19EB        ; New DATA routine in ROM 0.
1763
1763	L1763:  DEFB $03          ; CLASS-03    RESTORE
1764			DEFW RESTORE      ; $1E42. RESTORE routine in ROM 1.
1766
1766	L1766:  DEFB $09          ; CLASS-09    DRAW
1767			DEFB $0E          ; CLASS-0E
1768			DEFW L21BE        ; New DRAW routine in ROM 0.
176a
176a	L176A:  DEFB $0C          ; CLASS-0C    COPY
176b			DEFW L21A7        ; New COPY routine in ROM 0.
176d
176d	L176D:  DEFB $0E          ; CLASS-0E    LPRINT
176e			DEFW L2174        ; New LPRINT routine in ROM 0.
1770
1770	L1770:  DEFB $0E          ; CLASS-0E    LLIST
1771			DEFW L1B71        ; New LLIST routine in ROM 0.
1773
1773	L1773:  DEFB $0B          ; CLASS-0B    SAVE
1774
1774	L1774:  DEFB $0B          ; CLASS-0B    LOAD
1775
1775	L1775:  DEFB $0B          ; CLASS-0B    VERIFY
1776
1776	L1776:  DEFB $0B          ; CLASS-0B    MERGE
1777
1777	L1777:  DEFB $08          ; CLASS-08    BEEP
1778			DEFB $00          ; CLASS-00
1779			DEFW BEEP         ; $03F8. BEEP routine in ROM 1.
177b
177b	L177B:  DEFB $09          ; CLASS-09    CIRCLE
177c			DEFB $0E          ; CLASS-0E
177d			DEFW L21AE        ; New CIRCLE routine in ROM 0.
177f
177f	L177F:  DEFB $07          ; CLASS-07    INK
1780
1780	L1780:  DEFB $07          ; CLASS-07    PAPER
1781
1781	L1781:  DEFB $07          ; CLASS-07    FLASH
1782
1782	L1782:  DEFB $07          ; CLASS-07    BRIGHT
1783
1783	L1783:  DEFB $07          ; CLASS-07    INVERSE
1784
1784	L1784:  DEFB $07          ; CLASS-07    OVER
1785
1785	L1785:  DEFB $08          ; CLASS-08    OUT
1786			DEFB $00          ; CLASS-00
1787			DEFW COUT         ; $1E7A. OUT routine in ROM 1.
1789
1789	L1789:  DEFB $06          ; CLASS-06    BORDER
178a			DEFB $00          ; CLASS-00
178b			DEFW BORDER       ; $2294. BORDER routine in ROM 1.
178d
178d	L178D:  DEFB $0E          ; CLASS-0E    DEF FN
178e			DEFW L1A8C        ; New DEF FN routine in ROM 0.
1790
1790	L1790:  DEFB $06          ; CLASS-06    OPEN #
1791			DEFB ','          ; $2C. ','
1792			DEFB $0A          ; CLASS-0A
1793			DEFB $00          ; CLASS-00
1794			DEFW OPEN         ; $1736. OPEN # routine in ROM 1.
1796
1796	L1796:  DEFB $06          ; CLASS-06    CLOSE #
1797			DEFB $00          ; CLASS-00
1798			DEFW CLOSE        ; $16E5. CLOSE # routine in ROM 1.
179a
179a	L179A:  DEFB $0E          ; CLASS-0E    FORMAT
179b			DEFW L0641        ; FORMAT routine in ROM 0.
179d
179d	L179D:  DEFB $0A          ; CLASS-0A    MOVE
179e			DEFB ','          ; $2C. ','
179f			DEFB $0A          ; CLASS-0A
17a0			DEFB $0C          ; CLASS-0C
17a1			DEFW L1AF0        ; Just execute a RET.
17a3
17a3	L17A3:  DEFB $0E          ; CLASS-0E    ERASE
17a4			DEFW L1C0C        ; New ERASE routine in ROM 0.
17a6
17a6	L17A6:  DEFB $0E          ; CLASS-0E    CAT
17a7			DEFW L1BE5        ; New CAT routine in ROM 0.
17a9
17a9	L17A9:  DEFB $0C          ; CLASS-0C    SPECTRUM
17aa			DEFW L1B2B        ; SPECTRUM routine in ROM 0.
17ac
17ac	L17AC:  DEFB $0E          ; CLASS-0E    PLAY
17ad			DEFW L2317        ; PLAY routine in ROM 0.
17af
17af			; (From Logan & O'Hara's 48K ROM disassembly):
17af			; The requirements for the different command classes are as follows:
17af			; CLASS-00 - No further operands.
17af			; CLASS-01 - Used in LET. A variable is required.
17af			; CLASS-02 - Used in LET. An expression, numeric or string, must follow.
17af			; CLASS-03 - A numeric expression may follow. Zero to be used in case of default.
17af			; CLASS-04 - A single character variable must follow.
17af			; CLASS-05 - A set of items may be given.
17af			; CLASS-06 - A numeric expression must follow.
17af			; CLASS-07 - Handles colour items.
17af			; CLASS-08 - Two numeric expressions, separated by a comma, must follow.
17af			; CLASS-09 - As for CLASS-08 but colour items may precede the expressions.
17af			; CLASS-0A - A string expression must follow.
17af			; CLASS-0B - Handles cassette/RAM disk routines.
17af
17af			; In addition the 128 adds the following classes:
17af			; CLASS-0C - Like class 00 but calling ROM 0. (Used by SPECTRUM, MOVE, COPY, NEW, GO SUB, RETURN)
17af			; CLASS-0D - Like class 06 but calling ROM 0. (Used by CLEAR, RUN)
17af			; CLASS-0E - Handled in ROM 0. (Used by PLAY, ERASE, CAT, FORMAT, CIRCLE, LPRINT, LLIST, DRAW, DATA, READ, LIST, DIM, INPUT, PRINT, FOR, IF)
17af
17af			; ------------------------------------------
17af			; The 'Main Parser' Of the BASIC Interpreter
17af			; ------------------------------------------
17af			; The parsing routine of the BASIC interpreter is entered at $17AF (ROM 0) when syntax is being checked,
17af			; and at $1838 (ROM 0) when a BASIC program of one or more statements is to be executed.
17af			; This code is similar to that in ROM 1 at $1B17.
17af
17af	L17AF:  RES  7,(IY+$01)   ; FLAGS. Signal 'syntax checking'.
17b3			RST  28H          ;
17b4			DEFW E_LINE_NO    ; $19FB. CH-ADD is made to point to the first code after any line number
17b6			XOR  A            ;
17b7			LD   ($5C47),A    ; SUBPPC. Set to $00.
17ba			DEC  A            ;
17bb			LD   ($5C3A),A    ; ERR_NR. Set to $FF.
17be			JR   L17C1        ; Jump forward to consider the first statement of the line.
17c0
17c0			; ------------------
17c0			; The Statement Loop
17c0			; ------------------
17c0			; Each statement is considered in turn until the end of the line is reached.
17c0
17c0	L17C0:  RST  20H          ; Advance CH-ADD along the line.
17c1
17c1	L17C1:  RST  28H          ;
17c2			DEFW SET_WORK     ; $16BF. The work space is cleared.
17c4			INC  (IY+$0D)     ; SUBPPC. Increase SUBPPC on each passage around the loop.
17c7			JP   M,L1912      ; Only '127' statements are allowed in a single line. Jump to report "C Nonsense in BASIC".
17ca
17ca			RST  18H          ; Fetch a character.
17cb			LD   B,$00        ; Clear the register for later.
17cd			CP   $0D          ; Is the character a 'carriage return'?
17cf			JP   Z,L1863      ; jump if it is.
17d2
17d2			CP   ':'          ; $3A. Go around the loop again if it is a ':'.
17d4			JR   Z,L17C0      ;
17d6
17d6			;A statement has been identified so, first, its initial command is considered
17d6
17d6			LD   HL,L1821     ; Pre-load the machine stack with the return address.
17d9			PUSH HL           ;
17da
17da			LD   C,A          ; Save the command temporarily
17db			RST  20H          ; in the C register whilst CH-ADD is advanced again.
17dc			LD   A,C          ;
17dd			SUB  $CE          ; Reduce the command's code by $CE giving the range indexed from $00.
17df			JR   NC,L17F4     ; Jump for DEF FN and above.
17e1
17e1			ADD  A,$CE        ;
17e3			LD   HL,L17A9     ;
17e6			CP   $A3          ; Is it 'SPECTRUM'?
17e8			JR   Z,L1800      ; Jump if so into the scanning loop with this address.
17ea
17ea			LD   HL,L17AC     ;
17ed			CP   $A4          ; Is it 'PLAY'?
17ef			JR   Z,L1800      ; Jump if so into the scanning loop with this address.
17f1
17f1			JP   L1912        ; Produce error report "C Nonsense in BASIC".
17f4
17f4	L17F4:  LD   C,A          ; Move the command code to BC (B holds $00).
17f5			LD   HL,L16DC     ; The base address of the syntax offset table.
17f8			ADD  HL,BC        ;
17f9			LD   C,(HL)       ;
17fa			ADD  HL,BC        ; Find address for the command's entries in the parameter table.
17fb			JR   L1800        ; Jump forward into the scanning loop with this address.
17fd
17fd			;Each of the command class routines applicable to the present command are executed in turn.
17fd			;Any required separators are also considered.
17fd
17fd	L17FD:  LD   HL,($5C74)   ; T_ADDR. The temporary pointer to the entries in the parameter table.
1800
1800	L1800:  LD   A,(HL)       ; Fetch each entry in turn.
1801			INC  HL           ; Update the pointer to the entries for the next pass.
1802			LD   ($5C74),HL   ; T_ADDR.
1805
1805			LD   BC,L17FD     ; Pre-load the machine stack with the return address.
1808			PUSH BC           ;
1809
1809			LD   C,A          ; Copy the entry to the C register for later.
180a			CP   $20          ;
180c			JR   NC,L181A     ; Jump forward if the entry is a 'separator'.
180e
180e			LD   HL,L18B5     ; The base address of the 'command class' table.
1811			LD   B,$00        ;
1813			ADD  HL,BC        ; Index into the table.
1814			LD   C,(HL)       ;
1815			ADD  HL,BC        ; HL=base + code + (base + code).
1816			PUSH HL           ; HL=The starting address of the required command class routine.
1817
1817			RST  18H          ; Before making an indirect jump to the command class routine pass the command code
1818			DEC  B            ; to the A register and set the B register to $FF.
1819			RET               ; Return to the stacked address.
181a
181a			; --------------------------
181a			; The 'Separator' Subroutine
181a			; --------------------------
181a			; The report 'Nonsense in BASIC is given if the required separator is not present.
181a			; But note that when syntax is being checked the actual report does not appear on the screen - only the 'error marker'.
181a			; This code is similar to that in ROM 1 at $1B6F.
181a
181a	L181A:  RST  18H          ; The current character is
181b			CP   C            ; fetched and compared to the entry in the parameter table.
181c			JP   NZ,L1912     ; Give the error report if there is not a match.
181f
181f			RST  20H          ; Step past a correct character
1820			RET               ; and return.
1821
1821			; ---------------------------------
1821			; The 'Statement Return' Subroutine
1821			; ---------------------------------
1821			; After the correct interpretation of a statement, a return is made to this entry point.
1821			; This code is similar to that in ROM 1 at $1B76.
1821
1821	L1821:  CALL L05D6        ; Check for BREAK
1824			JR   C,L182A      ; Jump if pressed.
1826
1826			CALL L05AC        ; Produce error report.
1829			DEFB $14          ; "L Break into program"
182a
182a	L182A:  BIT  7,(IY+$0A)   ; NSPPC - statement number in line to be jumped to
182e			JP   NZ,L18A8     ; Jump forward if there is not a 'jump' to be made.
1831
1831			LD   HL,($5C42)   ; NEWPPC, line number to be jumped to.
1834			BIT  7,H          ;
1836			JR   Z,L184C      ; Jump forward unless dealing with a further statement in the editing area.
1838
1838			; --------------------------
1838			; The 'Line Run' Entry Point
1838			; --------------------------
1838			; This entry point is used wherever a line in the editing area is to be 'run'.
1838			; In such a case the syntax/run flag (bit 7 of FLAGS) will be set.
1838			; The entry point is also used in the syntax checking of a line in the editing area
1838			; that has more than one statement (bit 7 of FLAGS will be reset).
1838			; This code is similar to that in ROM 1 at $1B8A.
1838
1838	L1838:  LD   HL,$FFFE     ; A line in the editing area is considered as line '-2'.
183b			LD   ($5C45),HL   ; PPC.
183e			LD   HL,($5C61)   ; WORKSP. Make HL point to the end marker of the editing area.
1841			DEC  HL           ;
1842			LD   DE,($5C59)   ; E_LINE. Make DE point to the location before the end marker of the editing area.
1846			DEC  DE           ;
1847			LD   A,($5C44)    ; NSPPC. Fetch the number of the next statement to be handled.
184a			JR   L1882        ; Jump forward.
184c
184c			; -------------------------
184c			; The 'Line New' Subroutine
184c			; -------------------------
184c			; There has been a jump in the program and the starting address of the new line has to be found.
184c			; This code is similar to that in ROM 1 at 1B9E.
184c
184c	L184C:  RST  28H          ;
184d			DEFW LINE_ADDR    ; $196E. The starting address of the line, or the 'first line after' is found.
184f			LD   A,($5C44)    ; NSPPC. Collect the statement number.
1852			JR   Z,L1870      ; Jump forward if the required line was found.
1854
1854			AND  A            ; Check the validity of the statement number - must be zero.
1855			JR   NZ,L189D     ; Jump if not to produce error report "N Statement lost".
1857
1857			LD   B,A          ; Also check that the 'first
1858			LD   A,(HL)       ; line after' is not after the
1859			AND  $C0          ; actual 'end of program'.
185b			LD   A,B          ;
185c			JR   Z,L1870      ; Jump forward with valid addresses; otherwise signal the error 'OK'.
185e
185e			CALL L05AC        ; Produce error report.
1861			DEFB $FF          ; "0 OK"
1862
1862			; -----------
1862			; REM Routine
1862			; -----------
1862			; The return address to STMT-RET is dropped which has the effect of forcing the rest of the
1862			; line to be ignored.
1862			; This code is similar to that in ROM 1 at $1BB2.
1862
1862	L1862:  POP  BC           ; Drop the statement return address.
1863
1863			; ----------------------
1863			; The 'Line End' Routine
1863			; ----------------------
1863			; If checking syntax a simple return is made but when 'running' the address held by NXTLIN
1863			; has to be checked before it can be used.
1863			; This code is similar to that in ROM 1 at $1BB3.
1863
1863	L1863:  BIT  7,(IY+$01)   ;
1867			RET  Z            ; Return if syntax is being checked.
1868
1868			LD   HL,($5C55)   ; NXTLIN.
186b			LD   A,$C0        ; Return if the address is after the end of the program - the 'run' is finished.
186d			AND  (HL)         ;
186e			RET  NZ           ;
186f
186f			XOR  A            ; Signal 'statement zero' before proceeding.
1870
1870			; ----------------------
1870			; The 'Line Use' Routine
1870			; ----------------------
1870			; This routine has three functions:
1870			;  i.   Change statement zero to statement '1'.
1870			;  ii.  Find the number of the new line and enter it into PPC.
1870			;  iii. Form the address of the start of the line after.
1870			; This code is similar to that in ROM 1 at $1BBF.
1870
1870	L1870:  CP   $01          ; Statement zero becomes statement 1.
1872			ADC  A,$00        ;
1874			LD   D,(HL)       ; The line number of the line to be used is collected and
1875			INC  HL           ; passed to PPC.
1876			LD   E,(HL)       ;
1877			LD   ($5C45),DE   ; PPC.
187b			INC  HL           ;
187c			LD   E,(HL)       ; Now find the 'length' of the line.
187d			INC  HL           ;
187e			LD   D,(HL)       ;
187f			EX   DE,HL        ; Switch over the values.
1880			ADD  HL,DE        ; Form the address of the start of the line after in HL and the
1881			INC  HL           ; location before the 'next' line's first character in DE.
1882
1882			; -----------------------
1882			; The 'Next Line' Routine
1882			; -----------------------
1882			; On entry the HL register pair points to the location after the end of the 'next' line
1882			; to be handled and the DE register pair to the location before the first character of the line.
1882			; This applies to lines in the program area and also to a line in the editing area - where the
1882			; next line will be the same line again whilst there are still statements to be interpreted.
1882			; This code is similar to that in ROM 1 at $1BD1.
1882
1882	L1882:  LD   ($5C55),HL   ; NXTLIN. Set NXTLIN for use once the current line has been completed.
1885			EX   DE,HL        ;
1886			LD   ($5C5D),HL   ; CH_ADD. CH_ADD points to the location before the first character to be considered.
1889			LD   D,A          ; The statement number is fetched.
188a			LD   E,$00        ; The E register is cleared in case the 'Each Statement' routine is used.
188c			LD   (IY+$0A),$FF ; NSPPC. Signal 'no jump'.
1890			DEC  D            ;
1891			LD   (IY+$0D),D   ; SUB_PPC. Statement number-1.
1894			JP   Z,L17C0      ; Jump if the first statement.
1897
1897			INC  D            ; For later statements the 'starting address' has to be found.
1898			RST  28H          ;
1899			DEFW EACH_STMT    ; $198B.
189b			JR   Z,L18A8      ; Jump forward unless the statement does not exist.
189d
189d	L189D:  CALL L05AC        ; Produce error report.
18a0			DEFB $16          ; "N Statement lost"
18a1
18a1			; --------------------------
18a1			; The 'CHECK-END' Subroutine
18a1			; --------------------------
18a1			; This is called when the syntax of the edit-line is being checked. The purpose of the routine is to
18a1			; give an error report if the end of a statement has not been reached and to move on to the next
18a1			; statement if the syntax is correct.
18a1			; The routine is the equivalent of routine CHECK_END in ROM 1 at $1BEE.
18a1
18a1	L18A1:  BIT  7,(IY+$01)   ; Very like CHECK-END at 1BEE in ROM 1
18a5			RET  NZ           ; Return unless checking syntax.
18a6
18a6			POP  BC           ; Drop scan loop and statement return addresses.
18a7			POP  BC           ;
18a8
18a8			; -----------------------
18a8			; The 'STMT-NEXT' Routine
18a8			; -----------------------
18a8			; If the present character is a 'carriage return' then the 'next statement' is on the 'next line',
18a8			; if ':' it is on the same line; but if any other character is found then there is an error in syntax.
18a8			; The routine is the equivalent of routine STMT_NEXT in ROM 1 at $1BF4.
18a8
18a8	L18A8:  RST  18H          ; Fetch the present character.
18a9			CP   $0D          ; Consider the 'next line' if
18ab			JR   Z,L1863      ; it is a 'carriage return'.
18ad
18ad			CP   ':'          ; $3A. Consider the 'next statement'
18af			JP   Z,L17C0      ; if it is a ':'.
18b2
18b2			JP   L1912        ; Otherwise there has been a syntax error so produce "C Nonsense in BASIC".
18b5
18b5			; -------------------------
18b5			; The 'Command Class' Table
18b5			; -------------------------
18b5
18b5	L18B5:  DEFB L18D9-$      ; CLASS-00 -> L18D9 = $24
18b6			DEFB L18F9-$      ; CLASS-01 -> L18F9 = $43
18b7			DEFB L18FD-$      ; CLASS-02 -> L18FD = $46
18b8			DEFB L18D6-$      ; CLASS-03 -> L18D6 = $1E
18b9			DEFB L1905-$      ; CLASS-04 -> L1905 = $4C
18ba			DEFB L18DA-$      ; CLASS-05 -> L18DA = $20
18bb			DEFB L190E-$      ; CLASS-06 -> L190E = $53
18bc			DEFB L191A-$      ; CLASS-07 -> L191A = $5E
18bd			DEFB L190A-$      ; CLASS-08 -> L190A = $4D
18be			DEFB L1944-$      ; CLASS-09 -> L1944 = $86
18bf			DEFB L1916-$      ; CLASS-0A -> L1916 = $57
18c0			DEFB L1948-$      ; CLASS-0B -> L1948 = $88
18c1			DEFB L18C7-$      ; CLASS-0C -> L18C7 = $06
18c2			DEFB L18C4-$      ; CLASS-0D -> L18C4 = $02
18c3			DEFB L18C8-$      ; CLASS-0E -> L18C8 = $05
18c4
18c4			; -----------------------------------
18c4			; The 'Command Classes - 0C, 0D & 0E'
18c4			; -----------------------------------
18c4			; For commands of class-0D a numeric expression must follow.
18c4
18c4	L18C4:  RST  28H          ; Code 0D enters here.
18c5			DEFW FETCH_NUM    ; $1CDE.
18c7
18c7			;The commands of class-0C must not have any operands. e.g. SPECTRUM.
18c7
18c7	L18C7:  CP   A            ; Code 0C enters here. Set zero flag.
18c8
18c8			;The commands of class-0E may be followed by a set of items. e.g. PLAY.
18c8
18c8	L18C8:  POP  BC           ; Code 0E enters here.
18c9			; Retrieve return address.
18c9			CALL Z,L18A1      ; If handling commands of classes 0C & 0D and syntax is being
18cc			; checked move on now to consider the next statement.
18cc			EX   DE,HL        ; Save the line pointer in DE.
18cd
18cd			; After the command class entries and the separator entries in the parameter table have
18cd			; been considered the jump to the appropriate command routine is made.
18cd			; The routine is similar to JUMP-C-R in ROM 1 at $1C16.
18cd
18cd			LD   HL,($5C74)   ; T_ADDR.
18d0			LD   C,(HL)       ; Fetch the pointer to the entries in the parameter table
18d1			INC  HL           ; and fetch the address of the
18d2			LD   B,(HL)       ; required command routine.
18d3			EX   DE,HL        ; Exchange the pointers back.
18d4			PUSH BC           ; Make an indirect jump to the command routine.
18d5			RET               ;
18d6
18d6			; -----------------------------------
18d6			; The 'Command Classes - 00, 03 & 05'
18d6			; -----------------------------------
18d6			; These routines are the equivalent of the routines in ROM 1 starting at $1C0D.
18d6
18d6			; The commands of class-03 may, or may not, be followed by a number. e.g. RUN & RUN 200.
18d6
18d6	L18D6:  RST  28H          ; Code 03 enters here.
18d7			DEFW FETCH_NUM    ; $1CDE. A number is fetched but zero is used in cases of default.
18d9
18d9			;The commands of class-00 must not have any operands. e.g. COPY & CONTINUE.
18d9
18d9	L18D9:  CP   A            ; Code 00 enters here. Set the zero flag.
18da
18da			;The commands of class-05 may be followed by a set of items. e.g. PRINT & PRINT "222".
18da
18da	L18DA:  POP  BC           ; Code 05 enters here. Drop return address.
18db			CALL Z,L18A1      ; If handling commands of classes 00 & 03 and syntax is being
18de			; checked move on now to consider the next statement.
18de			EX   DE,HL        ; Save the line pointer in DE.
18df
18df			LD   HL,($5C74)   ; T_ADDR. Fetch the pointer to the entries in the parameter table.
18e2			LD   C,(HL)       ;
18e3			INC  HL           ;
18e4			LD   B,(HL)       ; Fetch the address of the required command routine.
18e5			EX   DE,HL        ; Exchange the pointers back.
18e6			PUSH HL           ; Save command routine address.
18e7
18e7			LD   HL,L18F8     ; The address to return to (the RET below).
18ea			LD   (RETADDR),HL ; $5B5A. Store the return address.
18ed			LD   HL,YOUNGER   ; $5B14. Paging subroutine.
18f0			EX   (SP),HL      ; Replace the return address with the address of the YOUNGER routine.
18f1			PUSH HL           ; Save the original top stack item.
18f2			LD   H,B          ;
18f3			LD   L,C          ; HL=Address of command routine.
18f4			EX   (SP),HL      ; Put onto the stack so that an indirect jump will be made to it.
18f5			JP   SWAP         ; $5B00. Switch to other ROM and 'return' to the command routine.
18f8
18f8			;Comes here after ROM 1 has been paged in, the command routine called, ROM 0 paged back in.
18f8
18f8	L18F8:  RET               ; Simply make a return.
18f9
18f9			; ------------------------
18f9			; The 'Command Class - 01'
18f9			; ------------------------
18f9			; Command class 01 is concerned with the identification of the variable in a LET, READ or INPUT statement.
18f9
18f9	L18F9:  RST  28H          ; Delegate handling to ROM 1.
18fa			DEFW CLASS_01     ; $1C1F.
18fc			RET               ;
18fd
18fd			; ------------------------
18fd			; The 'Command Class - 02'
18fd			; ------------------------
18fd			; Command class 02 is concerned with the actual calculation of the value to be assigned in a LET statement.
18fd
18fd	L18FD:  POP  BC           ; Code 02 enters here. Delegate handling to ROM 1.
18fe			RST  28H          ;
18ff			DEFW VAL_FET_1    ; $1C56. "... used by LET, READ and INPUT statements to
1901			;         first evaluate and then assign values to the
1901			;         previously designated variable" (Logan/O'Hara)
1901			CALL L18A1        ; Move on to the next statement if checking syntax
1904			RET               ; else return here.
1905
1905			; ------------------------
1905			; The 'Command Class - 04'
1905			; ------------------------
1905			; The command class 04 entry point is used by FOR & NEXT statements.
1905
1905	L1905:  RST  28H          ; Code 04 enters here. Delegate handling to ROM 1.
1906			DEFW CLASS_04     ; $1C6C.
1908			RET               ;
1909
1909			; ------------------------
1909			; The 'Command Class - 08'
1909			; ------------------------
1909			; Command class 08 allows for two numeric expressions, separated by a comma, to be evaluated.
1909
1909	L1909:  RST  20H          ; [Redundant byte]
190a
190a	L190A:  RST  28H          ; Delegate handling to ROM 1.
190b			DEFW EXPT_2NUM    ; $1C7A.
190d			RET               ;
190e
190e			; ------------------------
190e			; The 'Command Class - 06'
190e			; ------------------------
190e			; Command class 06 allows for a single numeric expression to be evaluated.
190e
190e	L190E:  RST  28H          ; Code 06 enters here. Delegate handling to ROM 1.
190f			DEFW EXPT_1NUM    ; $1C82.
1911			RET               ;
1912
1912			; ----------------------------
1912			; Report C - Nonsense in BASIC
1912			; ----------------------------
1912
1912	L1912:  CALL L05AC        ; Produce error report. [Could have saved 4 bytes by using the identical routine at $1219 (ROM 0) instead]
1915			DEFB $0B          ; "C Nonsense in BASIC"
1916
1916			; ------------------------
1916			; The 'Command Class - 0A'
1916			; ------------------------
1916			; Command class 0A allows for a single string expression to be evaluated.
1916
1916	L1916:  RST  28H          ; Code 0A enters here. Delegate handling to ROM 1.
1917			DEFW EXPT_EXP     ; $1C8C.
1919			RET               ;
191a
191a			; ------------------------
191a			; The 'Command Class - 07'
191a			; ------------------------
191a			; Command class 07 is the command routine for the six colour item commands.
191a			; Makes the current temporary colours permanent.
191a
191a	L191A:  BIT  7,(IY+$01)   ; The syntax/run flag is read.
191e			RES  0,(IY+$02)   ; TV_FLAG. Signal 'main screen'.
1922			JR   Z,L1927      ; Jump ahead if syntax checking.
1924
1924			RST  28H          ; Only during a 'run' call TEMPS to ensure the temporary
1925			DEFW TEMPS        ; $0D4D.   colours are the main screen colours.
1927
1927	L1927:  POP  AF           ; Drop the return address.
1928			LD   A,($5C74)    ; T_ADDR.
192b			SUB  (L177F & $00FF)+$28 ; Reduce to range $D9-$DE which are the token codes for INK to OVER.
192d			RST  28H          ;
192e			DEFW CO_TEMP_4    ; $21FC. Change the temporary colours as directed by the BASIC statement.
1930			CALL L18A1        ; Move on to the next statement if checking syntax.
1933
1933			LD   HL,($5C8F)   ; ATTR_T. Now the temporary colour
1936			LD   ($5C8D),HL   ; ATTR_P.   values are made permanent
1939			LD   HL,$5C91     ; P_FLAG.
193c			LD   A,(HL)       ; Value of P_FLAG also has to be considered.
193d
193d			;The following instructions cleverly copy the even bits of the supplied byte to the odd bits.
193d			;In effect making the permanent bits the same as the temporary ones.
193d
193d			RLCA              ; Move the mask leftwards.
193e			XOR  (HL)         ; Impress onto the mask
193f			AND  $AA          ; only the even bits of the
1941			XOR  (HL)         ; other byte.
1942			LD   (HL),A       ; Restore the result.
1943			RET               ;
1944
1944			; ------------------------
1944			; The 'Command Class - 09'
1944			; ------------------------
1944			; This routine is used by PLOT, DRAW & CIRCLE statements in order to specify the default conditions
1944			; of 'FLASH 8; BRIGHT 8; PAPER 8;' that are set up before any embedded colour items are considered.
1944
1944	L1944:  RST  28H          ; Code 09 enters here. Delegate handling to ROM 1.
1945			DEFW CLASS_09     ; $1CBE.
1947			RET
1948
1948			; ------------------------
1948			; The 'Command Class - 0B'
1948			; ------------------------
1948			; This routine is used by SAVE, LOAD, VERIFY & MERGE statements.
1948
1948	L1948:  POP  AF           ; Drop the return address.
1949
1949			LD   A,(FLAGS3)   ; $5B66.
194c			AND  $0F          ; Clear LOAD/SAVE/VERIFY/MERGE indication bits.
194e			LD   (FLAGS3),A   ; $5B66.
1951
1951			LD   A,($5C74)    ; T_ADDR-lo.
1954			SUB  1+(L1773 & $00FF) ; Correct by $74 so that SAVE = $00, LOAD = $01, VERIFY = $02, MERGE = $03.
1956			LD   ($5C74),A    ; T_ADDR-lo.
1959			JP   Z,L11EB      ; Jump to handle SAVE.
195c
195c			DEC  A            ;
195d			JP   Z,L11F2      ; Jump to handle LOAD.
1960
1960			DEC  A            ;
1961			JP   Z,L11F9      ; Jump to handle VERIFY.
1964
1964			JP   L1200        ; Jump to handle MERGE.
1967
1967			; ----------
1967			; IF Routine
1967			; ----------
1967			; On entry the value of the expression between the IF and the THEN is the
1967			; 'last value' on the calculator stack. If this is logically true then the next
1967			; statement is considered; otherwise the line is considered to have been finished.
1967
1967	L1967:  POP  BC           ; Drop the return address.
1968			BIT  7,(IY+$01)   ;
196c			JR   Z,L197E      ; Jump forward if checking syntax.
196e
196e			;Now 'delete' the last value on the calculator stack
196e
196e	L196E:  LD   HL,($5C65)   ; STKEND.
1971			LD   DE,$FFFB     ; -5
1974			ADD  HL,DE        ; The present 'last value' is deleted.
1975			LD   ($5C65),HL   ; STKEND. HL point to the first byte of the value.
1978			RST  28H          ;
1979			DEFW TEST_ZERO    ; $34E9. Is the value zero?
197b			JP   C,L1863      ; If the value was 'FALSE' jump to the next line.
197e
197e	L197E:  JP   L17C1        ; But if 'TRUE' jump to the next statement (after the THEN).
1981
1981			; -----------
1981			; FOR Routine
1981			; -----------
1981			; This command routine is entered with the VALUE and the LIMIT of the FOR statement already
1981			; on the top of the calculator stack.
1981
1981	L1981:  CP   $CD          ; Jump forward unless a 'STEP' is given.
1983			JR   NZ,L198E     ;
1985
1985			RST  20H          ; Advance pointer
1986			CALL L190E        ; Indirectly call EXPT_1NUM in ROM 1 to get the value of the STEP.
1989			CALL L18A1        ; Move on to the next statement if checking syntax.
198c			JR   L19A6        ; Otherwise jump forward.
198e
198e			;There has not been a STEP supplied so the value '1' is to be used.
198e
198e	L198E:  CALL L18A1        ; Move on to the next statement if checking syntax.
1991			LD   HL,($5C65)   ; STKEND.
1994			LD   (HL),$00     ;
1996			INC  HL           ;
1997			LD   (HL),$00     ;
1999			INC  HL           ;
199a			LD   (HL),$01     ;
199c			INC  HL           ;
199d			LD   (HL),$00     ;
199f			INC  HL           ;
19a0			LD   (HL),$00     ; Place a value of 1 on the calculator stack.
19a2			INC  HL           ;
19a3			LD   ($5C65),HL   ; STKEND.
19a6
19a6			;The three values on the calculator stack are the VALUE (v), the LIMIT (l) and the STEP (s).
19a6			;These values now have to be manipulated. Delegate handling to ROM 1.
19a6
19a6	L19A6:  RST  28H          ;
19a7			DEFW F_REORDER    ; $1D16.
19a9			RET               ;
19aa
19aa			; ------------
19aa			; READ Routine
19aa			; ------------
19aa
19aa	L19AA:  RST  20H          ; Come here on each pass, after the first, to move along the READ statement.
19ab
19ab	L19AB:  CALL L18F9        ; Indirectly call CLASS_01 in ROM 1 to consider whether the variable has
19ae			; been used before, and find the existing entry if it has.
19ae			BIT  7,(IY+$01)   ;
19b2			JR   Z,L19E2      ; Jump forward if checking syntax.
19b4
19b4			RST  18H          ; Save the current pointer CH_ADD in X_PTR.
19b5			LD   ($5C5F),HL   ; X_PTR.
19b8
19b8			LD   HL,($5C57)   ; DATADD.
19bb			LD   A,(HL)       ; Fetch the current DATA list pointer
19bc			CP   $2C          ; and jump forward unless a new
19be			JR   Z,L19CB      ; DATA statement has to be found.
19c0
19c0			LD   E,$E4        ; The search is for 'DATA'.
19c2			RST  28H          ;
19c3			DEFW LOOK_PROG    ; $1D86.
19c5			JR   NC,L19CB     ; Jump forward if the search is successful.
19c7
19c7			CALL L05AC        ; Produce error report.
19ca			DEFB $0D          ; "E Out of Data"
19cb
19cb			; Pick up a value from the DATA list.
19cb
19cb	L19CB:  INC  HL           ; Advance the pointer along the DATA list.
19cc			LD   ($5C5D),HL   ; CH_ADD.
19cf			LD   A,(HL)       ;
19d0			RST  28H          ;
19d1			DEFW VAL_FET_1    ; $1C56. Fetch the value and assign it to the variable.
19d3			RST  18H          ;
19d4
19d4			LD   ($5C57),HL   ; DATADD.
19d7			LD   HL,($5C5F)   ; X_PTR. Fetch the current value of CH_ADD and store it in DATADD.
19da
19da			LD   (IY+$26),$00 ; X_PTR_hi. Clear the address of the character after the '?' marker.
19de			LD   ($5C5D),HL   ; CH_ADD. Make CH-ADD once again point to the READ statement.
19e1			LD   A,(HL)       ;
19e2
19e2	L19E2:  RST  18H          ; GET the present character
19e3			CP   ','          ; $2C. Check if it is a ','.
19e5
19e5	L19E5:  JR   Z,L19AA      ; If it is then jump back as there are further items.
19e7
19e7			CALL L18A1        ; Return if checking syntax
19ea			RET               ; or here if not checking syntax.
19eb
19eb			; ------------
19eb			; DATA Routine
19eb			; ------------
19eb			; During syntax checking a DATA statement is checked to ensure that it contains a series
19eb			; of valid expressions, separated by commas. But in 'run-time' the statement is passed by.
19eb
19eb	L19EB:  BIT  7,(IY+$01)   ; Jump forward unless checking syntax.
19ef			JR   NZ,L19FC     ;
19f1
19f1			;A loop is now entered to deal with each expression in the DATA statement.
19f1
19f1	L19F1:  RST  28H          ;
19f2			DEFW SCANNING     ; $24FB. Scan the next expression.
19f4			CP   ','          ; $2C. Check for the correct separator ','.
19f6			CALL NZ,L18A1     ; but move on to the next statement if not matched.
19f9			RST  20H          ; Whilst there are still expressions to be checked
19fa			JR   L19F1        ; go around again.
19fc
19fc			;The DATA statement has to be passed-by in 'run-time'.
19fc
19fc	L19FC:  LD   A,$E4        ; It is a 'DATA' statement that is to be passed-by.
19fe
19fe			;On entry the A register will hold either the token 'DATA' or the token 'DEF FN'
19fe			;depending on the type of statement that is being 'passed-by'.
19fe
19fe	L19FE:  RST  28H          ;
19ff			DEFW PASS_BY      ; $1E39. Delegate handling to ROM 1.
1a01			RET
1a02
1a02			; -----------
1a02			; RUN Routine
1a02			; -----------
1a02			; The parameter of the RUN command is passed to NEWPPC by calling the GO TO command routine.
1a02			; The operations of 'RESTORE 0' and 'CLEAR 0' are then performed before a return is made.
1a02
1a02	L1A02:  RST  28H
1a03			DEFW GO_TO        ; $1E67.
1a05
1a05			LD BC,$0000       ; Now perform a 'RESTORE 0'.
1a08			RST  28H
1a09			DEFW REST_RUN     ; $1E45.
1a0b			JR   L1A10        ; Exit via the CLEAR command routine.
1a0d
1a0d			; -------------
1a0d			; CLEAR Routine
1a0d			; -------------
1a0d			; This routine allows for the variables area to be cleared, the display area cleared
1a0d			; and RAMTOP moved. In consequence of the last operation the machine stack is rebuilt
1a0d			; thereby having the effect of also clearing the GO SUB stack.
1a0d
1a0d	L1A0D:  RST  28H          ;
1a0e			DEFW FIND_INT2    ; $1E99. Fetch the operand - using zero by default.
1a10
1a10	L1A10:  LD   A,B          ; Jump forward if the operand is
1a11			OR   C            ; other than zero. When called
1a12			JR   NZ,L1A18     ; from RUN there is no jump.
1a14
1a14			LD   BC,($5CB2)   ; RAMTOP. Use RAMTOP if the parameter is 0.
1a18
1a18	L1A18:  PUSH BC           ; BC = Address to clear to. Save it.
1a19			LD   DE,($5C4B)   ; VARS.
1a1d			LD   HL,($5C59)   ; E LINE.
1a20			DEC  HL           ;
1a21			RST  28H          ; Delete the variables area.
1a22			DEFW RECLAIM      ; $19E5.
1a24			RST  28H          ; Clear the screen
1a25			DEFW CLS          ; $0D6B.
1a27
1a27			;The value in the BC register pair which will be used as RAMTOP is tested to ensure it
1a27			;is neither too low nor too high.
1a27
1a27			LD   HL,($5C65)   ; STKEND. The current value of STKEND
1a2a			LD   DE,$0032     ; is increased by 50 before
1a2d			ADD  HL,DE        ; being tested. This forms the
1a2e			POP  DE           ; ADE = address to clear to lower limit.
1a2f			SBC  HL,DE        ;
1a31			JR   NC,L1A3B     ; Ramtop no good.
1a33
1a33			LD   HL,($5CB4)   ; P_RAMT. For the upper test the value
1a36			AND  A            ; for RAMTOP is tested against P_RAMT.
1a37			SBC  HL,DE        ;
1a39			JR   NC,L1A3F     ; Jump forward if acceptable.
1a3b
1a3b	L1A3B:  CALL L05AC        ; Produce error report.
1a3e			DEFB $15          ; "M Ramtop no good"
1a3f
1a3f	L1A3F:  LD   ($5CB2),DE   ; RAMTOP.
1a43			POP  DE           ; Retrieve interpreter return address from stack
1a44			POP  HL           ; Retrieve 'error address' from stack
1a45			POP  BC           ; Retrieve the GO SUB stack end marker.
1a46			; [*BUG* - It is assumed that the top of the GO SUB stack will be empty and hence only
1a46			; contain the end marker. This will not be the case if CLEAR is used within a subroutine,
1a46			; in which case BC will now hold the calling line number and this will be stacked in place
1a46			; of the end marker. When a RETURN command is encountered, the GO SUB stack appears to contain
1a46			; an entry since the end marker was not the top item. An attempt to return is therefore made.
1a46			; The CLEAR command handler within the 48K Spectrum ROM does not make any assumption about
1a46			; the contents of the GO SUB stack and instead always re-inserts the end marker. The bug could
1a46			; be fixed by inserting the line LD BC,$3E00 after the POP BC. Credit: Ian Collier (+3), Paul Farrow (128)]
1a46			LD   SP,($5CB2)   ; RAMTOP.
1a4a			INC  SP           ;
1a4b			PUSH BC           ; Stack the GO SUB stack end marker.
1a4c			PUSH HL           ; Stack 'error address'.
1a4d			LD   ($5C3D),SP   ; ERR_SP.
1a51			PUSH DE           ; Stack the interpreter return address.
1a52			RET
1a53
1a53			; --------------
1a53			; GO SUB Routine
1a53			; --------------
1a53			; The present value of PPC and the incremented value of SUBPPC are stored on the GO SUB stack.
1a53
1a53	L1A53:  POP  DE           ; Save the return address.
1a54			LD   H,(IY+$0D)   ; SUBPPC. Fetch the statement number and increment it.
1a57			INC  H            ;
1a58			EX   (SP),HL      ; Exchange the 'error address' with the statement number.
1a59			INC  SP           ; Reclaim the use of a location.
1a5a
1a5a			LD   BC,($5C45)   ; PPC.
1a5e			PUSH BC           ; Next save the present line number.
1a5f			PUSH HL           ; Return the 'error address' to the machine stack
1a60			LD   ($5C3D),SP   ; ERR-SP.  and reset ERR-SP to point to it.
1a64			PUSH DE           ; Stack the return address.
1a65
1a65			RST  28H          ;
1a66			DEFW GO_TO        ; $1E67. Now set NEWPPC & NSPPC to the required values.
1a68
1a68			LD   BC,$0014     ; But before making the jump make a test for room.
1a6b			RST  28H          ;
1a6c			DEFW TEST_ROOM    ; $1F05. Will automatically produce error '4' if out of memory.
1a6e			RET
1a6f
1a6f			; --------------
1a6f			; RETURN Routine
1a6f			; --------------
1a6f			; The line number and the statement number that are to be made the object of a 'return'
1a6f			; are fetched from the GO SUB stack.
1a6f
1a6f	L1A6F:  POP  BC           ; Fetch the return address.
1a70			POP  HL           ; Fetch the 'error address'.
1a71			POP  DE           ; Fetch the last entry on the GO SUB stack.
1a72			LD   A,D          ; The entry is tested to see if
1a73			CP   $3E          ; it is the GO SUB stack end marker.
1a75			JR   Z,L1A86      ; Jump if it is.
1a77
1a77			DEC  SP           ; The full entry uses three locations only.
1a78			EX   (SP),HL      ; Exchange the statement number with the 'error address'.
1a79			EX   DE,HL        ; Move the statement number.
1a7a			LD   ($5C3D),SP   ; ERR_SP. Reset the error pointer.
1a7e			PUSH BC           ; Replace the return address.
1a7f			LD   ($5C42),HL   ; NEWPPC. Enter the line number.
1a82			LD   (IY+$0A),D   ; NSPPC.  Enter the statement number.
1a85			RET               ;
1a86
1a86	L1A86:  PUSH DE           ; Replace the end marker and
1a87			PUSH HL           ; the 'error address'.
1a88
1a88			CALL L05AC        ; Produce error report.
1a8b			DEFB $06          ; "7 RETURN without GO SUB"
1a8c
1a8c			; --------------
1a8c			; DEF FN Routine
1a8c			; --------------
1a8c			; During syntax checking a DEF FN statement is checked to ensure that it has the correct form.
1a8c			; Space is also made available for the result of evaluating the function.
1a8c			; But in 'run-time' a DEF FN statement is passed-by.
1a8c
1a8c	L1A8C:  BIT  7,(IY+$01)
1a90			JR   Z,L1A97      ; Jump forward if checking syntax.
1a92
1a92			LD   A,$CE        ; Otherwise bass-by the
1a94			JP   L19FE        ; 'DEF FN' statement.
1a97
1a97			;First consider the variable of the function.
1a97
1a97	L1A97:  SET  6,(IY+$01)   ; Signal 'a numeric variable'.
1a9b			RST  28H          ;
1a9c			DEFW ALPHA        ; $2C8D. Check that the present code is a letter.
1a9e			JR   NC,L1AB6     ; Jump forward if not.
1aa0
1aa0			RST  20H          ; Fetch the next character.
1aa1			CP   '$'          ; $24.
1aa3			JR   NZ,L1AAA     ; Jump forward unless it is a '$'.
1aa5
1aa5			RES  6,(IY+$01)   ; Change bit 6 as it is a string variable.
1aa9			RST  20H          ; Fetch the next character.
1aaa
1aaa	L1AAA:  CP   '('          ; $28. A '(' must follow the variable's name.
1aac			JR   NZ,L1AEA     ; Jump forward if not.
1aae
1aae			RST  20H          ; Fetch the next character
1aaf			CP   ')'          ; $29. Jump forward if it is a ')'
1ab1			JR   Z,L1AD3      ; as there are no parameters of the function.
1ab3
1ab3			;A loop is now entered to deal with each parameter in turn.
1ab3
1ab3	L1AB3:  RST  28H          ;
1ab4			DEFW ALPHA        ; $2C8D.
1ab6
1ab6	L1AB6:  JP   NC,L1912     ; The present code must be a letter.
1ab9
1ab9			EX   DE,HL        ; Save the pointer in DE.
1aba			RST  20H          ; Fetch the next character.
1abb			CP   '$'          ; $24.
1abd			JR   NZ,L1AC1     ; Jump forward unless it is a '$'.
1abf
1abf			EX   DE,HL        ; Otherwise save the new pointer in DE instead.
1ac0			RST  20H          ; Fetch the next character.
1ac1
1ac1	L1AC1:  EX   DE,HL        ; Move the pointer to the last character of the name to HL.
1ac2			LD   BC,$0006     ; Now make six locations after that last character.
1ac5			RST  28H          ;
1ac6			DEFW MAKE_ROOM    ; $1655.
1ac8			INC  HL           ;
1ac9			INC  HL           ;
1aca			LD   (HL),$0E     ; Enter a 'number marker' into the first of the new locations.
1acc			CP   ','          ; $2C. If the present character is a ',' then jump back as
1ace			JR   NZ,L1AD3     ; there should be a further parameter.
1ad0
1ad0			RST  20H          ;
1ad1			JR   L1AB3        ; Otherwise jump out of the loop.
1ad3
1ad3			;Next the definition of the function is considered.
1ad3
1ad3	L1AD3:  CP   ')'          ; $29. Check that the ')' does exist.
1ad5			JR   NZ,L1AEA     ; Jump if not.
1ad7
1ad7			RST  20H          ; The next character is fetched.
1ad8			CP   '='          ; $3D. It must be an '='.
1ada			JR   NZ,L1AEA     ; Jump if not.
1adc
1adc			RST  20H          ; Fetch the next character.
1add			LD   A,($5C3B)    ; FLAGS.
1ae0			PUSH AF           ; Save the nature (numeric or string) of the variable
1ae1			RST  28H          ;
1ae2			DEFW SCANNING     ; $24FB. Now consider the definition as an expression.
1ae4			POP  AF           ; Fetch the nature of the variable.
1ae5
1ae5			XOR  (IY+$01)     ; FLAGS. Check that it is of the same type
1ae8			AND  $40          ; as found for the definition.
1aea
1aea	L1AEA:  JP   NZ,L1912     ; Give an error report if required.
1aed
1aed			CALL L18A1        ; Move on to consider the next statement in the line.
1af0
1af0			; ------------
1af0			; MOVE Routine
1af0			; ------------
1af0
1af0	L1AF0:  RET               ; Simply return.
1af1
1af1
1af1			; ======================
1af1			; MENU ROUTINES - PART 1
1af1			; ======================
1af1
1af1			; ---------------
1af1			; Run Tape Loader
1af1			; ---------------
1af1			; Used by Main Menu - Tape Loader option.
1af1
1af1	L1AF1:  LD   HL,$EC0E     ; Fetch mode.
1af4			LD   (HL),$FF     ; Set Tape Loader mode.
1af6			CALL L1F20        ; Use Normal RAM Configuration (physical RAM bank 0).
1af9
1af9			RST  28H          ;
1afa			DEFW SET_MIN      ; $16B0. Clear out editing area.
1afc
1afc			LD   HL,($5C59)   ; E_LINE.
1aff			LD   BC,$0003     ; Create 3 bytes of space for the LOAD "" command.
1b02			RST  28H          ;
1b03			DEFW MAKE_ROOM    ; $1655.
1b05
1b05			LD   HL,L1B6E     ; Address of command bytes for LOAD "".
1b08			LD   DE,($5C59)   ; E_LINE.
1b0c			LD   BC,$0003     ;
1b0f			LDIR              ; Copy LOAD "" into the line editing area.
1b11
1b11			CALL L026B        ; Parse and execute the BASIC line.
1b14			; [Will not return here but will exit via the error handler routine]
1b14
1b14			; -----------------------
1b14			; List Program to Printer
1b14			; -----------------------
1b14			; Used by Edit Menu - Print option.
1b14
1b14	L1B14:  CALL L1F20        ; Use Normal RAM Configuration (physical RAM bank 0).
1b17			RST  28H          ;
1b18			DEFW SET_MIN      ; $16B0. Clear out editing area.
1b1a
1b1a			LD   HL,($5C59)   ; E_LINE.
1b1d			LD   BC,$0001     ; Create 1 byte of space.
1b20			RST  28H          ;
1b21			DEFW MAKE_ROOM    ; $1655.
1b23
1b23			LD   HL,($5C59)   ; E_LINE.
1b26			LD   (HL),$E1     ; Copy LLIST into the line editing area.
1b28
1b28			CALL L026B        ; Parse and execute the BASIC line.
1b2b			; [Will not return here but will exit via the error handler routine]
1b2b
1b2b
1b2b			; =======================================================
1b2b			; BASIC LINE AND COMMAND INTERPRETATION ROUTINES - PART 2
1b2b			; =======================================================
1b2b
1b2b			; ----------------
1b2b			; SPECTRUM Routine
1b2b			; ----------------
1b2b			; Return to 48K BASIC Mode. This routine will force caps lock is off.
1b2b
1b2b	L1B2B:  CALL L1B53        ; Overwrite 'P' channel data to use the ZX Printer.
1b2e
1b2e			LD   SP,($5C3D)   ; ERR_SP. Purge the stack.
1b32			POP  HL           ; Remove error handler address.
1b33
1b33			LD   HL,MAIN_4    ; $1303. The main execution loop within ROM 1.
1b36			PUSH HL           ;
1b37
1b37			LD   HL,PRINT_A_1+$0003 ; $0013. Address of a $FF byte within ROM 1, used to generate error report "0 OK".
1b3a			PUSH HL           ;
1b3b			LD   HL,ERROR_1   ; $0008. The address of the error handler within ROM 1.
1b3e			PUSH HL           ;
1b3f
1b3f			; [*BUG* - Although the channel 'P' information has been reconfigured to use the ZX Printer, the ZX printer buffer and
1b3f			; associated system variables still need to be cleared. Failure to do so means that the first use of the ZX Printer will
1b3f			; cause garbage to the printed, i.e. the paging routines and new system variables still present in the ZX Printer buffer.
1b3f			; Subsequently printer output will then be ok since the ZX Printer buffer and system variables will be cleared.
1b3f			; Worse still, there is the possibility that new data to be printed will be inserted beyond the ZX Printer buffer since
1b3f			; ROM 1 does not trap whether the ZX Printer system variable PR_POSN and PR_CC hold invalid values. The bug can be fixed
1b3f			; by inserting the following instructions, which cause the ZX Printer buffer to be cleared immediately after switching to
1b3f			; ROM 1 and before the error report "0 OK" is produced. Credit: Paul Farrow and Andrew Owen.]
1b3f			;
1b3f			;       LD   HL,CLEAR_PRB ; Address of the routine in ROM 1 to clear the ZX Printer buffer and associated system variables.
1b3f			;       PUSH HL           ;
1b3f			;       SET  1,(IY+$01)   ; FLAGS. Signal the printer is in use.]
1b3f
1b3f			LD   A,$20        ; Force 48K mode.
1b41			LD   (BANK_M),A   ; $5B5C.
1b44			JP   SWAP         ; $5B00. Swap to ROM 1 and return via a RST $08 / DEFB $FF.
1b47
1b47
1b47			; ======================
1b47			; MENU ROUTINES - PART 2
1b47			; ======================
1b47
1b47			; ---------------------------
1b47			; Main Menu - 48 BASIC Option
1b47			; ---------------------------
1b47
1b47	L1B47:  LD   HL,$0000     ; Stack a $0000 address to return to.
1b4a			PUSH HL           ;
1b4b
1b4b			LD   A,$20        ; Force 48 mode.
1b4d			LD   (BANK_M),A   ; $5B5C
1b50			JP   SWAP         ; $5B00. Swap to ROM 1, return to $0000.
1b53
1b53			; --------------------
1b53			; Set 'P' Channel Data
1b53			; --------------------
1b53			; This routine overwrites the 'P' channel data with the 'S' channel data, i.e. the default values when using the ZX Printer.
1b53
1b53	L1B53:  LD   HL,($5C4F)   ; CHANS.
1b56			LD   DE,$0005     ;
1b59			ADD  HL,DE        ; HL=Address 'S' channel data.
1b5a			LD   DE,$000A     ;
1b5d			EX   DE,HL        ; HL=$000A, DE=Address 'S' channel data.
1b5e			ADD  HL,DE        ; HL=Address 'P' channel data.
1b5f			EX   DE,HL        ; DE=Address 'P' channel data, HL=Address 'S' channel data.
1b60			LD   BC,$0004     ;
1b63			LDIR              ; Copy the 'S' channel data over the 'P' channel data.
1b65			RES  3,(IY+$30)   ; FLAGS2. Signal caps lock unset. [Not really necessary for switching back to 48 BASIC mode]
1b69			RES  4,(IY+$01)   ; FLAGS. Signal not 128K mode.
1b6d			RET               ;
1b6e
1b6e			; ---------------------
1b6e			; LOAD "" Command Bytes
1b6e			; ---------------------
1b6e			; Used by the Tape Loader routine.
1b6e
1b6e	L1B6E:  DEFB $EF, $22, $22  ; LOAD ""
1b71
1b71
1b71			; =======================================================
1b71			; BASIC LINE AND COMMAND INTERPRETATION ROUTINES - PART 3
1b71			; =======================================================
1b71
1b71			; -------------
1b71			; LLIST Routine
1b71			; -------------
1b71
1b71	L1B71:  LD   A,$03        ; Printer channel.
1b73			JR   L1B77        ; Jump ahead to join LIST.
1b75
1b75			; ------------
1b75			; LIST Routine
1b75			; ------------
1b75
1b75	L1B75:  LD   A,$02        ; Main screen channel.
1b77
1b77	L1B77:  LD   (IY+$02),$00 ; TV_FLAG. Signal 'an ordinary listing in the main part of the screen'.
1b7b			RST  28H          ;
1b7c			DEFW SYNTAX_Z     ; $2530.
1b7e			JR   Z,L1B83      ; Do not open the channel if checking syntax.
1b80
1b80			RST  28H          ;
1b81			DEFW CHAN_OPEN    ; $1601. Open the channel.
1b83
1b83	L1B83:  RST  28H          ;
1b84			DEFW GET_CHAR     ; $0018. [Could just do RST $18]
1b86			RST  28H          ;
1b87			DEFW STR_ALTER    ; $2070. See if the stream is to be changed.
1b89			JR   C,L1BA3      ; Jump forward if unchanged.
1b8b
1b8b			RST  28H
1b8c			DEFW GET_CHAR     ; $0018. Get current character.
1b8e			CP   $3B          ; Is it a ';'?
1b90			JR   Z,L1B96      ; Jump if it is.
1b92
1b92			CP   ','          ; $2C. Is it a ','?
1b94			JR   NZ,L1B9E     ; Jump if it is not.
1b96
1b96	L1B96:  RST  28H          ;
1b97			DEFW NEXT_CHAR    ; $0020. Get the next character.
1b99			CALL L190E        ; Indirectly call EXPT-1NUM in ROM 1 to check that
1b9c			; a numeric expression follows, e.g. LIST #5,20.
1b9c			JR   L1BA6        ; Jump forward with it.
1b9e
1b9e	L1B9E:  RST  28H          ;
1b9f			DEFW USE_ZERO     ; $1CE6. Otherwise use zero and
1ba1			JR   L1BA6        ; jump forward.
1ba3
1ba3			;Come here if the stream was unaltered.
1ba3
1ba3	L1BA3:  RST  28H          ;
1ba4			DEFW FETCH_NUM    ; $1CDE. Fetch any line or use zero if none supplied.
1ba6
1ba6	L1BA6:  CALL L18A1        ; If checking the syntax of the edit-line move on to the next statement.
1ba9			RST  28H          ;
1baa			DEFW LIST_5+3     ; $1825. Delegate handling to ROM 1.
1bac			RET
1bad
1bad			; ----------------------
1bad			; RAM Disk SAVE! Routine
1bad			; ----------------------
1bad
1bad	L1BAD:  LD   (OLDSP),SP   ; $5B81. Save SP.
1bb1			LD   SP,TSTACK    ; $5BFF. Use temporary stack.
1bb4
1bb4			CALL L1C97        ; Create new catalogue entry.
1bb7
1bb7			LD   BC,(HD_0B)   ; $5B72. get the length of the file.
1bbb			LD   HL,$FFF7     ; -9 (9 is the length of the file header).
1bbe			OR   $FF          ; Extend the negative number into the high byte.
1bc0			SBC  HL,BC        ; AHL=-(length of file + 9).
1bc2			CALL L1CF3        ; Check for space in RAM disk (produce "4 Out of memory" if no room).
1bc5
1bc5			LD   BC,$0009     ; File header length.
1bc8			LD   HL,HD_00     ; $5B71. Address of file header.
1bcb			CALL L1DAC        ; Store file header to RAM disk.
1bce
1bce			LD   HL,(HD_0D)   ; $5B74. Start address of file data.
1bd1			LD   BC,(HD_0B)   ; $5B72. Length of file data.
1bd5			CALL L1DAC        ; Store bytes to RAM disk.
1bd8			CALL L1D56        ; Update catalogue entry (leaves logical RAM bank 4 paged in).
1bdb
1bdb			LD   A,$05        ; Page in logical RAM bank 5 (physical RAM bank 0).
1bdd			CALL L1C64        ;
1be0
1be0			LD   SP,(OLDSP)   ; $5B81. Use original stack.
1be4			RET               ;
1be5
1be5			; ------------
1be5			; CAT! Routine
1be5			; ------------
1be5
1be5	L1BE5:  RST  28H          ; Get the current character.
1be6			DEFW GET_CHAR     ; $0018. [Could just do RST $18 here]
1be8			CP   '!'          ; $21. Is it '!'?
1bea			JP   NZ,L1912     ; Jump to "C Nonsense in BASIC" if not.
1bed
1bed			RST  28H          ; Get the next character.
1bee			DEFW NEXT_CHAR    ; $0020. [Could just do RST $20 here]
1bf0			CALL L18A1        ; Check for end of statement.
1bf3
1bf3			LD   A,$02        ; Select main screen.
1bf5			RST  28H          ;
1bf6			DEFW CHAN_OPEN    ; $1601.
1bf8
1bf8			LD   (OLDSP),SP   ; $5B81. Store SP.
1bfc			LD   SP,TSTACK    ; $5BFF. Use temporary stack.
1bff
1bff			CALL L20D2        ; Print out the catalogue.
1c02
1c02			LD   A,$05        ; Page in logical RAM bank 5 (physical RAM bank 0).
1c04			CALL L1C64        ;
1c07
1c07			LD   SP,(OLDSP)   ; $5B81. Use original stack.
1c0b			RET               ;
1c0c
1c0c			; --------------
1c0c			; ERASE! Routine
1c0c			; --------------
1c0c
1c0c	L1C0C:  RST  28H          ; Get character from BASIC line.
1c0d			DEFW GET_CHAR     ; $0018.
1c0f			CP   '!'          ; $21. Is it '!'?
1c11			JP   NZ,L1912     ; Jump to "C Nonsense in BASIC" if not.
1c14
1c14			CALL L1393        ; Get the filename into N_STR1.
1c17			CALL L18A1        ; Make sure we've reached the end of the BASIC statement.
1c1a
1c1a			LD   (OLDSP),SP   ; $5B81. Store SP.
1c1e			LD   SP,TSTACK    ; $5BFF. Use temporary stack.
1c21
1c21			CALL L1F5F        ; Do the actual erasing (leaves logical RAM bank 4 paged in).
1c24
1c24			LD   A,$05        ; Restore RAM configuration.
1c26			CALL L1C64        ; Page in logical RAM bank 5 (physical RAM bank 0).
1c29
1c29			LD   SP,(OLDSP)   ; $5B81. Use original stack.
1c2d			RET               ;
1c2e
1c2e
1c2e			; ==================================
1c2e			; RAM DISK COMMAND ROUTINES - PART 2
1c2e			; ==================================
1c2e
1c2e			; -------------------------
1c2e			; Load Header from RAM Disk
1c2e			; -------------------------
1c2e
1c2e	L1C2E:  LD   (OLDSP),SP   ; $5B81. Store SP.
1c32			LD   SP,TSTACK    ; $5BFF. Use temporary stack.
1c35
1c35			CALL L1D35        ; Find file (return details pointed to by IX). Leaves logical RAM bank 4 paged in.
1c38
1c38			;The file exists else the call above would have produced an error "h file does not exist"
1c38
1c38			LD   HL,HD_00     ; $5B71. Load 9 header bytes.
1c3b			LD   BC,$0009     ;
1c3e			CALL L1E37        ; Load bytes from RAM disk.
1c41
1c41			LD   A,$05        ; Restore RAM configuration.
1c43			CALL L1C64        ; Page in logical RAM bank 5 (physical RAM bank 0).
1c46
1c46			LD   SP,(OLDSP)   ; $5B81. Use original stack.
1c4a			RET               ;
1c4b
1c4b			; ------------------
1c4b			; Load from RAM Disk
1c4b			; ------------------
1c4b			; Used by LOAD, VERIFY and MERGE. Note that VERIFY will simply perform a LOAD.
1c4b			; Entry: HL=Destination address.
1c4b			;        DE=Length (will be greater than zero).
1c4b			;        IX=File descriptor.
1c4b			;        IX=Address of catalogue entry (IX+$10-IX+$12 points to the address of the file's data, past its header).
1c4b			;        HD_00-HD_11 holds file header information.
1c4b
1c4b	L1C4B:  LD   (OLDSP),SP   ; $5B81. Store SP
1c4f			LD   SP,TSTACK    ; $5BFF. Use temporary stack.
1c52
1c52			LD   B,D          ;
1c53			LD   C,E          ; BC=Length.
1c54			CALL L1E37        ; Load bytes from RAM disk.
1c57			CALL L1D56        ; Update catalogue entry (leaves logical RAM bank 4 paged in).
1c5a
1c5a			LD   A,$05        ; Restore RAM configuration.
1c5c			CALL L1C64        ; Page in logical RAM bank 5 (physical RAM bank 0).
1c5f
1c5f			LD   SP,(OLDSP)   ; $5B81. Use original stack.
1c63			RET               ;
1c64
1c64
1c64			; ========================
1c64			; PAGING ROUTINES - PART 1
1c64			; ========================
1c64
1c64			; ---------------------
1c64			; Page Logical RAM Bank
1c64			; ---------------------
1c64			; This routine converts between logical and physical RAM banks and pages the
1c64			; selected bank in.
1c64			; Entry: A=Logical RAM bank.
1c64
1c64	L1C64:  PUSH HL           ; Save BC and HL.
1c65			PUSH BC           ;
1c66
1c66			LD   HL,L1C81     ; Physical banks used by RAM disk.
1c69			LD   B,$00        ;
1c6b			LD   C,A          ; BC=Logical RAM bank.
1c6c			ADD  HL,BC        ; Point to table entry.
1c6d			LD   C,(HL)       ; Look up physical page.
1c6e
1c6e			DI                ; Disable interrupts whilst paging.
1c6f			LD   A,(BANK_M)   ; $5B5C. Fetch the current configuration.
1c72			AND  $F8          ; Mask off current RAM bank.
1c74			OR   C            ; Include new RAM bank.
1c75			LD   (BANK_M),A   ; $5B5C. Store the new configuration.
1c78			LD   BC,$7FFD     ;
1c7b			OUT  (C),A        ; Perform the page.
1c7d			EI                ; Re-enable interrupts.
1c7e
1c7e			POP  BC           ; Restore BC and HL.
1c7f			POP  HL           ;
1c80			RET               ;
1c81
1c81			; -------------------------------
1c81			; Physical RAM Bank Mapping Table
1c81			; -------------------------------
1c81
1c81	L1C81:  DEFB $01          ; Logical bank $00.
1c82			DEFB $03          ; Logical bank $01.
1c83			DEFB $04          ; Logical bank $02.
1c84			DEFB $06          ; Logical bank $03.
1c85			DEFB $07          ; Logical bank $04.
1c86			DEFB $00          ; Logical bank $05.
1c87
1c87
1c87			; ==================================
1c87			; RAM DISK COMMAND ROUTINES - PART 3
1c87			; ==================================
1c87
1c87			; -----------------
1c87			; Compare Filenames
1c87			; -----------------
1c87			; Compare filenames at N_STR1 and IX.
1c87			; Exit: Zero flag set if filenames match.
1c87			;       Carry flag set if filename at DE is alphabetically lower than filename at IX.
1c87
1c87	L1C87:  LD   DE,N_STR1    ; $5B67.
1c8a
1c8a			; Compare filenames at DE and IX
1c8a
1c8a	L1C8A:  PUSH IX           ;
1c8c			POP  HL           ;
1c8d			LD   B,$0A        ; Maximum of 10 characters.
1c8f
1c8f	L1C8F:  LD   A,(DE)       ;
1c90			INC  DE           ;
1c91			CP   (HL)         ; compare each character.
1c92			INC  HL           ;
1c93			RET  NZ           ; Return if characters are different.
1c94
1c94			DJNZ L1C8F        ; Repeat for all characters of the filename.
1c96
1c96			RET               ;
1c97
1c97			; --------------------------
1c97			; Create New Catalogue Entry
1c97			; --------------------------
1c97			; Add a catalogue entry with filename contained in N_STR1.
1c97			; Exit: HL=Address of next free catalogue entry.
1c97			;       IX=Address of newly created catalogue entry.
1c97
1c97	L1C97:  CALL L1D12        ; Find entry in RAM disk area, returning IX pointing to catalogue entry (leaves logical RAM bank 4 paged in).
1c9a			JR   Z,L1CA0      ; Jump ahead if does not exist.
1c9c
1c9c			CALL L05AC        ; Produce error report.
1c9f			DEFB $20          ; "e File already exists"
1ca0
1ca0	L1CA0:  PUSH IX           ;
1ca2			LD   BC,$3FEC     ; 16384-20 (maximum size of RAM disk catalogue).
1ca5			ADD  IX,BC        ; IX grows downwards as new RAM disk catalogue entries added.
1ca7			; If adding the maximum size to IX does not result in the carry flag being set
1ca7			; then the catalogue is full, so issue an error report "4 Out of Memory".
1ca7			POP  IX           ;
1ca9			JR   NC,L1D0E     ; Jump if out of memory.
1cab
1cab			LD   HL,$FFEC     ; -20 (20 bytes is the size of a RAM disk catalogue entry).
1cae			LD   A,$FF        ; Extend the negative number into the high byte.
1cb0			CALL L1CF3        ; Ensure space in RAM disk area.
1cb3			LD   HL,FLAGS3    ; $5B66.
1cb6			SET  2,(HL)       ; Signal editing RAM disk catalogue.
1cb8			PUSH IX           ;
1cba			POP  DE           ; DE=Address of new catalogue entry.
1cbb			LD   HL,N_STR1    ; $5B67. Filename.
1cbe
1cbe	L1CBE:  LD   BC,$000A     ; 10 characters in the filename.
1cc1			LDIR              ; Copy the filename.
1cc3
1cc3			SET  0,(IX+$13)   ; Indicate catalogue entry requires updating.
1cc7
1cc7			LD   A,(IX+$0A)   ; Set the file access address to be the
1cca			LD   (IX+$10),A   ; start address of the file.
1ccd			LD   A,(IX+$0B)   ;
1cd0			LD   (IX+$11),A   ;
1cd3			LD   A,(IX+$0C)   ;
1cd6			LD   (IX+$12),A   ;
1cd9
1cd9			XOR  A            ; Set the fill length to zero.
1cda			LD   (IX+$0D),A   ;
1cdd			LD   (IX+$0E),A   ;
1ce0			LD   (IX+$0F),A   ;
1ce3
1ce3			LD   A,$05        ;
1ce5			CALL L1C64        ; Logical RAM bank 5 (physical RAM bank 0).
1ce8
1ce8			PUSH IX           ;
1cea			POP  HL           ; HL=Address of new catalogue entry.
1ceb			LD   BC,$FFEC     ; -20 (20 bytes is the size of a catalogue entry).
1cee			ADD  HL,BC        ;
1cef			LD   (SFNEXT),HL  ; $5B83. Store address of next free catalogue entry.
1cf2			RET               ;
1cf3
1cf3			; --------------------------
1cf3			; Adjust RAM Disk Free Space
1cf3			; --------------------------
1cf3			; Adjust the count of free bytes within the RAM disk.
1cf3			; The routine can produce "4 Out of memory" when adding.
1cf3			; Entry: AHL=Size adjustment (negative when a file added, positive when a file deleted).
1cf3			;        A=Bit 7 set for adding data, else deleting data.
1cf3
1cf3	L1CF3:  LD   DE,(SFSPACE) ; $5B85.
1cf7			EX   AF,AF'       ; A'HL=Requested space.
1cf8
1cf8			LD   A,(SFSPACE+2) ; $5B87. ADE=Free space on RAM disk.
1cfb			LD   C,A          ; CDE=Free space.
1cfc
1cfc			EX   AF,AF'       ; AHL=Requested space.
1cfd			BIT  7,A          ; A negative adjustment, i.e. adding data?
1cff			JR   NZ,L1D0A     ; Jump ahead if so.
1d01
1d01			;Deleting data
1d01
1d01			ADD  HL,DE        ;
1d02			ADC  A,C          ; AHL=Free space left.
1d03
1d03	L1D03:  LD   (SFSPACE),HL ; $5B85. Store free space.
1d06			LD   (SFSPACE+2),A ; $5B87.
1d09			RET               ;
1d0a
1d0a			;Adding data
1d0a
1d0a	L1D0A:  ADD  HL,DE        ;
1d0b			ADC  A,C          ;
1d0c			JR   C,L1D03      ; Jump back to store free space if space left.
1d0e
1d0e	L1D0E:  CALL L05AC        ; Produce error report.
1d11			DEFB 03           ; "4 Out of memory"
1d12
1d12			; ---------------------------------
1d12			; Find Catalogue Entry for Filename
1d12			; ---------------------------------
1d12			; Entry: Filename stored at N_STR1 ($5B67).
1d12			; Exit : Zero flag set if file does not exist.
1d12			;        If file exists, IX points to catalogue entry.
1d12			;        Always leaves logical RAM bank 4 paged in.
1d12
1d12	L1D12:  LD   A,$04        ; Page in logical RAM bank 4 (physical RAM bank 7).
1d14			CALL L1C64        ;
1d17
1d17			LD   IX,$EBEC     ; Point to first catalogue entry.
1d1b
1d1b	L1D1B:  LD   DE,(SFNEXT)  ; $5B83. Pointer to last catalogue entry.
1d1f			OR   A            ; Clear carry flag.
1d20			PUSH IX           ;
1d22			POP  HL           ; HL=First catalogue entry.
1d23			SBC  HL,DE        ;
1d25			RET  Z            ; Return with zero flag set if end of catalogue reached
1d26			; and hence filename not found.
1d26
1d26			CALL L1C87        ; Test filename match with N_STR1 ($5B67).
1d29			JR   NZ,L1D2E     ; Jump ahead if names did not match.
1d2b
1d2b			OR   $FF          ; Reset zero flag to indicate filename exists.
1d2d			RET               ;
1d2e
1d2e	L1D2E:  LD   BC,$FFEC     ; -20 bytes (20 bytes is the size of a catalogue entry).
1d31			ADD  IX,BC        ; Point to the next directory entry.
1d33			JR   L1D1B        ; Test the next name.
1d35
1d35			; ------------------
1d35			; Find RAM Disk File
1d35			; ------------------
1d35			; Find a file in the RAM disk matching name held in N_STR1,
1d35			; and return with IX pointing to the catalogue entry.
1d35
1d35	L1D35:  CALL L1D12        ; Find entry in RAM disk area, returning IX pointing to catalogue entry (leaves logical RAM bank 4 paged in).
1d38			JR   NZ,L1D3E     ; Jump ahead if it exists.
1d3a
1d3a			CALL L05AC        ; Produce error report.
1d3d			DEFB $23          ; "h File does not exist"
1d3e
1d3e	L1D3E:  LD   A,(IX+$0A)   ; Take the current start address (bank + location)
1d41			LD   (IX+$10),A   ; and store it as the current working address.
1d44			LD   A,(IX+$0B)   ;
1d47			LD   (IX+$11),A   ;
1d4a			LD   A,(IX+$0C)   ;
1d4d			LD   (IX+$12),A   ;
1d50
1d50			LD   A,$05        ; Page in logical RAM bank 5 (physical RAM bank 0).
1d52			CALL L1C64        ;
1d55			RET               ; [Could have saved 1 byte by using JP $1C64 (ROM 0)]
1d56
1d56			; ----------------------
1d56			; Update Catalogue Entry
1d56			; ----------------------
1d56			; Entry: IX=Address of catalogue entry (IX+$10-IX+$12 points to end of the file).
1d56			; Exits with logical RAM bank 4 paged in.
1d56
1d56	L1D56:  LD   A,$04        ; Page in logical RAM bank 4 (physical RAM bank 7).
1d58			CALL L1C64        ;
1d5b
1d5b			BIT  0,(IX+$13)   ;
1d5f			RET  Z            ; Ignore if catalogue entry does not require updating.
1d60
1d60			RES  0,(IX+$13)   ; Indicate catalogue entry updated.
1d64
1d64			LD   HL,FLAGS3    ; $5B66.
1d67			RES  2,(HL)       ; Signal not editing RAM disk catalogue.
1d69
1d69			LD   L,(IX+$10)   ; Points to end address within logical RAM bank.
1d6c			LD   H,(IX+$11)   ;
1d6f			LD   A,(IX+$12)   ; Points to end logical RAM bank.
1d72
1d72			LD   E,(IX+$0A)   ; Start address within logical RAM bank.
1d75			LD   D,(IX+$0B)   ;
1d78			LD   B,(IX+$0C)   ; Start logical RAM bank.
1d7b			OR   A            ; Clear carry flag.
1d7c			SBC  HL,DE        ; HL=End address-Start address. Maximum difference fits within 14 bits.
1d7e
1d7e			SBC  A,B          ; A=End logical RAM bank-Start logical RAM bank - 1 if addresses overlap.
1d7f			RL   H            ;
1d81			RL   H            ; Work out how many full banks of 16K are being used.
1d83			SRA  A            ; Place this in the upper two bits of H.
1d85			RR   H            ;
1d87			SRA  A            ;
1d89			RR   H            ; HL=Total length.
1d8b
1d8b			LD   (IX+$0D),L   ; Length within logical RAM bank.
1d8e			LD   (IX+$0E),H   ;
1d91			LD   (IX+$0F),A   ;
1d94
1d94			;Copy the end address of the previous entry into the new entry
1d94
1d94			LD   L,(IX+$10)   ; End address within logical RAM bank.
1d97			LD   H,(IX+$11)   ;
1d9a			LD   A,(IX+$12)   ; End logical RAM bank.
1d9d			LD   BC,$FFEC     ; -20 bytes (20 bytes is the size of a catalogue entry).
1da0			ADD  IX,BC        ; Address of next catalogue entry.
1da2			LD   (IX+$0A),L   ; Start address within logical RAM bank.
1da5			LD   (IX+$0B),H   ;
1da8			LD   (IX+$0C),A   ; Start logical RAM bank.
1dab			RET               ;
1dac
1dac			; ----------------------
1dac			; Save Bytes to RAM Disk
1dac			; ----------------------
1dac			; Entry: IX=Address of catalogue entry.
1dac			;        HL=Source address in conventional RAM.
1dac			;        BC=Length.
1dac			; Advances IX+$10-IX+$12 as bytes are saved so that always points to next location to fill,
1dac			; eventually pointing to the end of the file.
1dac
1dac	L1DAC:  LD   A,B          ; Check whether a data length of zero was requested.
1dad			OR   C            ;
1dae			RET  Z            ; Ignore if so since all bytes already saved.
1daf
1daf			PUSH HL           ; Save the source address.
1db0			LD   DE,$C000     ; DE=The start of the upper RAM bank.
1db3			EX   DE,HL        ; HL=The start of the RAM bank. DE=Source address.
1db4			SBC  HL,DE        ; HL=RAM bank start - Source address.
1db6			JR   Z,L1DD5      ; Jump ahead if saving bytes from $C000.
1db8
1db8			JR   C,L1DD5      ; Jump ahead if saving bytes from an address above $C000.
1dba
1dba			;Source is below $C000
1dba
1dba			PUSH HL           ; HL=Distance below $C000 (RAM bank start - Source address).
1dbb			SBC  HL,BC        ;
1dbd			JR   NC,L1DCC     ; Jump if requested bytes are all below $C000.
1dbf
1dbf			;Source spans across $C000
1dbf
1dbf			LD   H,B          ;
1dc0			LD   L,C          ; HL=Requested length.
1dc1			POP  BC           ; BC=Distance below $C000.
1dc2			OR   A            ;
1dc3			SBC  HL,BC        ; HL=Bytes occupying upper RAM bank.
1dc5			EX   (SP),HL      ; Stack it. HL=Source address.
1dc6			LD   DE,$C000     ; Start of upper RAM bank.
1dc9			PUSH DE           ;
1dca			JR   L1DF4        ; Jump forward.
1dcc
1dcc			;Source fits completely below upper RAM bank (less than $C000)
1dcc
1dcc	L1DCC:  POP  HL           ; Forget the 'distance below $C000' count.
1dcd			POP  HL           ; HL=Source address.
1dce			LD   DE,$0000     ; Remaining bytes to transfer.
1dd1			PUSH DE           ;
1dd2			PUSH DE           ; Stack dummy Start of upper RAM bank.
1dd3			JR   L1DF4        ; Jump forward.
1dd5
1dd5			;Source fits completely within upper RAM bank (greater than or equal $C000)
1dd5
1dd5	L1DD5:  LD   H,B          ;
1dd6			LD   L,C          ; HL=Requested length.
1dd7			LD   DE,$0020     ; DE=Length of buffer.
1dda			OR   A            ;
1ddb			SBC  HL,DE        ; HL=Requested length-Length of buffer = Buffer overspill.
1ddd			JR   C,L1DE4      ; Jump if requested length will fit within the buffer.
1ddf
1ddf			;Source spans transfer buffer
1ddf
1ddf			EX   (SP),HL      ; Stack buffer overspill. HL=$0000.
1de0			LD   B,D          ;
1de1			LD   C,E          ; BC=Buffer length.
1de2			JR   L1DE9        ; Jump forward.
1de4
1de4			;Source fits completely within transfer buffer
1de4
1de4	L1DE4:  POP  HL           ; HL=Destination address.
1de5			LD   DE,$0000     ; Remaining bytes to transfer.
1de8			PUSH DE           ; Stack 'transfer buffer in use' flag.
1de9
1de9			;Transfer a block
1de9
1de9	L1DE9:  PUSH BC           ; Stack the length.
1dea			LD   DE,STRIP1    ; $5B98. Transfer buffer.
1ded			LDIR              ; Transfer bytes.
1def			POP  BC           ; BC=Length.
1df0			PUSH HL           ; HL=New source address.
1df1			LD   HL,STRIP1    ; $5B98. Transfer buffer.
1df4
1df4	L1DF4:  LD   A,$04        ; Page in logical RAM bank 4 (physical RAM bank 7).
1df6			CALL L1C64        ;
1df9
1df9			LD   E,(IX+$10)   ;
1dfc			LD   D,(IX+$11)   ; Fetch the address from the current logical RAM bank.
1dff			LD   A,(IX+$12)   ; Logical RAM bank.
1e02			CALL L1C64        ; Page in appropriate logical RAM bank.
1e05
1e05	L1E05:  LDI               ; Transfer a byte from the file to the required RAM disk location or transfer buffer.
1e07			LD   A,D          ;
1e08			OR   E            ; Has DE been incremented to $0000?
1e09			JR   Z,L1E24      ; Jump if end of RAM bank reached.
1e0b
1e0b	L1E0B:  LD   A,B          ;
1e0c			OR   C            ;
1e0d			JP   NZ,L1E05     ; Repeat until all bytes transferred.
1e10
1e10			LD   A,$04        ; Page in logical RAM bank 4 (physical RAM bank 7).
1e12			CALL L1C64        ;
1e15
1e15			LD   (IX+$10),E   ;
1e18			LD   (IX+$11),D   ; Store the next RAM bank source address.
1e1b
1e1b			LD   A,$05        ; Page in logical RAM bank 5 (physical RAM bank 0).
1e1d			CALL L1C64        ;
1e20
1e20			POP  HL           ; HL=Source address.
1e21			POP  BC           ; BC=Length.
1e22			JR   L1DAC        ; Re-enter this routine to transfer another block.
1e24
1e24			;The end of a RAM bank has been reached so switch to the next bank
1e24
1e24	L1E24:  LD   A,$04        ; Page in logical RAM bank 4 (physical RAM bank 7).
1e26			CALL L1C64        ;
1e29
1e29			INC  (IX+$12)     ; Increment to the new logical RAM bank.
1e2c			LD   A,(IX+$12)   ; Fetch the new logical RAM bank.
1e2f			LD   DE,$C000     ; The start of the RAM disk
1e32			CALL L1C64        ; Page in next RAM bank.
1e35			JR   L1E0B        ; Jump back to transfer another block.
1e37
1e37			; ------------------------
1e37			; Load Bytes from RAM Disk
1e37			; ------------------------
1e37			; Used for loading file header and data.
1e37			; Entry: IX=RAM disk catalogue entry address. IX+$10-IX+$12 points to the next address to fetch from the file.
1e37			;        HL=Destination address.
1e37			;        BC=Requested length.
1e37
1e37	L1E37:  LD   A,B          ; Check whether a data length of zero was requested.
1e38			OR   C            ;
1e39			RET  Z            ; Ignore if so since all bytes already loaded.
1e3a
1e3a			PUSH HL           ; Save the destination address.
1e3b			LD   DE,$C000     ; DE=The start of the upper RAM bank.
1e3e			EX   DE,HL        ; HL=The start of the RAM bank. DE=Destination address.
1e3f			SBC  HL,DE        ; HL=RAM bank start - Destination address.
1e41			JR   Z,L1E67      ; Jump if destination is $C000.
1e43			JR   C,L1E67      ; Jump if destination is above $C000.
1e45
1e45			;Destination is below $C000
1e45
1e45	L1E45:  PUSH HL           ; HL=Distance below $C000 (RAM bank start - Destination address).
1e46			SBC  HL,BC        ;
1e48			JR   NC,L1E5C     ; Jump if requested bytes all fit below $C000.
1e4a
1e4a			;Code will span across $C000
1e4a
1e4a			LD   H,B          ;
1e4b			LD   L,C          ; HL=Requested length.
1e4c			POP  BC           ; BC=Distance below $C000.
1e4d			OR   A            ;
1e4e			SBC  HL,BC        ; HL=Bytes destined for upper RAM bank.
1e50			EX   (SP),HL      ; Stack it. HL=Destination address.
1e51			LD   DE,$0000     ; Remaining bytes to transfer.
1e54			PUSH DE           ;
1e55			LD   DE,$C000     ; Start of upper RAM bank.
1e58			PUSH DE           ;
1e59			EX   DE,HL        ; HL=Start of upper RAM bank.
1e5a			JR   L1E80        ; Jump forward.
1e5c
1e5c			;Code fits completely below upper RAM bank (less than $C000)
1e5c
1e5c	L1E5C:  POP  HL           ; Forget the 'distance below $C000' count.
1e5d			POP  HL           ; HL=Destination address.
1e5e			LD   DE,$0000     ; Remaining bytes to transfer.
1e61			PUSH DE           ;
1e62			PUSH DE           ; Stack dummy Start of upper RAM bank.
1e63			PUSH DE           ;
1e64			EX   DE,HL        ; HL=$0000, DE=Destination address.
1e65			JR   L1E80        ; Jump forward.
1e67
1e67			;Code destined for upper RAM bank (greater than or equal to $C000)
1e67
1e67	L1E67:  LD   H,B          ;
1e68			LD   L,C          ; HL=Requested length.
1e69			LD   DE,$0020     ; DE=Length of buffer.
1e6c			OR   A            ;
1e6d			SBC  HL,DE        ; HL=Requested length-Length of buffer = Buffer overspill.
1e6f			JR   C,L1E76      ; Jump if requested length will fit within the buffer.
1e71
1e71			;Code will span transfer buffer
1e71
1e71			EX   (SP),HL      ; Stack buffer overspill. HL=$0000.
1e72			LD   B,D          ;
1e73			LD   C,E          ; BC=Buffer length.
1e74			JR   L1E7B        ; Jump forward.
1e76
1e76			;Code will all fit within transfer buffer
1e76
1e76	L1E76:  POP  HL           ; HL=Destination address.
1e77			LD   DE,$0000     ; Remaining bytes to transfer.
1e7a			PUSH DE           ; Stack 'transfer buffer in use' flag.
1e7b
1e7b	L1E7B:  PUSH BC           ; Stack the length.
1e7c			PUSH HL           ; Stack destination address.
1e7d			LD   DE,STRIP1    ; $5B98. Transfer buffer.
1e80
1e80			;Transfer a block
1e80
1e80	L1E80:  LD   A,$04        ; Page in logical RAM bank 4 (physical RAM bank 7).
1e82			CALL L1C64        ;
1e85
1e85			LD   L,(IX+$10)   ; RAM bank address.
1e88			LD   H,(IX+$11)   ;
1e8b			LD   A,(IX+$12)   ; Logical RAM bank.
1e8e			CALL L1C64        ; Page in appropriate logical RAM bank.
1e91
1e91			;Enter a loop to transfer BC bytes, either to required destination or to the transfer buffer
1e91
1e91	L1E91:  LDI               ; Transfer a byte from the file to the required location or transfer buffer.
1e93			LD   A,H          ;
1e94			OR   L            ; Has HL been incremented to $0000?
1e95			JR   Z,L1EBC      ; Jump if end of RAM bank reached.
1e97
1e97	L1E97:  LD   A,B          ;
1e98			OR   C            ;
1e99			JP   NZ,L1E91     ; Repeat until all bytes transferred.
1e9c
1e9c			LD   A,$04        ; Page in logical RAM bank 4 (physical RAM bank 7).
1e9e			CALL L1C64        ;
1ea1
1ea1			LD   (IX+$10),L   ;
1ea4			LD   (IX+$11),H   ; Store the next RAM bank destination address.
1ea7
1ea7			LD   A,$05        ; Page in logical RAM bank 5 (physical RAM bank 0).
1ea9			CALL L1C64        ;
1eac
1eac			POP  DE           ; DE=Destination address.
1ead			POP  BC           ; BC=Length.
1eae
1eae			LD   HL,STRIP1    ; $5B98. Transfer buffer.
1eb1			LD   A,B          ;
1eb2			OR   C            ; All bytes transferred?
1eb3			JR   Z,L1EB7      ; Jump forward if so.
1eb5
1eb5			LDIR              ; Transfer code in buffer to the required address.
1eb7
1eb7	L1EB7:  EX   DE,HL        ; HL=New destination address.
1eb8			POP  BC           ; BC=Remaining bytes to transfer.
1eb9			JP   L1E37        ; Re-enter this routine to transfer another block.
1ebc
1ebc			;The end of a RAM bank has been reached so switch to the next bank
1ebc
1ebc	L1EBC:  LD   A,$04        ; Page in logical RAM bank 4 (physical RAM bank 7).
1ebe			CALL L1C64        ;
1ec1
1ec1			INC  (IX+$12)     ; Increment to the new logical RAM bank.
1ec4			LD   A,(IX+$12)   ; Fetch the new logical RAM bank.
1ec7			LD   HL,$C000     ; The start of the RAM disk.
1eca			CALL L1C64        ; Page in next logical RAM bank.
1ecd			JR   L1E97        ; Jump back to transfer another block.
1ecf
1ecf			; -------------------------------------------------
1ecf			; Transfer Bytes to RAM Bank 4 - Vector Table Entry
1ecf			; -------------------------------------------------
1ecf			; This routine can be used to transfer bytes from the current RAM bank into logical RAM bank 4.
1ecf			; It is not used in this ROM and is a remnant of the original Spanish Spectrum 128 ROM 0.
1ecf			; Entry: HL=Source address in conventional RAM.
1ecf			;        DE=Destination address in logical RAM bank 4 (physical RAM bank 7).
1ecf			;        BC=Number of bytes to save.
1ecf
1ecf	L1ECF:  PUSH AF           ; Save AF.
1ed0
1ed0			LD   A,(BANK_M)   ; $5B5C. Fetch current physical RAM bank configuration.
1ed3			PUSH AF           ; Save it.
1ed4			PUSH HL           ; Save source address.
1ed5			PUSH DE           ; Save destination address.
1ed6			PUSH BC           ; Save length.
1ed7
1ed7			LD   IX,N_STR1+3  ; $5B6A.
1edb
1edb			LD   (IX+$10),E   ; Store destination address as the current address pointer.
1ede			LD   (IX+$11),D   ;
1ee1			LD   (IX+$12),$04 ; Destination is in logical RAM bank 4 (physical RAM bank 7).
1ee5
1ee5			CALL L1DAC        ; Store bytes to RAM disk.
1ee8
1ee8			;Entered here by load vector routine
1ee8
1ee8	L1EE8:  LD   A,$05        ; Page in logical RAM bank 5 (physical RAM bank 0).
1eea			CALL L1C64        ;
1eed
1eed			POP  BC           ; Get length.
1eee			POP  DE           ; Get destination address.
1eef			POP  HL           ; Get source address.
1ef0
1ef0			ADD  HL,BC        ; HL=Address after end of source.
1ef1			EX   DE,HL        ; DE=Address after end of source. HL=Destination address.
1ef2			ADD  HL,BC        ; HL=Address after end of destination.
1ef3			EX   DE,HL        ; HL=Address after end of source. DE=Address after end of destination.
1ef4
1ef4			POP  AF           ; Get original RAM bank configuration.
1ef5			LD   BC,$7FFD     ;
1ef8			DI                ; Disable interrupts whilst paging.
1ef9			OUT  (C),A        ;
1efb			LD   (BANK_M),A   ; $5B5C.
1efe			EI                ; Re-enable interrupts.
1eff
1eff			LD   BC,$0000     ; Signal all bytes loaded/saved.
1f02			POP  AF           ; Restore AF.
1f03			RET               ;
1f04
1f04			; ---------------------------------------------------
1f04			; Transfer Bytes from RAM Bank 4 - Vector Table Entry
1f04			; ---------------------------------------------------
1f04			; This routine can be used to transfer bytes from logical RAM bank 4 into the current RAM bank.
1f04			; It is not used in this ROM and is a remnant of the original Spanish Spectrum 128 ROM 0.
1f04			; Entry: HL=Source address in logical RAM bank 4 (physical RAM bank 7).
1f04			;        DE=Destination address in current RAM bank.
1f04			;        BC=Number of bytes to load.
1f04
1f04	L1F04:  PUSH AF           ; Save AF.
1f05
1f05			LD   A,(BANK_M)   ; $5B5C. Fetch current physical RAM bank configuration.
1f08			PUSH AF           ; Save it.
1f09			PUSH HL           ; Save source address.
1f0a			PUSH DE           ; Save destination address.
1f0b			PUSH BC           ; Save length.
1f0c
1f0c			LD   IX,N_STR1+3  ; $5B6A.
1f10
1f10			LD   (IX+$10),L   ; Store source address as the current address pointer.
1f13			LD   (IX+$11),H   ;
1f16			LD   (IX+$12),$04 ; Source is in logical RAM bank 4 (physical RAM bank 7).
1f1a
1f1a			EX   DE,HL        ; HL=Destination address.
1f1b			CALL L1E37        ; Load bytes from RAM disk.
1f1e			JR   L1EE8        ; Join the save vector routine above.
1f20
1f20
1f20			; ========================
1f20			; PAGING ROUTINES - PART 2
1f20			; ========================
1f20
1f20			; ----------------------------
1f20			; Use Normal RAM Configuration
1f20			; ----------------------------
1f20			; Page in physical RAM bank 0, use normal stack and stack TARGET address.
1f20			; Entry: HL=TARGET address.
1f20
1f20	L1F20:  EX   AF,AF'       ; Save AF.
1f21
1f21			LD   A,$00        ; Physical RAM bank 0.
1f23			DI                ; Disable interrupts whilst paging.
1f24			CALL L1F3A        ; Page in physical RAM bank 0.
1f27			POP  AF           ; AF=Address on stack when CALLed.
1f28			LD   (TARGET),HL  ; $5B58. Store HL.
1f2b			LD   HL,(OLDSP)   ; $5B81. Fetch the old stack.
1f2e			LD   (OLDSP),SP   ; $5B81. Save the current stack.
1f32			LD   SP,HL        ; Use the old stack.
1f33			EI                ; Re-enable interrupts.
1f34			LD   HL,(TARGET)  ; $5B58. Restore HL.
1f37			PUSH AF           ; Re-stack the return address.
1f38
1f38			EX   AF,AF'       ; Get AF back.
1f39			RET               ;
1f3a
1f3a			; ---------------
1f3a			; Select RAM Bank
1f3a			; ---------------
1f3a			; Used twice by the ROM to select either physical RAM bank 0 or physical RAM bank 7.
1f3a			; However, it could in theory also be used to set other paging settings.
1f3a			; Entry: A=RAM bank number.
1f3a
1f3a	L1F3A:  PUSH BC           ; Save BC
1f3b			LD   BC,$7FFD     ;
1f3e			OUT  (C),A        ; Perform requested paging.
1f40			LD   (BANK_M),A   ; $5B5C.
1f43			POP  BC           ; Restore BC.
1f44			RET               ;
1f45
1f45			; -------------------------------
1f45			; Use Workspace RAM Configuration
1f45			; -------------------------------
1f45			; Page in physical RAM bank 7, use workspace stack and stack TARGET address.
1f45			; Entry: HL=TARGET address.
1f45
1f45	L1F45:  EX   AF,AF'       ; Save A.
1f46
1f46			DI                ; Disable interrupts whilst paging.
1f47
1f47			POP  AF           ; Fetch return address.
1f48			LD   (TARGET),HL  ; $5B58. Store HL.
1f4b
1f4b			LD   HL,(OLDSP)   ; $5B81. Fetch the old stack.
1f4e			LD   (OLDSP),SP   ; $5B81. Save the current stack.
1f52			LD   SP,HL        ; Use the old stack.
1f53
1f53			LD   HL,(TARGET)  ; $5B58. Restore HL.
1f56			PUSH AF           ; Stack return address.
1f57
1f57			LD   A,$07        ; RAM bank 7.
1f59			CALL L1F3A        ; Page in RAM bank 7.
1f5c			EI                ; Re-enable interrupts.
1f5d
1f5d			EX   AF,AF'       ; Restore A.
1f5e			RET               ;
1f5f
1f5f
1f5f			; ==================================
1f5f			; RAM DISK COMMAND ROUTINES - PART 4
1f5f			; ==================================
1f5f
1f5f			; ---------------------
1f5f			; Erase a RAM Disk File
1f5f			; ---------------------
1f5f			; N_STR1 contains the name of the file to erase.
1f5f
1f5f	L1F5F:  CALL L1D12        ; Find entry in RAM disk area, returning IX pointing to catalogue entry (leaves logical RAM bank 4 paged in).
1f62			JR   NZ,L1F68     ; Jump ahead if it was found. [Could have saved 3 bytes by using JP Z,$1D3E (ROM 0)]
1f64
1f64			CALL L05AC        ; Produce error report.
1f67			DEFB $23          ; "h File does not exist"
1f68
1f68	L1F68:  LD   L,(IX+$0D)   ; AHL=Length of file.
1f6b			LD   H,(IX+$0E)   ;
1f6e			LD   A,(IX+$0F)   ; Bit 7 of A will be 0 indicating to delete rather than add.
1f71			CALL L1CF3        ; Free up this amount of space.
1f74
1f74			PUSH IY           ; Preserve current value of IY.
1f76
1f76			LD   IY,(SFNEXT)  ; $5B83. IY points to next free catalogue entry.
1f7a			LD   BC,$FFEC     ; BC=-20 (20 bytes is the size of a catalogue entry).
1f7d			ADD  IX,BC        ; IX points to the next catalogue entry
1f7f
1f7f			LD   L,(IY+$0A)   ; AHL=First spare byte in RAM disk file area.
1f82			LD   H,(IY+$0B)   ;
1f85			LD   A,(IY+$0C)   ;
1f88
1f88			POP  IY           ; Restore IY to normal value.
1f8a
1f8a			LD   E,(IX+$0A)   ; BDE=Start of address of next RAM disk file entry.
1f8d			LD   D,(IX+$0B)   ;
1f90			LD   B,(IX+$0C)   ;
1f93			OR   A            ;
1f94			SBC  HL,DE        ;
1f96			SBC  A,B          ;
1f97			RL   H            ;
1f99			RL   H            ;
1f9b			SRA  A            ;
1f9d			RR   H            ;
1f9f			SRA  A            ;
1fa1			RR   H            ; HL=Length of all files to be moved.
1fa3
1fa3			LD   BC,$0014     ; 20 bytes is the size of a catalogue entry.
1fa6			ADD  IX,BC        ; IX=Catalogue entry to delete.
1fa8
1fa8			LD   (IX+$10),L   ; Store file length in the 'deleted' catalogue entry.
1fab			LD   (IX+$11),H   ;
1fae			LD   (IX+$12),A   ;
1fb1
1fb1			LD   BC,$FFEC     ; -20 (20 bytes is the size of a catalogue entry).
1fb4			ADD  IX,BC        ; IX=Next catalogue entry.
1fb6
1fb6			LD   L,(IX+$0A)   ; DHL=Start address of next RAM disk file entry.
1fb9			LD   H,(IX+$0B)   ;
1fbc			LD   D,(IX+$0C)   ;
1fbf
1fbf			LD   BC,$0014     ; 20 bytes is the size of a catalogue entry.
1fc2			ADD  IX,BC        ; IX points to catalogue entry to delete.
1fc4
1fc4			LD   A,D          ; Page in logical RAM bank for start address of entry to delete.
1fc5			CALL L1C64        ;
1fc8
1fc8			LD   A,(BANK_M)   ; $5B5C.
1fcb			LD   E,A          ; Save current RAM bank configuration in E.
1fcc			LD   BC,$7FFD     ; Select physical RAM bank 7.
1fcf			LD   A,$07        ;
1fd1			DI                ; Disable interrupts whilst performing paging operations.
1fd2			OUT  (C),A        ; Page in selected RAM bank.
1fd4			EXX               ; DHL'=Start address of next RAM disk file entry.
1fd5
1fd5			LD   L,(IX+$0A)   ; DHL=Start of address of RAM disk file entry to delete.
1fd8			LD   H,(IX+$0B)   ;
1fdb			LD   D,(IX+$0C)   ;
1fde
1fde			LD   A,D          ;
1fdf			CALL L1C64        ; Page in logical RAM bank for file entry (will update BANK_M).
1fe2
1fe2			LD   A,(BANK_M)   ; $5B5C.
1fe5			LD   E,A          ; Get RAM bank configuration for the file in E.
1fe6			LD   BC,$7FFD     ;
1fe9			EXX               ; DHL=Start address of next RAM disk file entry.
1fea
1fea			; At this point we have the registers and alternate registers pointing
1fea			; to the actual bytes in the RAM disk for the file to be deleted and the next file,
1fea			; with length bytes of the catalogue entry for the file to be deleted containing
1fea			; the length of bytes for all subsequent files that need to be moved down in memory.
1fea			; A loop is entered to move all of these bytes where the delete file began.
1fea
1fea			; DHL holds the address of the byte to be moved.
1fea			; E contains the value which should be OUTed to $5B5C to page in the relevant RAM page.
1fea
1fea	L1FEA:  LD   A,$07        ; Select physical RAM bank 7.
1fec			DI                ; Disable interrupts whilst performing paging operations.
1fed			OUT  (C),A        ; Page in selected RAM bank.
1fef
1fef			LD   A,(IX+$10)   ; Decrement end address.
1ff2			SUB  $01          ;
1ff4			LD   (IX+$10),A   ;
1ff7			JR   NC,L200D     ; If no carry then the decrement is finished.
1ff9
1ff9			LD   A,(IX+$11)   ; Otherwise decrement the middle byte.
1ffc			SUB  $01          ;
1ffe			LD   (IX+$11),A   ;
2001			JR   NC,L200D     ; If no carry then the decrement is finished.
2003
2003			LD   A,(IX+$12)   ; Otherwise decrement the highest byte.
2006			SUB  $01          ;
2008			LD   (IX+$12),A   ;
200b			JR   C,L203E      ; Jump forward if finished moving the file.
200d
200d	L200D:  OUT  (C),E        ; Page in RAM bank containing the next file.
200f			LD   A,(HL)       ; Get the byte from the next file.
2010			INC  L            ; Increment DHL.
2011			JR   NZ,L2024     ; If not zero then the increment is finished.
2013
2013			INC  H            ; Otherwise increment the middle byte.
2014			JR   NZ,L2024     ; If not zero then the increment is finished.
2016
2016			EX   AF,AF'       ; Save the byte read from the next file.
2017			INC  D            ; Advance to next logical RAM bank for the next file.
2018
2018			LD   A,D          ;
2019			CALL L1C64        ; Page in next logical RAM bank for next file entry (will update BANK_M).
201c
201c			LD   A,(BANK_M)   ; $5B5C.
201f			LD   E,A          ; Get RAM bank configuration for the next file in E.
2020			LD   HL,$C000     ; The next file continues at the beginning of the next RAM bank.
2023			EX   AF,AF'       ; Retrieve the byte read from the next file.
2024
2024	L2024:  EXX               ; DHL=Address of file being deleted.
2025
2025			DI                ; Disable interrupts whilst performing paging operations.
2026			OUT  (C),E        ; Page in next RAM bank containing the next file.
2028
2028			LD   (HL),A       ; Store the byte taken from the next file.
2029			INC  L            ; Increment DHL.
202a			JR   NZ,L203B     ; If not zero then the increment is finished.
202c
202c			INC  H            ; Otherwise increment the middle byte.
202d			JR   NZ,L203B     ; If not zero then the increment is finished.
202f
202f			INC  D            ; Advance to next logical RAM bank for the file being deleted.
2030
2030			LD   A,D          ;
2031			CALL L1C64        ; Page in next logical RAM bank for file being deleted entry (will update BANK_M).
2034
2034			LD   A,(BANK_M)   ; $5B5C.
2037			LD   E,A          ; Get RAM bank configuration for the file being deleted in E.
2038			LD   HL,$C000     ; The file being deleted continues at the beginning of the next RAM bank.
203b
203b	L203B:  EXX               ; DHL=Address of byte in next file.
203c			; DHL'=Address of byte in file being deleted.
203c			JR   L1FEA        ;
203e
203e			;The file has been moved
203e
203e	L203E:  LD   A,$04        ; Page in logical RAM bank 4 (physical RAM bank 7).
2040			CALL L1C64        ;
2043
2043			LD   A,$00        ;
2045			LD   HL,$0014     ; AHL=20 bytes is the size of a catalogue entry.
2048
2048	L2048:  CALL L1CF3        ; Delete a catalogue entry.
204b
204b			LD   E,(IX+$0D)   ;
204e			LD   D,(IX+$0E)   ;
2051			LD   C,(IX+$0F)   ; CDE=File length of file entry to delete.
2054
2054			LD   A,D          ;
2055			RLCA              ;
2056			RL   C            ;
2058			RLCA              ;
2059			RL   C            ; C=RAM bank.
205b			LD   A,D          ;
205c			AND  $3F          ; Mask off upper bits to leave length in this bank (range 0-16383).
205e			LD   D,A          ; DE=Length in this bank.
205f
205f			PUSH IX           ; Save address of catalogue entry to delete.
2061
2061	L2061:  PUSH DE           ;
2062			LD   DE,$FFEC     ; -20 (20 bytes is the size of a catalogue entry).
2065			ADD  IX,DE        ; Point to next catalogue entry.
2067			POP  DE           ; DE=Length in this bank.
2068
2068			LD   L,(IX+$0A)   ;
206b			LD   H,(IX+$0B)   ;
206e			LD   A,(IX+$0C)   ; AHL=File start address.
2071			OR   A            ;
2072			SBC  HL,DE        ; Will move into next RAM bank?
2074			SUB  C            ;
2075			BIT  6,H          ;
2077			JR   NZ,L207C     ; Jump if same RAM bank.
2079
2079			SET  6,H          ; New address in next RAM bank.
207b			DEC  A            ; Next RAM bank.
207c
207c	L207C:  LD   (IX+$0A),L   ;
207f			LD   (IX+$0B),H   ;
2082			LD   (IX+$0C),A   ; Save new start address of file.
2085
2085			LD   L,(IX+$10)   ;
2088			LD   H,(IX+$11)   ;
208b			LD   A,(IX+$12)   ; Fetch end address of file.
208e			OR   A            ;
208f			SBC  HL,DE        ; Will move into next RAM bank?
2091			SUB  C            ;
2092			BIT  6,H          ;
2094			JR   NZ,L2099     ; Jump if same RAM bank.
2096
2096			SET  6,H          ; New address in next RAM bank.
2098			DEC  A            ; Next RAM bank.
2099
2099	L2099:  LD   (IX+$10),L   ;
209c			LD   (IX+$11),H   ;
209f			LD   (IX+$12),A   ; Save new end address of file.
20a2
20a2			PUSH IX           ;
20a4			POP  HL           ; HL=Address of next catalogue entry.
20a5
20a5			PUSH DE           ;
20a6			LD   DE,(SFNEXT)  ; $5B83.
20aa			OR   A            ;
20ab			SBC  HL,DE        ; End of catalogue reached?
20ad			POP  DE           ; DE=Length in this bank.
20ae			JR   NZ,L2061     ; Jump if not to move next entry.
20b0
20b0			LD   DE,(SFNEXT)  ; $5B83. Start address of the next available catalogue entry.
20b4
20b4			POP  HL           ;
20b5			PUSH HL           ; HL=Start address of catalogue entry to delete.
20b6
20b6			OR   A            ;
20b7			SBC  HL,DE        ;
20b9			LD   B,H          ;
20ba			LD   C,L          ; BC=Length of catalogue entries to move.
20bb			POP  HL           ;
20bc			PUSH HL           ; HL=Start address of catalogue entry to delete.
20bd			LD   DE,$0014     ; 20 bytes is the size of a catalogue entry.
20c0			ADD  HL,DE        ; HL=Start address of previous catalogue entry.
20c1			EX   DE,HL        ; DE=Start address of previous catalogue entry.
20c2			POP  HL           ; HL=Start address of catalogue entry to delete.
20c3			DEC  DE           ; DE=End address of catalogue entry to delete.
20c4			DEC  HL           ; HL=End address of next catalogue entry.
20c5			LDDR              ; Move all catalogue entries.
20c7
20c7			LD   HL,(SFNEXT)  ; $5B83. Start address of the next available catalogue entry.
20ca			LD   DE,$0014     ; 20 bytes is the size of a catalogue entry.
20cd			ADD  HL,DE        ;
20ce			LD   (SFNEXT),HL  ; $5B83. Store the new location of the next available catalogue entry.
20d1			RET               ;
20d2
20d2			; ------------------------
20d2			; Print RAM Disk Catalogue
20d2			; ------------------------
20d2			; This routine prints catalogue filenames in alphabetically order.
20d2			; It does this by repeatedly looping through the catalogue to find
20d2			; the next 'highest' name.
20d2
20d2	L20D2:  LD   A,$04        ; Page in logical RAM bank 4
20d4			CALL L1C64        ;  (physical RAM bank 7)
20d7
20d7			LD   HL,L2121     ; HL points to ten $00 bytes, the initial comparison filename.
20da
20da	L20DA:  LD   BC,L212B     ; BC point to ten $FF bytes.
20dd			LD   IX,$EBEC     ; IX points to first catalogue entry.
20e1
20e1	L20E1:  CALL L05D6        ; Check for BREAK.
20e4
20e4			PUSH IX           ; Save address of catalogue entry.
20e6
20e6			EX   (SP),HL      ; HL points to current catalogue entry. Top of stack points to ten $00 data.
20e7			LD   DE,(SFNEXT)  ; $5B83. Find address of next free catalogue entry.
20eb			OR   A            ;
20ec			SBC  HL,DE        ; Have we reached end of catalogue?
20ee
20ee			POP  HL           ; Fetch address of catalogue entry.
20ef			JR   Z,L2111      ; Jump ahead if end of catalogue reached.
20f1
20f1			LD   D,H          ;
20f2			LD   E,L          ; DE=Current catalogue entry.
20f3			PUSH HL           ;
20f4			PUSH BC           ;
20f5			CALL L1C8A        ; Compare current filename (initially ten $00 bytes).
20f8			POP  BC           ;
20f9			POP  HL           ;
20fa			JR   NC,L210A     ; Jump if current catalogue name is 'above' the previous.
20fc
20fc			LD   D,B          ;
20fd			LD   E,C          ; DE=Last filename
20fe			PUSH HL           ;
20ff			PUSH BC           ;
2100			CALL L1C8A        ; Compare current filename (initially ten $FF bytes).
2103			POP  BC           ;
2104			POP  HL           ;
2105			JR   C,L210A      ; Jump if current catalogue name is 'below' the previous.
2107
2107			PUSH IX           ;
2109			POP  BC           ; BC=Address of current catalogue entry name.
210a
210a	L210A:  LD   DE,$FFEC     ; -20 (20 bytes is the size of a catalogue entry).
210d			ADD  IX,DE        ; Point to next catalogue entry.
210f			JR   L20E1        ; Check next filename.
2111
2111	L2111:  PUSH HL           ; HL points to current catalogue entry.
2112			LD   HL,L212B     ; Address of highest theoretical filename data.
2115			OR   A            ;
2116			SBC  HL,BC        ; Was a new filename to print found?
2118			POP  HL           ;
2119			RET  Z            ; Return if all filenames printed.
211a
211a			LD   H,B          ;
211b			LD   L,C          ; HL=Address of current catalogue entry name.
211c			CALL L2135        ; Print the catalogue entry.
211f			JR   L20DA        ; Repeat for next filename.
2121
2121			; -----------------------------
2121			; Print Catalogue Filename Data
2121			; -----------------------------
2121
2121	L2121:  DEFB $00, $00, $00, $00, $00  ; Lowest theoretical filename.
2126			DEFB $00, $00, $00, $00, $00
212b
212b	L212B:  DEFB $FF, $FF, $FF, $FF, $FF  ; Highest theoretical filename.
2130			DEFB $FF, $FF, $FF, $FF, $FF
2135
2135			; ----------------------------
2135			; Print Single Catalogue Entry
2135			; ----------------------------
2135			; Entry: HL=Address of filename.
2135			;        BC=Address of filename.
2135
2135	L2135:  PUSH HL           ; Save address of filename.
2136
2136			PUSH BC           ;
2137			POP  HL           ; [No need to transfer BC to HL since they already have the same value].
2138
2138			LD   DE,N_STR1    ; $5B67. Copy the filename to N_STR1 so that it
213b			LD   BC,$000A     ;        is visible when this RAM bank is paged out.
213e			LDIR              ;
2140
2140			LD   A,$05        ; Page in logical RAM bank 5 (physical RAM bank 0).
2142			CALL L1C64        ;
2145
2145			LD   HL,(OLDSP)   ; $5B81.
2148			LD   (OLDSP),SP   ; $5B81. Save temporary stack.
214c			LD   SP,HL        ; Use original stack.
214d
214d			LD   HL,N_STR1    ; $5B67. HL points to filename.
2150			LD   B,$0A        ; 10 characters to print.
2152
2152	L2152:  LD   A,(HL)       ; Print each character of the filename.
2153			PUSH HL           ;
2154			PUSH BC           ;
2155			RST  28H          ;
2156			DEFW PRINT_A_1    ; $0010.
2158			POP  BC           ;
2159			POP  HL           ;
215a			INC  HL           ;
215b			DJNZ L2152        ;
215d
215d			LD   A,$0D        ; Print a newline character.
215f			RST  28H          ;
2160			DEFW PRINT_A_1    ; $0010.
2162
2162			RST  28H          ;
2163			DEFW TEMPS        ; $0D4D. Copy permanent colours to temporary colours.
2165
2165			LD   HL,(OLDSP)   ; $5B81.
2168			LD   (OLDSP),SP   ; $5B81. Save original stack.
216c			LD   SP,HL        ; Switch back to temporary stack.
216d
216d			LD   A,$04        ; Page in logical RAM bank 4 (physical RAM bank 7).
216f			CALL L1C64        ;
2172
2172			POP  HL           ; HL=Address of filename.
2173			RET               ;
2174
2174
2174			; =======================================================
2174			; BASIC LINE AND COMMAND INTERPRETATION ROUTINES - PART 4
2174			; =======================================================
2174
2174			; --------------
2174			; LPRINT Routine
2174			; --------------
2174
2174	L2174:  LD   A,$03        ; Printer channel.
2176			JR   L217A        ; Jump ahead.
2178
2178			; --------------
2178			; PRINT Routine
2178			; --------------
2178
2178	L2178:  LD   A,$02        ; Main screen channel.
217a
217a	L217A:  RST  28H          ;
217b			DEFW SYNTAX_Z     ; $2530.
217d			JR   Z,L2182      ; Jump forward if syntax is being checked.
217f
217f			RST  28H          ;
2180			DEFW CHAN_OPEN    ; $1601.
2182
2182	L2182:  RST  28H          ;
2183			DEFW TEMPS        ; $0D4D.
2185			RST  28H          ;
2186			DEFW PRINT_2      ; $1FDF. Delegate handling to ROM 1.
2188			CALL L18A1        ; "C Nonsense in BASIC" during syntax checking if not
218b			; at end of line or statement.
218b			RET               ;
218c
218c			; -------------
218c			; INPUT Routine
218c			; -------------
218c			; This routine allows for values entered from the keyboard to be assigned
218c			; to variables. It is also possible to have print items embedded in the
218c			; INPUT statement and these items are printed in the lower part of the display.
218c
218c	L218C:  RST  28H          ;
218d			DEFW SYNTAX_Z     ; $2530.
218f			JR   Z,L2199      ; Jump forward if syntax is being checked.
2191
2191			LD   A,$01        ; Open channel 'K'.
2193			RST  28H          ;
2194			DEFW CHAN_OPEN    ; $1601.
2196			RST  28H          ; Clear the lower part of the display.
2197			DEFW CLS_LOWER    ; $0D6E. [*BUG* - This call will re-select channel 'S' and so should have been called prior to opening
2199			; channel 'K'. It is a direct copy of the code that appears in the standard Spectrum ROM (and ROM 1). It is
2199			; debatable whether it is better to reproduce the bug so as to ensure that the INPUT routine operates the same
2199			; in 128K mode as it does in 48K mode. Credit: Geoff Wearmouth]
2199
2199	L2199:  LD   (IY+$02),$01 ; TV_FLAG. Signal that the lower screen is being handled. [Not a bug as has been reported elsewhere. The confusion seems to have
219d			; arisen due to the incorrect system variable being originally mentioned in the Spectrum ROM Disassembly by Logan and O'Hara]
219d			RST  28H          ;
219e			DEFW IN_ITEM_1    ; $20C1. Call the subroutine to deal with the INPUT items.
21a0			CALL L18A1        ; Move on to the next statement if checking syntax.
21a3			RST  28H          ;
21a4			DEFW INPUT_1+$000A ; $20A0. Delegate handling to ROM 1.
21a6			RET               ;
21a7
21a7			; ------------
21a7			; COPY Routine
21a7			; ------------
21a7
21a7	L21A7:  JP   L08F0        ; Jump to new COPY routine.
21aa
21aa			; -----------
21aa			; NEW Routine
21aa			; -----------
21aa
21aa	L21AA:  DI                ;
21ab			JP   L019D        ; Re-initialise the machine.
21ae
21ae			; --------------
21ae			; CIRCLE Routine
21ae			; --------------
21ae			; This routine draws an approximation to the circle with centre co-ordinates
21ae			; X and Y and radius Z. These numbers are rounded to the nearest integer before use.
21ae			; Thus Z must be less than 87.5, even when (X,Y) is in the centre of the screen.
21ae			; The method used is to draw a series of arcs approximated by straight lines.
21ae
21ae	L21AE:  RST  18H          ; Get character from BASIC line.
21af			CP   ','          ; $2C. Check for second parameter.
21b1			JR   NZ,L21EB     ; Jump ahead (for error C) if not.
21b3
21b3			RST  20H          ; Advance pointer into BASIC line.
21b4			RST  28H          ; Get parameter.
21b5			DEFW EXPT_1NUM    ; $1C82. Radius to calculator stack.
21b7			CALL L18A1        ; Move to consider next statement if checking syntax.
21ba			RST  28H          ;
21bb			DEFW CIRCLE+$000D ; $232D. Delegate handling to ROM 1.
21bd			RET               ;
21be
21be			; ------------
21be			; DRAW Routine
21be			; ------------
21be			; This routine is entered with the co-ordinates of a point X0, Y0, say, in
21be			; COORDS. If only two parameters X, Y are given with the DRAW command, it
21be			; draws an approximation to a straight line from the point X0, Y0 to X0+X, Y0+Y.
21be			; If a third parameter G is given, it draws an approximation to a circular arc
21be			; from X0, Y0 to X0+X, Y0+Y turning anti-clockwise through an angle G radians.
21be
21be	L21BE:  RST  18H          ; Get current character.
21bf			CP   ','          ; $2C.
21c1			JR   Z,L21CA      ; Jump if there is a third parameter.
21c3
21c3			CALL L18A1        ; Error C during syntax checking if not at end of line/statement.
21c6			RST  28H          ;
21c7			DEFW LINE_DRAW    ; $2477. Delegate handling to ROM 1.
21c9			RET               ;
21ca
21ca	L21CA:  RST  20H          ; Get the next character.
21cb			RST  28H          ;
21cc			DEFW EXPT_1NUM    ; $1C82. Angle to calculator stack.
21ce			CALL L18A1        ; Error C during syntax checking if not at end of line/statement.
21d1			RST  28H          ;
21d2			DEFW DR_3_PRMS+$0007 ; $2394. Delegate handling to ROM 1.
21d4			RET               ;
21d5
21d5			; -----------
21d5			; DIM Routine
21d5			; -----------
21d5			; This routine establishes new arrays in the variables area. The routine starts
21d5			; by searching the existing variables area to determine whether there is an existing
21d5			; array with the same name. If such an array is found then it is 'reclaimed' before
21d5			; the new array is established. A new array will have all its elements set to zero
21d5			; if it is a numeric array, or to 'spaces' if it is an array of strings.
21d5
21d5	L21D5:  RST  28H          ; Search to see if the array already exists.
21d6			DEFW LOOK_VARS    ; $28B2.
21d8			JR   NZ,L21EB     ; Jump if array variable not found.
21da
21da			RST  28H
21db			DEFW SYNTAX_Z     ; $2530.
21dd			JR   NZ,L21E7     ; Jump ahead during syntax checking.
21df
21df			RES  6,C          ; Test the syntax for string arrays as if they were numeric.
21e1			RST  28H          ;
21e2			DEFW STK_VAR      ; $2996. Check the syntax of the parenthesised expression.
21e4			CALL L18A1        ; Error when checking syntax unless at end of line/statement.
21e7
21e7			;An 'existing array' is reclaimed.
21e7
21e7	L21E7:  RST  28H          ;
21e8			DEFW D_RUN        ; $2C15. Delegate handling to ROM 1.
21ea			RET               ;
21eb
21eb			; ----------------------------------
21eb			; Error Report C - Nonsense in BASIC
21eb			; ----------------------------------
21eb
21eb	L21EB:  CALL L05AC        ; Produce error report.
21ee			DEFB $0B          ; "C Nonsense in BASIC"
21ef
21ef			; --------------------
21ef			; Clear Screen Routine
21ef			; --------------------
21ef			; Clear screen if it is not already clear.
21ef
21ef	L21EF:  BIT  0,(IY+$30)   ; FLAGS2. Is the screen clear?
21f3			RET  Z            ; Return if it is.
21f4
21f4			RST  28H          ;
21f5			DEFW CL_ALL       ; $0DAF. Otherwise clear the whole display.
21f7			RET               ;
21f8
21f8			; ---------------------------
21f8			; Evaluate Numeric Expression
21f8			; ---------------------------
21f8			; This routine is called when a numerical expression is typed directly into the editor or calculator.
21f8			; A numeric expression is any that begins with '(', '-' or '+', or is one of the function keywords, e.g. ABS, SIN, etc,
21f8			; or is the name of a numeric variable.
21f8
21f8	L21F8:  LD   HL,$FFFE     ; A line in the editing area is considered as line '-2'.
21fb			LD   ($5C45),HL   ; PPC. Signal no current line number.
21fe
21fe			;Check the syntax of the BASIC line
21fe
21fe			RES  7,(IY+$01)   ; Indicate 'syntax checking' mode.
2202			CALL L228E        ; Point to start of the BASIC command line.
2205
2205			RST  28H          ;
2206			DEFW SCANNING     ; $24FB. Evaluate the command line.
2208			BIT  6,(IY+$01)   ; Is it a numeric value?
220c			JR   Z,L223A      ; Jump to produce an error if a string result.
220e
220e			RST  18H          ; Get current character.
220f			CP   $0D          ; Is it the end of the line?
2211			JR   NZ,L223A     ; Jump if not to produce an error if not.
2213
2213			;The BASIC line has passed syntax checking so now execute it
2213
2213			SET  7,(IY+$01)   ; If so, indicate 'execution' mode.
2217			CALL L228E        ; Point to start of the BASIC command line.
221a
221a			LD   HL,L0321     ; Set up the error handler routine address.
221d			LD   (SYNRET),HL  ; $5B8B.
2220
2220			RST  28H          ;
2221			DEFW SCANNING     ; $24FB. Evaluate the command line.
2223			BIT  6,(IY+$01)   ; Is it a numeric value?
2227			JR   Z,L223A      ; Jump to produce an error if a string result.
2229
2229			LD   DE,LASTV     ; $5B8D. DE points to last calculator value.
222c			LD   HL,($5C65)   ; STKEND.
222f			LD   BC,$0005     ; The length of the floating point value.
2232			OR   A            ;
2233			SBC  HL,BC        ; HL points to value on top of calculator stack.
2235			LDIR              ; Copy the value in the workspace to the top of the calculator stack.
2237			JP   L223E        ; [Could have saved 1 byte by using a JR instruction]
223a
223a	L223A:  CALL L05AC        ; Produce error report.
223d			DEFB $19          ; "Q Parameter error"
223e
223e	L223E:  LD   A,$0D        ; Make it appear that 'Enter' has been pressed.
2240			CALL L226F        ; Process key press.
2243
2243			LD   BC,$0001     ;
2246			RST  28H          ;
2247			DEFW BC_SPACES    ; $0030. Create a byte in the workspace.
2249
2249			LD   ($5C5B),HL   ; K_CUR. Address of the cursor.
224c			PUSH HL           ; Save it.
224d
224d			LD   HL,($5C51)   ; CURCHL. Current channel information.
2250			PUSH HL           ; Save it.
2251
2251			LD   A,$FF        ; Channel 'R', the workspace.
2253			RST  28H          ;
2254			DEFW CHAN_OPEN    ; $1601.
2256
2256			RST 28H
2257			DEFW PRINT_FP     ; $2DE3. Print a floating point number to the workspace.
2259
2259			POP  HL           ; Get the current channel information address.
225a
225a			RST  28H          ;
225b			DEFW CHAN_FLAG    ; $1615. Set appropriate flags back for the old channel.
225d
225d			POP  DE           ; DE=Address of the old cursor position.
225e
225e			LD   HL,($5C5B)   ; K_CUR. Address of the cursor.
2261			AND  A            ;
2262			SBC  HL,DE        ; HL=Length of floating point number.
2264
2264	L2264:  LD   A,(DE)       ; Fetch the character and make it appear to have been typed.
2265			CALL L226F        ; Process the key press.
2268			INC  DE           ;
2269			DEC  HL           ; Decrement floating point number character count.
226a			LD   A,H          ;
226b			OR   L            ;
226c			JR   NZ,L2264     ; Repeat for all characters.
226e
226e			RET               ;
226f
226f			; -----------------
226f			; Process Key Press
226f			; -----------------
226f			; Entry: A=Key code.
226f
226f	L226F:  PUSH HL           ; Save registers.
2270			PUSH DE           ;
2271
2271			CALL L1F45        ; Use Workspace RAM configuration (physical RAM bank 7).
2274
2274			LD   HL,$EC0D     ; Editor flags.
2277			RES  3,(HL)       ; Reset 'line altered' flag
2279
2279			PUSH AF           ;
227a			LD   A,$02        ; Main screen
227c			RST  28H          ;
227d			DEFW CHAN_OPEN    ; $1601.
227f			POP  AF           ;
2280
2280			CALL L2669        ; Process key press.
2283
2283			LD   HL,$EC0D     ; Editor flags.
2286			RES  3,(HL)       ; Reset 'line altered' flag
2288
2288			CALL L1F20        ; Use Normal RAM Configuration (physical RAM bank 0).
228b
228b			POP  DE           ; Restore registers.
228c			POP  HL           ;
228d			RET               ;
228e
228e			; ---------------------------
228e			; Find Start of BASIC Command
228e			; ---------------------------
228e			; Point to the start of a typed in BASIC command
228e			; and return first character in A.
228e
228e	L228E:  LD   HL,($5C59)   ; E_LINE. Get the address of command being typed in.
2291			DEC  HL           ;
2292			LD   ($5C5D),HL   ; CH_ADD. Store it as the address of next character to be interpreted.
2295			RST  20H          ; Get the next character.
2296			RET               ;
2297
2297			; ---------------
2297			; Is LET Command?
2297			; ---------------
2297			; A typed in command resides in the editing workspace.
2297			; This function tests whether the text is a single LET command.
2297			; Exit: Zero flag set if a single LET command.
2297
2297	L2297:  CALL L228E        ; Point to start of typed in command.
229a			CP   $F1          ; Is it 'LET'?
229c			RET  NZ           ; Return if not with zero flag reset.
229d
229d			LD   HL,($5C5D)   ; CH_ADD. HL points to next character.
22a0
22a0	L22A0:  LD   A,(HL)       ; Fetch next character.
22a1			INC  HL           ;
22a2			CP   $0D          ; Has end of line been found?
22a4			RET  Z            ; Return if so with zero flag set.
22a5
22a5			CP   ':'          ; $3A.  Has start of new statement been found?
22a7			JR   NZ,L22A0     ; Loop back if not.
22a9
22a9			OR   A            ; Return zero flag reset indicating a multi-statement
22aa			RET               ; LET command.
22ab
22ab			; ----------------------
22ab			; Is Operator Character?
22ab			; ----------------------
22ab			; Exit: Zero flag set if character is an operator.
22ab
22ab	L22AB:  LD   B,A          ; Save B.
22ac			LD   HL,L22BD     ; Start of operator token table.
22af
22af	L22AF:  LD   A,(HL)       ; Fetch character from the table.
22b0			INC  HL           ; Advance to next entry.
22b1			OR   A            ; End of table?
22b2			JR   Z,L22B9      ; Jump if end of table reached.
22b4
22b4			CP   B            ; Found required character?
22b5			JR   NZ,L22AF     ; Jump if not to try next character in table.
22b7
22b7			;Found
22b7
22b7			LD   A,B          ; Restore character to A.
22b8			RET               ; Return with zero flag set to indicate an operator.
22b9
22b9			;Not found
22b9
22b9	L22B9:  OR   $FF          ; Reset zero flag to indicate not an operator.
22bb			LD   A,B          ; Restore character to A.
22bc			RET               ;
22bd
22bd			; ---------------------
22bd			; Operator Tokens Table
22bd			; ---------------------
22bd
22bd	L22BD:  DEFB $2B, $2D, $2A  ; '+',  '-',  '*'
22c0			DEFB $2F, $5E, $3D  ; '/',  '^',  '='
22c3			DEFB $3E, $3C, $C7  ; '>',  '<',  '<='
22c6			DEFB $C8, $C9, $C5  ; '>=', '<>', 'OR'
22c9			DEFB $C6            ; 'AND'
22ca			DEFB $00            ; End marker.
22cb
22cb			; ----------------------
22cb			; Is Function Character?
22cb			; ----------------------
22cb			; Exit: Zero set if a function token.
22cb
22cb	L22CB:  CP   $A5          ; 'RND'. (first 48K token)
22cd			JR   C,L22DD      ; Jump ahead if not a token with zero flag reset.
22cf
22cf			CP   $C4          ; 'BIN'.
22d1			JR   NC,L22DD     ; Jump ahead if not a function token.
22d3
22d3			CP   $AC          ; 'AT'.
22d5			JR   Z,L22DD      ; Jump ahead if not a function token.
22d7
22d7			CP   $AD          ; 'TAB'.
22d9			JR   Z,L22DD      ; Jump ahead if not a function token.
22db
22db			CP   A            ; Return zero flag set if a function token.
22dc			RET               ;
22dd
22dd	L22DD:  CP   $A5          ; Return zero flag set if a function token.
22df			RET               ;
22e0
22e0			; ----------------------------------
22e0			; Is Numeric or Function Expression?
22e0			; ----------------------------------
22e0			; Exit: Zero flag set if a numeric or function expression.
22e0
22e0	L22E0:  LD   B,A          ; Fetch character code.
22e1			OR   $20          ; Make lowercase.
22e3			CP   'a'          ; $61. Is it 'a' or above?
22e5			JR   C,L22ED      ; Jump ahead if not a letter.
22e7
22e7			CP   '{'          ; $7B. Is it below '{'?
22e9	L22E9:  JR   NC,L22ED     ; Jump ahead if not.
22eb
22eb			CP   A            ; Character is a letter so return
22ec			RET               ; with zero flag set.
22ed
22ed	L22ED:  LD   A,B          ; Fetch character code.
22ee			CP   '.'          ; $2E. Is it '.'?
22f0			RET  Z            ; Return zero flag set indicating numeric.
22f1
22f1			CALL L230A        ; Is character a number?
22f4			JR   NZ,L2307     ; Jump ahead if not a number.
22f6
22f6	L22F6:  RST  20H          ; Get next character.
22f7			CALL L230A        ; Is character a number?
22fa			JR   Z,L22F6      ; Repeat for next character if numeric.
22fc
22fc			CP   '.'          ; $2E. Is it '.'?
22fe			RET  Z            ; Return zero flag set indicating numeric.
22ff
22ff			CP   'E'          ; $45. Is it 'E'?
2301			RET  Z            ; Return zero flag set indicating  numeric.
2302
2302			CP   'e'          ; $65. Is it 'e'?
2304			RET  Z            ; Return zero flag set indicating  numeric.
2305
2305			JR   L22AB        ; Jump to test for operator tokens.
2307
2307	L2307:  OR   $FF          ; Reset the zero flag to indicate non-alphanumeric.
2309			RET               ;
230a
230a			; ---------------------
230a			; Is Numeric Character?
230a			; ---------------------
230a			; Exit: Zero flag set if numeric character.
230a
230a	L230A:  CP   '0'          ; $30. Is it below '0'?
230c			JR   C,L2314      ; Jump below '0'.
230e
230e			CP   ':'          ; $3A. Is it below ':'?
2310			JR   NC,L2314     ; Jump above '9'
2312
2312			CP   A            ;
2313			RET               ; Set zero flag if numeric.
2314
2314	L2314:  CP   '0'          ; $30. This will cause zero flag to be reset.
2316			RET               ;
2317
2317			; ------------
2317			; PLAY Routine
2317			; ------------
2317
2317	L2317:  LD   B,$00        ; String index.
2319			RST  18H          ;
231a
231a	L231A:  PUSH BC           ;
231b			RST  28H          ; Get string expression.
231c			DEFW EXPT_EXP
231e			POP  BC           ;
231f			INC  B            ;
2320			CP   ','          ; $2C. A ',' indicates another string.
2322			JR   NZ,L2327     ; Jump ahead if no more.
2324
2324			RST  20H          ; Advance to the next character.
2325			JR   L231A        ; Loop back.
2327
2327	L2327:  LD   A,B          ; Check the index.
2328			CP   $09          ; Maximum of 8 strings (to support synthesisers, drum machines or sequencers).
232a			JR   C,L2330      ;
232c
232c			CALL L05AC        ; Produce error report.
232f			DEFB $2B          ; "p (c) 1986 Sinclair Research Ltd" [*BUG* - This should be "Parameter error". The Spanish 128
2330			; produces "p Bad parameter" but to save memory perhaps the UK 128 was intended to use the existing
2330			; "Q Parameter error" and the change of the error code byte here was overlooked. In that case it would
2330			; have had a value of $19. Note that generation of this error when using the main screen editor will
2330			; result in a crash. Credit: Andrew Owen]
2330
2330	L2330:  CALL L18A1        ; Ensure end-of-statement or end-of-line.
2333			JP   L0985        ; Continue with PLAY code.
2336
2336
2336			; ========================
2336			; UNUSED ROUTINES - PART 1
2336			; ========================
2336
2336			; There now follows 513 bytes of routines that are not used by the ROM, from $2336 (ROM 0) to $2536 (ROM 0).
2336			; They are remnants of the original Spanish 128's ROM code, although surprisingly they appear in a different
2336			; order within that ROM.
2336
2336			; ----------------
2336			; Return to Editor
2336			; ----------------
2336			; [Never called by this ROM]
2336
2336	L2336:  LD   HL,TSTACK    ; $5BFF.
2339			LD   (OLDSP),HL   ; $5B81.
233c
233c			CALL L1F45        ; Use Workspace RAM configuration (physical RAM bank 7).
233f			JP   L25CB        ; Jump ahead to the Editor.
2342
2342			; ------------------------
2342			; BC=HL-DE, Swap HL and DE
2342			; ------------------------
2342			; Exit: BC=HL-DE.
2342			;       DE=HL, HL=DE.
2342			;
2342			; [Never called by this ROM]
2342
2342	L2342:  AND  A            ;
2343			SBC  HL,DE        ;
2345			LD   B,H          ;
2346			LD   C,L          ; BC=HL-DE.
2347			ADD  HL,DE        ;
2348			EX   DE,HL        ; HL=DE, DE=HL.
2349			RET               ;
234a
234a			; ----------------------
234a			; Create Room for 1 Byte
234a			; ----------------------
234a			; Creates a single byte in the workspace, or automatically produces an error '4' if not.
234a			;
234a			; [Never called by this ROM]
234a
234a	L234A:  LD   BC,$0001     ; Request 1 byte.
234d			PUSH HL           ;
234e			PUSH DE           ;
234f			CALL L2358        ; Test whether there is space. If it fails this will cause the error
2352			POP  DE           ; handler in ROM 0 to be called. If MAKE_ROOM were called directly and
2353			POP  HL           ; and out of memory condition detected then the ROM 1 error handler would
2354			RST  28H          ; be called instead.
2355			DEFW MAKE_ROOM    ; $1655. The memory check passed so safely make the room.
2357			RET
2358
2358			; ------------------
2358			; Room for BC Bytes?
2358			; ------------------
2358			; Test whether there is room for the specified number of bytes in the spare memory,
2358			; producing error "4 Out of memory" if not. This routine is very similar to that at
2358			; $3F66 with the exception that this routine assumes IY points at the system variables.
2358			; Entry: BC=Number of bytes required.
2358			; Exit : Returns if the room requested is available else an error '4' is produced.
2358			;
2358			; [Called by the routine at $234A (ROM 0), which is itself never called by this ROM]
2358
2358	L2358:  LD   HL,($5C65)   ; STKEND.
235b			ADD  HL,BC        ; Would adding the specified number of bytes overflow the RAM area?
235c			JR   C,L2368      ; Jump to produce an error if so.
235e
235e			EX   DE,HL        ; DE=New end address.
235f			LD   HL,$0082     ; Would there be at least 130 bytes at the top of RAM?
2362			ADD  HL,DE        ;
2363			JR   C,L2368      ; Jump to produce an error if not.
2365
2365			SBC  HL,SP        ; If the stack is lower in memory, would there still be enough room?
2367			RET  C            ; Return if there would.
2368
2368	L2368:  LD   (IY+$00),$03 ; Signal error "4 Out of Memory".
236c			JP   L0321        ; Jump to error handler routine.
236f
236f			; ---------
236f			; HL = A*32
236f			; ---------
236f			; [Called by routines at $2383 (ROM 0) and $23B8 (ROM 0), which are themselves never called by this ROM]
236f
236f	L236F:  ADD  A,A          ; A*2.
2370			ADD  A,A          ; A*4. Then multiply by 8 in following routine.
2371
2371			; --------
2371			; HL = A*8
2371			; --------
2371			; [Called by the routine at $23E1 (ROM 0), which ultimately is itself never called by this ROM]
2371
2371	L2371:  LD   L,A          ;
2372			LD   H,$00        ;
2374			ADD  HL,HL        ; A*2.
2375			ADD  HL,HL        ; A*4.
2376			ADD  HL,HL        ; A*8.
2377			RET               ; Return HL=A*8.
2378
2378			; -------------------------
2378			; Find Amount of Free Space
2378			; -------------------------
2378			; Exit: Carry flag set if no more space, else HL holds the amount of free space.
2378			;
2378			; [Never called by this ROM]
2378
2378	L2378:  LD   HL,$0000     ;
237b			ADD  HL,SP        ; HL=SP.
237c			LD   DE,($5C65)   ; STKEND.
2380			OR   A            ;
2381			SBC  HL,DE        ; Effectively SP-STKEND, i.e. the amount of available space.
2383			RET               ;
2384
2384			; -----------------------
2384			; Print Screen Buffer Row
2384			; -----------------------
2384			; Prints row from the screen buffer to the screen.
2384			; Entry: A=Row number.
2384			;
2384			; [Never called by this ROM]
2384
2384	L2384:  RES  0,(IY-$39)   ; KSTATE+1. Signal do not invert attribute value. [IY+$3B on the Spanish 128]
2388
2388			CALL L236F        ; HL=A*32. Number of bytes prior to the requested row.
238b			PUSH HL           ; Save offset to requested row to print.
238c
238c			LD   DE,($FF24)   ; Fetch address of screen buffer.
2390			ADD  HL,DE        ; Point to row entry.
2391			LD   D,H          ;
2392			LD   E,L          ; DE=Address of row entry.
2393			EX   (SP),HL      ; Stack address of row entry. HL=Offset to requested row to print.
2394
2394			PUSH HL           ; Save offset to requested row to print.
2395			PUSH DE           ; Save address of row entry.
2396			LD   DE,$5800     ; Attributes file.
2399			ADD  HL,DE        ; Point to start of corresponding row in attributes file.
239a			EX   DE,HL        ; DE=Start address of corresponding row in attributes file.
239b			POP  HL           ; HL=Address of row entry.
239c
239c			LD   BC,$0020     ; 32 columns.
239f			LD   A,($5C8F)    ; ATTR_T. Fetch the temporary colours.
23a2			CALL L249B        ; Set the colours for the 32 columns in this row, processing
23a5			; any colour control codes from the print string.
23a5
23a5			POP  HL           ; HL=Offset to requested row to print.
23a6			LD   A,H          ;
23a7			LD   H,$00        ; Calculate corresponding display file address.
23a9			ADD  A,A          ;
23aa			ADD  A,A          ;
23ab			ADD  A,A          ;
23ac			ADD  A,$40        ;
23ae			LD   D,A          ;
23af			LD   E,H          ;
23b0			ADD  HL,DE        ;
23b1			EX   DE,HL        ; DE=Display file address.
23b2
23b2			POP  HL           ; HL=Offset to requested row to print.
23b3			LD   B,$20        ; 32 columns.
23b5			JP   L23E1        ; Print one row to the display file.
23b8
23b8			; ---------------------------
23b8			; Blank Screen Buffer Content
23b8			; ---------------------------
23b8			; Sets the specified number of screen buffer positions from the specified row to $FF.
23b8			; Entry: A=Row number.
23b8			;        BC=Number of bytes to set.
23b8			;
23b8			; [Never called by this ROM]
23b8
23b8	L23B8:  LD   D,$FF        ; The character to set the screen buffer contents to.
23ba			CALL L236F        ; HL=A*32. Offset to the specified row.
23bd			LD   A,D          ;
23be			LD   DE,($FF24)   ; Fetch the address of the screen buffer.
23c2			ADD  HL,DE        ; HL=Address of first column in the requested row.
23c3			LD   E,L          ;
23c4			LD   D,H          ;
23c5			INC  DE           ; DE=Address of second column in the requested row.
23c6			LD   (HL),A       ; Store the character.
23c7			DEC  BC           ;
23c8			LDIR              ; Repeat for all remaining bytes required.
23ca			RET               ;
23cb
23cb			; -----------------------------------
23cb			; Print Screen Buffer to Display File
23cb			; -----------------------------------
23cb			; [Never called by this ROM]
23cb
23cb	L23CB:  CALL L2488        ; Set attributes file from screen buffer.
23ce
23ce			LD   DE,$4000     ; DE=First third of display file.
23d1			LD   HL,($FF24)   ; Fetch address of screen buffer.
23d4			LD   B,E          ; Display 256 characters.
23d5			CALL L23E1        ; Display string.
23d8
23d8			LD   D,$48        ; Middle third of display file.
23da			CALL L23E1        ; Display string.
23dd
23dd			LD   D,$50        ; Last third of display file.
23df			LD   B,$C0        ; Display 192 characters.
23e1
23e1			; ----------------------------------------------
23e1			; Print Screen Buffer Characters to Display File
23e1			; ----------------------------------------------
23e1			; Displays ASCII characters, UDGs, graphic characters or two special symbols in the display file,
23e1			; but does not alter the attributes file. Character code $FE is used to represent the error marker
23e1			; bug symbol and the character code $FF is used to represent a null, which is displayed as a space.
23e1			; Entry: DE=Display file address.
23e1			;        HL=Points to string to print.
23e1			;        B=Number of characters to print.
23e1			;
23e1			; [Used by routine at $23CB (ROM 0) and called by the routine at $2383 (ROM 0), both of which are themselves never called by this ROM]
23e1
23e1	L23E1:  LD   A,(HL)       ; Fetch the character.
23e2			PUSH HL           ; Save string pointer.
23e3			PUSH DE           ; Save display file address.
23e4			CP   $FE          ; Was if $FE (bug) or $FF (null)?
23e6			JR   C,L23EC      ; Jump ahead if not.
23e8
23e8			SUB  $FE          ; Reduce range to $00-$01.
23ea			JR   L2422        ; Jump ahead to show symbol.
23ec
23ec			;Comes here if character code if below $FE
23ec
23ec	L23EC:  CP   $20          ; Is it a control character?
23ee			JR   NC,L23F7     ; Jump ahead if not.
23f0
23f0			;Comes here if a control character
23f0
23f0			LD   HL,L2527     ; Graphic for a 'G' (not a normal G though). Used to indicate embedded colour control codes.
23f3			AND  A            ; Clear the carry flag to indicate no need to switch back to RAM bank 7.
23f4			EX   AF,AF'       ; Save the flag.
23f5			JR   L242B        ; Jump ahead to display the symbol.
23f7
23f7	L23F7:  CP   $80          ; Is it a graphic character or UDG?
23f9			JR   NC,L2409     ; Jump ahead if so.
23fb
23fb			;Comes here if an ASCII character
23fb
23fb			CALL L2371        ; HL=A*8.
23fe			LD   DE,($5C36)   ; CHARS.
2402			ADD  HL,DE        ; Point to the character bit pattern.
2403			POP  DE           ; Fetch the display file address.
2404			CALL $FF28        ; Copy character into display file (via RAM Routine).
2407			; Can't use routine at $242C (ROM 0) since it does not perform a simple return.
2407			JR   L2450        ; Continue with next character.
2409
2409			;Comes here if a graphic character or UDG
2409
2409	L2409:  CP   $90          ; Is it a graphic character?
240b			JR   NC,L2411     ; Jump ahead if not.
240d
240d			;Comes here if a graphic character
240d
240d			SUB  $7F          ; Reduce range to $01-$10.
240f			JR   L2422        ; Jump ahead to display the symbol.
2411
2411			;Comes here if a UDG
2411
2411	L2411:  SUB  $90          ; Reduce range to $00-$6D.
2413			CALL L2371        ; HL=A*8.
2416
2416			POP  DE           ; Fetch display file address.
2417			CALL L1F20        ; Use Normal RAM Configuration (RAM bank 0) to allow access to character bit patterns.
241a			PUSH DE           ; Save display file address.
241b
241b			LD   DE,($5C7B)   ; UDG. Fetch address of UDGs.
241f			SCF               ; Set carry flag to indicate need to switch back to RAM bank 7.
2420			JR   L2429        ; Jump ahead to locate character bit pattern and display the symbol.
2422
2422			;Come here if (HL) was $FE or $FF, or with a graphic character.
2422			;At this point A=$00 if (HL) was $FE indicating a bug symbol, or $01 if (HL) was $FF indicating a null,
2422			;or A=$01-$10 if a graphic character.
2422
2422	L2422:  LD   DE,L252F     ; Start address of the graphic character bitmap table.
2425			CALL L2371        ; HL=A*8 -> $0000 or $0008.
2428			AND  A            ; Clear carry flag to indicate no need to switch back to RAM bank 7.
2429
2429	L2429:  EX   AF,AF'       ; Save switch bank indication flag.
242a			ADD  HL,DE        ; Point to the symbol bit pattern data.
242b
242b	L242B:  POP  DE           ; Fetch display file address. Drop through into routine below.
242c
242c			; ------------------------------------
242c			; Copy A Character <<< RAM Routine >>>
242c			; ------------------------------------
242c			; Routine copied to RAM at $FF36-$FF55 by subroutine at $246F (ROM 0).
242c			; Also used in ROM from above routine.
242c			;
242c			; This routine copies 8 bytes from HL to DE. It increments HL and D after
242c			; each byte, restoring D afterwards.
242c			; It is used to copy a character into the display file.
242c			; Entry: HL=Character data.
242c			;        DE=Display file address.
242c			;
242c			; [Called by a routine that is itself never called by this ROM]
242c
242c	L242C:  LD   C,D          ; Save D.
242d
242d			LD   A,(HL)       ;
242e			LD   (DE),A       ; Copy byte 1.
242f
242f			INC  HL           ;
2430			INC  D            ;
2431			LD   A,(HL)       ;
2432			LD   (DE),A       ; Copy byte 2.
2433
2433			INC  HL           ;
2434			INC  D            ;
2435			LD   A,(HL)       ;
2436			LD   (DE),A       ; Copy byte 3.
2437
2437			INC  HL           ;
2438			INC  D            ;
2439			LD   A,(HL)       ;
243a			LD   (DE),A       ; Copy byte 4.
243b
243b			INC  HL           ;
243c			INC  D            ;
243d			LD   A,(HL)       ;
243e			LD   (DE),A       ; Copy byte 5.
243f
243f			INC  HL           ;
2440			INC  D            ;
2441			LD   A,(HL)       ;
2442			LD   (DE),A       ; Copy byte 6.
2443
2443			INC  HL           ;
2444			INC  D            ;
2445			LD   A,(HL)       ;
2446			LD   (DE),A       ; Copy byte 7.
2447
2447			INC  HL           ;
2448			INC  D            ;
2449			LD   A,(HL)       ;
244a			LD   (DE),A       ; Copy byte 8.
244b
244b			LD   D,C          ; Restore D. <<< Last byte copied to RAM >>>
244c
244c			; When the above routine is used in ROM, it drops through to here.
244c
244c	L244C:  EX   AF,AF'       ; Need to switch back to RAM bank 7?
244d			CALL C,L1F45      ; If so then switch to use Workspace RAM configuration (physical RAM bank 7).
2450
2450	L2450:  POP  HL           ; Fetch address of string data.
2451			INC  HL           ; Move to next character.
2452			INC  DE           ; Advance to next display file column.
2453			DJNZ L23E1        ; Repeat for all requested characters.
2455
2455			RET               ;
2456
2456			; ---------------------------------
2456			; Toggle ROMs 1 <<< RAM Routine >>>
2456			; ---------------------------------
2456			; Routine copied to RAM at $FF28-$FF35 by subroutine at $246F (ROM 0).
2456			;
2456			; This routine toggles to the other ROM than the one held in BANK_M.
2456			; Entry: A'= Current paging configuration.
2456			;
2456			; [Called by a routine that is itself never called by this ROM]
2456
2456	L2456:  PUSH BC           ; Save BC
2457
2457			DI                ; Disable interrupts whilst paging.
2458
2458			LD   BC,$7FFD     ;
245b			LD   A,(BANK_M)   ; $5B5C. Fetch current paging configuration.
245e			XOR  $10          ; Toggle ROMs.
2460			OUT  (C),A        ; Perform paging.
2462			EI                ; Re-enable interrupts.
2463			EX   AF,AF'       ; Save the new configuration in A'. <<< Last byte copied to RAM >>>
2464
2464			; ---------------------------------
2464			; Toggle ROMs 2 <<< RAM Routine >>>
2464			; ---------------------------------
2464			; Routine copied to RAM at $FF56-$FF60 by subroutine at $246F (ROM 0).
2464			;
2464			; This routine toggles to the other ROM than the one specified.
2464			; It is used to page back to the original configuration.
2464			; Entry: A'= Current paging configuration.
2464			;
2464			; [Called by a routine that is itself never called by this ROM]
2464
2464	L2464:  EX   AF,AF'       ; Retrieve current paging configuration.
2465			DI                ; Disable interrupts whilst paging.
2466			LD   C,$FD        ; Restore Paging I/O port number.
2468			XOR  $10          ; Toggle ROMs.
246a			OUT  (C),A        ; Perform paging.
246c			EI                ; Re-enable interrupts.
246d
246d			POP  BC           ; Restore BC.
246e			RET               ; <<< Last byte copied to RAM >>>
246f
246f			; -----------------------------------------
246f			; Construct 'Copy Character' Routine in RAM
246f			; -----------------------------------------
246f			; This routine copies 3 sections of code into RAM to construct a single
246f			; routine that can be used to copy the bit pattern for a character into
246f			; the display file.
246f			;
246f			; Copy $2456-$2463 (ROM 0) to $FF28-$FF35 (14 bytes).
246f			; Copy $242C-$244B (ROM 0) to $FF36-$FF55 (32 bytes).
246f			; Copy $2464-$246E (ROM 0) to $FF56-$FF60 (11 bytes).
246f			;
246f			; [Never called by this ROM]
246f
246f	L246F:  LD   HL,L2456     ; Point to the 'page in other ROM' routine.
2472			LD   DE,$FF28     ; Destination RAM address.
2475			LD   BC,$000E     ;
2478			LDIR              ; Copy the routine.
247a
247a			PUSH HL           ;
247b			LD   HL,L242C     ; Copy a character routine.
247e			LD   C,$20        ;
2480			LDIR              ; Copy the routine.
2482
2482			POP  HL           ; HL=$2464 (ROM 0), which is the address of the 'page back to original ROM' routine.
2483			LD   C,$0B        ;
2485			LDIR              ; Copy the routine.
2487			RET               ;
2488
2488			; --------------------------------------
2488			; Set Attributes File from Screen Buffer
2488			; --------------------------------------
2488			; This routine parses the screen buffer string contents looking for colour
2488			; control codes and changing the attributes file contents correspondingly.
2488			;
2488			; [Called by the routine at $23CB (ROM 0), which is itself never called by this ROM]
2488
2488	L2488:  RES  0,(IY-$39)   ; KSTATE+1. Signal do not invert attribute value. [Spanish 128 uses IY-$3B]
248c
248c			LD   DE,$5800     ; The start of the attributes file.
248f			LD   BC,$02C0     ; 22 rows of 32 columns.
2492			LD   HL,($FF24)   ; The address of the string to print.
2495			LD   A,($5C8D)    ; ATTR_P.
2498			LD   ($5C8F),A    ; ATTR_T. Use the permanent colours.
249b
249b			; --------------------------------------
249b			; Set Attributes for a Screen Buffer Row
249b			; --------------------------------------
249b			; Entry: A=Colour byte.
249b			;        HL=Address within screen buffer.
249b			;        BC=Number of characters.
249b			;        DE=Address within attributes file.
249b
249b	L249B:  EX   AF,AF'       ; Save the colour byte.
249c
249c			;The main loop returns here on each iteration
249c
249c	L249C:  PUSH BC           ; Save the number of characters.
249d
249d			LD   A,(HL)       ; Fetch a character from the buffer.
249e			CP   $FF          ; Is it blank?
24a0			JR   NZ,L24AA     ; Jump ahead if not.
24a2
24a2			LD   A,($5C8D)    ; ATTR_P. Get the default colour byte.
24a5			LD   (DE),A       ; Store it in the attributes file.
24a6			INC  HL           ; Point to next screen buffer position.
24a7			INC  DE           ; Point to next attributes file position.
24a8			JR   L2507        ; Jump ahead to handle the next character.
24aa
24aa			;Not a blank character
24aa
24aa	L24AA:  EX   AF,AF'       ; Get the colour byte.
24ab			LD   (DE),A       ; Store it in the attributes file.
24ac			INC  DE           ; Point to the next attributes file position.
24ad			EX   AF,AF'       ; Save the colour byte.
24ae			INC  HL           ; Point to the next screen buffer position.
24af
24af			CP   $15          ; Is the string character OVER or above?
24b1			JR   NC,L2507     ; Jump if it is to handle the next character.
24b3
24b3			CP   $10          ; Is the string character below INK?
24b5			JR   C,L2507      ; Jump if it is to handle the next character.
24b7
24b7			;Screen buffer character is INK, PAPER, FLASH, BRIGHT or INVERSE.
24b7
24b7			DEC  HL           ; Point back to the previous screen buffer position.
24b8			JR   NZ,L24C2     ; Jump if not INK.
24ba
24ba			;Screen character was INK so insert the new ink into the attribute byte.
24ba
24ba			INC  HL           ; Point to the next screen buffer position.
24bb			LD   A,(HL)       ; Fetch the ink colour from the next screen buffer position.
24bc			LD   C,A          ; and store it in C.
24bd			EX   AF,AF'       ; Get the colour byte.
24be			AND  $F8          ; Mask off the ink bits.
24c0			JR   L2505        ; Jump ahead to store the new attribute value and then to handle the next character.
24c2
24c2	L24C2:  CP   $11          ; Is the string character PAPER?
24c4			JR   NZ,L24D1     ; Jump ahead if not.
24c6
24c6			;Screen character was PAPER so insert the new paper into the attribute byte.
24c6
24c6			INC  HL           ; Point to the next screen buffer position.
24c7			LD   A,(HL)       ; Fetch the paper colour from the next screen buffer position.
24c8			ADD  A,A          ;
24c9			ADD  A,A          ;
24ca			ADD  A,A          ; Multiple by 8 so that ink colour become paper colour.
24cb			LD   C,A          ;
24cc			EX   AF,AF'       ; Get the colour byte.
24cd			AND  $C7          ; Mask off the paper bits.
24cf			JR   L2505        ; Jump ahead to store the new attribute value and then to handle the next character.
24d1
24d1	L24D1:  CP   $12          ; Is the string character FLASH?
24d3			JR   NZ,L24DE     ; Jump ahead if not.
24d5
24d5			;Screen character was FLASH
24d5
24d5			INC  HL           ; Point to the next screen buffer position.
24d6			LD   A,(HL)       ; Fetch the flash status from the next screen buffer position.
24d7			RRCA              ; Shift the flash bit into bit 0.
24d8			LD   C,A          ;
24d9			EX   AF,AF'       ; Get the colour byte.
24da			AND  $7F          ; Mask off the flash bit.
24dc			JR   L2505        ; Jump ahead to store the new attribute value and then to handle the next character.
24de
24de	L24DE:  CP   $13          ; Is the string character BRIGHT?
24e0			JR   NZ,L24EC     ; Jump ahead if not.
24e2
24e2			;Screen character was BRIGHT
24e2
24e2			INC  HL           ; Point to the next screen buffer position.
24e3			LD   A,(HL)       ; Fetch the bright status from the next screen buffer position.
24e4			RRCA              ;
24e5			RRCA              ; Shift the bright bit into bit 0.
24e6			LD   C,A          ;
24e7			EX   AF,AF'       ; Get the colour byte.
24e8			AND  $BF          ; Mask off the bright bit.
24ea			JR   L2505        ; Jump ahead to store the new attribute value and then to handle the next character.
24ec
24ec	L24EC:  CP   $14          ; Is the string character INVERSE?
24ee			INC  HL           ; Point to the next screen buffer position.
24ef			JR   NZ,L2507     ; Jump ahead if not to handle the next character.
24f1
24f1			;Screen character was INVERSE
24f1
24f1			LD   C,(HL)       ; Fetch the inverse status from the next screen buffer position.
24f2			LD   A,($5C01)    ; KSTATE+1. Fetch inverting status (Bit 0 is 0 for non-inverting, 1 for inverting).
24f5			XOR  C            ; Invert status.
24f6			RRA               ; Shift status into the carry flag.
24f7			JR   NC,L2507     ; Jump if not inverting to handle the next character.
24f9
24f9			LD   A,$01        ; Signal inverting is active.
24fb			XOR  (IY-$39)     ; KSTATE+1. Toggle the status.
24fe			LD   ($5C01),A    ; KSTATE+1. Store the new status.
2501			EX   AF,AF'       ; Get the colour byte.
2502
2502			CALL L2513        ; Swap ink and paper in the colour byte.
2505
2505	L2505:  OR   C            ; Combine the old and new colour values.
2506			EX   AF,AF'       ; Save the new colour byte.
2507
2507	L2507:  POP  BC           ; Fetch the number of characters.
2508			DEC  BC           ;
2509			LD   A,B          ;
250a			OR   C            ;
250b			JP   NZ,L249C     ; Repeat for all characters.
250e
250e			EX   AF,AF'       ; Get colour byte.
250f			LD   ($5C8F),A    ; ATTR_T. Make it the new temporary colour.
2512			RET               ;
2513
2513			; ---------------------------------
2513			; Swap Ink and Paper Attribute Bits
2513			; ---------------------------------
2513			; Entry: A=Attribute byte value.
2513			; Exit : A=Attribute byte value with paper and ink bits swapped.
2513			;
2513			; [Called by the routine at $2488 (ROM 0), which is itself never called by this ROM]
2513
2513	L2513:  LD   B,A          ; Save the original colour byte.
2514
2514			AND  $C0          ; Keep only the flash and bright bits.
2516			LD   C,A          ;
2517			LD   A,B          ;
2518			ADD  A,A          ; Shift ink bits into paper bits.
2519			ADD  A,A          ;
251a			ADD  A,A          ;
251b			AND  $38          ; Keep only the paper bits.
251d			OR   C            ; Combine with the flash and bright bits.
251e			LD   C,A          ;
251f
251f			LD   A,B          ; Get the original colour byte.
2520			RRA               ;
2521			RRA               ;
2522			RRA               ; Shift the paper bits into the ink bits.
2523			AND  $07          ; Keep only the ink bits.
2525			OR   C            ; Add with the paper, flash and bright bits.
2526			RET               ;
2527
2527			; --------------
2527			; Character Data
2527			; --------------
2527
2527			;Graphic control code indicator
2527
2527	L2527:  DEFB $00          ; 0 0 0 0 0 0 0 0
2528			DEFB $3C          ; 0 0 1 1 1 1 0 0      XXXX
2529			DEFB $62          ; 0 1 1 0 0 0 1 0     XX   X
252a			DEFB $60          ; 0 1 1 0 0 0 0 0     XX
252b			DEFB $6E          ; 0 1 1 0 1 1 1 0     XX XXX
252c			DEFB $62          ; 0 1 1 0 0 0 1 0     XX   X
252d			DEFB $3E          ; 0 0 1 1 1 1 1 0      XXXX
252e			DEFB $00          ; 0 0 0 0 0 0 0 0
252f
252f			;Error marker
252f
252f	L252F:  DEFB $00          ; 0 0 0 0 0 0 0 0
2530			DEFB $6C          ; 0 1 1 0 1 1 0 0     XX XX
2531			DEFB $10          ; 0 0 0 1 0 0 0 0       X
2532			DEFB $54          ; 0 1 0 1 0 1 0 0     X X X
2533			DEFB $BA          ; 1 0 1 1 1 0 1 0    X XXX X
2534			DEFB $38          ; 0 0 1 1 1 0 0 0      XXX
2535			DEFB $54          ; 0 1 0 1 0 1 0 0     X X X
2536			DEFB $82          ; 1 0 0 0 0 0 1 0    X     X
2537
2537			; <<< End of Unused ROM Routines >>>
2537
2537
2537			; =================
2537			; KEY ACTION TABLES
2537			; =================
2537
2537			; -------------------------
2537			; Editing Keys Action Table
2537			; -------------------------
2537			; Each editing key code maps to the appropriate handling routine.
2537			; This includes those keys which mirror the functionality of the
2537			; add-on keypad; these are found by trapping the keyword produced
2537			; by the keystrokes in 48K mode.
2537			; [Surprisingly there is no attempt to produce an intelligible layout;
2537			; instead the first 16 keywords have been used. Additionally the entries for DELETE
2537			; and ENTER should probably come in the first six entries for efficiency reasons.]
2537
2537	L2537:  DEFB $15          ; Number of table entries.
2538			DEFB $0B          ; Key code: Cursor up.
2539			DEFW L2A94        ; CURSOR-UP handler routine.
253b			DEFB $0A          ; Key code: Cursor Down.
253c			DEFW L2AB5        ; CURSOR-DOWN handler routine.
253e			DEFB $08          ; Key code: Cursor Left.
253f			DEFW L2AD7        ; CURSOR-LEFT handler routine.
2541			DEFB $09          ; Key code: Cursor Right.
2542			DEFW L2AE3        ; CURSOR-RIGHT handler routine.
2544			DEFB $AD          ; Key code: Extend Mode + P.
2545			DEFW L2A4F        ; TEN-ROWS-UP handler routine.
2547			DEFB $AC          ; Key code: Symbol Shift + I.
2548			DEFW L2A25        ; TEN-ROWS-DOWN handler routine.
254a			DEFB $AF          ; Key code: Extend Mode + I.
254b			DEFW L29D4        ; WORD-LEFT handler routine.
254d			DEFB $AE          ; Key code: Extend Mode + Shift + J.
254e			DEFW L29E1        ; WORD-RIGHT handler routine.
2550			DEFB $A6          ; Key code: Extend Mode + N, or Graph + W.
2551			DEFW L2983        ; TOP-OF-PROGRAM handler routine.
2553			DEFB $A5          ; Key code: Extend Mode + T, or Graph + V.
2554			DEFW L29AB        ; END-OF-PROGRAM handler routine.
2556			DEFB $A8          ; Key code: Extend Mode Symbol Shift + 2, or Graph Y.
2557			DEFW L2A87        ; START-OF-LINE handler routine.
2559			DEFB $A7          ; Key code: Extend Mode + M, or Graph + X.
255a			DEFW L2A7A        ; END-OF-LINE handler routine.
255c			DEFB $AA          ; Key code: Extend Mode + Shift + K.
255d			DEFW L291B        ; DELETE-RIGHT handler routine.
255f			DEFB $0C          ; Key code: Delete.
2560			DEFW L292B        ; DELETE handler routine.
2562			DEFB $B3          ; Key code: Extend Mode + W.
2563			DEFW L3017        ; DELETE-WORD-RIGHT handler routine.
2565			DEFB $B4          ; Key code: Extend Mode + E.
2566			DEFW L2FBC        ; DELETE-WORD-LEFT handler routine.
2568			DEFB $B0          ; Key code: Extend Mode + J.
2569			DEFW L3072        ; DELETE-TO-END-OF-LINE handler routine.
256b			DEFB $B1          ; Key code: Extend Mode + K.
256c			DEFW L303E        ; DELETE-TO-START-OF-LINE handler routine.
256e			DEFB $0D          ; Key code: Enter.
256f			DEFW L2944        ; ENTER handler routine.
2571			DEFB $A9          ; Key code: Extend Mode + Symbol Shift + 8, or Graph + Z.
2572			DEFW L269B        ; TOGGLE handler routine.
2574			DEFB $07          ; Key code: Edit.
2575			DEFW L2704        ; MENU handler routine.
2577
2577			; ----------------------
2577			; Menu Keys Action Table
2577			; ----------------------
2577			; Each menu key code maps to the appropriate handling routine.
2577
2577	L2577:  DEFB $04          ; Number of entries.
2578			DEFB $0B          ; Key code: Cursor up.
2579			DEFW L272E        ; MENU-UP handler routine.
257b			DEFB $0A          ; Key code: Cursor down.
257c			DEFW L2731        ; MENU-DOWN handler routine.
257e			DEFB $07          ; Key code: Edit.
257f			DEFW L2717        ; MENU-SELECT handler routine.
2581			DEFB $0D          ; Key code: Enter.
2582			DEFW L2717        ; MENU-SELECT handler routine.
2584
2584
2584			; ======================
2584			; MENU ROUTINES - PART 3
2584			; ======================
2584
2584			; ------------------------
2584			; Initialise Mode Settings
2584			; ------------------------
2584			; Called before Main menu displayed.
2584
2584	L2584:  CALL L28BE        ; Reset Cursor Position.
2587
2587			LD   HL,$0000     ; No top line.
258a			LD   ($FC9A),HL   ; Line number at top of screen.
258d
258d			LD   A,$82        ; Signal waiting for key press, and menu is displayed.
258f			LD   ($EC0D),A    ; Store the Editor flags.
2592
2592			LD   HL,$0000     ; No current line number.
2595			LD   ($5C49),HL   ; E_PPC. Current line number.
2598
2598			CALL L35BC        ; Reset indentation settings.
259b			CALL L365E        ; Reset to 'L' Mode
259e			RET               ; [Could have saved one byte by using JP $365E (ROM 0)]
259f
259f			; --------------
259f			; Show Main Menu
259f			; --------------
259f
259f	L259F:  LD   HL,TSTACK    ; $5BFF.
25a2			LD   (OLDSP),HL   ; $5B81.
25a5
25a5			CALL L1F45        ; Use Workspace RAM configuration (physical RAM bank 7).
25a8
25a8			LD   A,$02        ; Select main screen.
25aa			RST  28H          ;
25ab			DEFW CHAN_OPEN    ; $1601.
25ad
25ad	L25AD:  LD   HL,L2744     ; Jump table for Main Menu.
25b0			LD   ($F6EA),HL   ; Store current menu jump table address.
25b3			LD   HL,L2754     ; The Main Menu text.
25b6			LD   ($F6EC),HL   ; Store current menu text table address.
25b9
25b9			PUSH HL           ; Store address of menu on stack.
25ba
25ba			LD   HL,$EC0D     ; Editor flags.
25bd			SET  1,(HL)       ; Indicate 'menu displayed'.
25bf			RES  4,(HL)       ; Signal return to main menu.
25c1			DEC  HL           ; Current menu index.
25c2			LD   (HL),$00     ; Select top entry.
25c4
25c4			POP  HL           ; Retrieve address of menu.
25c5
25c5			CALL L36A8        ; Display menu and highlight first item.
25c8
25c8			JP   L2653        ; Jump ahead to enter the main key waiting and processing loop.
25cb
25cb
25cb			; ========================
25cb			; EDITOR ROUTINES - PART 2
25cb			; ========================
25cb
25cb			; -----------------------------------------------
25cb			; Return to Editor / Calculator / Menu from Error
25cb			; -----------------------------------------------
25cb
25cb	L25CB:  LD   IX,$FD6C     ; Point IX at editing settings information.
25cf
25cf			LD   HL,TSTACK    ; $5BFF.
25d2			LD   (OLDSP),HL   ; $5B81.
25d5
25d5			CALL L1F45        ; Use Workspace RAM configuration (physical RAM bank 7).
25d8
25d8			LD   A,$02        ;
25da			RST  28H          ;
25db			DEFW CHAN_OPEN    ; $1601. Select main screen.
25dd
25dd			CALL L3668        ; Reset 'L' mode.
25e0			LD   HL,$5C3B     ; FLAGS.
25e3
25e3	L25E3:  BIT  5,(HL)       ; Has a key been pressed?
25e5			JR   Z,L25E3      ; Wait for a key press.
25e7
25e7			LD   HL,$EC0D     ; Editor flags.
25ea			RES  3,(HL)       ; Signal line has not been altered.
25ec
25ec			BIT  6,(HL)       ; Is editing area the lower screen?
25ee			JR   NZ,L2604     ; If so then skip printing a banner and jump ahead to return to the Editor.
25f0
25f0			LD   A,($EC0E)    ; Fetch mode.
25f3			CP   $04          ; Calculator mode?
25f5			JR   Z,L2601      ; Jump ahead if so.
25f7
25f7			CP   $00          ; Edit Menu mode?
25f9			JP   NZ,L28C7     ; Jump if not to re-display Main menu.
25fc
25fc			;Edit menu Print mode
25fc
25fc			CALL L3848        ; Clear screen and print "128 BASIC" in the banner line.
25ff			JR   L2604        ; Jump ahead to return to the Editor.
2601
2601			;Calculator mode
2601
2601	L2601:  CALL L384D        ; Clear screen and print "Calculator" in the banner line.
2604
2604			; --------------------
2604			; Return to the Editor
2604			; --------------------
2604			; Either as the result of a re-listing, an error or from completing the Edit Menu Print option.
2604
2604			; [*BUG* - Occurs only with ZX Interface 1 attached and a BASIC line such as 1000 OPEN #4, "X" (the line number must be greater than 999).
2604			;          This produces the error message "Invalid device expression, 1000:1" but the message is too long to fit on a single line. When using the lower screen
2604			;          for editing, spurious effects happen to the bottom lines. When using the full screen editor, a crash occurs. Credit: Toni Baker, ZX Computing Monthly]
2604
2604			; [The bug is caused by system variable DF_SZ being increased to 3 as a result of the error message spilling onto an extra line. The error can be resolved
2604			; by inserting a LD (IY+$31),$02 instruction at $2604 (ROM 0). Credit: Paul Farrow]
2604
2604	L2604:  CALL L30D6        ; Reset Below-Screen Line Edit Buffer settings to their default values.
2607			CALL L3222        ; Reset Above-Screen Line Edit Buffer settings to their default values.
260a
260a			LD   A,($EC0E)    ; Fetch the mode.
260d			CP   $04          ; Calculator mode?
260f			JR   Z,L2653      ; Jump ahead if not to wait for a key press.
2611
2611			;Calculator mode
2611
2611			LD   HL,($5C49)   ; E_PPC. Fetch current line number.
2614			LD   A,H          ;
2615			OR   L            ; Is there a current line number?
2616			JR   NZ,L262D     ; Jump ahead if so.
2618
2618			LD   HL,($5C53)   ; PROG. Address of start of BASIC program.
261b			LD   BC,($5C4B)   ; VARS. Address of start of variables area.
261f			AND  A            ;
2620			SBC  HL,BC        ; HL=Length of program.
2622			JR   NZ,L262A     ; Jump if a program exists.
2624
2624			;No program exists
2624
2624			LD   HL,$0000     ;
2627			LD   ($EC08),HL   ; Set no line number last edited.
262a
262a	L262A:  LD   HL,($EC08)   ; Fetch line number of last edited line.
262d
262d	L262D:  CALL L1F20        ; Use Normal RAM Configuration (physical RAM bank 0).
2630
2630			RST  28H          ; Find address of line number held in HL, or the next line if it does not exist.
2631			DEFW LINE_ADDR    ; $196E. Return address in HL.
2633			RST  28H          ; Find line number for specified address, and return in DE.
2634			DEFW LINE_NO      ; $1695. Fetch the line number for the line found.
2636
2636			CALL L1F45        ; Use Workspace RAM configuration (physical RAM bank 7).
2639
2639			LD   ($5C49),DE   ; E_PPC. Save the current line number.
263d
263d			LD   HL,$EC0D     ; Editor flags.
2640			BIT  5,(HL)       ; Process the BASIC line?
2642			JR   NZ,L2653     ; Jump ahead if calculator mode.
2644
2644			LD   HL,$0000     ;
2647			LD   ($EC06),HL   ; Signal no editable characters in the line prior to the cursor.
264a
264a			CALL L152F        ; Relist the BASIC program.
264d
264d			CALL L29F2        ; Set attribute at editing position so as to show the cursor.
2650			CALL L2944        ; Call the ENTER handler routine.
2653
2653			; -----------------
2653			; Main Waiting Loop
2653			; -----------------
2653			; Enter a loop to wait for a key press. Handles key presses for menus, the Calculator and the Editor.
2653
2653	L2653:  LD   SP,TSTACK    ; $5BFF. Use temporary stack.
2656
2656			CALL L3668        ; Reset 'L' mode.
2659
2659			CALL L367F        ; Wait for a key. [Note that it is possible to change CAPS LOCK mode whilst on a menu]
265c			PUSH AF           ; Save key code.
265d
265d			LD   A,($5C39)    ; PIP. Tone of keyboard click.
2660			CALL L26EC        ; Produce a key click noise.
2663
2663			POP  AF           ; Retrieve key code.
2664			CALL L2669        ; Process the key press.
2667
2667			JR   L2653        ; Wait for another key.
2669
2669			; -----------------
2669			; Process Key Press
2669			; -----------------
2669			; Handle key presses for the menus and the Editor.
2669			; Entry: A=Key code.
2669			;        Zero flag set if a menu is being displayed.
2669
2669	L2669:  LD   HL,$EC0D     ; Editor flags.
266c			BIT  1,(HL)       ; Is a menu is displayed?
266e			PUSH AF           ; Save key code and flags.
266f
266f			LD   HL,L2577     ; Use menu keys lookup table.
2672			JR   NZ,L2677     ; Jump if menu is being displayed.
2674
2674			LD   HL,L2537     ; Use editing keys lookup table.
2677
2677	L2677:  CALL L3FCE        ; Find and call the action handler for this key press.
267a			JR   NZ,L2681     ; Jump ahead if no match found.
267c
267c			CALL NC,L26E7     ; If required then produce error beep.
267f
267f			POP  AF           ; Restore key code.
2680			RET               ;
2681
2681			;No action defined for key code
2681
2681	L2681:  POP  AF           ; Restore key code and flags.
2682			JR   Z,L2689      ; Jump if menu is not being displayed.
2684
2684			;A menu is being displayed, so just ignore key press
2684
2684			XOR  A            ; Select 'L' mode.
2685			LD   ($5C41),A    ; MODE.
2688			RET               ;
2689
2689			;A menu is not being displayed
2689
2689	L2689:  LD   HL,$EC0D     ; Editor flags.
268c			BIT  0,(HL)       ; Is the Screen Line Edit Buffer is full?
268e			JR   Z,L2694      ; Jump if not to process the key code.
2690
2690			;The buffer is full so ignore the key press
2690
2690			CALL L26E7        ; Produce error beep.
2693			RET               ; [Could have save a byte by using JP $26E7 (ROM 0)]
2694
2694	L2694:  CP   $A3          ; Was it a supported function key code?
2696			JR   NC,L2653     ; Ignore by jumping back to wait for another key.
2698			; [*BUG* - This should be RET NC since it was called from the loop at $2653 (ROM 0). Repeatedly pressing an unsupported
2698			; key will result in a stack memory leak and eventual overflow. Credit: John Steven (+3), Paul Farrow (128)]
2698			JP   L28F1        ; Jump forward to handle the character key press.
269b
269b			; --------------------------
269b			; TOGGLE Key Handler Routine
269b			; --------------------------
269b			; Toggle between editing in the lower and upper screen areas.
269b			; Also used by the editing menu SCREEN option.
269b
269b	L269B:  LD   A,($EC0E)    ; Fetch mode.
269e			CP   $04          ; Calculator mode?
26a0			RET  Z            ; Return if so (TOGGLE has no effect in Calculator mode).
26a1
26a1			CALL L1630        ; Clear Editing Display.
26a4
26a4			LD   HL,$EC0D     ; Editor flags.
26a7			RES  3,(HL)       ; Reset 'line altered' flag.
26a9
26a9			LD   A,(HL)       ;
26aa			XOR  $40          ; Toggle screen editing area flag.
26ac			LD   (HL),A       ;
26ad			AND  $40          ;
26af			JR   Z,L26B6      ; Jump forward if the editing area is now the upper area.
26b1
26b1			CALL L26BB        ; Set the lower area as the current editing area.
26b4			JR   L26B9        ; Jump forward.
26b6
26b6	L26B6:  CALL L26CE        ; Set the upper area as the current editing area.
26b9
26b9	L26B9:  SCF               ; Signal do not produce an error beep.
26ba			RET               ;
26bb
26bb			; -------------------
26bb			; Select Lower Screen
26bb			; -------------------
26bb			; Set the lower screen as the editing area.
26bb
26bb	L26BB:  CALL L3881        ; Clear lower editing area display.
26be			LD   HL,$EC0D     ; Editor flags.
26c1			SET  6,(HL)       ; Signal using lower screen.
26c3
26c3			CALL L2E2D        ; Reset to lower screen.
26c6			CALL L3A88        ; Set default lower screen editing cursor settings.
26c9			CALL L28DF        ; Set default lower screen editing settings.
26cc
26cc			JR   L26D9        ; Jump ahead to continue.
26ce
26ce			; -------------------
26ce			; Select Upper Screen
26ce			; -------------------
26ce			; Set the upper screen as the editing area.
26ce
26ce	L26CE:  LD   HL,$EC0D     ; Editor flags.
26d1			RES  6,(HL)       ; Signal using main screen.
26d3
26d3			CALL L28BE        ; Reset Cursor Position.
26d6			CALL L3848        ; Clear screen and print the "128 BASIC" banner line.
26d9
26d9	L26D9:  LD   HL,($FC9A)   ; Line number at top of screen.
26dc			LD   A,H          ;
26dd			OR   L            ; Is there a line?
26de			CALL NZ,L334A     ; If there is then get the address of BASIC line for this line number.
26e1			CALL L152F        ; Relist the BASIC program.
26e4			JP   L29F2        ; Set attribute at editing position so as to show the cursor, and return.
26e7
26e7			; ------------------
26e7			; Produce Error Beep
26e7			; ------------------
26e7			; This is the entry point to produce the error beep, e.g. when trying to cursor up or down past the BASIC program.
26e7			; It produces a different tone and duration from the error beep of 48K mode. The change is pitch is due to the SRL A
26e7			; instruction at $26EA (ROM 0), and the change in duration is due to the instruction at $26F1 (ROM 0) which loads HL with $0C80 as opposed
26e7			; to $1A90 which is used when in 48K mode. The key click and key repeat sounds are produced by entering at $26EC (ROM 0) but with A
26e7			; holding the value of system variable PIP. This produces the same tone as 48K mode but is of a much longer duration due to
26e7			; HL being loaded with $0C80 as opposed to the value of $00C8 used in 48K mode. The Spanish 128 uses the same key click tone
26e7			; and duration in 128K mode as it does in 48K mode, leading to speculation that the Spectrum 128 (and subsequent models) should
26e7			; have done the same and hence suffer from a bug. However, there is no reason why this should be the case, and it can easily be
26e7			; imagined that the error beep note duration of 48K mode would quickly become very irritating when in 128K mode where it is likely
26e7			; to occur far more often. Hence the reason for its shorter duration. The reason for the longer key click is less clear, unless it
26e7			; was to save memory by using a single routine. However, it would only have required an additional 3 bytes to set HL independently
26e7			; for key clicks, which is not a great deal considering there is 1/2K of unused routines at $2336 (ROM 0). Since the
26e7			; INPUT command is handled by ROM 1, it produces key clicks at the 48K mode duration even when executed from 128 BASIC mode.
26e7
26e7	L26E7:  LD   A,($5C38)    ; RASP.
26ea			SRL  A            ; Divide by 2.
26ec
26ec			;This entry point is called to produce the key click tone. In 48K mode, the key click sound uses an HL value of $00C8
26ec			;and so is 16 times shorter than in 128K mode.
26ec
26ec	L26EC:  PUSH IX           ;
26ee
26ee			LD   D,$00        ; Pitch.
26f0			LD   E,A          ;
26f1			LD   HL,$0C80     ; Duration.
26f4
26f4	L26F4:  RST  28H          ;
26f5			DEFW BEEPER       ; $03B5. Produce a tone.
26f7
26f7			POP  IX           ;
26f9			RET               ;
26fa
26fa			; --------------------
26fa			; Produce Success Beep
26fa			; --------------------
26fa
26fa	L26FA:  PUSH IX           ;
26fc
26fc			LD   DE,$0030     ; Frequency*Time.
26ff			LD   HL,$0300     ; Duration.
2702			JR   L26F4        ; Jump to produce the tone.
2704
2704
2704			; ======================
2704			; MENU ROUTINES - PART 4
2704			; ======================
2704
2704			; ===============================
2704			; Menu Key Press Handler Routines
2704			; ===============================
2704
2704			; -----------------------------
2704			; Menu Key Press Handler - MENU
2704			; -----------------------------
2704			; This is executed when the EDIT key is pressed, either from within a menu or from the BASIC editor.
2704
2704	L2704:  CALL L29EC        ; Remove cursor, restoring old attribute.
2707
2707			LD   HL,$EC0D     ; HL points to Editor flags.
270a			SET  1,(HL)       ; Signal 'menu is being displayed'.
270c			DEC  HL           ; HL=$EC0C.
270d			LD   (HL),$00     ; Set 'current menu item' as the top item.
270f
270f	L270F:  LD   HL,($F6EC)   ; Address of text for current menu.
2712			CALL L36A8        ; Display menu and highlight first item.
2715
2715			SCF               ; Signal do not produce an error beep.
2716			RET               ;
2717
2717			; -------------------------------
2717			; Menu Key Press Handler - SELECT
2717			; -------------------------------
2717
2717	L2717:  LD   HL,$EC0D     ; HL points to Editor flags.
271a			RES  1,(HL)       ; Clear 'displaying menu' flag.
271c
271c			DEC  HL           ; HL=$EC0C.
271d			LD   A,(HL)       ; A=Current menu option index.
271e
271e			LD   HL,($F6EA)   ; HL points to jump table for current menu.
2721			PUSH HL           ;
2722			PUSH AF           ;
2723			CALL L373E        ; Restore menu screen area.
2726			POP  AF           ;
2727			POP  HL           ;
2728
2728			CALL L3FCE        ; Call the item in the jump table corresponding to the
272b			; currently selected menu item.
272b			JP   L29F2        ; Set attribute at editing position so as to show the cursor, and return.
272e
272e			; ----------------------------------
272e			; Menu Key Press Handler - CURSOR UP
272e			; ----------------------------------
272e
272e	L272E:  SCF               ; Signal move up.
272f			JR   L2732        ; Jump ahead to continue.
2731
2731			; ------------------------------------
2731			; Menu Key Press Handler - CURSOR DOWN
2731			; ------------------------------------
2731
2731	L2731:  AND  A            ; Signal moving down.
2732
2732	L2732:  LD   HL,$EC0C     ;
2735			LD   A,(HL)       ; Fetch current menu index.
2736			PUSH HL           ; Save it.
2737
2737			LD   HL,($F6EC)   ; Address of text for current menu.
273a			CALL C,L37A7      ; Call if moving up.
273d			CALL NC,L37B6     ; Call if moving down.
2740
2740			POP  HL           ; HL=Address of current menu index store.
2741			LD   (HL),A       ; Store the new menu index.
2742
2742			; Comes here to complete handling of Menu cursor up and down. Also as the handler routines
2742			; for Edit Menu return to 128 BASIC option and Calculator menu return to Calculator option,
2742			; which simply make a return.
2742
2742	L2742:  SCF               ;
2743			RET               ;
2744
2744
2744			; ===========
2744			; Menu Tables
2744			; ===========
2744
2744			; ---------
2744			; Main Menu
2744			; ---------
2744
2744			; Jump table for the main 128K menu, referenced at $25AD (ROM 0).
2744
2744	L2744:  DEFB $05          ; Number of entries.
2745			DEFB $00
2746			DEFW L2831        ; Tape Loader option handler.
2748			DEFB $01
2749			DEFW L286C        ; 128 BASIC option handler.
274b			DEFB $02
274c			DEFW L2885        ; Calculator option handler.
274e			DEFB $03
274f			DEFW L1B47        ; 48 BASIC option handler.
2751			DEFB $04
2752			DEFW L2816        ; Tape Tester option handler.
2754
2754			; Text for the main 128K menu
2754
2754	L2754:  DEFB $06          ; Number of entries.
2755			DEFM "128     "   ; Menu title.
275d			DEFB $FF
275e	L275E:  DEFM "Tape Loade"
2768			DEFB $80+'r'
2769	L2769:  DEFM "128 BASI"
2771			DEFB $80+'C'
2772	L2772:  DEFM "Calculato"
277b			DEFB $80+'r'
277c			DEFM "48 BASI"
2783			DEFB $80+'C'
2784	L2784:  DEFM "Tape Teste"
278e			DEFB $80+'r'
278f
278f			DEFB $80+' '      ; $A0. End marker.
2790
2790			; ---------
2790			; Edit Menu
2790			; ---------
2790
2790			; Jump table for the Edit menu
2790
2790	L2790:  DEFB $05          ; Number of entries.
2791			DEFB $00
2792			DEFW L2742        ; (Return to) 128 BASIC option handler.
2794			DEFB $01
2795			DEFW L2851        ; Renumber option handler.
2797			DEFB $02
2798			DEFW L2811        ; Screen option handler.
279a			DEFB $03
279b			DEFW L2862        ; Print option handler.
279d			DEFB $04
279e			DEFW L281C        ; Exit option handler.
27a0
27a0			; Text for the Edit menu
27a0
27a0	L27A0:  DEFB $06          ; Number of entries.
27a1			DEFM "Options "
27a9			DEFB $FF
27aa			DEFM "128 BASI"
27b2			DEFB $80+'C'
27b3			DEFM "Renumbe"
27ba			DEFB $80+'r'
27bb			DEFM "Scree"
27c0			DEFB $80+'n'
27c1			DEFM "Prin"
27c5			DEFB $80+'t'
27c6			DEFM "Exi"
27c9			DEFB $80+'t'
27ca
27ca			DEFB $80+' '      ; $A0. End marker.
27cb
27cb			; ---------------
27cb			; Calculator Menu
27cb			; ---------------
27cb
27cb			; Jump table for the Calculator menu
27cb
27cb	L27CB:  DEFB $02          ; Number of entries.
27cc			DEFB $00
27cd			DEFW L2742        ; (Return to) Calculator option handler.
27cf			DEFB $01
27d0			DEFW L281C        ; Exit option handler.
27d2
27d2			; Text for the Calculator menu
27d2
27d2	L27D2:  DEFB 03           ; Number of entries.
27d3			DEFM "Options "
27db			DEFB $FF
27dc			DEFM "Calculato"
27e5			DEFB $80+'r'
27e6			DEFM "Exi"
27e9			DEFB $80+'t'
27ea
27ea			DEFB $80+' '      ; $A0. End marker.
27eb
27eb			; ----------------
27eb			; Tape Loader Text
27eb			; ----------------
27eb
27eb	L27EB:  DEFB $16, $01, $00 ; AT 1,0;
27ee			DEFB $10, $00      ; INK 0;
27f0			DEFB $11, $07      ; PAPER 7;
27f2			DEFB $13, $00      ; BRIGHT 1;
27f4			DEFM "To cancel - press BREAK twic"
2810			DEFB $80+'e'
2811
2811
2811			; =====================
2811			; Menu Handler Routines
2811			; =====================
2811
2811			; -------------------------
2811			; Edit Menu - Screen Option
2811			; -------------------------
2811
2811	L2811:  CALL L269B        ; Toggle between editing in the lower and upper screen areas.
2814			JR   L2874        ; Jump ahead.
2816
2816			; ------------------------------
2816			; Main Menu - Tape Tester Option
2816			; ------------------------------
2816
2816	L2816:  CALL L3857        ; Clear screen and print the "Tape Tester" in the banner.
2819			CALL L3BE9        ; Run the tape tester, exiting via the 'Exit' option menu handler.
281c
281c			; -----------------------------------------
281c			; Edit Menu / Calculator Menu - Exit Option
281c			; -----------------------------------------
281c
281c	L281C:  LD   HL,$EC0D     ; Editor flags.
281f			RES  6,(HL)       ; Indicate main screen editing.
2821			CALL L28BE        ; Reset Cursor Position.
2824
2824			LD   B,$00        ; Top row to clear.
2826			LD   D,$17        ; Bottom row to clear.
2828			CALL L3B5E        ; Clear specified display rows.
282b
282b			CALL L1F20        ; Use Normal RAM Configuration (physical RAM bank 0).
282e			JP   L259F        ; Jump back to show the menu.
2831
2831			; ------------------------------
2831			; Main Menu - Tape Loader Option
2831			; ------------------------------
2831
2831	L2831:  CALL L3852        ; Clear screen and print "Tape Loader" in the banner line.
2834
2834			LD   HL,$5C3C     ; TVFLAG.
2837			SET  0,(HL)       ; Signal using lower screen area.
2839
2839			LD   DE,L27EB     ; Point to message "To cancel - press BREAK twice".
283c			CALL L057D        ; Print the text.
283f
283f			RES  0,(HL)       ; Signal using main screen area.
2841			SET  6,(HL)       ; [This bit is unused in the 48K Spectrum and only ever set in 128K mode via the Tape Loader option.
2843			; It is never subsequently tested or reset. It may have been the intention to use this to indicate that
2843			; the screen requires clearing after loading to remove the "Tape Loader" banner and the lower screen
2843			; message "To cancel - press BREAK twice"]
2843
2843			LD   A,$07        ; Tape Loader mode.
2845			LD   ($EC0E),A    ; [Redundant since call to $1AF1 (ROM 0) will set it to $FF]
2848
2848			LD   BC,$0000     ;
284b			CALL L372B        ; Perform 'Print AT 0,0;'.
284e
284e			JP   L1AF1        ; Run the tape loader.
2851
2851			; ---------------------------
2851			; Edit Menu - Renumber Option
2851			; ---------------------------
2851
2851	L2851:  CALL L3888        ; Run the renumber routine.
2854			CALL NC,L26E7     ; If not successful then produce error beep if required.
2857
2857			LD   HL,$0000     ; There is no current line number.
285a			LD   ($5C49),HL   ; E_PPC. Current line number.
285d			LD   ($EC08),HL   ; Temporary E_PPC used by BASIC Editor.
2860
2860			JR   L2865        ; Jump ahead to display the "128 BASIC" banner if required, set the menu mode and return.
2862
2862			; ------------------------
2862			; Edit Menu - Print Option
2862			; ------------------------
2862
2862	L2862:  CALL L1B14        ; Perform an LLIST.
2865
2865			;Edit Menu - Renumber option joins here
2865
2865	L2865:  LD   HL,$EC0D     ; Editor flags.
2868			BIT  6,(HL)       ; Using lower editing screen?
286a			JR   NZ,L2874     ; Jump ahead if so.
286c
286c	L286C:  LD   HL,$5C3C     ; TVFLAG.
286f			RES  0,(HL)       ; Allow leading space.
2871			CALL L3848        ; Clear screen and print the "128 BASIC" banner line.
2874
2874			;Edit Menu - Screen option joins here
2874
2874	L2874:  LD   HL,$EC0D     ; Editor flags.
2877			RES  5,(HL)       ; Signal not to process the BASIC line.
2879			RES  4,(HL)       ; Signal return to main menu.
287b
287b			LD   A,$00        ; Select Edit menu mode. [Could have saved 1 byte by using XOR A]
287d			LD   HL,L2790     ; Edit Menu jump table.
2880			LD   DE,L27A0     ; Edit Menu text table.
2883			JR   L28B1        ; Store the new mode and menu details.
2885
2885			; -----------------------------
2885			; Main Menu - Calculator Option
2885			; -----------------------------
2885
2885	L2885:  LD   HL,$EC0D     ; Editor flags.
2888			SET  5,(HL)       ; Signal to process the BASIC line.
288a			SET  4,(HL)       ; Signal return to calculator.
288c			RES  6,(HL)       ; Signal editing are is the main screen.
288e
288e			CALL L28BE        ; Reset cursor position.
2891
2891			CALL L384D        ; Clear screen and print "Calculator" in the banner line.
2894
2894			LD   A,$04        ; Set calculator mode.
2896			LD   ($EC0E),A    ; Store mode.
2899
2899			LD   HL,$0000     ; No current line number.
289c			LD   ($5C49),HL   ; E_PPC. Store current line number.
289f
289f			CALL L152F        ; Relist the BASIC program.
28a2
28a2			LD   BC,$0000     ; B=Row. C=Column. Top left of screen.
28a5			LD   A,B          ; Preferred column.
28a6			CALL L29F8        ; Store editing position and print cursor.
28a9
28a9			LD   A,$04        ; Select calculator mode.
28ab			LD   HL,L27CB     ; Calculator Menu jump table
28ae			LD   DE,L27D2     ; Calculator Menu text table
28b1
28b1			;Edit Menu - Print option joins here
28b1
28b1	L28B1:  LD   ($EC0E),A    ; Store mode.
28b4			LD   ($F6EA),HL   ; Store address of current menu jump table.
28b7			LD   ($F6EC),DE   ; Store address of current menu text.
28bb			JP   L2604        ; Return to the Editor.
28be
28be
28be			; ========================
28be			; EDITOR ROUTINES - PART 3
28be			; ========================
28be
28be			; ---------------------
28be			; Reset Cursor Position
28be			; ---------------------
28be
28be	L28BE:  CALL L2E1F        ; Reset to main screen.
28c1			CALL L3A7F        ; Set default main screen editing cursor details.
28c4			JP   L28E8        ; Set default main screen editing settings.
28c7
28c7			; -------------------
28c7			; Return to Main Menu
28c7			; -------------------
28c7
28c7	L28C7:  LD   B,$00        ; Top row of editing area.
28c9			LD   D,$17        ; Bottom row of editing area.
28cb			CALL L3B5E        ; Clear specified display rows.
28ce
28ce			JP   L25AD        ; Jump to show Main menu.
28d1
28d1			; ---------------------------------
28d1			; Main Screen Error Cursor Settings
28d1			; ---------------------------------
28d1			; Main screen editing cursor settings.
28d1			; Gets copied to $F6EE.
28d1
28d1	L28D1:  DEFB $06          ; Number of bytes in table.
28d2			DEFB $00          ; $F6EE = Cursor position - row 0.
28d3			DEFB $00          ; $F6EF = Cursor position - column 0.
28d4			DEFB $00          ; $F6F0 = Cursor position - column 0 preferred.
28d5			DEFB $04          ; $F6F1 = Top row before scrolling up.
28d6			DEFB $10          ; $F6F2 = Bottom row before scrolling down.
28d7			DEFB $14          ; $F6F3 = Number of rows in the editing area.
28d8
28d8			; ---------------------------------
28d8			; Lower Screen Good Cursor Settings
28d8			; ---------------------------------
28d8			; Lower screen editing cursor settings.
28d8			; Gets copied to $F6EE.
28d8
28d8	L28D8:  DEFB $06          ; Number of bytes in table.
28d9			DEFB $00          ; $F6EE = Cursor position - row 0.
28da			DEFB $00          ; $F6EF = Cursor position - column 0.
28db			DEFB $00          ; $F6F0 = Cursor position - column 0 preferred.
28dc			DEFB $00          ; $F6F1 = Top row before scrolling up.
28dd			DEFB $01          ; $F6F2 = Bottom row before scrolling down.
28de			DEFB $01          ; $F6F3 = Number of rows in the editing area.
28df
28df			; ----------------------------------------
28df			; Initialise Lower Screen Editing Settings
28df			; ----------------------------------------
28df			; Used when selecting lower screen. Copies 6 bytes from $28D9 (ROM 0) to $F6EE.
28df
28df	L28DF:  LD   HL,L28D8     ; Default lower screen editing information.
28e2			LD   DE,$F6EE     ; Editing information stores.
28e5			JP   L3FBA        ; Copy bytes.
28e8
28e8			; ---------------------------------------
28e8			; Initialise Main Screen Editing Settings
28e8			; ---------------------------------------
28e8			; Used when selecting main screen. Copies 6 bytes from $28D2 (ROM 0) to $F6EE.
28e8
28e8	L28E8:  LD   HL,L28D1     ; Default main screen editing information.
28eb			LD   DE,$F6EE     ; Editing information stores.
28ee			JP   L3FBA        ; Copy bytes.
28f1
28f1			; -------------------------------
28f1			; Handle Key Press Character Code
28f1			; -------------------------------
28f1			; This routine handles a character typed at the keyboard, inserting it into the Screen Line Edit Buffer
28f1			; as appropriate.
28f1			; Entry: A=Key press character code.
28f1
28f1	L28F1:  LD   HL,$EC0D     ; Editor flags.
28f4			OR   A            ; Clear carry flag. [Redundant instruction since carry flag return state never checked]
28f5			OR   A            ; [Redundant instruction]
28f6			BIT  0,(HL)       ; Is the Screen Line Edit Buffer is full?
28f8			JP   NZ,L29F2     ; Jump if it is to set attribute at editing position so as to show the cursor, and return.
28fb
28fb			RES  7,(HL)       ; Signal got a key press.
28fd			SET  3,(HL)       ; Signal current line has been altered.
28ff
28ff			PUSH HL           ; Save address of the flags.
2900			PUSH AF           ; Save key code.
2901
2901			CALL L29EC        ; Remove cursor, restoring old attribute.
2904
2904			POP  AF           ;
2905			PUSH AF           ; Get and save key code.
2906
2906			CALL L2E81        ; Insert the character into the Screen Line Edit Buffer.
2909
2909			POP  AF           ; Get key code.
290a
290a			LD   A,B          ; B=Current cursor column position.
290b			CALL L2B78        ; Find next Screen Line Edit Buffer editable position to right, moving to next row if necessary.
290e
290e			POP  HL           ; Get address of the flags.
290f			SET  7,(HL)       ; Signal wait for a key.
2911			JP   NC,L29F2     ; Jump if new position not available to set cursor attribute at existing editing position, and return.
2914
2914			LD   A,B          ; A=New cursor column position.
2915			JP   C,L29F8      ; Jump if new position is editable to store editing position and print cursor.
2918			; [This only needs to be JP $29F8 (ROM 0), thereby saving 3 bytes, since a branch to $29F2 (ROM 0) would have been taken above if the carry flag was reset]
2918			JP   L29F2        ; Set attribute at editing position so as to show the cursor, and return.
291b
291b			; --------------------------------
291b			; DELETE-RIGHT Key Handler Routine
291b			; --------------------------------
291b			; Delete a character to the right. An error beep is not produced if there is nothing to delete.
291b			;
291b			; Symbol: DEL
291b			;         -->
291b			;
291b			; Exit: Carry flag set to indicate not to produce an error beep.
291b
291b	L291B:  LD   HL,$EC0D     ; HL points to Editor flags.
291e			SET  3,(HL)       ; Indicate 'line altered'.
2920
2920			CALL L29EC        ; Remove cursor, restoring old attribute. Exit with C=row, B=column.
2923
2923			CALL L2F12        ; Delete character to the right, shifting subsequent rows as required.
2926
2926			SCF               ; Signal do not produce an error beep.
2927			LD   A,B          ; A=The new cursor editing position.
2928			JP   L29F8        ; Store editing position and print cursor, and then return.
292b
292b			; --------------------------
292b			; DELETE Key Handler Routine
292b			; --------------------------
292b			; Delete a character to the left. An error beep is not produced if there is nothing to delete.
292b			;
292b			; Symbol: DEL
292b			;         <--
292b			;
292b			; Exit: Carry flag set to indicate not to produce an error beep.
292b
292b	L292B:  LD   HL,$EC0D     ; HL points to Editor flags.
292e			RES  0,(HL)       ; Signal that the Screen Line Edit Buffer is not full.
2930			SET  3,(HL)       ; Indicate 'line altered'.
2932
2932			CALL L29EC        ; Remove cursor, restoring old attribute. Exit with C=row, B=column.
2935
2935			CALL L2B5B        ; Select previous column position (Returns carry flag set if editable).
2938			CCF               ; Signal do not produce an error beep if not editable.
2939			JP   C,L29F2      ; Jump if not editable to set attribute at editing position so as to show the cursor, and return.
293c
293c			CALL L2F12        ; Delete character to the right, shifting subsequent rows as required.
293f
293f			SCF               ; Signal do not produce an error beep.
2940			LD   A,B          ; A=The new cursor editing position.
2941			JP   L29F8        ; Store editing position and print cursor, and then return.
2944
2944			; -------------------------
2944			; ENTER Key Handler Routine
2944			; -------------------------
2944			; This routine handles ENTER being pressed. If not on a BASIC line then it does nothing. If on an
2944			; unaltered BASIC line then insert a blank row after it and move the cursor to it. If on an altered
2944			; BASIC line then attempt to enter it into the BASIC program, otherwise return to produce an error beep.
2944			; Exit: Carry flag reset to indicate to produce an error beep.
2944
2944	L2944:  CALL L29EC        ; Remove cursor, restoring old attribute.
2947
2947			PUSH AF           ; Save preferred column number.
2948			CALL L30B4        ; DE=Start address in Screen Line Edit Buffer of the row specified in C.
294b			PUSH BC           ; Stack current editing position.
294c			LD   B,$00        ; Column 0.
294e			CALL L2E41        ; Is this a blank row? i.e. Find editable position on this row to the right, returning column number in B.
2951			POP  BC           ; Retrieve current editing position.
2952			JR   C,L295E      ; Jump ahead if editable position found, i.e. not a blank row.
2954
2954			;No editable characters on the row, i.e. a blank row
2954
2954			LD   HL,$0020     ;
2957			ADD  HL,DE        ; Point to the flag byte for the row.
2958			LD   A,(HL)       ; Fetch the flag byte.
2959			CPL               ; Invert it.
295a			AND  $09          ; Keep the 'first row' and 'last row' flags.
295c			JR   Z,L297A      ; Jump if both flags were set indicating not on a BASIC line.
295e
295e			;On a BASIC line
295e
295e	L295E:  LD   A,($EC0D)    ; Editor flags.
2961			BIT  3,A          ; Has the current line been altered?
2963			JR   Z,L296A      ; Jump ahead if not.
2965
2965			;The current BASIC line has been altered
2965
2965			CALL L2C8E        ; Enter line into program.
2968			JR   NC,L297F     ; Jump if syntax error to produce an error beep.
296a
296a	L296A:  CALL L2C4C        ; Find end of the current BASIC line in the Screen Line Edit Buffer, scrolling up rows as required. Returns column number into B.
296d			CALL L2B78        ; Find address of end position in current BASIC line. Returns address into HL.
2970			CALL L2ECE        ; Insert a blank line in the Screen Line Edit Buffer, shifting subsequent rows down.
2973
2973			;Display the cursor on the first column of the next row
2973
2973			LD   B,$00        ; First column.
2975			POP  AF           ; A=Preferred column number.
2976			SCF               ; Signal do not produce an error beep.
2977			JP   L29F8        ; Store editing position and print cursor, and then return.
297a
297a			;Cursor is on a blank row, which is not part of a BASIC line
297a
297a	L297A:  POP  AF           ; Discard stacked item.
297b			SCF               ; Signal do not produce an error beep.
297c			JP   L29F2        ; Set attribute at current editing position so as to show the cursor, and return.
297f
297f			;A syntax error occurred so return signalling to produce an error beep
297f
297f	L297F:  POP  AF           ; Discard stacked item.
2980			JP   L29F2        ; Set attribute at current editing position so as to show the cursor, and return.
2983
2983			; ----------------------------------
2983			; TOP-OF-PROGRAM Key Handler Routine
2983			; ----------------------------------
2983			; Move to the first row of the first line of the BASIC program. An error beep is not produced if there is no program.
2983			;
2983			; Symbol: ------
2983			;         / \/ \
2983			;          |  |
2983			;
2983			; Exit: Carry flag set to indicate not to produce an error beep.
2983
2983	L2983:  LD   A,($EC0E)    ; Fetch mode.
2986			CP   $04          ; Calculator mode?
2988			RET  Z            ; Exit if so.
2989
2989			;Editor mode
2989
2989			CALL L29EC        ; Remove cursor, restoring old attribute.
298c
298c			LD   HL,$0000     ; The first possible line number.
298f
298f			CALL L1F20        ; Use Normal RAM Configuration (physical RAM bank 0).
2992
2992			RST  28H          ; Find address of line number 0, or the next line if it does not exist.
2993			DEFW LINE_ADDR    ; $196E. Return address in HL.
2995			RST  28H          ; Find line number for specified address, and return in DE.
2996			DEFW LINE_NO      ; $1695. DE=Address of first line in the BASIC program.
2998
2998			CALL L1F45        ; Use Workspace RAM configuration (physical RAM bank 7).
299b
299b			LD   ($5C49),DE   ; E_PPC. Store the current line number.
299f
299f			LD   A,$0F        ; Paper 1, Ink 7 - Blue.
29a1			CALL L3A96        ; Set the cursor colour.
29a4
29a4			CALL L152F        ; Relist the BASIC program.
29a7			SCF               ; Signal do not produce an error beep.
29a8			JP   L29F2        ; Set attribute at editing position so as to show the cursor, and return.
29ab
29ab			; ----------------------------------
29ab			; END-OF-PROGRAM Key Handler Routine
29ab			; ----------------------------------
29ab			; Move to the last row of the bottom line of the BASIC program. An error beep is not produced if there is no program.
29ab			;
29ab			; Symbol:   |  |
29ab			;          \ /\ /
29ab			;          ------
29ab			;
29ab			; Exit: Carry flag set to indicate not to produce an error beep.
29ab
29ab	L29AB:  LD   A,($EC0E)    ; Fetch mode.
29ae			CP   $04          ; Calculator mode?
29b0			RET  Z            ; Exit if so.
29b1
29b1			;Editor mode
29b1
29b1			CALL L29EC        ; Remove cursor, restoring old attribute.
29b4
29b4			LD   HL,$270F     ; The last possible line number, 9999.
29b7
29b7			CALL L1F20        ; Use Normal RAM Configuration (physical RAM bank 0).
29ba
29ba			RST  28H          ; Find address of line number 9999, or the previous line if it does not exist.
29bb			DEFW LINE_ADDR    ; $196E. Return address in HL.
29bd
29bd			EX   DE,HL        ; DE=Address of last line number.
29be
29be			RST  28H          ; Find line number for specified address, and return in DE.
29bf			DEFW LINE_NO      ; $1695. DE=Address of last line in the BASIC program.
29c1
29c1			CALL L1F45        ; Use Workspace RAM configuration (physical RAM bank 7).
29c4
29c4			LD   ($5C49),DE   ; E_PPC. Store the current line number.
29c8
29c8			LD   A,$0F        ; Paper 1, Ink 7 - Blue.
29ca			CALL L3A96        ; Set the cursor colour.
29cd
29cd			CALL L152F        ; Relist the BASIC program.
29d0			SCF               ; Signal do not produce an error beep.
29d1			JP   L29F2        ; Set attribute at editing position so as to show the cursor, and return.
29d4
29d4			; -----------------------------
29d4			; WORD-LEFT Key Handler Routine
29d4			; -----------------------------
29d4			; This routine moves to the start of the current word that the cursor is on, or if it is on the first
29d4			; character of a word then it moves to the start of the previous word. If there is no word to move to
29d4			; then signal to produce an error beep.
29d4			;
29d4			; Symbol: <--
29d4			;         <--
29d4			;
29d4			; Exit: Carry flag reset to indicate to produce an error beep.
29d4
29d4	L29D4:  CALL L29EC        ; Remove cursor, restoring old attribute.
29d7
29d7			CALL L2BEA        ; Find start of the current word to the left.
29da			JP   NC,L29F2     ; Jump if no word to the left to restore cursor attribute at current editing position, and return.
29dd			; [Could have saved 4 bytes by joining the routine below, i.e. JR $29E7]
29dd
29dd			LD   A,B          ; A=New cursor column number. Carry flag is set indicating not to produce an error beep.
29de			JP   L29F8        ; Store editing position and print cursor, and then return.
29e1
29e1			; ------------------------------
29e1			; WORD-RIGHT Key Handler Routine
29e1			; ------------------------------
29e1			; This routine moves to the start of the next word. If there is no word to move to then signal to produce an error beep.
29e1			;
29e1			; Symbol: -->
29e1			;         -->
29e1			;
29e1			; Exit: Carry flag reset to indicate to produce an error beep.
29e1
29e1	L29E1:  CALL L29EC        ; Remove cursor, restoring old attribute.
29e4
29e4			CALL L2C09        ; Find start of the current word to the right.
29e7			JR   NC,L29F2     ; Jump if no word to the right to restore cursor attribute at current editing position, and return.
29e9
29e9			LD   A,B          ; A=The new cursor editing column number. Carry is set indicating not to produce an error beep.
29ea			JR   L29F8        ; Store editing position and print cursor, and then return.
29ec
29ec			; -------------
29ec			; Remove Cursor
29ec			; -------------
29ec			; Remove editing cursor colour from current position.
29ec			; Exit: C=row number.
29ec			;       B=Column number.
29ec
29ec	L29EC:  CALL L2A07        ; Get current cursor position (C=row, B=column, A=preferred column).
29ef			JP   L364F        ; Restore previous colour to character square
29f2
29f2			; -----------
29f2			; Show Cursor
29f2			; -----------
29f2			; Set editing cursor colour at current position.
29f2			; Exit: C=row number.
29f2			;       B=Column number.
29f2
29f2	L29F2:  CALL L2A07        ; Get current cursor position (C=row, B=column, A=preferred column).
29f5			JP   L3640        ; Set editing position character square to cursor colour to show it.
29f8			; [Could have saved 1 byte by using a JR instruction to join the end of the routine below]
29f8
29f8			; --------------
29f8			; Display Cursor
29f8			; --------------
29f8			; Set editing cursor position and colour and then show it.
29f8			; Entry: C=Row number.
29f8			;        B=Column number.
29f8			;        A=Preferred column number.
29f8
29f8	L29F8:  CALL L2A11        ; Store new editing position.
29fb
29fb			PUSH AF           ;
29fc			PUSH BC           ;
29fd
29fd			LD   A,$0F        ; Paper 1, Ink 7 - Blue.
29ff			CALL L3A96        ; Store new cursor colour.
2a02
2a02			POP  BC           ;
2a03			POP  AF           ;
2a04
2a04			JP   L3640        ; Set editing position character square to cursor colour to show it.
2a07
2a07			; ---------------------
2a07			; Fetch Cursor Position
2a07			; ---------------------
2a07			; Returns the three bytes of the cursor position.
2a07			; Exit : C=Row number.
2a07			;        B=Column number
2a07			;        A=Preferred column number.
2a07
2a07	L2A07:  LD   HL,$F6EE     ; Editing info.
2a0a			LD   C,(HL)       ; Row number.
2a0b			INC  HL           ;
2a0c			LD   B,(HL)       ; Column number.
2a0d			INC  HL           ;
2a0e			LD   A,(HL)       ; Preferred column number.
2a0f			INC  HL           ;
2a10			RET               ;
2a11
2a11			; ---------------------
2a11			; Store Cursor Position
2a11			; ---------------------
2a11			; Store new editing cursor position.
2a11			; Entry: C=Row number.
2a11			;        B=Column number.
2a11			;        A=Preferred column number.
2a11
2a11	L2A11:  LD   HL,$F6EE     ; Editing information.
2a14			LD   (HL),C       ; Row number.
2a15			INC  HL           ;
2a16			LD   (HL),B       ; Column number.
2a17			INC  HL           ;
2a18			LD   (HL),A       ; Preferred column number.
2a19			RET               ;
2a1a
2a1a			; --------------------------------------------------
2a1a			; Get Current Character from Screen Line Edit Buffer
2a1a			; --------------------------------------------------
2a1a			; Entry: C=Row number.
2a1a			;        B=Column number.
2a1a			; Exit : A=Character.
2a1a
2a1a	L2A1A:  PUSH HL           ;
2a1b
2a1b			CALL L30B4        ; DE=Start address in Screen Line Edit Buffer of the row specified in C.
2a1e			LD   H,$00        ; [Could have saved 2 bytes by calling the unused routine at $2E7B (ROM 0)]
2a20			LD   L,B          ;
2a21			ADD  HL,DE        ; Point to the column position within the row.
2a22			LD   A,(HL)       ; Get character at this position.
2a23
2a23			POP  HL           ;
2a24			RET               ;
2a25
2a25			; ---------------------------------
2a25			; TEN-ROWS-DOWN Key Handler Routine
2a25			; ---------------------------------
2a25			; Move down 10 rows within the BASIC program, attempting to place the cursor as close to the preferred column number as possible.
2a25			; An error beep is produced if there is not 10 rows below.
2a25			;
2a25			; Symbol:  |  |
2a25			;         \ /\ /
2a25			;
2a25			; Exit: Carry flag reset to indicate to produce an error beep.
2a25
2a25	L2A25:  CALL L29EC        ; Remove cursor, restoring old attribute.
2a28			LD   E,A          ; E=Preferred column.
2a29
2a29			LD   D,$0A        ; The ten lines to move down.
2a2b
2a2b	L2A2B:  PUSH DE           ;
2a2c			CALL L2B30        ; Move down to the next row, shifting rows up as appropriate. If moving onto a new BASIC line then
2a2f			POP  DE           ; insert the previous BASIC line into the BASIC program if it has been altered. Returns new row number in C.
2a30			JR   NC,L29F2     ; Jump if there was no row below to set attribute at editing position so as to show the cursor, and return.
2a32
2a32			LD   A,E          ; A=Preferred column.
2a33			CALL L2A11        ; Store cursor editing position.
2a36
2a36			LD   B,E          ; B=Preferred column.
2a37			CALL L2AF9        ; Find closest Screen Line Edit Buffer editable position to the right else to the left, returning column number in B.
2a3a			JR   NC,L2A42     ; Jump if no editable position found on the row, i.e. a blank row.
2a3c
2a3c			DEC  D            ; Decrement row counter.
2a3d			JR   NZ,L2A2B     ; Repeat to move down to the next row.
2a3f
2a3f			LD   A,E          ; A=Preferred column.
2a40			JR   C,L29F8      ; Jump if editable row exists to store editing position and print cursor, and then return.
2a42			; [Redundant check of the carry flag, should just be JR $29F8 (ROM 0)]
2a42
2a42			;A blank row was found below, must be at the end of the BASIC program
2a42
2a42	L2A42:  PUSH DE           ;
2a43			CALL L2B0B        ; Move back up to the previous row.
2a46			POP  DE           ;
2a47
2a47			LD   B,E          ; B=Preferred column.
2a48			CALL L2AF9        ; Find closest Screen Line Edit Buffer editable position to the right else to the left, returning column number in B.
2a4b
2a4b			LD   A,E          ; A=Preferred column.
2a4c			OR   A            ; Carry will be reset indicating to produce an error beep.
2a4d			JR   L29F8        ; Store editing position and print cursor, and then return.
2a4f
2a4f			; -------------------------------
2a4f			; TEN-ROWS-UP Key Handler Routine
2a4f			; -------------------------------
2a4f			; Move up 10 rows within the BASIC program, attempting to place the cursor as close to the preferred column number as possible.
2a4f			; An error beep is produced if there is not 10 rows above.
2a4f			;
2a4f			; Symbol: / \/ \
2a4f			;          |  |
2a4f			;
2a4f			; Exit: Carry flag reset to indicate to produce an error beep.
2a4f
2a4f	L2A4F:  CALL L29EC        ; Remove cursor, restoring old attribute.
2a52			LD   E,A          ; E=Preferred column.
2a53
2a53			LD   D,$0A        ; The ten lines to move up.
2a55
2a55	L2A55:  PUSH DE           ;
2a56			CALL L2B0B        ; Move up to the previous row, shifting rows down as appropriate. If moving onto a new BASIC line then
2a59			POP  DE           ; insert the previous BASIC line into the BASIC program if it has been altered.
2a5a			JR   NC,L29F2     ; Jump if there was no row above to set cursor attribute colour at existing editing position, and return.
2a5c
2a5c			LD   A,E          ; A=Preferred column.
2a5d			CALL L2A11        ; Store cursor editing position.
2a60
2a60			LD   B,E          ; B=Preferred column.
2a61			CALL L2B02        ; Find closest Screen Line Edit Buffer editable position to the left else right, return column number in B.
2a64			JR   NC,L2A6D     ; Jump if no editable positions were found in the row, i.e. it is a blank row.
2a66
2a66			DEC  D            ; Decrement row counter.
2a67			JR   NZ,L2A55     ; Repeat to move up to the previous row.
2a69
2a69			LD   A,E          ; A=Preferred column.
2a6a			JP   C,L29F8      ; Jump if editable row exists to store editing position and print cursor, and then return.
2a6d			; [Redundant check of the carry flag, should just be JP $29F8 (ROM 0)]
2a6d
2a6d			;A blank row was found above, must be at the start of the BASIC program [???? Can this ever be the case?]
2a6d
2a6d	L2A6D:  PUSH AF           ; Save the preferred column number and the flags.
2a6e
2a6e			CALL L2B30        ; Move back down to the next row. Returns new row number in C.
2a71
2a71			LD   B,$00        ; Column 0.
2a73			CALL L2BD4        ; Find editable position in the Screen Line Edit Buffer row to the right, return column position in B.
2a76
2a76			POP  AF           ; A=Preferred column. Carry will be reset indicating to produce an error beep.
2a77			JP   L29F8        ; Store editing position and print cursor, and then return.
2a7a
2a7a			; -------------------------------
2a7a			; END-OF-LINE Key Handler Routine
2a7a			; -------------------------------
2a7a			; Move to the end of the current BASIC line. An error beep is produced if there is no characters in the current BASIC line.
2a7a			;
2a7a			; Symbol: -->|
2a7a			;         -->|
2a7a			;
2a7a			; Exit: Carry flag reset to indicate to produce an error beep and set not to produce an error beep.
2a7a
2a7a	L2A7A:  CALL L29EC        ; Remove cursor, restoring old attribute.
2a7d
2a7d			CALL L2C4C        ; Find the end of the current BASIC line in the Screen Line Edit Buffer.
2a80			JP   NC,L29F2     ; Jump if a blank row to set attribute at existing editing position so as to show the cursor, and return.
2a83
2a83			LD   A,B          ; A=The new cursor editing column number. Carry is set indicating not to produce an error beep.
2a84			JP   L29F8        ; Store editing position and print cursor, and then return.
2a87
2a87			; ---------------------------------
2a87			; START-OF-LINE Key Handler Routine
2a87			; ---------------------------------
2a87			; Move to the start of the current BASIC line. An error beep is produced if there is no characters in the current BASIC line.
2a87			;
2a87			; Symbol: |<--
2a87			;         |<--
2a87			;
2a87			; Exit: Carry flag reset to indicate to produce an error beep.
2a87
2a87	L2A87:  CALL L29EC        ; Remove cursor, restoring old attribute.
2a8a
2a8a			CALL L2C31        ; Find the start of the current BASIC line in the Screen Line Edit Buffer.
2a8d			JP   NC,L29F2     ; Jump if a blank row to set attribute at existing editing position so as to show the cursor, and return.
2a90
2a90			LD   A,B          ; A=The new cursor editing position. Carry is set indicating not to produce an error beep.
2a91			JP   L29F8        ; Store editing position and print cursor, and then return.
2a94
2a94			; -----------------------------
2a94			; CURSOR-UP Key Handler Routine
2a94			; -----------------------------
2a94			; Move up 1 row, attempting to place the cursor as close to the preferred column number as possible.
2a94			; An error beep is produced if there is no row above.
2a94			; Exit: Carry flag reset to indicate to produce an error beep.
2a94
2a94	L2A94:  CALL L29EC        ; Remove cursor, restoring old attribute.
2a97
2a97			LD   E,A          ; E=Preferred column.
2a98			PUSH DE           ;
2a99			CALL L2B0B        ; Move up to the previous row, shifting rows down as appropriate. If moving onto a new BASIC line then
2a9c			POP  DE           ; insert the previous BASIC line into the BASIC program if it has been altered.
2a9d			JP   NC,L29F2     ; Jump if there was no row above to set cursor attribute colour at existing editing position, and return.
2aa0
2aa0			LD   B,E          ; B=Preferred column.
2aa1			CALL L2B02        ; Find closest Screen Line Edit Buffer editable position to the left else right, return column number in B.
2aa4			LD   A,E          ; A=Preferred column.
2aa5			JP   C,L29F8      ; Jump if an editable position was found to store editing position and print cursor, and then return.
2aa8
2aa8			;A blank row was found above, must be at the start of the BASIC program [???? Can this ever be the case?]
2aa8
2aa8			PUSH AF           ; Save the preferred column number and the flags.
2aa9
2aa9			CALL L2B30        ; Move down to the next row, shifting rows up as appropriate. Returns new row number in C.
2aac
2aac			LD   B,$00        ; Column 0.
2aae			CALL L2AF9        ; Find closest Screen Line Edit Buffer editable position to the right.
2ab1
2ab1			POP  AF           ; A=Preferred column. Carry flag is reset indicating to produce an error beep.
2ab2			JP   L29F8        ; Store editing position and print cursor, and then return.
2ab5
2ab5			; -------------------------------
2ab5			; CURSOR-DOWN Key Handler Routine
2ab5			; -------------------------------
2ab5			; Move down 1 row, attempting to place the cursor as close to the preferred column number as possible.
2ab5			; An error beep is produced if there is no row below.
2ab5			; Exit: Carry flag reset to indicate to produce an error beep.
2ab5
2ab5	L2AB5:  CALL L29EC        ; Remove cursor, restoring old attribute.
2ab8
2ab8			LD   E,A          ; E=Preferred column.
2ab9			PUSH DE           ;
2aba			CALL L2B30        ; Move down to the next row, shifting rows up as appropriate. If moving onto a new BASIC line then
2abd			POP  DE           ; insert the previous BASIC line into the BASIC program if it has been altered. Returns new row number in C.
2abe			JP   NC,L29F2     ; Jump if there was no row below to set attribute at editing position so as to show the cursor, and return.
2ac1
2ac1			LD   B,E          ; B=Preferred column.
2ac2			CALL L2B02        ; Find closest Screen Line Edit Buffer editable position to the left else right, return column number in B.
2ac5			LD   A,E          ; A=Preferred column.
2ac6			JP   C,L29F8      ; Jump if an editable position was found to store editing position and print cursor, and then return.
2ac9
2ac9			;A blank row was found above, must be at the start of the BASIC program [???? Can this ever be the case?]
2ac9
2ac9			PUSH DE           ; Save the preferred column.
2aca			CALL L2B0B        ; Move up to the previous row, shifting rows down as appropriate.
2acd			POP  DE           ;
2ace
2ace			LD   B,E          ; B=Preferred column.
2acf			CALL L2AF9        ; Find closest Screen Line Edit Buffer editable position to the right else to the left, returning column number in B.
2ad2
2ad2			LD   A,E          ; A=Preferred column.
2ad3			OR   A            ; Reset carry flag to indicate to produce an error beep.
2ad4			JP   L29F8        ; Store editing position and print cursor, and then return.
2ad7
2ad7			; -------------------------------
2ad7			; CURSOR-LEFT Key Handler Routine
2ad7			; -------------------------------
2ad7			; Move left 1 character, stopping if the start of the first row of the first BASIC line is reached.
2ad7			; An error beep is produced if there is no character to the left or no previous BASIC line to move to.
2ad7			; Exit: Carry flag reset to indicate to produce an error beep.
2ad7
2ad7	L2AD7:  CALL L29EC        ; Remove cursor, restoring old attribute. Returns with C=row, B=column.
2ada
2ada			CALL L2B5B        ; Find next Screen Line Edit Buffer editable position to left, wrapping to previous row as necessary.
2add			JP   C,L29F8      ; Jump if editable position found to store editing position and print cursor, and then return.
2ae0
2ae0			;A blank row was found above, must be at the start of the BASIC program
2ae0
2ae0			JP   L29F2        ; Set cursor attribute at existing editing position, and return. Carry flag is reset indicating to produce an error beep.
2ae3
2ae3			; --------------------------------
2ae3			; CURSOR-RIGHT Key Handler Routine
2ae3			; --------------------------------
2ae3			; Move right 1 character, stopping if the end of the last row of the last BASIC line is reached.
2ae3			; An error beep is produced if there is no character to the right or no next BASIC line to move to.
2ae3			; Exit: Carry flag reset to indicate to produce an error beep.
2ae3
2ae3	L2AE3:  CALL L29EC        ; Remove cursor, restoring old attribute.
2ae6
2ae6			CALL L2B78        ; Find next Screen Line Edit Buffer editable position to right, wrapping to next row if necessary.
2ae9			JP   C,L29F8      ; Jump if editable position found to store editing position and print cursor, and then return.
2aec
2aec			;A blank row was found below, must be at the end of the BASIC program
2aec
2aec			PUSH AF           ; Save the carry flag and preferred column number.
2aed
2aed			CALL L2B0B        ; Move up to the previous row, shifting rows down as appropriate.
2af0
2af0			LD   B,$1F        ; Column 31.
2af2			CALL L2BDF        ; Find the last editable column position searching to the left, returning the column number in B. (Returns carry flag set if there is one)
2af5			;
2af5			POP  AF           ; Carry flag is reset indicating to produce an error beep.
2af6			JP   L29F8        ; Store editing position and print cursor, and then return.
2af9
2af9
2af9			; =============================
2af9			; Edit Buffer Routines - Part 1
2af9			; =============================
2af9
2af9			; -----------------------------------------------------------------------------
2af9			; Find Closest Screen Line Edit Buffer Editable Position to the Right else Left
2af9			; -----------------------------------------------------------------------------
2af9			; This routine searches the specified Screen Line Edit Buffer row from the specified column to the right
2af9			; looking for the first editable position. If one cannot be found then a search is made to the left.
2af9			; Entry: B=Column number.
2af9			; Exit : Carry flag set if character at specified column is editable.
2af9			;        B=Number of closest editable column.
2af9			;        HL=Address of closest editable position.
2af9
2af9	L2AF9:  PUSH DE           ;
2afa
2afa			CALL L2BD4        ; Find Screen Line Edit Buffer editable position from previous column (or current column if the previous column does not exist) to the right, return column position in B.
2afd			CALL NC,L2BDF     ; If no editable character found then search to the left for an editable character, return column position in B.
2b00
2b00			POP  DE           ;
2b01			RET               ;
2b02
2b02			; -----------------------------------------------------------------------------
2b02			; Find Closest Screen Line Edit Buffer Editable Position to the Left else Right
2b02			; -----------------------------------------------------------------------------
2b02			; This routine searches the specified Screen Line Edit Buffer row from the specified column to the left
2b02			; looking for the first editable position. If one cannot be found then a search is made to the right.
2b02			; Entry: B=Column number.
2b02			; Exit : Carry flag set if character at specified column is editable.
2b02			;        B=Number of closest editable column.
2b02			;        HL=Address of closest editable position.
2b02
2b02	L2B02:  PUSH DE           ;
2b03
2b03			CALL L2BDF        ; Find Screen Line Edit Buffer editable position to the left, returning column position in B.
2b06			CALL NC,L2BD4     ; If no editable character found then search from previous column (or current column if the previous column does not exist) to the right, return column position in B.
2b09
2b09			POP  DE           ;
2b0a			RET               ;
2b0b
2b0b			; ----------------------------------------------------------------------------------------------
2b0b			; Insert BASIC Line, Shift Edit Buffer Rows Down If Required and Update Display File If Required
2b0b			; ----------------------------------------------------------------------------------------------
2b0b			; Called from the cursor up and down related key handlers. For example, when cursor up key is pressed the current
2b0b			; BASIC line may need to be inserted into the BASIC program if it has been altered. It may also be necessary
2b0b			; to shift all rows down should the upper scroll threshold be reached. If the cursor was on a blank row between BASIC
2b0b			; lines then it is necessary to shift all BASIC lines below it up, i.e. remove the blank row.
2b0b			; Entry: C=Current cursor row number in the Screen Line Edit Buffer.
2b0b			; Exit : C=New cursor row number in the Screen Line Edit Buffer.
2b0b			;        Carry flag set if a new row was moved to.
2b0b
2b0b	L2B0B:  CALL L2C7C        ; If current BASIC line has been altered and moved off of then insert it into the program.
2b0e			JR   NC,L2B2F     ; Jump if BASIC line was not inserted. [Could have saved 1 byte by using RET NC]
2b10
2b10			PUSH BC           ; Save the new cursor row and column numbers.
2b11
2b11			CALL L30B4        ; DE=Start address in Screen Line Edit Buffer of the row specified in C.
2b14			LD   B,$00        ; Column 0.
2b16			CALL L2E41        ; Is this a blank row? i.e. Find editable position on this row to the right, returning column number in B.
2b19			CALL NC,L2F80     ; If no editable position found then the cursor is on a blank row so shift all BASIC lines below it up to close the gap.
2b1c
2b1c			POP  BC           ; Retrieve the new cursor row and column numbers.
2b1d
2b1d			LD   HL,$F6F1     ; Point to the editing area information.
2b20			LD   A,(HL)       ; Fetch the upper scroll threshold.
2b21			CP   C            ; Is it on the threshold?
2b22			JR   C,L2B2D      ; Jump if on a row below the threshold.
2b24
2b24			;The upper row threshold for triggering scrolling the screen has been reached so proceed to scroll down one row
2b24
2b24			PUSH BC           ; Save the new cursor row and column numbers.
2b25			CALL L166F        ; Shift all edit buffer rows down, and update display file if required.
2b28			POP  BC           ;
2b29			RET  C            ; Return if edit buffer rows were shifted.
2b2a
2b2a			;The edit buffer rows were not shifted down
2b2a
2b2a			LD   A,C          ; On the top row of the editing area?
2b2b			OR   A            ;
2b2c			RET  Z            ; Return with carry flag reset if on the top row.
2b2d
2b2d	L2B2D:  DEC  C            ; Move onto the previous row.
2b2e			SCF               ; Signal a new row was moved to.
2b2f
2b2f	L2B2F:  RET               ;
2b30
2b30			; --------------------------------------------------------------------------------------------
2b30			; Insert BASIC Line, Shift Edit Buffer Rows Up If Required and Update Display File If Required
2b30			; --------------------------------------------------------------------------------------------
2b30			; Called from the cursor up and down related key handlers. For example, when cursor down key is pressed the current
2b30			; BASIC line may need to be inserted into the BASIC program if it has been altered. It may also be necessary
2b30			; to shift all rows up should the lower scroll threshold be reached. If the cursor was on a blank row between BASIC
2b30			; lines then it is necessary to shift all BASIC lines below it up, i.e. remove the blank row.
2b30			; Entry: C=Current cursor row number in the Screen Line Edit Buffer.
2b30			; Exit : C=New cursor row number in the Screen Line Edit Buffer.
2b30			;        Carry flag set if a new row was moved to.
2b30
2b30	L2B30:  PUSH BC           ; Save row number.
2b31
2b31			CALL L30B4        ; DE=Start address in Screen Line Edit Buffer of row held in C, i.e. the new cursor row.
2b34			LD   B,$00        ; Column 0.
2b36			CALL L2E41        ; Is this a blank row? i.e. Find editable position on this row to the right, returning column number in B.
2b39
2b39			POP  BC           ; Get row number.
2b3a			JR   C,L2B3F      ; Jump if editable position found, i.e. the row exists. [Could have saved 2 bytes by using JP NC,$2F80 (ROM 0)]
2b3c
2b3c			JP   L2F80        ; Cursor is on a blank row so shift all BASIC lines below it up to close the gap.
2b3f
2b3f	L2B3F:  CALL L2C68        ; Insert the BASIC Line into the BASIC program if the line has been altered.
2b42			JR   NC,L2B5A     ; Jump if the line was inserted into the program. [Could have saved 1 byte by using RET NC]
2b44
2b44			;The BASIC line was not inserted into the program. C=New cursor row number, B=New cursor column number, A=New cursor preferred column number
2b44
2b44			LD   HL,$F6F1     ; Point to the editing area information.
2b47			INC  HL           ; Point to the 'Bottom Row Scroll Threshold' value. [Could have saved 1 byte by using LD HL,$F6F2]
2b48			LD   A,C          ; Fetch the new cursor row number.
2b49			CP   (HL)         ; Is it on the lower scroll threshold?
2b4a			JR   C,L2B58      ; Jump if on a row above the threshold.
2b4c
2b4c			;The lower row threshold for triggering scrolling the screen has been reached so proceed to scroll up one row
2b4c
2b4c			PUSH BC           ; Save the new cursor row and column numbers.
2b4d			PUSH HL           ; Save the editing area information address.
2b4e			CALL L1639        ; Shift all edit buffer rows up, and update display file if required.
2b51			POP  HL           ;
2b52			POP  BC           ;
2b53			RET  C            ; Return if edit buffer rows were shifted.
2b54
2b54			;The edit buffer rows were not shifted up
2b54
2b54			INC  HL           ; Point to the 'Number of Rows in the Editing Area' value.
2b55			LD   A,(HL)       ; A=Number of rows in the editing area.
2b56			CP   C            ; On the last row of the editing area?
2b57			RET  Z            ; Return with carry flag reset if on the bottom row.
2b58
2b58	L2B58:  INC  C            ; Move onto the next row.
2b59			SCF               ; Signal a new row was moved to.
2b5a
2b5a	L2B5A:  RET               ;
2b5b
2b5b			; ---------------------------------------------------------------------------------------
2b5b			; Find Next Screen Line Edit Buffer Editable Position to Left, Wrapping Above if Required
2b5b			; ---------------------------------------------------------------------------------------
2b5b			; This routine searches to the left to see if an editable position exists. If there is no editable position
2b5b			; available to the left on the current row then the previous row is examined from the last column position.
2b5b			; Entry: B=Column number.
2b5b			;        Carry flag reset.
2b5b			; Exit : Carry flag set if a position to the 'left' exists.
2b5b			;        B=Number of new editable position.
2b5b			;        HL=Address of new editable position.
2b5b
2b5b	L2B5B:  LD   D,A          ; Save the key code character.
2b5c
2b5c			DEC  B            ; Back one column position.
2b5d			JP   M,L2B66      ; Jump if already at beginning of row.
2b60
2b60			LD   E,B          ; E=Column number.
2b61			CALL L2BDF        ; Find Screen Line Edit Buffer editable position to the left, returning column position in B.
2b64			LD   A,E          ; A=Column number.
2b65			RET  C            ; Return if the new column is editable, i.e. the cursor can be moved within this row.
2b66
2b66			;Wrap above to the previous row
2b66
2b66	L2B66:  PUSH DE           ; E=Store the column number.
2b67			CALL L2B0B        ; Move up to the previous row, shifting rows down as appropriate. If moving onto a new BASIC line then
2b6a			POP  DE           ; insert the previous BASIC line into the BASIC program if it has been altered.
2b6b			LD   A,E          ; A=Column number.
2b6c			RET  NC           ; Return if there was no row above.
2b6d
2b6d			;A row above exists
2b6d
2b6d			LD   B,$1F        ; Column 31.
2b6f			CALL L2BDF        ; Find the last editable column position searching to the left, returning the column number in B. (Returns carry flag set if there is one)
2b72			LD   A,B          ; A=Column number of the closest editable position.
2b73			RET  C            ; Return if an editable position was found, i.e. the cursor can be moved.
2b74
2b74			;Return column 0
2b74
2b74			LD   A,D          ; Restore the key code character.
2b75			LD   B,$00        ; Set column position 0.
2b77			RET               ; [*BUG* - This should really ensure the carry flag is reset to signal that no editable position to the left exists, e.g. by using OR A.
2b78			; Fortunately, the carry flag is always reset when this routine is called and so the bug is harmless. Credit: Paul Farrow]
2b78
2b78			; ----------------------------------------------------------------------------------------
2b78			; Find Next Screen Line Edit Buffer Editable Position to Right, Wrapping Below if Required
2b78			; ----------------------------------------------------------------------------------------
2b78			; This routine searches to the right to see if an editable position exists. If there is no editable position
2b78			; available to the right on the current row then the next row is examined from the first column position.
2b78			; The routine is also called when a character key has been pressed and in this case if the cursor moves to the next
2b78			; row then a blank row is inserted and all affected rows are shifted down.
2b78			; Entry: B=Column number.
2b78			;        C=Row number.
2b78			; Exit : Carry flag set if a position to the 'right' exists.
2b78			;        B=Number of closest editable column, i.e. new column number.
2b78			;        A=New column position, i.e. preferred column number or indentation column number.
2b78			;        HL=Address of the new editable position.
2b78
2b78	L2B78:  LD   D,A          ; Save the key code character.
2b79
2b79			INC  B            ; Advance to the next column position.
2b7a			LD   A,$1F        ; Column 31.
2b7c			CP   B            ;
2b7d			JR   C,L2B85      ; Jump if reached end of row.
2b7f
2b7f			;New position is within the row
2b7f
2b7f			LD   E,B          ; E=New column number.
2b80			CALL L2BD4        ; Find Screen Line Edit Buffer editable position from previous column to the right, returning column position in B.
2b83			LD   A,E          ; A=New column number.
2b84			RET  C            ; Return if the new column is editable, i.e. the cursor can be moved within this row.
2b85
2b85			;Need to wrap below to the next row
2b85
2b85	L2B85:  DEC  B            ; B=Original column position.
2b86			PUSH BC           ; Save original column and row numbers.
2b87			PUSH HL           ; HL=Address of the new editable position.
2b88
2b88			LD   HL,$EC0D     ; Editor flags.
2b8b			BIT  7,(HL)       ; Got a key press?
2b8d			JR   NZ,L2BC0     ; Jump if not.
2b8f
2b8f			;A key is being pressed so need to insert a new row
2b8f
2b8f			CALL L30B4        ; DE=Start address in Screen Line Edit Buffer of the row specified in C.
2b92			LD   HL,$0020     ;
2b95			ADD  HL,DE        ; Point to the flag byte for the current row.
2b96			LD   A,(HL)       ;
2b97			BIT  1,A          ; Does the BASIC line row span onto another row?
2b99			JR   NZ,L2BC0     ; Jump if so to test the next row (it could just be the cursor).
2b9b
2b9b			;The BASIC line row does not span onto another row, i.e. cursor at end of line
2b9b
2b9b			SET  1,(HL)       ; Signal that the row spans onto another row, i.e. a new blank row containing the cursor.
2b9d			RES  3,(HL)       ; Signal that the row is not the last row of the BASIC line.
2b9f
2b9f			LD   HL,$0023     ; Point to the next row.
2ba2			ADD  HL,DE        ;
2ba3			EX   DE,HL        ; DE=Address of the next row. [Redundant calculation as never used. Could have saved 5 bytes]
2ba4
2ba4			POP  HL           ; HL=Address of the new editable position.
2ba5			POP  BC           ; B=Original column number. C=Row number.
2ba6
2ba6			PUSH AF           ; Save flag byte for the previous row.
2ba7			CALL L2B30        ; Move down to the next row, shifting rows up as appropriate. Returns new row number in C.
2baa			POP  AF           ; Retrieve flag byte for the previous row.
2bab
2bab			CALL L30B4        ; DE=Start address in Screen Line Edit Buffer of the new row, as specified in C.
2bae
2bae			LD   HL,$0023     ;
2bb1			ADD  HL,DE        ; HL=Address of the row after the new row.
2bb2			EX   DE,HL        ; DE=Address of the row after the new row. HL=Address of the new row.
2bb3
2bb3			RES  0,A          ; Signal 'not the start row of the BASIC line'.
2bb5			SET  3,A          ; Signal 'end row of the BASIC line'.
2bb7
2bb7			CALL L2ED3        ; Insert a blank row into the Screen Edit Buffer at row specified by C, shifting rows down.
2bba
2bba			; [*BUG* - When typing a line that spills over onto a new row, the new row needs to be indented. However, instead of the newly inserted
2bba			;          row being indented, it is the row after it that gets indented. The indentation occurs within the Screen Line Edit Buffer and is not
2bba			;          immediately reflected in the display file. When the newly typed line is executed or inserted into the program area, the Screen Line Edit Buffer
2bba			;          gets refreshed and hence the effect of the bug is never normally seen. The bug can be fixed by inserting the following instructions. Credit: Paul Farrow.
2bba			;
2bba			;       LD   HL,$FFDD     ; -35.
2bba			;       ADD  HL,DE
2bba			;       EX   DE,HL        ; DE=Points to the start of the previous row.]
2bba
2bba			CALL L35F4        ; Indent the row by setting the appropriate number of null characters in the current Screen Line Edit Buffer row.
2bbd
2bbd			LD   A,B          ; A=First column after indentation.
2bbe			SCF               ; Signal not to produce an error beep.
2bbf			RET               ;
2bc0
2bc0			;Wrap below to the next row. Either a key was not being pressed, or a key was being pressed and the BASIC line spans onto a row below (which could contain the cursor only)
2bc0
2bc0	L2BC0:  POP  HL           ; HL=Address of the new editable position.
2bc1			POP  BC           ; B=Original column position.
2bc2
2bc2			PUSH DE           ; E=New column number.
2bc3			CALL L2B30        ; Move down to the next row, shifting rows up as appropriate. If moving onto a new BASIC line then
2bc6			POP  DE           ; insert the previous BASIC line into the BASIC program if it has been altered. Returns new row number in C.
2bc7			LD   A,B          ; A=Original column position.
2bc8			RET  NC           ; Return if there was no row below.
2bc9
2bc9			;A row below exists
2bc9
2bc9			LD   B,$00        ; Column 0.
2bcb			CALL L2BD4        ; Find Screen Line Edit Buffer editable position to the right, returning column position in B.
2bce			LD   A,B          ; A=New column position.
2bcf			RET  C            ; Return if an editable position was found, i.e. the cursor can be moved.
2bd0
2bd0			;Return column 0
2bd0
2bd0			LD   A,E          ; A=Preferred column number.
2bd1			LD   B,$00        ; Column 0.
2bd3			RET               ; Return with carry flag reset.
2bd4
2bd4			; --------------------------------------------------------------------------------
2bd4			; Find Screen Line Edit Buffer Editable Position from Previous Column to the Right
2bd4			; --------------------------------------------------------------------------------
2bd4			; This routine finds the first editable character position in the specified Screen Line Edit Buffer row from the previous column to the right.
2bd4			; It first checks the current column, then the previous column and then the columns to the right. The column containing the first non-null
2bd4			; character encountered is returned.
2bd4			; Entry: B=Column number to start searching from.
2bd4			;        C=Row number.
2bd4			; Exit : Carry flag set if an editable character was found.
2bd4			;        B=Number of closest editable column.
2bd4
2bd4	L2BD4:  PUSH DE           ; Save registers.
2bd5			PUSH HL           ;
2bd6
2bd6			CALL L30B4        ; DE=Start address in Screen Line Edit Buffer of the row specified in C.
2bd9			CALL L2E41        ; Find editable position on this row from the previous column to the right, returning column number in B.
2bdc
2bdc			JP   L2C65        ; Restore registers and return. [Could have saved a byte by using JR $2C07 (ROM 0)]
2bdf
2bdf			; ----------------------------------------------------------
2bdf			; Find Screen Line Edit Buffer Editable Position to the Left
2bdf			; ----------------------------------------------------------
2bdf			; This routine finds the first editable character position in the Screen Line Edit Buffer row from the current column to the left.
2bdf			; It first checks the current column and returns this if it contains an editable character. Otherwise it searches the columns to
2bdf			; the left and if an editable character is found then it returns the column to the right of it.
2bdf			; Entry: B=Column number to start searching from.
2bdf			;        C=Row number.
2bdf			; Exit : Carry flag set if an editable character was found.
2bdf			;        B=Number of the column after the editable position.
2bdf
2bdf	L2BDF:  PUSH DE           ; Save registers.
2be0			PUSH HL           ;
2be1
2be1			CALL L30B4        ; DE=Start address in Screen Line Edit Buffer of the row specified in C.
2be4			CALL L2E63        ; Find editable position from current column to the left, returning the column number in B.
2be7
2be7			JP   L2C65        ; Restore registers and return. [Could have saved a byte by using JR $2C07 (ROM 0)]
2bea
2bea			; -----------------------------------------------------
2bea			; Find Start of Word to Left in Screen Line Edit Buffer
2bea			; -----------------------------------------------------
2bea			; This routine searches for the start of the current word to the left within the current Screen Line Edit Buffer.
2bea			; It is called from the WORD-LEFT key handler routine.
2bea			; Entry: C=Row number.
2bea			; Exit : Carry flag set if word to the left is found.
2bea			;        B=Column position of the found word.
2bea
2bea	L2BEA:  PUSH DE           ; Save registers.
2beb			PUSH HL           ;
2bec
2bec			;Search towards the left of this row until a space or start of line is found
2bec
2bec	L2BEC:  CALL L2B5B        ; Find next Screen Line Edit Buffer editable position to left, moving to next row if necessary.
2bef			JR   NC,L2C07     ; Jump if not editable, i.e. at start of line.
2bf1
2bf1	L2BF1:  CALL L2A1A        ; Get character at new position.
2bf4			CP   ' '          ; $20. Is it a space?
2bf6			JR   Z,L2BEC      ; Jump back if it is, until a non-space or start of line is found.
2bf8
2bf8			;Search towards the left of this row until the start of the word or start of the line is found
2bf8
2bf8	L2BF8:  CALL L2B5B        ; Find next Screen Line Edit Buffer editable position to left, moving to next row if necessary.
2bfb			JR   NC,L2C07     ; Jump if not editable, i.e. at start of line.
2bfd
2bfd			CALL L2A1A        ; Get character at new position.
2c00			CP   ' '          ; $20. Is it a space?
2c02			JR   NZ,L2BF8     ; Jump back if it is not, until a space or start of line is found.
2c04
2c04			;A space prior to the word was found
2c04
2c04			CALL L2B78        ; Find next Screen Line Edit Buffer editable position to right to start of the word, moving to next row if necessary.
2c07			; [Returns carry flag set since the character will exist]
2c07
2c07	L2C07:  JR   L2C65        ; Jump forward to restore registers and return.
2c09
2c09			; ------------------------------------------------------
2c09			; Find Start of Word to Right in Screen Line Edit Buffer
2c09			; ------------------------------------------------------
2c09			; This routine searches for the start of the current word to the right within the current Screen Line Edit Buffer.
2c09			; It is called from the WORD-RIGHT key handler routine.
2c09			; Entry: C=Row number.
2c09			; Exit : Carry flag set if word to the right is found.
2c09			;        B=Column position of the found word.
2c09
2c09	L2C09:  PUSH DE           ; Save registers.
2c0a			PUSH HL           ;
2c0b
2c0b			;Search towards the right of this row until a space or end of line is found
2c0b
2c0b	L2C0B:  CALL L2B78        ; Find next Screen Line Edit Buffer editable position to right, moving to next row if necessary.
2c0e			JR   NC,L2C2B     ; Jump if none editable, i.e. at end of line.
2c10
2c10			CALL L2A1A        ; Get character at new position.
2c13			CP   ' '          ; $20. Is it a space?
2c15			JR   NZ,L2C0B     ; Jump back if it is not, until a space or end of line is found.
2c17
2c17			;Search towards the right of this row until the start of a new word or end of the line is found
2c17
2c17	L2C17:  CALL L2B78        ; Find next Screen Line Edit Buffer editable position to right, moving to next row if necessary.
2c1a			JR   NC,L2C2B     ; Jump if none editable, i.e. at end of line.
2c1c
2c1c			CALL L2E41        ; Find editable position on this row from the previous column to the right, returning column number in B.
2c1f			JR   NC,L2C2B     ; Jump if none editable, i.e. at start of next line.
2c21
2c21			CALL L2A1A        ; Get character at new position.
2c24			CP   ' '          ; $20. Is it a space?
2c26			JR   Z,L2C17      ; Loop back until a non-space is found, i.e. start of a word.
2c28
2c28			;Start of new word found
2c28
2c28			SCF               ; Indicate cursor position can be moved.
2c29			JR   L2C65        ; Jump forward to restore registers and return.
2c2b
2c2b			;End of line or start of next line was found
2c2b
2c2b	L2C2B:  CALL NC,L2B5B     ; If no word on this row then find next Screen Line Edit Buffer editable position to left,
2c2e			; moving to previous row if necessary thereby restoring the row number to its original value.
2c2e			; [Carry flag is always reset by here so the test on the flag is unnecessary]
2c2e			OR   A            ; Clear carry flag to indicate cursor position can not be moved.
2c2f			JR   L2C65        ; Jump forward to restore registers and return.
2c31
2c31			; -----------------------------------------------------------
2c31			; Find Start of Current BASIC Line in Screen Line Edit Buffer
2c31			; -----------------------------------------------------------
2c31			; This routine searches for the start of the BASIC line, wrapping
2c31			; to the previous rows as necessary.
2c31			; It is called from the START-OF-LINE key handler routine.
2c31			; Entry: C=Row number.
2c31			; Exit : Carry flag set if row is not blank.
2c31			;        B=New cursor column.
2c31
2c31	L2C31:  PUSH DE           ; Save registers.
2c32			PUSH HL           ;
2c33
2c33	L2C33:  CALL L30B4        ; DE=Start address in Screen Line Edit Buffer of the row specified in C.
2c36			LD   HL,$0020     ;
2c39			ADD  HL,DE        ; Point to flag byte of next row.
2c3a			BIT  0,(HL)       ; On first row of the BASIC line?
2c3c			JR   NZ,L2C45     ; Jump if on the first row of the BASIC line.
2c3e
2c3e			;Not on the first row of the BASIC line
2c3e
2c3e			CALL L2B0B        ; Move up to the previous row, shifting rows down as appropriate. If moving onto a new BASIC line then
2c41			; insert the previous BASIC line into the BASIC program if it has been altered.
2c41			JR   C,L2C33      ; Jump back if still on the same BASIC line, i.e. was not on first row of the BASIC line.
2c43
2c43			JR   L2C65        ; Jump forward to restore registers and return.
2c45
2c45			;On the first row of the BASIC line, so find the starting column
2c45
2c45	L2C45:  LD   B,$00        ; Column 0.
2c47			CALL L2BD4        ; Find Screen Line Edit Buffer editable position to the right, return column position in B. (Returns carry flag reset if blank row)
2c4a			JR   L2C65        ; Jump forward to restore registers and return.
2c4c
2c4c			; ---------------------------------------------------------
2c4c			; Find End of Current BASIC Line in Screen Line Edit Buffer
2c4c			; ---------------------------------------------------------
2c4c			; This routine searches for the end of the BASIC line, wrapping
2c4c			; to the next rows as necessary.
2c4c			; It is called from the END-OF-LINE key handler routine.
2c4c			; Entry: C=Row number.
2c4c			; Exit : Carry flag set if row is not blank.
2c4c			;        B=New cursor column.
2c4c
2c4c	L2C4C:  PUSH DE           ; Save registers.
2c4d			PUSH HL           ;
2c4e
2c4e	L2C4E:  CALL L30B4        ; DE=Start address in Screen Line Edit Buffer of the row specified in C.
2c51			LD   HL,$0020     ;
2c54			ADD  HL,DE        ; Point to flag byte of next row.
2c55			BIT  3,(HL)       ; On last row of the BASIC line?
2c57			JR   NZ,L2C60     ; Jump if on the last row of the BASIC line.
2c59
2c59			;Not on the last row of the BASIC line
2c59
2c59			CALL L2B30        ; Move down to the next row, shifting rows up as appropriate. If moving onto a new BASIC line then
2c5c			; insert the previous BASIC line into the BASIC program if it has been altered. Returns new row number in C.
2c5c			JR   C,L2C4E      ; Jump back if still on the same BASIC line, i.e. was not on last row of the BASIC line.
2c5e
2c5e			JR   L2C65        ; Jump forward to restore registers and return.
2c60
2c60			;On the last row of the BASIC line, so find the last column
2c60
2c60	L2C60:  LD   B,$1F        ; Column 31.
2c62			CALL L2BDF        ; Find the last editable column position searching to the left, returning the column number in B. (Returns carry flag reset if blank row)
2c65
2c65	L2C65:  POP  HL           ; Restore registers.
2c66			POP  DE           ;
2c67			RET               ;
2c68
2c68			; -----------------------------------------
2c68			; Insert BASIC Line into Program if Altered
2c68			; -----------------------------------------
2c68			; Entry: C=Row number.
2c68			; Exit : Carry flag set if BASIC line was not inserted into the program.
2c68
2c68	L2C68:  LD   A,($EC0D)    ; Editor flags.
2c6b			BIT  3,A          ; Has the current line been altered?
2c6d			SCF               ; Signal line not inserted into BASIC program.
2c6e			RET  Z            ; Return if it has not.
2c6f
2c6f			CALL L30B4        ; DE=Start address in Screen Line Edit Buffer of the row specified in C.
2c72			LD   HL,$0020     ;
2c75			ADD  HL,DE        ; HL points to the flag byte for the row.
2c76			BIT  3,(HL)       ; Is this the end of the BASIC line?
2c78			SCF               ; Signal line not inserted into BASIC program.
2c79			RET  Z            ; Return if it is not.
2c7a
2c7a			JR   L2C8E        ; Insert line into BASIC program.
2c7c
2c7c			; -----------------------------------------------------------------------
2c7c			; Insert Line into BASIC Program If Altered and the First Row of the Line
2c7c			; -----------------------------------------------------------------------
2c7c			; Entry: C=Row number.
2c7c			;        B=Column number.
2c7c			; Exit : Carry flag set if successful, reset if a syntax error.
2c7c
2c7c	L2C7C:  LD   A,($EC0D)    ; Editor flags.
2c7f			BIT  3,A          ; Has current line been altered?
2c81			SCF               ; Signal success.
2c82			RET  Z            ; Return if it has not.
2c83
2c83			CALL L30B4        ; DE=Start address in Screen Line Edit Buffer of the row specified in C.
2c86			LD   HL,$0020     ;
2c89			ADD  HL,DE        ; Point to the flag byte for the row.
2c8a			BIT  0,(HL)       ; Is this the first row of the BASIC line?
2c8c			SCF               ; Signal success.
2c8d			RET  Z            ; Return if it is not.
2c8e
2c8e			; ------------------------------
2c8e			; Insert Line into BASIC Program
2c8e			; ------------------------------
2c8e			; This routine parses a line and if valid will insert it into the BASIC program. If in calculator mode
2c8e			; then the line is not inserted into the BASIC program. If a syntax error is found then the location to
2c8e			; show the error marker is determined.
2c8e			; Entry: C=Row number.
2c8e			; Exit : Carry flag reset if a syntax error.
2c8e			;        Carry flag set if the BASIC line was inserted successfully, and C=Cursor row number, B=Cursor column number, A=Preferred cursor column number.
2c8e
2c8e	L2C8E:  LD   A,$02        ; Signal on first row of BASIC line.
2c90
2c90			;Find the start address of the row in the Screen Line Edit Buffer
2c90
2c90	L2C90:  CALL L30B4        ; DE=Start address in Screen Line Edit Buffer of the row specified in C.
2c93			LD   HL,$0020     ;
2c96			ADD  HL,DE        ; Point to the flag byte for the row.
2c97			BIT  0,(HL)       ; First row of the BASIC line?
2c99			JR   NZ,L2CA3     ; Jump ahead if so.
2c9b
2c9b			DEC  C            ; Move to previous row.
2c9c			JP   P,L2C90      ; Jump back until found the first row of the BASIC line or the top of the screen.
2c9f
2c9f			;First row of the BASIC line is above the screen
2c9f
2c9f			LD   C,$00        ; Row 0.
2ca1			LD   A,$01        ; Signal first row of BASIC line above screen.
2ca3
2ca3			;DE=Start address of the first row of the BASIC line
2ca3			;HL=Address of the flag byte for the first row of the BASIC line
2ca3
2ca3	L2CA3:  LD   HL,$EC00     ; BASIC line insertion flags.
2ca6			LD   DE,$EC03     ; BASIC line insertion error flags.
2ca9			OR   $80          ; Signal location of cursor not yet found.
2cab			LD   (HL),A       ;
2cac			LD   (DE),A       ;
2cad
2cad			INC  HL           ;
2cae			INC  DE           ;
2caf			LD   A,$00        ; [Could have saved 1 byte by using XOR A]
2cb1			LD   (HL),A       ; Starting column number of the first visible row of the BASIC line being entered.
2cb2			LD   (DE),A       ;
2cb3
2cb3			INC  HL           ;
2cb4			INC  DE           ;
2cb5			LD   A,C          ; Fetch the row number of the first visible row of the BASIC line being entered.
2cb6			LD   (HL),A       ; Store the start row number of the first visible row of the BASIC line being entered.
2cb7			LD   (DE),A       ;
2cb8
2cb8			LD   HL,$0000     ;
2cbb			LD   ($EC06),HL   ; No editable characters in the line prior to the cursor.
2cbe
2cbe			CALL L335F        ; Copy 'Insert Keyword Representation Into Keyword Construction Buffer' routine to RAM.
2cc1			CALL L3C67        ; Tokenize the typed BASIC line.
2cc4
2cc4			PUSH IX           ; IX=Address of cursor settings.
2cc6
2cc6			CALL L1F20        ; Use Normal RAM Configuration (physical RAM bank 0).
2cc9			CALL L026B        ; Syntax check/execute the command line.
2ccc			CALL L1F45        ; Use Workspace RAM configuration (physical RAM bank 7).
2ccf
2ccf			POP  IX           ; IX=Address of cursor settings.
2cd1
2cd1			LD   A,($5C3A)    ; ERR_NR. Fetch error code.
2cd4			INC  A            ; Was an error code set?
2cd5			JR   NZ,L2CEF     ; Jump ahead if so.
2cd7
2cd7			LD   HL,$EC0D     ; Editor flags.
2cda			RES  3,(HL)       ; Signal line has not been altered.
2cdc
2cdc			CALL L365E        ; Reset to 'L' Mode.
2cdf
2cdf			LD   A,($EC0E)    ; Fetch mode.
2ce2			CP   $04          ; Calculator mode?
2ce4			CALL NZ,L152F     ; If not calculator mode then relist the BASIC program.
2ce7
2ce7			CALL L26FA        ; Produce success beep.
2cea			CALL L2A07        ; Get current cursor position (C=Row, B=Column, A=Preferred column).
2ced
2ced			SCF               ; Set the carry flag to signal that that BASIC line was inserted successfully.
2cee			RET               ;
2cef
2cef			; A syntax error occurred
2cef			; -----------------------
2cef
2cef	L2CEF:  LD   HL,$EC00     ; BASIC line insertion flags.
2cf2			LD   DE,$EC03     ; BASIC line insertion error flags.
2cf5			LD   A,(DE)       ; Fetch the BASIC line insertion error flags.
2cf6			RES  7,A          ; Signal location of cursor found.
2cf8			LD   (HL),A       ; Update the BASIC line insertion flags with the error flags.
2cf9
2cf9			INC  HL           ;
2cfa			INC  DE           ;
2cfb			LD   A,(DE)       ;
2cfc			LD   (HL),A       ; Restore the initial column number, i.e. column 0.
2cfd
2cfd			INC  HL           ;
2cfe			INC  DE           ;
2cff			LD   A,(DE)       ;
2d00			LD   (HL),A       ; Restore the initial row number, i.e. row number of the first visible row of the BASIC line being entered.
2d01
2d01			CALL L3C63        ; Locate the position to insert the error marker into the typed BASIC line.
2d04			JR   C,L2D0A      ; Jump if the error marker was found.
2d06
2d06			;Assume the error maker is at the same position as the cursor
2d06
2d06			LD   BC,($EC06)   ; Fetch the number of editable characters in the line prior to the cursor within the Screen Line Edit Buffer.
2d0a
2d0a			;The position of the error marker within the typed BASIC line has been determined. Now shift the cursor to the corresponding position on the screen.
2d0a
2d0a	L2D0A:  LD   HL,($EC06)   ; Fetch the number of editable characters in the line prior to the cursor within the Screen Line Edit Buffer.
2d0d			OR   A            ;
2d0e			SBC  HL,BC        ; HL=Difference between the cursor and the error marker positions (negative if the error marker is after the cursor).
2d10
2d10			PUSH AF           ; Save the flags.
2d11			PUSH HL           ; HL=Difference between the cursor and error marker.
2d12			CALL L2A07        ; Get current cursor position, returning C=row number, B=column number, A=preferred column number.
2d15			POP  HL           ; HL=Difference between the cursor and error marker.
2d16			POP  AF           ; Restore the flags.
2d17			JR   C,L2D2A      ; Jump if error marker is after the cursor position.
2d19
2d19			JR   Z,L2D45      ; Jump if cursor is at the same location as the error marker.
2d1b
2d1b			;The error marker is before the cursor position. Move the cursor back until it is at the same position as the error marker.
2d1b
2d1b	L2D1B:  PUSH HL           ; Save the number of positions to move.
2d1c			LD   A,B          ; B=Cursor column number.
2d1d			CALL L2B5B        ; Find previous editable position to the left in the Screen Line Edit Buffer, moving to previous row if necessary.
2d20			POP  HL           ; Retrieve the number of positions to move.
2d21			JR   NC,L2D45     ; Jump if no previous editable position exists.
2d23
2d23			DEC  HL           ; Decrement the number of positions to move.
2d24			LD   A,H          ;
2d25			OR   L            ;
2d26			JR   NZ,L2D1B     ; Jump back if the cursor position requires further moving.
2d28
2d28			JR   L2D45        ; Jump ahead to continue.
2d2a
2d2a			;The error marker is after the cursor position. Move the cursor back until it is at the same position as the error marker.
2d2a
2d2a	L2D2A:  PUSH HL           ; Save the number of positions that the error marker is before the cursor. This will be a
2d2b			; negative number is the cursor is after the error marker.
2d2b
2d2b	L2D2B:  LD   HL,$EC0D     ; Editor flags.
2d2e			RES  7,(HL)       ; Signal 'got a key press'. Used in routine at $2B78 (ROM 0) to indicate that a new character has caused the need to shift the cursor position.
2d30
2d30			POP  HL           ; Retrieve the negative difference in the cursor and error marker positions.
2d31			EX   DE,HL        ; DE=Negative difference in the cursor and error marker positions.
2d32
2d32			LD   HL,$0000     ; Make the negative difference a positive number by subtracting it from 0.
2d35			OR   A            ;
2d36			SBC  HL,DE        ; HL=Positive difference in the cursor and error marker positions.
2d38
2d38	L2D38:  PUSH HL           ; Save the number of positions to move.
2d39			LD   A,B          ; B=Cursor column number.
2d3a			CALL L2B78        ; Find next editable position to the right in the Screen Line Edit Buffer, moving to next row if necessary.
2d3d			POP  HL           ; Retrieve the number of positions to move.
2d3e			JR   NC,L2D45     ; Jump if no next editable position exists.
2d40
2d40			DEC  HL           ; Decrement the number of positions to move.
2d41			LD   A,H          ;
2d42			OR   L            ;
2d43			JR   NZ,L2D38     ; Jump back if the cursor position requires further moving.
2d45
2d45			;The cursor position is at the location of the error marker position
2d45
2d45	L2D45:  LD   HL,$EC0D     ; Editor flags.
2d48			SET  7,(HL)       ; Set 'waiting for key press' flag.
2d4a
2d4a			; [*BUG* - When moving the cursor up or down, an attempt is made to place the cursor at the same column position that it had on the previous row (the preferred column).
2d4a			;          If this is not possible then the cursor is placed at the end of the row. However, it is the intention that the preferred column is still remembered
2d4a			;          and hence an attempt is made to place the cursor at this column whenever it is subsequently moved. However, a bug at this point in the ROM causes
2d4a			;          the preferred column position for the cursor to be overwritten with random data. If the cursor was moved from its original position
2d4a			;          into its error position then the preferred column gets set to zero and the next up or down cursor movement will cause the cursor marker
2d4a			;          to jump to the left-hand side of the screen. However, if the cursor remained in the same position then the preferred column gets set to
2d4a			;          a random value and so on the next up or down cursor movement the cursor marker can jump to a random position on the screen. The bug can
2d4a			;          can reproduced by typing a line that is just longer than one row, pressing enter twice and then cursor down. The cursor marker will probably
2d4a			;          jump somewhere in the middle of the screen. Press an arrow again and the computer may even crash. Credit: Ian Collier (+3), Andrew Owen (128)]
2d4a
2d4a			; [The bug can be fixed by pre-loading the A register with the current preferred column number. Credit: Paul Farrow.
2d4a			;
2d4a			;       LD   A,($F6F0)    ; Fetch the preferred column position.]
2d4a
2d4a			CALL L2A11        ; Store cursor editing position.
2d4d
2d4d			LD   A,$17        ; Paper 2, Ink 7 - Red.
2d4f			CALL L3A96        ; Set the cursor colour to show the position of the error.
2d52
2d52			OR   A            ; Reset the carry flag to signal that a syntax error occurred.
2d53			RET               ;
2d54
2d54			; ----------------------------------------------
2d54			; Fetch Next Character from BASIC Line to Insert
2d54			; ----------------------------------------------
2d54			; This routine fetches a character from the BASIC line being inserted. The line may span above or below the screen, and so the character
2d54			; is retrieved from the appropriate buffer.
2d54			; Exit : A=Character fetched from the current position, or 'Enter' if end of line found.
2d54
2d54	L2D54:  LD   HL,$EC00     ; Point to the 'insert BASIC line' details.
2d57			BIT  7,(HL)       ; Has the column with the cursor been found?
2d59			JR   Z,L2D62      ; Jump if it has been found.
2d5b
2d5b			LD   HL,($EC06)   ;
2d5e			INC  HL           ; Increment the count of the number of editable characters in the BASIC line up to the cursor.
2d5f			LD   ($EC06),HL   ;
2d62
2d62	L2D62:  LD   HL,$EC00     ; Point to the 'insert BASIC line' details.
2d65			LD   A,(HL)       ; Fetch flags.
2d66			INC  HL           ;
2d67			LD   B,(HL)       ; Fetch the column number of the character being examined.
2d68			INC  HL           ;
2d69			LD   C,(HL)       ; Fetch the row number of the character being examined.
2d6a			PUSH HL           ;
2d6b			AND  $0F          ; Extract the status code.
2d6d
2d6d			;Register A:
2d6d			;  Bit 0: 1=First row of the BASIC line off top of screen.
2d6d			;  Bit 1: 1=On first row of the BASIC line.
2d6d			;  Bit 2: 1=Using lower screen and only first row of the BASIC line visible.
2d6d			;  Bit 3: 1=At end of last row of the BASIC line (always 0 at this point).
2d6d
2d6d			LD   HL,L2D85     ; Jump table to select appropriate handling routine.
2d70			CALL L3FCE        ; Call handler routine.
2d73
2d73			;Register L:
2d73			;  $01 - A character was returned from the Above-Screen Line Edit Buffer row.
2d73			;  $02 - A character was returned from the Screen Line Edit Buffer row.
2d73			;  $04 - A character was returned from the Below-Screen Line Edit Buffer row.
2d73			;  $08 - At the end of the last row of the BASIC line.
2d73			;Register A holds the character fetched or 'Enter' if at the end of the BASIC line.
2d73
2d73			LD   E,L          ; E=Return status.
2d74			POP  HL           ;
2d75			JR   Z,L2D79      ; Jump if no match found.
2d77
2d77			LD   A,$0D        ; A='Enter' character.
2d79
2d79	L2D79:  LD   (HL),C       ; Save the next character position row to examine.
2d7a			DEC  HL           ;
2d7b			LD   (HL),B       ; Save the next character position column to examine.
2d7c			DEC  HL           ;
2d7d			PUSH AF           ; Save the character.
2d7e			LD   A,(HL)       ; Fetch the current status flags.
2d7f			AND  $F0          ; Keep the upper nibble.
2d81			OR   E            ; Update the location flags that indicate where to obtain the next character from.
2d82			LD   (HL),A       ; Store the status flags.
2d83			POP  AF           ; Retrieve the character.
2d84			RET               ;
2d85
2d85			; -------------------------------
2d85			; Fetch Next Character Jump Table
2d85			; -------------------------------
2d85			; Jump to one of three handling routines when fetching the next character from the BASIC line to insert.
2d85
2d85	L2D85:  DEFB $03           ; Number of table entries.
2d86			DEFB $02           ; On first row of the BASIC line.
2d87			DEFW L2DAC         ;
2d89			DEFB $04           ; Using lower screen and only first row of the BASIC line visible.
2d8a			DEFW L2DE9         ;
2d8c			DEFB $01           ; First row of the BASIC line off top of screen.
2d8d			DEFW L2D8F         ;
2d8f
2d8f			; -------------------------------------------------------------------------------------
2d8f			; Fetch Character from the Current Row of the BASIC Line in the Screen Line Edit Buffer
2d8f			; -------------------------------------------------------------------------------------
2d8f			; Fetch character from the current row of the BASIC line in the Screen Line Edit Buffer, skipping nulls until the end of
2d8f			; the BASIC line is found.
2d8f			; Entry: C=Row number.
2d8f			; Exit : L=$01 - A character was returned from the Above-Screen Line Edit Buffer row, with A holding the character.
2d8f			;          $02 - A character was returned from the Screen Line Edit Buffer row, with A holding the character.
2d8f			;          $04 - A character was returned from the Below-Screen Line Edit Buffer row, with A holding the character.
2d8f			;          $08 - At the end of the last row of the BASIC line, with A holding an 'Enter' character.
2d8f			;        Zero flag set to indicate a match from the handler table was found.
2d8f
2d8f			;Table entry point - First row of BASIC line off top of screen
2d8f
2d8f	L2D8F:  CALL L32B7        ; Find row address in Above-Screen Line Edit Buffer, return in DE.
2d92
2d92	L2D92:  CALL L2E0E        ; Fetch character from Above-Screen Line Edit Buffer row.
2d95			JR   NC,L2D9E     ; Jump if end of row reached.
2d97
2d97			CP   $00          ; Is it a null character, i.e. not editable?
2d99			JR   Z,L2D92      ; Jump back if so until character found or end of row reached.
2d9b
2d9b			LD   L,$01        ; Signal a character was returned from the Above-Screen Line Edit Buffer row, with A holding the character.
2d9d			RET               ; Return with zero flag reset to indicate match found.
2d9e
2d9e			;End of row reached - no more editable characters in Above-Screen Line Edit Buffer row
2d9e
2d9e	L2D9E:  INC  C            ; Next row.
2d9f			LD   B,$00        ; Column 0.
2da1			LD   HL,($F9DB)   ; [*BUG* - This should be LD HL,$F9DB. The bug manifests itself when Enter is pressed on an edited BASIC line that goes off
2da4			; the top of the screen and causes corruption to that line. The bug at $30D0 (ROM 0) that sets default data for the Below-Screen Line Edit Buffer
2da4			; implies that originally there was the intention to have a pointer into the next location to use within that buffer, and so it seems to
2da4			; reasonable to assume the same arrangement would have been intended for the Above-Screen Line Edit Buffer. If that were the case then the
2da4			; instruction here was intended to fetch the next address within the Above-Screen Line Edit Buffer. Credit: Ian Collier (+3), Andrew Owen (128)]
2da4
2da4			LD   A,C          ; Fetch the row number.
2da5			CP   (HL)         ; Exceeded last row of Above-Screen Line Edit Buffer?
2da6			JR   C,L2D8F      ; Jump back if not exceeded last row the Above-Screen Line Edit Buffer.
2da8
2da8			;All characters from rows off top of screen fetched so continue onto the rows on screen
2da8
2da8			; [Note it is not possible to have more than 20 rows off the top of the screen]
2da8
2da8			LD   B,$00        ; Column 0.
2daa			LD   C,$00        ; Row 0. This is the first visible row of the BASIC line on screen.
2dac
2dac			; Table entry point - On visible row of BASIC line
2dac			; ------------------------------------------------
2dac
2dac			;C=Row number of the first visible row of the BASIC line in the Screen Line Edit Buffer
2dac			;B=Starting column number of the first visible row of the BASIC line in the Screen Line Edit Buffer
2dac
2dac	L2DAC:  PUSH HL           ; Save address of the table entry.
2dad
2dad			LD   HL,$F6EE     ; Point to the cursor position details.
2db0			LD   A,(HL)       ; Fetch the row number of the cursor.
2db1			CP   C            ; Is cursor on the first visible row of the BASIC line?
2db2			JR   NZ,L2DBE     ; Jump if not.
2db4
2db4			;Cursor on first visible row of the BASIC line in the Screen Line Edit Buffer.
2db4
2db4			INC  HL           ;
2db5			LD   A,(HL)       ; Fetch the column number of the cursor.
2db6			CP   B            ; Reached the column with the cursor in the first visible row of the BASIC line?
2db7			JR   NZ,L2DBE     ; Jump if not.
2db9
2db9			LD   HL,$EC00     ; BASIC line insertion flags.
2dbc			RES  7,(HL)       ; Indicate that the column with the cursor has been found.
2dbe
2dbe	L2DBE:  POP  HL           ; Retrieve address of the table entry.
2dbf
2dbf	L2DBF:  CALL L30B4        ; DE=Start address in Screen Line Edit Buffer of the row specified in C.
2dc2			CALL L2E0E        ; Fetch character from Screen Line Edit Buffer row at column held in B, then increment B.
2dc5			JR   NC,L2DCE     ; Jump if end of row reached.
2dc7
2dc7			CP   $00          ; Is the character a null, i.e. not editable?
2dc9			JR   Z,L2DAC      ; Jump back if null to keep fetching characters until a character is found or the end of the row is reached.
2dcb
2dcb			;A character in the current row of the BASIC line was found
2dcb
2dcb			LD   L,$02        ; L=Signal a character was returned from the Screen Line Edit Buffer row, with A holding the character.
2dcd			RET               ; Return with zero flag reset to indicate match found.
2dce
2dce			;End of row reached - no editable characters in the Screen Line Edit Buffer row
2dce
2dce	L2DCE:  LD   HL,$0020     ;
2dd1			ADD  HL,DE        ; Point to the flag byte for the row.
2dd2			BIT  3,(HL)       ; Is it the last row of the BASIC line?
2dd4			JR   Z,L2DDB      ; Jump if not.
2dd6
2dd6			;On last row of the BASIC line and finished fetching characters from the line
2dd6
2dd6			LD   L,$08        ; L=Signal at the end of the last row of the BASIC line.
2dd8			LD   A,$0D        ; A='Enter' character.
2dda			RET               ; Return with zero flag reset to indicate match found.
2ddb
2ddb			;Not on the last row of the BASIC line so move to the beginning of the next, if it is on screen.
2ddb
2ddb	L2DDB:  LD   HL,$F6F3     ; Point to the 'top row scroll threshold' value.
2dde			INC  C            ; Next row of the BASIC line in the Screen Line Edit Buffer.
2ddf			LD   A,(HL)       ; Fetch the number of the last row in the Screen Line Edit Buffer.
2de0			CP   C            ; Exceeded the upper scroll threshold?
2de1			LD   B,$00        ; Column 0.
2de3			JR   NC,L2DBF     ; Jump back if not to retrieve the character from the next row.
2de5
2de5			;The upper row threshold for triggering scrolling the screen has been reached so proceed to scroll up one line
2de5
2de5			LD   B,$00        ; Column 0. [Redundant byte]
2de7			LD   C,$01        ; Row 1. (Row 0 holds a copy of the last row visible on screen)
2de9
2de9			; Table entry point - Using lower screen and only top row of a multi-row BASIC line is visible
2de9			; --------------------------------------------------------------------------------------------
2de9
2de9	L2DE9:  CALL L31C3        ; Find the address of the row specified by C in Below-Screen Line Edit Buffer, into DE.
2dec
2dec	L2DEC:  CALL L2E0E        ; Fetch character from Below-Screen Line Edit Buffer row, incrementing the column number.
2def			JR   NC,L2DF8     ; Jump if end of row reached.
2df1
2df1			CP   $00          ; Is the character a null, i.e. not editable?
2df3			JR   Z,L2DEC      ; Jump back if null to keep fetching characters until a character is found or the end of the row is reached.
2df5
2df5			LD   L,$04        ; L=Signal a character was returned from the Below-Screen Line Edit Buffer row, with A holding the character.
2df7			RET               ; Return with zero flag reset to indicate match found.
2df8
2df8			;End of row reached - no editable characters in the (below screen) Below-Screen Line Edit Buffer row
2df8
2df8	L2DF8:  LD   HL,$0020     ;
2dfb			ADD  HL,DE        ; Point to the flag byte for the row.
2dfc			BIT  3,(HL)       ; Is it the last row of the BASIC line?
2dfe			JR   NZ,L2E09     ; Jump if so.
2e00
2e00			INC  C            ; Next row.
2e01			LD   B,$00        ; Column 0.
2e03
2e03			LD   A,($F6F5)    ; Fetch number of rows in the Below-Screen Line Edit Buffer.
2e06			CP   C            ; Exceeded last line in Below-Screen Line Edit Buffer?
2e07			JR   NC,L2DE9     ; Jump back if not to retrieve the character from the next row.
2e09
2e09			;All characters from rows off bottom of screen fetched so return an 'Enter'
2e09
2e09			; [Note it is not possible to have more than 20 rows off the bottom of the screen]
2e09
2e09	L2E09:  LD   L,$08        ; L=Signal at the end of the last row of the BASIC line.
2e0b			LD   A,$0D        ; A='Enter' character.
2e0d			RET               ; Return with zero flag reset to indicate match found.
2e0e
2e0e			; ------------------------------------
2e0e			; Fetch Character from Edit Buffer Row
2e0e			; ------------------------------------
2e0e			; Entry: B =Column number.
2e0e			;        DE=Start address of row in Edit Buffer.
2e0e			; Exit : Carry flag set indicates character fetched, reset if column out of range.
2e0e
2e0e	L2E0E:  LD   A,$1F        ; Column 31.
2e10			CP   B            ; Is column
2e11			CCF               ;
2e12			RET  NC           ; Return if B is greater than 31.
2e13
2e13			LD   L,B          ;
2e14			LD   H,$00        ; HL=Column number.
2e16			ADD  HL,DE        ;
2e17			LD   A,(HL)       ; Fetch the character at the specified column.
2e18			INC  B            ; Increment the column number.
2e19			SCF               ; Signal character fetched.
2e1a			RET               ;
2e1b
2e1b			; -----------------------
2e1b			; Upper Screen Rows Table
2e1b			; -----------------------
2e1b			; Copied to $EC15-$EC16.
2e1b
2e1b	L2E1B:  DEFB $01          ; Number of bytes to copy.
2e1c			DEFB $14          ; Number of editing rows (20 for upper screen).
2e1d
2e1d			; -----------------------
2e1d			; Lower Screen Rows Table
2e1d			; -----------------------
2e1d			; Copied to $EC15-$EC16.
2e1d
2e1d	L2E1D:  DEFB $01          ; Number of bytes to copy.
2e1e			DEFB $01          ; Number of editing rows (1 for lower screen).
2e1f
2e1f			; --------------------
2e1f			; Reset to Main Screen
2e1f			; --------------------
2e1f
2e1f	L2E1F:  LD   HL,$5C3C     ; TVFLAG.
2e22			RES  0,(HL)       ; Signal using main screen.
2e24			LD   HL,L2E1B     ; Upper screen lines table.
2e27			LD   DE,$EC15     ; Destination workspace variable. The number of editing rows on screen.
2e2a			JP   L3FBA        ; Copy one byte from $2E1C (ROM 0) to $EC15
2e2d
2e2d			; ---------------------
2e2d			; Reset to Lower Screen
2e2d			; ---------------------
2e2d
2e2d	L2E2D:  LD   HL,$5C3C     ; TVFLAG.
2e30			SET  0,(HL)       ; Signal using lower screen.
2e32
2e32			LD   BC,$0000     ;
2e35			CALL L372B        ; Perform 'PRINT AT 0,0;'.
2e38
2e38			LD   HL,L2E1D     ; Lower screen lines table.
2e3b			LD   DE,$EC15     ; Destination workspace variable. The number of editing rows on screen.
2e3e			JP   L3FBA        ; Copy one byte from $2E1E (ROM 0) to $EC15
2e41
2e41			; --------------------------------------------------------------------
2e41			; Find Edit Buffer Editable Position from Previous Column to the Right
2e41			; --------------------------------------------------------------------
2e41			; This routine finds the first editable character position in the specified edit buffer row from the previous column to the right.
2e41			; It first checks the current column, then the previous column and then the columns to the right. The column containing the first
2e41			; non-null character encountered is returned.
2e41			; Entry: B =Column number to start searching from.
2e41			;        DE=Start of row in edit buffer.
2e41			; Exit : Carry flag set if an editable character was found.
2e41			;        HL=Address of closest editable position.
2e41			;        B =Number of closest editable column.
2e41
2e41	L2E41:  LD   H,$00        ; [Could have saved 1 byte by calling routine at $2E7B (ROM 0)]
2e43			LD   L,B          ; HL=Column number.
2e44			ADD  HL,DE        ; HL=Address in edit buffer of the specified column.
2e45
2e45			LD   A,(HL)       ; Fetch the contents.
2e46			CP   $00          ; Is it a null character, i.e. end-of-line or past the end-of-line?
2e48			SCF               ;
2e49			RET  NZ           ; Return if this character is part of the edited line.
2e4a
2e4a			LD   A,B          ;
2e4b			OR   A            ;
2e4c			JR   Z,L2E5B      ; Jump ahead if the first column.
2e4e
2e4e			PUSH HL           ; Otherwise check the
2e4f			DEC  HL           ; preceding byte
2e50			LD   A,(HL)       ; and if it is non-zero
2e51			CP   $00          ; then return with
2e53			SCF               ; HL pointing to the
2e54			POP  HL           ; first zero byte.
2e55			RET  NZ           ;
2e56
2e56	L2E56:  LD   A,(HL)       ; Get the current character.
2e57			CP   $00          ; Is it a null (i.e. end-of-line)?
2e59			SCF               ; Signal position is editable.
2e5a			RET  NZ           ; Return if this character is part of the edited line.
2e5b
2e5b	L2E5B:  INC  HL           ; Advance to the next position.
2e5c			INC  B            ; Increment the column number.
2e5d			LD   A,B          ;
2e5e			CP   $1F          ; Reached the end of the row?
2e60			JR   C,L2E56      ; Jump back if more columns to check.
2e62
2e62			RET               ; Return with carry flag reset if specified column position does not exist.
2e63
2e63			; ----------------------------------------------
2e63			; Find Edit Buffer Editable Position to the Left
2e63			; ----------------------------------------------
2e63			; This routine finds the first editable character position in the specified edit buffer row from the current column to the left.
2e63			; It first checks the current column and returns this if it contains an editable character. Otherwise it searches the columns to
2e63			; the left and if an editable character is found then it returns the column to the right of it.
2e63			; Entry: B =Column number to start searching from.
2e63			;        DE=Start of row in edit buffer.
2e63			; Exit : Carry flag set if an editable character was found.
2e63			;        HL=Address of closest editable position.
2e63			;        B =Number of the column after the editable position.
2e63
2e63	L2E63:  LD   H,$00        ; [Could have saved 1 byte by calling routine at $2E7B (ROM 0)]
2e65			LD   L,B          ; HL=Column number.
2e66			ADD  HL,DE        ; HL=Address in edit buffer of the specified column.
2e67
2e67			LD   A,(HL)       ; Fetch the contents.
2e68			CP   $00          ; Is it a null character, i.e. end-of-line or past the end-of-line?
2e6a			SCF               ; Signal position is editable.
2e6b			RET  NZ           ; Return if an editable character was found.
2e6c
2e6c	L2E6C:  LD   A,(HL)       ; Get the current character.
2e6d			CP   $00          ; Is it a null, i.e. non-editable?
2e6f			JR   NZ,L2E78     ; Jump if not.
2e71
2e71			LD   A,B          ; At column 0?
2e72			OR   A            ;
2e73			RET  Z            ; Return if so.
2e74
2e74			DEC  HL           ; Next column position to test.
2e75			DEC  B            ; Decrement column index number.
2e76			JR   L2E6C        ; Repeat test on previous column.
2e78
2e78	L2E78:  INC  B            ; Advance to the column after the editable position.
2e79			SCF               ; Signal position is editable.
2e7a			RET               ;
2e7b
2e7b			; -------------------------------
2e7b			; Fetch Edit Buffer Row Character
2e7b			; -------------------------------
2e7b			; Entry: DE=Add of edit buffer row.
2e7b			;        B =Column number.
2e7b			; Exit : A =Character at specified column.
2e7b			;
2e7b			; [Not used by the ROM]
2e7b
2e7b	L2E7B:  LD   H,$00        ;
2e7d			LD   L,B          ; HL=Column number.
2e7e			ADD  HL,DE        ; HL=Address in edit buffer of the specified column.
2e7f			LD   A,(HL)       ; Get the current character.
2e80			RET               ;
2e81
2e81			; ---------------------------------------------
2e81			; Insert Character into Screen Line Edit Buffer
2e81			; ---------------------------------------------
2e81			; Called when a non-action key is pressed. It inserts a character into the Screen Line Edit Buffer if there is room.
2e81			; Entry: A=Character code.
2e81			;        B=Cursor column position.
2e81			;        C=Cursor row position.
2e81
2e81	L2E81:  LD   HL,$EC0D     ; Editor flags.
2e84			OR   A            ; Clear carry flag. [Redundant since carry flag return state never checked]
2e85			BIT  0,(HL)       ; Is the Screen Line Edit Buffer is full?
2e87			RET  NZ           ; Return if it is.
2e88
2e88			PUSH BC           ; Save cursor position.
2e89			PUSH AF           ; Save key code. [Redundant since $30B4 (ROM 0) preserves AF]
2e8a
2e8a			CALL L30B4        ; DE=Start address in Screen Line Edit Buffer of the row specified in C.
2e8d
2e8d			POP  AF           ; Get key code. [Redundant since $30B4 (ROM 0) preserves AF]
2e8e
2e8e			;Insert the character into the current row. If a spill from this row occurs then insert that character into the start of the
2e8e			;following row and shift all existing characters right by one. Repeat this process until all rows have been shifted.
2e8e
2e8e	L2E8E:  CALL L16AC        ; Insert character into edit buffer row at current cursor position, shifting the row right. Returns carry flag reset.
2e91			; Zero flag will be set if byte shift out of last column position was $00.
2e91
2e91			PUSH AF           ; Save key code and flags.
2e92
2e92			EX   DE,HL        ; HL=Address of edit buffer row. DE=Address of flags.
2e93			CALL L3604        ; Print a row of the edit buffer to the screen.
2e96			EX   DE,HL        ; DE=Address of edit buffer row. HL=Address of flags.
2e97
2e97			POP  AF           ; Get key code and flags.
2e98			CCF               ; Sets the carry flag since it was reset via the call to $16AC (ROM 0). [Redundant since never tested]
2e99			JR   Z,L2ECC      ; Jump ahead to make a return if there was no spill out from column 31, with the carry flag set.
2e9b
2e9b			;There was a spill out from the current row, and so this character will need to be inserted as the first character of the following row.
2e9b			;If this is the last row of the BASIC line then a new row will need to be inserted.
2e9b
2e9b			PUSH AF           ; Save key code.
2e9c
2e9c			LD   B,$00        ; First column in the next row.
2e9e			INC  C            ; Next row.
2e9f
2e9f			LD   A,($EC15)    ; The number of editing rows on screen.
2ea2			CP   C            ; Has the bottom of the Screen Line Edit Buffer been reached?
2ea3			JR   C,L2EC8      ; Jump ahead if so.
2ea5
2ea5			;The editing screen is not full
2ea5
2ea5			LD   A,(HL)       ; Fetch contents of flag byte for the row (byte after the 32 columns).
2ea6			LD   E,A          ; E=Old flags.
2ea7			AND  $D7          ; Mask off 'last row of BASIC line' flag. [Other bits not used, could have used AND $F7]
2ea9			CP   (HL)         ; Has the status changed?
2eaa			LD   (HL),A       ; Store the new flags, marking it as not the last BASIC row.
2eab			LD   A,E          ; A=Original flags byte for the row.
2eac			SET  1,(HL)       ; Signal that the row spans onto another row.
2eae
2eae			PUSH AF           ; Save the flags.
2eaf			CALL L30B4        ; DE=Start address in Screen Line Edit Buffer of the following row, as specified in C.
2eb2			POP  AF           ; Fetch the flags.
2eb3			JR   Z,L2EC2      ; Jump if the character was not inserted into the last row of the BASIC line.
2eb5
2eb5			;The character was inserted into the last row of the BASIC line causing a spill of an existing character into a new row,
2eb5			;and therefore a new 'last' row needs to be inserted.
2eb5
2eb5			RES  0,A          ; Signal not the first row of the BASIC line.
2eb7			CALL L2ED3        ; Insert a blank line into the Screen Edit Buffer.
2eba			JR   NC,L2ECC     ; Jump if the buffer is full to exit.
2ebc
2ebc			CALL L35F4        ; Indent the row by setting the appropriate number of null characters in the current Screen Line Edit Buffer row.
2ebf
2ebf			POP  AF           ; Get key code.
2ec0			JR   L2E8E        ; Jump back to insert the character in the newly inserted row. [Could have saved 2 bytes by using JR $2EC5 (ROM 0)]
2ec2
2ec2			;The character was not inserted into the last row of the BASIC line, so find the first editable position on the following row, i.e.
2ec2			;skip over any indentation.
2ec2
2ec2	L2EC2:  CALL L2E41        ; Find editable position on this row from the previous column to the right, returning column number in B.
2ec5			POP  AF           ; Get key code.
2ec6			JR   L2E8E        ; Jump back to insert the character into the first editable position of next the row.
2ec8
2ec8			;The Screen Edit Line Buffer is full and the character insertion requires shifting of all rows that are off screen in the Below-Screen Line Edit Buffer.
2ec8
2ec8	L2EC8:  POP  AF           ; Get key code.
2ec9			CALL L316E        ; Insert the character at the start of the Below-Screen Line Edit Buffer, shifting all existing characters to the right.
2ecc
2ecc			;All paths join here
2ecc
2ecc	L2ECC:  POP  BC           ; Retrieve cursor position.
2ecd			RET               ;
2ece
2ece			; ------------------------------------------------------------
2ece			; Insert Blank Row into Screen Edit Buffer, Shifting Rows Down
2ece			; ------------------------------------------------------------
2ece			; This routine inserts a blank row at the specified row, shifting affected rows down.
2ece			; Entry: C=Row number to insert the row at.
2ece			; Exit : Carry flag set to indicate edit buffer rows were shifted.
2ece
2ece	L2ECE:  CALL L30B4        ; DE=Start address in Screen Line Edit Buffer of the row specified in C.
2ed1			LD   A,$09        ; Signal 'first row' and 'last row', indicating a new blank row.
2ed3
2ed3			;DE=Address of row within Screen Line Edit Buffer.
2ed3			;C=Row number to insert the row at.
2ed3			;A=Screen Line Edit Buffer row flags value.
2ed3
2ed3	L2ED3:  PUSH BC           ; Save registers.
2ed4			PUSH DE           ;
2ed5
2ed5			LD   B,C          ; B=Row number.
2ed6			LD   HL,L2EEF     ; The empty row data.
2ed9			LD   C,A          ; C=Flags for the row.
2eda
2eda			PUSH BC           ;
2edb			CALL L1675        ; Shift all Screen Line Edit Buffer rows down and insert a new blank row, updating the display file if required.
2ede			POP  BC           ;
2edf			LD   A,C          ; A=Flags for the row.
2ee0			JR   NC,L2EEC     ; Jump if no edit buffer rows were shifted.
2ee2
2ee2			;Rows were shifted down
2ee2
2ee2			LD   C,B          ; B=Row number, where the new blank row now is.
2ee3			CALL L30B4        ; DE=Start address in Screen Line Edit Buffer of the row specified in C.
2ee6
2ee6			LD   HL,$0020     ; Point to the flag byte for the row.
2ee9			ADD  HL,DE        ;
2eea			LD   (HL),A       ; Store the flag byte value for the row.
2eeb			SCF               ; Signal edit buffer rows were shifted.
2eec
2eec	L2EEC:  POP  DE           ; Restore registers.
2eed			POP  BC           ;
2eee			RET               ;
2eef
2eef			; --------------------------
2eef			; Empty Edit Buffer Row Data
2eef			; --------------------------
2eef
2eef	L2EEF:  DEFB $00          ; 32 null column markers, i.e. none of the columns are editable.
2ef0			DEFB $00
2ef1			DEFB $00
2ef2			DEFB $00
2ef3			DEFB $00
2ef4			DEFB $00
2ef5			DEFB $00
2ef6			DEFB $00
2ef7			DEFB $00
2ef8			DEFB $00
2ef9			DEFB $00
2efa			DEFB $00
2efb			DEFB $00
2efc			DEFB $00
2efd			DEFB $00
2efe			DEFB $00
2eff			DEFB $00
2f00			DEFB $00
2f01			DEFB $00
2f02			DEFB $00
2f03			DEFB $00
2f04			DEFB $00
2f05			DEFB $00
2f06			DEFB $00
2f07			DEFB $00
2f08			DEFB $00
2f09			DEFB $00
2f0a			DEFB $00
2f0b			DEFB $00
2f0c			DEFB $00
2f0d			DEFB $00
2f0e			DEFB $00
2f0f
2f0f			DEFB $09          ; Flags:
2f10			;   Bit 0: 1=The first row of the BASIC line.
2f10			;   Bit 1: 0=Does not span onto another row.
2f10			;   Bit 2: 0=Not used (always 0).
2f10			;   Bit 3: 1=The last row of the BASIC line.
2f10			;   Bit 4: 0=No associated line number.
2f10			;   Bit 5: 0=Not used (always 0).
2f10			;   Bit 6: 0=Not used (always 0).
2f10			;   Bit 7: 0=Not used (always 0).
2f10			DEFW $0000        ; There is no BASIC line number associated with this edit row.
2f12
2f12			; -------------------------------------------------------------------
2f12			; Delete a Character from a BASIC Line in the Screen Line Edit Buffer
2f12			; -------------------------------------------------------------------
2f12			; Delete a character at the specified position, shifting subsequent characters left as applicable.
2f12			; Entry: B=Column number.
2f12			;        C=Row number.
2f12
2f12	L2F12:  PUSH BC           ; Save initial cursor row and column numbers.
2f13
2f13			CALL L30B4        ; DE=Start address in Screen Line Edit Buffer of the row specified in C.
2f16
2f16			PUSH BC           ; Stack initial cursor row and column numbers again.
2f17
2f17			;Enter a loop to find the last row of the BASIC line or the end of the visible screen, whichever comes first
2f17
2f17	L2F17:  LD   HL,$0020     ;
2f1a			ADD  HL,DE        ; Point to the flag byte for this row.
2f1b			BIT  1,(HL)       ; Does the row span onto another row?
2f1d			LD   A,$00        ; A null character will be inserted. [Could have saved 1 byte by using XOR A and placing it above the BIT 1,(HL) instruction]
2f1f			JR   Z,L2F31      ; Jump ahead if the row does not span onto another row, i.e. the last row.
2f21
2f21			;The row spans onto another
2f21
2f21			INC  C            ; C=Advance to the next row.
2f22			LD   HL,$0023     ;
2f25			ADD  HL,DE        ;
2f26			EX   DE,HL        ; DE points to the first character of the next row. HL points to the first character of the current row.
2f27
2f27			LD   A,($EC15)    ; A=Number of editing lines.
2f2a			CP   C            ; Has the end of the screen been reached?
2f2b			JR   NC,L2F17     ; Jump back if within screen range to find the last row of the BASIC line.
2f2d
2f2d			;The end of the screen has been reached without the end of the BASIC line having been reached
2f2d
2f2d			DEC  C            ; Point to last row on screen.
2f2e			CALL L31C9        ; Shift all characters of the BASIC Line held within the Below-Screen Line Edit Buffer.
2f31
2f31			;A loop is entered to shift all characters to the left, beginning with the last row of the BASIC line in the Screen Line Edit Buffer
2f31			;and until the row that matches the current cursor position is reached.
2f31
2f31	L2F31:  POP  HL           ; Fetch the initial cursor row and column numbers.
2f32
2f32	L2F32:  PUSH HL           ; Stack initial cursor row and column numbers.
2f33			CALL L30B4        ; DE=Start address in Screen Line Edit Buffer of the last row, as specified in C.
2f36			POP  HL           ; HL=Initial cursor row and column numbers.
2f37
2f37			LD   B,A          ; B=Character to insert.
2f38			LD   A,C          ; A=Row number to delete from.
2f39			CP   L            ; Deleting from the same row as the cursor is on within the BASIC line?
2f3a			LD   A,B          ; A=Character to insert.
2f3b			PUSH AF           ; Save the flags status.
2f3c			JR   NZ,L2F41     ; Jump if not deleting from the row containing the cursor.
2f3e
2f3e			;Deleting from the row matching the cursor position within the BASIC line, therefore only shift those bytes after the cursor position
2f3e
2f3e			LD   B,H          ; B=Initial column number.
2f3f			JR   L2F4A        ; Jump ahead to continue, with zero flag set to indicate deleting from the row contain the cursor.
2f41
2f41			;Deleting on row after that matching the cursor position, therefore shift all editable characters within the row
2f41
2f41	L2F41:  PUSH AF           ; Save the character to insert.
2f42			PUSH HL           ; Save initial cursor row and column numbers.
2f43
2f43			LD   B,$00        ;
2f45			CALL L2E41        ; Find first editable position on this row searching to the right, returning column number in B.
2f48
2f48			POP  HL           ; HL=Initial cursor row and column numbers.
2f49			POP  AF           ; A=Character to insert, and zero flag reset to indicate not deleting from the row contain the cursor.
2f4a
2f4a			;DE=Start address of Screen Line Edit Buffer row.
2f4a			;A=Character to shift into right of row.
2f4a			;B=The column to start shifting at.
2f4a			;C=Row number to start shifting from.
2f4a			;Zero flag is set if deleting from the row matching the cursor position.
2f4a
2f4a	L2F4A:  PUSH HL           ; HL=Initial cursor row and column numbers.
2f4b
2f4b			LD   HL,$F6F4     ; Deleting flags.
2f4e			SET  0,(HL)       ; Signal deleting on the row matching the cursor position.
2f50			JR   Z,L2F54      ; Jump if deleting from the row matching the cursor position.
2f52
2f52			RES  0,(HL)       ; Signal not deleting on the row matching the cursor position.
2f54
2f54	L2F54:  CALL L16C1        ; Insert the character into the end of the edit buffer row, shifting all columns left until the cursor position is reached.
2f57
2f57			PUSH AF           ; A=Character shifted out, and therefore to be potentially shifted into the end of the previous row.
2f58			PUSH BC           ; B=New column number. C=Row number.
2f59			PUSH DE           ; DE=Start address of row to delete from.
2f5a
2f5a			LD   HL,$F6F4     ; Deleting flags.
2f5d			BIT  0,(HL)       ; Deleting from the row matching the cursor position?
2f5f			JR   NZ,L2F6F     ; Jump ahead if so.
2f61
2f61			;Deleting from a row after the cursor position
2f61
2f61			LD   B,$00        ; Column 0.
2f63			CALL L2BD4        ; Is there an editable character on the row?
2f66			JR   C,L2F6F      ; Jump if there is.
2f68
2f68			;Shifting the characters on this row has resulted in a blank row, so shift all rows below screen up to remove this blank row
2f68
2f68			CALL L2F80        ; Shift up all BASIC line rows below to close the gap.
2f6b
2f6b			POP  DE           ; DE=Start address of row to delete from.
2f6c			POP  BC           ; B=New column number. C=Row number.
2f6d			JR   L2F74        ; Jump ahead.
2f6f
2f6f			;There are characters remaining on the row following the shift so display this to the screen and then continue to shift the remaining rows
2f6f
2f6f	L2F6F:  POP  HL           ; HL=Start address of the row.
2f70			POP  BC           ; B=New column number. C=Row number.
2f71
2f71			CALL L3604        ; Print the row of the edit buffer to the screen, if required.
2f74
2f74	L2F74:  POP  AF           ; A=Character to insert.
2f75
2f75			DEC  C            ; Previous row.
2f76			LD   B,A          ; B=Character to insert.
2f77
2f77			POP  HL           ; HL=Initial cursor row and column numbers.
2f78			POP  AF           ; Retrieve the flags status (zero flag set if deleting from the row matching the cursor position).
2f79			LD   A,B          ; A=Character to insert.
2f7a			JP   NZ,L2F32     ; Jump back if not deleting from the row matching the cursor position, i.e. all rows after the cursor have not yet been shifted.
2f7d
2f7d			; [*BUG* - The 'line altered' flag is not cleared when an 'edited' null line is entered. To reproduce the bug, insert a couple of BASIC lines, type a character,
2f7d			;          delete it, and then cursor up or down onto a program line. The line is considered to have been changed and so is processed as if it consists
2f7d			;          of characters. Further, when cursor down is pressed to move to a BASIC line below, that line is deemed to have changed and hence moving off from it
2f7d			;          causing that line to be re-inserted into the BASIC program. Credit: Ian Collier (+3), Paul Farrow (128)]
2f7d
2f7d			; [The fix for the bug is to check whether all characters have been deleted from the line and if so to reset the 'line altered' flag.
2f7d			; This would require the following code to be inserted at this point. Credit: Paul Farrow.
2f7d			;
2f7d			;       PUSH DE           ;
2f7d			;       LD   HL,$0020     ;
2f7d			;       ADD  HL,DE        ; Point to the flag byte for this row.
2f7d			;       POP  DE
2f7d			;       BIT  0,(HL)       ; First row of BASIC line in addition to the last?
2f7d			;       JR   Z,SKIP_CLEAR ; Jump ahead if not.
2f7d			;
2f7d			;       LD   B,$00        ;
2f7d			;       CALL $2E41 (ROM 0) ; Is this a blank row? i.e. Find editable position on this row to the right, returning column number in B.
2f7d			;       JR   C,SKIP_CLEAR ; Jump if a character exists on the line.
2f7d			;
2f7d			;       LD   HL,$EC0D
2f7d			;       RES  3,(HL)       ; Signal that the current line has not been altered.
2f7d			;
2f7d			;SKIP_CLEAR:
2f7d			;       XOR A             ; Set the preferred column to 0.]
2f7d
2f7d			SCF               ; [Redundant since never subsequently checked]
2f7e			POP  BC           ; Retrieve initial cursor row and column numbers.
2f7f			RET               ;
2f80
2f80			; -----------------------------------------------------------
2f80			; Shift Rows Up to Close Blank Row in Screen Line Edit Buffer
2f80			; -----------------------------------------------------------
2f80			; The cursor is on a blank row but has been moved off of it. Therefore shift all BASIC lines below it up so as to remove the blank row.
2f80			; Entry: DE=Address of the row in the Screen Line Edit Buffer containing the cursor.
2f80			;        C =Row number in the Screen Line Edit Buffer containing the cursor.
2f80			;        Carry flag set if rows were shifted up, i.e. a row below existed.
2f80
2f80	L2F80:  LD   HL,$0020     ;
2f83			ADD  HL,DE        ; Point to the flag byte for the row.
2f84			LD   A,(HL)       ;
2f85			BIT  0,(HL)       ; Is the cursor on a blank row (which is flagged as the first row of a BASIC line)?
2f87			JR   NZ,L2FB2     ; Jump ahead if it is. [Could have improved speed by jumping to $2FB6 (ROM 0) since DE already holds the start address of the row]
2f89
2f89			;Cursor not on a blank row but is on its own row at the end of a multi-row BASIC line
2f89
2f89			PUSH AF           ; Save the cursor row flag byte.
2f8a			PUSH BC           ; Save the cursor row number in C.
2f8b
2f8b			LD   A,C          ; Is the cursor on row 0?
2f8c			OR   A            ;
2f8d			JR   NZ,L2FA4     ; Jump ahead if it is not, i.e. there is at least one row above.
2f8f
2f8f			;Cursor on row 0, hence a BASIC line must be off the top of the screen [???? Can this ever be the case?]
2f8f
2f8f			PUSH BC           ; Save the cursor row number.
2f90
2f90			LD   HL,($FC9A)   ; Line number at top of screen.
2f93			CALL L334A        ; Find closest line number (or $0000 if no line).
2f96			LD   ($FC9A),HL   ; Line number at top of screen.
2f99
2f99			LD   A,($F9DB)    ; Fetch the number of rows of the BASIC line that are in the Above-Screen Line Edit Buffer,
2f9c			LD   C,A          ; i.e. that are off the top of the screen.
2f9d			DEC  C            ; Decrement the row count, i.e. one less row off the top of the screen.
2f9e			CALL L32B7        ; DE=Address of row in Above-Screen Line Edit Buffer.
2fa1
2fa1			POP  BC           ; Retrieve the cursor row number.
2fa2			JR   L2FA8        ; Jump ahead.
2fa4
2fa4			;There is a row above so set this as the last row of the BASIC line
2fa4
2fa4	L2FA4:  DEC  C            ; Previous row, i.e. the last row of the BASIC line that contains editable characters.
2fa5			CALL L30B4        ; DE=Start address in Screen Line Edit Buffer of the previous row.
2fa8
2fa8	L2FA8:  POP  BC           ; Retrieve the cursor row number.
2fa9			POP  AF           ; Retrieve the cursor row flag byte, which indicates last row of BASIC line.
2faa
2faa			LD   HL,$0020     ; Point to the flag byte for the previous row.
2fad			ADD  HL,DE        ;
2fae			RES  1,(HL)       ; Signal that the previous row does not span onto another row.
2fb0			OR   (HL)         ; Keep the previous row's first BASIC row flag.
2fb1			LD   (HL),A       ; Update the flag byte for the previous row.
2fb2
2fb2			;Shift up all rows below the old cursor position within the Screen Line Edit Buffer and including the Below-Screen Line Edit Buffer, and update the display file if required
2fb2
2fb2	L2FB2:  LD   B,C          ; B=Row number in the Screen Line Edit Buffer.
2fb3			CALL L30B4        ; DE=Start address in Screen Line Edit Buffer of the row specified in C.
2fb6			CALL L30DF        ; Shift up rows of the BASIC line in the Below-Screen Line Edit Buffer, or insert the next line BASIC line if buffer empty.
2fb9			JP   L1648        ; Shift Screen Line Edit Buffer rows up from row specified by B and update the display file if required.
2fbc			; [Could have saved 3 bytes by replacing the instructions CALL $30DF (ROM 0) / JP $1648 (ROM 0) with JP $1645 (ROM 0)]
2fbc
2fbc			; ------------------------------------
2fbc			; DELETE-WORD-LEFT Key Handler Routine
2fbc			; ------------------------------------
2fbc			; This routine deletes to the start of the current word that the cursor is on, or if it is on the first
2fbc			; character of a word then it deletes to the start of the previous word. Since the function works by deleting one
2fbc			; character at a time, display file updates are disabled whilst the function is executing to prevent screen flicker.
2fbc			; If there is no word to delete then an error beep is requested.
2fbc			;
2fbc			; Symbol: <-- DEL
2fbc			;         <--
2fbc			;
2fbc			; Exit: Carry flag reset to indicate to produce an error beep and set not to produce an error beep.
2fbc
2fbc	L2FBC:  CALL L3084        ; Remove cursor attribute, disable display file updates and get current cursor position. Exits with HL pointing to the editing area information.
2fbf
2fbf	L2FBF:  PUSH HL           ; Save address of the editing area information.
2fc0			CALL L3095        ; Does a previous character exist in the current Screen Line Edit Buffer row?
2fc3			JR   Z,L2FF7      ; Jump if at the start of the BASIC line to print all rows.
2fc5
2fc5			CALL L2B5B        ; Is previous column position editable? (Returns carry flag set if editable)
2fc8			POP  HL           ; Retrieve address of the editing area information.
2fc9			JR   NC,L2FF8     ; Jump if not editable to print all rows.
2fcb
2fcb			;A previous character exists and is editable
2fcb
2fcb			CALL L2A1A        ; Get character from current cursor position.
2fce			PUSH AF           ; Save current character.
2fcf			PUSH HL           ; Save address of the editing area information.
2fd0			CALL L2F12        ; Delete character to the right, shifting subsequent rows as required.
2fd3			POP  HL           ; Retrieve address of the editing area information.
2fd4			POP  AF           ; Retrieve current character.
2fd5			CP   $20          ; Is it a space?
2fd7			JR   Z,L2FBF      ; Jump back if so to find the end of the last word.
2fd9
2fd9			;The end of the word to delete has been found, so enter a loop to search for the start of the word
2fd9
2fd9	L2FD9:  PUSH HL           ; Save address of the editing area information.
2fda			CALL L3095        ; Does a previous character exist in the current Screen Line Edit Buffer row?
2fdd			JR   Z,L2FF7      ; Jump if at the start of a BASIC line to print all rows.
2fdf
2fdf			CALL L2B5B        ; Is previous column position editable? (Returns carry flag set if editable)
2fe2			POP  HL           ; Retrieve address of the editing area information.
2fe3			JR   NC,L2FF8     ; Jump if not editable to print all rows.
2fe5
2fe5			CALL L2A1A        ; Get character from current cursor position
2fe8			CP   $20          ; Is it a space?
2fea			JR   Z,L2FF3      ; Jump if so.
2fec
2fec			;Character is not a space
2fec
2fec			PUSH HL           ; Save address of the editing area information.
2fed			CALL L2F12        ; Delete character to the right, shifting subsequent rows as required.
2ff0			POP  HL           ; Retrieve address of the editing area information.
2ff1			JR   L2FD9        ; Jump back to delete next character until start of the word found.
2ff3
2ff3			;A space prior to a word has been found
2ff3
2ff3	L2FF3:  PUSH HL           ; Save address of the editing area information.
2ff4			CALL L2B78        ; Find next Screen Line Edit Buffer editable position to right, moving to next row if necessary.
2ff7
2ff7	L2FF7:  POP  HL           ; Retrieve address of the editing area information.
2ff8
2ff8			;Print all rows to the screen
2ff8
2ff8	L2FF8:  LD   A,B          ; Fetch the new end column number.
2ff9
2ff9			PUSH AF           ; Save the flags status.
2ffa			PUSH HL           ; Save address of the editing area information.
2ffb
2ffb			LD   HL,$EEF5     ;
2ffe			RES  2,(HL)       ; Re-enable display file updates.
3000
3000			LD   A,($EC15)    ; The number of editing rows on screen. [This will end up being used as the alternate cursor column]
3003
3003			PUSH BC           ; Save the row and new column numbers.
3004			LD   B,$00        ; B=Print from row 0.
3006			LD   C,A          ; C=Number of editing rows on screen.
3007			CP   A            ; Set the zero flag to signal not to change cursor position settings.
3008			CALL L1605        ; Print all Screen Line Edit Buffer rows to the display file.
300b			POP  BC           ; Retrieve the row and new column numbers.
300c
300c			LD   HL,$EC0D     ; Editor flags.
300f			SET  3,(HL)       ; Indicate current line has been altered.
3011			POP  HL           ; Retrieve address of the editing area information.
3012
3012			; [*BUG* - The preferred cursor column field gets corrupted with the number of editing rows on screen. Credit: Ian Collier (+3), Andrew Owen (128)]
3012
3012			; [The bug can be fixed by pre-loading the A register with the current preferred column number. Credit: Paul Farrow.
3012			;
3012			;       LD   A,($F6F0)    ; Fetch the preferred column position.]
3012
3012			CALL L29F8        ; Store editing position and print cursor.
3015
3015			POP  AF           ; Retrieve the flags status.
3016			RET               ;
3017
3017			; -------------------------------------
3017			; DELETE-WORD-RIGHT Key Handler Routine
3017			; -------------------------------------
3017			; This routine deletes to the start of the next word. Since the function works by deleting one character
3017			; at a time, display file updates are disabled whilst the function is executing to prevent screen flicker.
3017			; If there is no word to delete then an error beep is requested.
3017			;
3017			; Symbol: --> DEL
3017			;         -->
3017			;
3017			; Exit: Carry flag set to indicate not to produce an error beep.
3017
3017	L3017:  CALL L3084        ; Remove cursor attribute, disable display file updates and get current cursor position. Exits with HL pointing to the editing area information.
301a
301a	L301A:  PUSH HL           ; Save address of the editing area information.
301b			CALL L2A1A        ; Get character from current cursor position.
301e			POP  HL           ; Retrieve address of the editing area information.
301f			CP   $00          ; Is it a null character, i.e. end of BASIC line?
3021			SCF               ; Signal do not produce an error beep.
3022			JR   Z,L2FF8      ; Jump if end of the BASIC line to print all rows.
3024
3024			PUSH AF           ; Save the character.
3025			PUSH HL           ; Save address of the editing area information.
3026			CALL L2F12        ; Delete character to the right, shifting subsequent rows as required.
3029			POP  HL           ; Retrieve address of the editing area information.
302a			POP  AF           ; Retrieve the character.
302b
302b			CP   $20          ; Was the character a space?
302d			JR   NZ,L301A     ; Jump back if not to delete the next character until the end of the word is found.
302f
302f	L302F:  CALL L2A1A        ; Get character from current cursor position.
3032			CP   $20          ; Is it a space?
3034			SCF               ; Signal do not produce an error beep.
3035			JR   NZ,L2FF8     ; Jump if not to print all rows.
3037
3037			PUSH HL           ; Save address of the editing area information.
3038			CALL L2F12        ; Delete character to the right, shifting subsequent rows as required.
303b			POP  HL           ; Retrieve address of the editing area information.
303c			JR   L302F        ; Jump back to delete all subsequent spaces until the start of the next word or the end of the line is found.
303e
303e			; -------------------------------------------
303e			; DELETE-TO-START-OF-LINE Key Handler Routine
303e			; -------------------------------------------
303e			; Delete to the start of the current BASIC line. Since the function works by deleting one character at
303e			; a time, display file updates are disabled whilst the function is executing to prevent screen flicker.
303e			; An error beep is not produced if there is no characters in the current BASIC line.
303e			;
303e			; Symbol: |<-- DEL
303e			;         |<--
303e			;
303e			; Exit: Carry flag set to indicate not to produce an error beep.
303e
303e	L303E:  CALL L3084        ; Remove cursor attribute, disable display file updates and get current cursor position. Exits with HL pointing to the editing area information.
3041
3041	L3041:  PUSH HL           ; Save address of the editing area information.
3042			CALL L30B4        ; DE=Start address in Screen Line Edit Buffer of the row specified in C.
3045
3045			LD   HL,$0020     ;
3048			ADD  HL,DE        ; Point to the flag byte for the row.
3049			BIT  0,(HL)       ; Is it the first row of the BASIC line?
304b			JR   NZ,L3059     ; Jump if so.
304d
304d			;Not in the first row of a BASIC line
304d
304d			CALL L2B5B        ; Is previous column position editable? (Returns carry flag set if editable)
3050			JR   NC,L306D     ; Jump if not editable since nothing to delete.
3052
3052			CALL L2F12        ; Delete character to the right, shifting subsequent rows as required.
3055			POP  HL           ; Retrieve address of the editing area information.
3056			JR   L3041        ; Jump back to delete next character until first row of the BASIC line is found.
3058
3058			PUSH HL           ; [Redundant byte]
3059
3059			;In the first row of the BASIC line
3059
3059	L3059:  LD   A,B          ; Fetch the new end column number.
305a			CP   $00          ; Is it at the start of the row?
305c			JR   Z,L306D      ; Jump if so since nothing to delete.
305e
305e			DEC  B            ; Point to previous column.
305f			CALL L2A1A        ; Get character from current cursor position.
3062			INC  B            ; Point back to the new end column.
3063			CP   $00          ; Is it a null character, i.e. not editable?
3065			JR   Z,L306D      ; Jump if so since nothing to delete.
3067
3067			DEC  B            ; Point to previous column.
3068			CALL L2F12        ; Delete character to the right, shifting subsequent rows as required.
306b			JR   L3059        ; Jump back to delete the next character until the start of the BASIC line is found.
306d
306d	L306D:  POP  HL           ; Retrieve address of the editing area information.
306e
306e	L306E:  SCF               ; Signal not to produce error beep.
306f			JP   L2FF8        ; Jump back to print all rows.
3072
3072			; -----------------------------------------
3072			; DELETE-TO-END-OF-LINE Key Handler Routine
3072			; -----------------------------------------
3072			; Delete to the end of the current BASIC line. Since the function works by deleting one character at
3072			; a time, display file updates are disabled whilst the function is executing to prevent screen flicker.
3072			; An error beep is not produced if there is no characters in the current BASIC line.
3072			;
3072			; Symbol: -->| DEL
3072			;         -->|
3072			;
3072			; Exit: Carry flag set to indicate not to produce an error beep.
3072
3072	L3072:  CALL L3084        ; Remove cursor attribute, disable display file updates and get current cursor position. Exits with HL pointing to the editing area information.
3075
3075	L3075:  CALL L2A1A        ; Get character from current cursor position.
3078			CP   $00          ; Is it a null character, i.e. at end of BASIC line?
307a			SCF               ; Signal not to produce an error beep.
307b			JR   Z,L306E      ; Jump if end of BASIC line to print all rows.
307d
307d			PUSH HL           ; Save address of the editing area information.
307e			CALL L2F12        ; Delete character to the right, shifting subsequent rows as required.
3081			POP  HL           ; Retrieve address of the editing area information.
3082			JR   L3075        ; Jump back to delete the next character until the end of the BASIC line is found.
3084
3084			; ---------------------------------------------------------
3084			; Remove Cursor Attribute and Disable Updating Display File
3084			; ---------------------------------------------------------
3084			; This routine is called by the DELETE key handler routines. Aside from removing the cursor from the display,
3084			; it prevents display file updates occurring whilst the delete functions are executing.
3084			; Exit: HL=Address of the editing area information.
3084			;       A=Cursor column number preferred.
3084			;       B=Cursor column number.
3084			;       C=Cursor row number.
3084
3084	L3084:  LD   HL,$EC0D     ; Editor flags.
3087			RES  0,(HL)       ; Signal that the Screen Line Edit Buffer is not full.
3089
3089			CALL L29EC        ; Remove cursor, restoring old attribute.
308c
308c			LD   HL,$EEF5     ;
308f			SET  2,(HL)       ; Indicate not to print edit buffer rows, therefore preventing intermediate screen updates.
3091
3091			LD   HL,$F6F1     ; Point to the editing area information.
3094			RET               ;
3095
3095			; -----------------------------------------------------
3095			; Previous Character Exists in Screen Line Edit Buffer?
3095			; -----------------------------------------------------
3095			; This routine tests the whether a previous character exists in the current BASIC line within
3095			; the Screen Line Edit Buffer.
3095			; Entry: C=Row number.
3095			;        B=Column number.
3095			; Exit : Zero flag set if at start of the BASIC line (first column or leading null).
3095
3095	L3095:  CALL L30B4        ; DE=Start address in Screen Line Edit Buffer of the row specified in C.
3098			LD   HL,$0020     ;
309b			ADD  HL,DE        ; HL=Address of the flag byte for this row.
309c			BIT  0,(HL)       ; Is this the first row of a BASIC line?
309e			JR   Z,L30AE      ; Jump if not.
30a0
30a0			;On first row of a BASIC line
30a0
30a0			LD   A,B          ; Fetch the column number.
30a1			CP   $00          ; At the start of the row?
30a3			JR   Z,L30B2      ; Jump ahead if so.
30a5
30a5			DEC  B            ; Move to the previous column.
30a6			CALL L2A1A        ; Get current character from Screen Line Edit Buffer.
30a9
30a9			INC  B            ; Move back to the original column.
30aa			CP   $00          ; Does the position contain a null?
30ac			JR   Z,L30B2      ; Jump if not.
30ae
30ae	L30AE:  LD   A,$01        ;
30b0			OR   A            ; Reset the zero flag.
30b1			RET               ;
30b2
30b2	L30B2:  XOR  A            ; Set the zero flag.
30b3			RET               ;
30b4
30b4			; -------------------------------------------
30b4			; Find Row Address in Screen Line Edit Buffer
30b4			; -------------------------------------------
30b4			; Find address in Screen Line Edit Buffer of specified row.
30b4			; This routine calculates DE = $EC16 + $0023*C.
30b4			; Entry: C=Row number.
30b4			; Exit : DE=Address of edit row.
30b4
30b4	L30B4:  LD   HL,$EC16     ; Point to the Screen Line Edit Buffer.
30b7
30b7	L30B7:  PUSH AF           ; Save A.
30b8
30b8			LD   A,C          ; A=Edit row number.
30b9			LD   DE,$0023     ; 35 bytes per row.
30bc
30bc	L30BC:  OR   A            ; Row requested found?
30bd			JR   Z,L30C3      ; Jump to exit if so.
30bf
30bf			ADD  HL,DE        ; Advance to next row.
30c0			DEC  A            ;
30c1			JR   L30BC        ; Jump to test if requested row found.
30c3
30c3	L30C3:  EX   DE,HL        ; Transfer address to DE.
30c4
30c4			POP  AF           ; Restore A.
30c5			RET               ;
30c6
30c6			; --------------------------------------------
30c6			; Find Position within Screen Line Edit Buffer
30c6			; --------------------------------------------
30c6			; Find the address of a specified row and column in the Screen Line Edit Buffer.
30c6			; The routine calculates DE = $EC16 + $0023*C + B.
30c6			; Entry: B=Column number.
30c6			;        C=Row number.
30c6			; Exit : HL=Address of specified position.
30c6
30c6			; [Not used by the ROM]
30c6
30c6	L30C6:  PUSH DE           ;
30c7			CALL L30B4        ; DE=Start address in Screen Line Edit Buffer of the row specified in C.
30ca			LD   H,$00        ;
30cc			LD   L,B          ;
30cd			ADD  HL,DE        ; DE = $EC16 + $0023*C + B.
30ce			POP  DE           ;
30cf			RET               ;
30d0
30d0			; --------------------------------------
30d0			; Below-Screen Line Edit Buffer Settings
30d0			; --------------------------------------
30d0			; This table holds the default values for the Below-Screen Line Edit Buffer settings starting at $F6F5. It should only contain a table of 3 bytes to tie up
30d0			; with the space allocated within the Editor workspace variables at $F6F5. As a result, the last 2 bytes will get copied into the Below-Screen Line Edit Buffer
30d0			; itself. It appears that the word at $F6F6 is supposed to be a pointer to the next available or accessed location within the buffer but this facility
30d0			; is never used. Therefore the table need only be 1 byte long, in which case it would be more efficient for the routine at $30D6 (ROM 0) to simply set the byte
30d0			; at $F6F5 directly.
30d0
30d0	L30D0:  DEFB $05          ; Number of bytes in table.
30d1			DEFB $00          ; $F6F5 = Number of rows held in the Below-Screen Line Edit Buffer.
30d2			DEFW $0000        ; $F6F6/7. [*BUG* - These two bytes should not be here and the table should only contain 3 bytes. Credit: Paul Farrow]
30d4			DEFW $F6F8        ; $F6F8/9 = Points to next location within the Below-Screen Line Edit Buffer.
30d6
30d6			; ------------------------------------------
30d6			; Set Below-Screen Line Edit Buffer Settings
30d6			; ------------------------------------------
30d6			; Sets the default values for the Below-Screen Line Edit Buffer settings.
30d6			; Copy 5 bytes from $30D1-$30D5 (ROM 0) to $F6F5-$F6F9.
30d6
30d6	L30D6:  LD   HL,L30D0     ; Default Below-Screen Line Edit Buffer settings.
30d9			LD   DE,$F6F5     ; Destination address.
30dc			JP   L3FBA        ; Copy bytes.
30df
30df			; ----------------------------------------------
30df			; Shift Up Rows in Below-Screen Line Edit Buffer
30df			; ----------------------------------------------
30df			; Shifts up all rows in the Below-Screen Line Edit Buffer, or if empty then
30df			; copies a BASIC line from the program area into the Below-Screen Line Edit Buffer.
30df			; Exit: HL=Address of the Below-Screen Line Edit Buffer.
30df
30df	L30DF:  PUSH BC           ; Save BC.
30e0			PUSH DE           ; Save DE.
30e1
30e1			LD   HL,$F6F5     ; Point to the Below-Screen Line Edit Buffer details.
30e4			PUSH HL           ; Save it.
30e5			LD   A,(HL)       ; A=Number of rows held in Below-Screen Line Edit Buffer.
30e6			OR   A            ; Are there any rows below screen?
30e7			JR   NZ,L3101     ; Jump if so.
30e9
30e9			;There are no rows in the Below-Screen Line Edit Buffer
30e9
30e9			PUSH HL           ; Save the address of the Below-Screen Line Edit Buffer details.
30ea			CALL L335F        ; Copy 'Insert Keyword Representation Into Keyword Construction Buffer' routine into RAM.
30ed
30ed			LD   HL,($F9D7)   ; HL=Line number of the BASIC line in the program area being edited.
30f0			CALL L3352        ; Create line number representation in the Keyword Construction Buffer of the next BASIC line.
30f3			JR   NC,L30F8     ; Jump if next line does not exist, with HL holding $0000.
30f5
30f5			LD   ($F9D7),HL   ; Store the new line number.
30f8
30f8	L30F8:  LD   B,H          ;
30f9			LD   C,L          ; BC=Line number of the next BASIC line, or last BASIC line in the program.
30fa			POP  HL           ; Retrieve the address of the Below-Screen Line Edit Buffer details.
30fb			CALL L32D6        ; Copy the BASIC line into the Below-Screen Line Edit Buffer, or empty the first buffer row if the BASIC line does not exist.
30fe			DEC  A            ; Decrement the count of the number of rows held in the Below-Screen Line Edit Buffer, i.e. assume the rows have been shifted.
30ff			JR   L3116        ; Jump forward.
3101
3101			;There are rows in the Below-Screen Line Edit Buffer so shift all rows up
3101
3101	L3101:  LD   HL,$EC0D     ; Editor flags.
3104			RES  0,(HL)       ; Signal that the Screen Line Edit Buffer is not full.
3106
3106			LD   HL,$F6F8     ; Below-Screen Line Edit Buffer, the temporary copy of line being edited.
3109			LD   D,H          ;
310a			LD   E,L          ;
310b			LD   BC,$0023     ; Move all rows in the Below-Screen Line Edit Buffer up by one row.
310e			ADD  HL,BC        ;
310f			LD   BC,$02BC     ; 20 rows.
3112			LDIR              ;
3114			DEC  A            ; Decrement the count of the number of rows held in the Below-Screen Line Edit Buffer.
3115			SCF               ; [Redundant since never subsequently checked]
3116
3116	L3116:  POP  DE           ; DE=Points to number of rows held in the Below-Screen Line Edit Buffer.
3117			LD   (DE),A       ; Update the number of rows held in the Below-Screen Line Edit Buffer
3118
3118			LD   HL,$F6F8     ; HL=Address of first row in the Below-Screen Line Edit Buffer.
311b
311b			POP  DE           ; Restore DE.
311c			POP  BC           ; Restore BC.
311d			RET               ;
311e
311e			; ------------------------------------------------
311e			; Shift Down Rows in Below-Screen Line Edit Buffer
311e			; ------------------------------------------------
311e			; Shifts down all rows in the Below-Screen Line Edit Buffer, or the last Screen Line Edit Buffer
311e			; row contains a complete BASIC line then it empties the Below-Screen Line Edit Buffer.
311e			; Entry: DE=Start address in Screen Line Edit Buffer of the last editing row.
311e			; Exit : Carry flag reset to indicate Below-Screen Line Edit Buffer full.
311e			;        A =Number of rows held in the Below-Screen Line Edit Buffer.
311e			;        HL=Address of first row in the Below-Screen Line Edit Buffer.
311e
311e	L311E:  PUSH BC           ; Save BC.
311f			PUSH DE           ; DE=Start address in Screen Line Edit Buffer of the last editing row.
3120
3120			LD   HL,$0020     ;
3123			ADD  HL,DE        ; Point to the flag byte for the edit buffer row.
3124			LD   A,(HL)       ; Fetch flag byte.
3125			CPL               ; Invert bits.
3126			AND  $11          ;
3128			JR   NZ,L313F     ; Jump if not the first row of the BASIC line or no associated line number stored.
312a
312a			;First row of the BASIC line or an associated line number stored
312a
312a			PUSH HL           ; HL=Points at flag byte of the last Screen Line Edit Buffer row.
312b			PUSH DE           ; DE=Address of the last Screen Line Edit Buffer row.
312c			INC  HL           ;
312d			LD   D,(HL)       ;
312e			INC  HL           ;
312f			LD   E,(HL)       ; DE=Corresponding BASIC line number.
3130			PUSH DE           ; Save it.
3131
3131			CALL L335F        ; Copy 'Insert Keyword Representation Into Keyword Construction Buffer' routine to RAM.
3134
3134			POP  HL           ; HL=Corresponding line number for last editing row.
3135			CALL L334A        ; Find the closest line number.
3138			JR   NC,L313D     ; Jump if line does not exist.
313a
313a			LD   ($F9D7),HL   ; Store as the line number of the BASIC line being edited.
313d
313d	L313D:  POP  DE           ; DE=Address of the last Screen Line Edit Buffer row.
313e			POP  HL           ; HL=Points at flag byte of edit buffer row.
313f
313f	L313F:  BIT  0,(HL)       ; Is it the first row of the BASIC line?
3141			LD   HL,$F6F5     ; Point to the Below-Screen Line Edit Buffer details.
3144			PUSH HL           ; Save the address of the Below-Screen Line Edit Buffer details.
3145			JR   Z,L314C      ; Jump if not the first row of the BASIC line.
3147
3147			;The first row of the BASIC line, hence after the shift there will not be a row straggling off the bottom of the screen
3147
3147			LD   A,$00        ; Signal no rows held in the Below-Screen Line Edit Buffer. [Could have saved 1 byte by using XOR A]
3149			SCF               ; Signal Below-Screen Line Edit Buffer is not full.
314a			JR   L3116        ; Store new flag.
314c
314c			;Not the first row the BASIC line
314c
314c	L314C:  LD   A,(HL)       ; Fetch the number of rows held in the Below-Screen Line Edit Buffer.
314d			CP   $14          ; Has the bottom of the buffer been reached?
314f			JR   Z,L3116      ; Jump if so, with the carry flag reset to indicate the buffer is full.
3151
3151			;The Below-Screen Line Edit Buffer is not full so copy the last Screen Line Edit Buffer row into the top 'visible' Below-Screen Line Edit Buffer row
3151
3151			LD   BC,$0023     ; Length of an edit buffer row.
3154			LD   HL,$F6F8     ; Address of the first row in the Below-Screen Line Edit Buffer.
3157			EX   DE,HL        ; HL=Address of the last row in the Screen Line Edit Buffer, DE=Address of the first row in the Below-Screen Line Edit Buffer.
3158			LDIR              ; Copy the last Screen Line Edit Buffer row into the first Below-Screen Line Edit Buffer row, i.e. the 'visible' edit buffer row.
315a
315a			;Copy all Below-Screen Line Edit Buffer rows down
315a
315a			LD   HL,$F9D6     ;
315d			LD   D,H          ;
315e			LD   E,L          ; DE=End of the last row in the Below-Screen Line Edit Buffer.
315f			LD   BC,$0023     ; Length of an edit buffer row.
3162			OR   A            ;
3163			SBC  HL,BC        ; HL=End of penultimate row in the Below-Screen Line Edit Buffer.
3165			LD   BC,$02BC     ; Length of the Below-Screen Line Edit Buffer minus one row.
3168			LDDR              ; Shift all the rows down by one.
316a
316a			INC  A            ; Increment the number of rows held in the Below-Screen Line Edit Buffer.
316b			SCF               ; Signal Below-Screen Line Edit Buffer is not full.
316c			JR   L3116        ; Jump to store the number of rows held in the Below-Screen Line Edit Buffer.
316e
316e			; ---------------------------------------------------
316e			; Insert Character into Below-Screen Line Edit Buffer
316e			; ---------------------------------------------------
316e			; Called when a non-action key is pressed and rows of the BASIC line spans into the Below-Screen Line Edit Buffer and therefore
316e			; require shifting.
316e			; Entry: HL=Current row's flag byte.
316e			;        A=Character code to insert at the start of the first row of the Below-Screen Line Edit Buffer.
316e
316e	L316E:  PUSH BC           ; Save registers.
316f			PUSH DE           ;
3170
3170			PUSH AF           ; Save the character to insert.
3171
3171			LD   B,$00        ; Column 0.
3173			LD   C,$01        ; Row 1.
3175			PUSH HL           ; Save address of the row's flag byte.
3176			CALL L31C3        ; Find row address specified by C in the Below-Screen Line Edit Buffer, into DE.
3179			POP  HL           ; Retrieve address of the row's flag byte.
317a
317a			BIT  3,(HL)       ; Is this the end row of the BASIC line?
317c			RES  3,(HL)       ; Indicate that it is no longer the end row of the BASIC line.
317e			JR   NZ,L31A0     ; Jump if it was the end row of the BASIC line.
3180
3180			;The row in the Below-Screen Line Edit Buffer is not the last row of the BASIC line.
3180
3180			;Insert the character into the current row. If a spill from this row occurs then insert that character into the start of the
3180			;following row and shift all existing characters right by one. Repeat this process until all rows have been shifted.
3180
3180	L3180:  CALL L2E41        ; Find first editable position on this row from the previous column to the right, returning column number in B.
3183			POP  AF           ; A=Character to insert.
3184
3184	L3184:  CALL L16AC        ; Insert character into the start of the edit buffer row, shifting the row right. Returns carry flag reset.
3187			JR   Z,L31BA      ; Jump if the byte shifted out of the last column position was $00, hence no more shifting required.
3189
3189			;The end character of the row has spilled out so it must be inserted as the first editable character of the following row
3189
3189			PUSH AF           ; Stack the character which needs to be inserted into the next row.
318a
318a			LD   B,$00        ; B=First column in the next row.
318c			INC  C            ; C=Next row.
318d			LD   A,C          ;
318e			CP   $15          ; Has the bottom row of the Below-Screen Line Edit Buffer been reached, i.e. row 21?
3190			JR   C,L31A0      ; Jump ahead if not.
3192
3192			;The bottom row of the Below-Screen Line Edit Buffer has been reached
3192
3192			DEC  HL           ; Point to last character of the current row.
3193			LD   A,(HL)       ; Get the character.
3194			INC  HL           ; Point back to the flag byte of this row.
3195			CP   $00          ; Is the character a null character? [Could have saved 1 byte by using AND A]
3197			JR   Z,L31A0      ; Jump ahead if it is.
3199
3199			;The Below-Screen Line Edit Buffer is completely full
3199
3199			PUSH HL           ; Save address of the flag byte.
319a			LD   HL,$EC0D     ; Editor flags.
319d			SET  0,(HL)       ; Signal that the Screen Line Edit Buffer (including Below-Screen Line Edit Buffer) is full.
319f			POP  HL           ; HL=Address of the flag byte.
31a0
31a0			;Check whether there is another row to shift
31a0
31a0	L31A0:  BIT  1,(HL)       ; Does the row span onto another row?
31a2			SET  1,(HL)       ; Signal that the row spans onto another row.
31a4			RES  3,(HL)       ; Signal not the last row of the BASIC line.
31a6			CALL L31C3        ; Find the address of the row specified by C in Below-Screen Line Edit Buffer, into DE.
31a9			JR   NZ,L3180     ; Jump back if spans onto another row to shift it also.
31ab
31ab			;All existing rows have now been shifted but a new row needs to be inserted
31ab
31ab			PUSH BC           ; B=Column number. C=Row number.
31ac			PUSH DE           ; DE=Start address of the row in the edit buffer.
31ad			CALL L35E6        ; Null all column positions in the edit buffer row.
31b0			LD   (HL),$08     ; Set the flag byte for the row to indicate it is the last row of the BASIC line.
31b2			POP  DE           ; DE=Start address of the row in the edit buffer.
31b3			POP  BC           ; B=Column number. C=Row number.
31b4
31b4			CALL L35F4        ; Indent the row by setting the appropriate number of null characters.
31b7
31b7			POP  AF           ; Get character to insert.
31b8			JR   L3184        ; Jump back to insert it.
31ba
31ba			;The shifting of all rows has completed
31ba
31ba	L31BA:  LD   A,C          ; Get the row number.
31bb			LD   ($F6F5),A    ; Store as the number of rows held within the Below-Screen Line Edit Buffer.
31be			SET  3,(HL)       ; Mark this row as the last row of the BASIC line.
31c0
31c0			POP  DE           ; Restore registers.
31c1			POP  BC           ;
31c2			RET               ;
31c3
31c3			; -------------------------------------------------
31c3			; Find Row Address in Below-Screen Line Edit Buffer
31c3			; -------------------------------------------------
31c3			; Find address in the Below-Screen Line Edit Buffer of specified row.
31c3			; This routine calculates DE = $F6F8 + $0023*C.
31c3			; Entry: C=Row number.
31c3			; Exit : Address of edit row in DE.
31c3
31c3	L31C3:  LD   HL,$F6F8     ; Address of the Below-Screen Line Edit Buffer.
31c6			JP   L30B7        ; Jump to find the row address and return.
31c9
31c9			; -------------------------------------------------------------------------
31c9			; Delete a Character from a BASIC Line in the Below-Screen Line Edit Buffer
31c9			; -------------------------------------------------------------------------
31c9			; Delete a character at the specified position, shifting subsequent characters left as applicable.
31c9			; Exit: A=Character shifted out of the top row of the Below-Screen Line Edit Buffer.
31c9
31c9	L31C9:  PUSH BC           ; Save registers.
31ca			PUSH DE           ;
31cb
31cb			LD   HL,$EC0D     ; Editor flags.
31ce			RES  0,(HL)       ; Signal that the Screen Line Edit Buffer (including Below-Screen Line Edit Buffer) is not full.
31d0
31d0			LD   A,($F6F5)    ; A=Number of rows held in the Below-Screen Line Edit Buffer.
31d3			LD   C,A          ; C=Number of rows held in the Below-Screen Line Edit Buffer.
31d4			OR   A            ; Are there any rows in the Below-Screen Line Edit Buffer?
31d5			LD   A,$00        ; A null character.
31d7			JR   Z,L321B      ; Jump if there are no rows. [Redundant check since this routine should never be called if there are no rows in this buffer]
31d9
31d9			;There is at least one row in the Below-Screen Line Edit Buffer
31d9
31d9	L31D9:  CALL L31C3        ; Find the address of the last used row within Below-Screen Line Edit Buffer, into DE.
31dc			PUSH AF           ; Save the character to insert.
31dd
31dd			LD   B,$00        ; Start searching from column 0.
31df			CALL L2E41        ; Find editable position on this row to the right, returning column number in B.
31e2			JR   NC,L31F2     ; Jump if no editable position found, i.e. a blank row.
31e4
31e4			;The row is not blank
31e4
31e4			POP  AF           ; A=Character to insert.
31e5
31e5			;DE=Address within a row of edit buffer.
31e5			;A=Character to shift into right of row.
31e5			;B=The column to start shifting at.
31e5
31e5			CALL L16C1        ; Insert the character into the end of the edit buffer row, shifting all columns left until the cursor position is reached.
31e8
31e8			PUSH AF           ; A=Character shifted out, zero flag set if the shifted out character was a null ($00).
31e9			PUSH BC           ; Save the row number.
31ea
31ea			LD   B,$00        ; Start searching from column 0.
31ec			CALL L2E41        ; Is this now a blank row? i.e. Find editable position on this row to the right, returning column number in B.
31ef			POP  BC           ; C=Row number.
31f0			JR   C,L3216      ; Jump if editable position found.
31f2
31f2			;The row is already blank or the result of the shift has caused it to become blank.
31f2			;HL points to the last blank character in the row.
31f2
31f2	L31F2:  INC  HL           ; Point to the flag byte for the blank row.
31f3			LD   A,(HL)       ; Fetch the flag byte.
31f4			PUSH AF           ; Save the flag byte for the blank row.
31f5			PUSH BC           ; Save the row number.
31f6
31f6			LD   A,C          ; Fetch the row number of this blank row.
31f7			CP   $01          ; Is this the first row in the Below-Screen Line Edit Buffer?
31f9			JR   NZ,L3204     ; Jump if not.
31fb
31fb			;The first row in the Below-Screen Line Edit Buffer is empty and hence the BASIC line now fits completely on screen, i.e. within the Screen Line Edit Buffer
31fb
31fb			LD   A,($EC15)    ; The number of editing rows on screen.
31fe			LD   C,A          ; C=Bottom row number in the Screen Line Edit Buffer.
31ff			CALL L30B4        ; DE=Start address in Screen Line Edit Buffer of the bottom row, as specified in C.
3202			JR   L3208        ; Jump ahead to continue.
3204
3204			;The blank row is not the first row in the Below-Screen Line Edit Buffer, and hence there are further rows above to be shifted
3204
3204	L3204:  DEC  C            ; Previous row within the Below-Screen Line Edit Buffer.
3205			CALL L31C3        ; Find the address of the row specified by C in Below-Screen Line Edit Buffer, into DE.
3208
3208	L3208:  POP  BC           ; Retrieve the row number.
3209			POP  AF           ; A=Flag byte value for the blank row.
320a
320a			LD   HL,$0020     ;
320d			ADD  HL,DE        ; Point to the flag byte for the row above.
320e			RES  1,(HL)       ; Signal that the row above does not span onto another row.
3210			OR   (HL)         ; Or in the flag bits from the blank row, essentially this will retain the 'last row' bit.
3211			LD   (HL),A       ; Update the flag byte for the row above.
3212
3212			LD   HL,$F6F5     ; Point to the number of rows held in the Below-Screen Line Edit Buffer.
3215			DEC  (HL)         ; Decrement the row count.
3216
3216			;Continue with the next row
3216
3216	L3216:  POP  AF           ; Fetch the character shifted out from the current row, ready for insertion into the row above.
3217			DEC  C            ; Previous row.
3218			JR   NZ,L31D9     ; Jump back if the character shifted out was not null, i.e. more rows above to shift.
321a
321a			;All rows in the Below-Screen Line Edit Buffer have been shifted
321a
321a			SCF               ; [Redundant since never subsequently checked]
321b
321b	L321B:  POP  DE           ; Restore registers.
321c			POP  BC           ;
321d			RET               ;
321e
321e			; --------------------------------------
321e			; Above-Screen Line Edit Buffer Settings
321e			; --------------------------------------
321e			; This table holds the default values for the Below-Screen Line Edit Buffer settings starting at $F9DB.
321e			; It appears that the word at $F9DC is supposed to be a pointer to the next available or accessed location within the buffer but this facility
321e			; is never used. Therefore the table need only be 1 byte long, in which case it would be more efficient for the routine at $3222 (ROM 0) to simply
321e			; set the byte at $F9DB directly.
321e
321e	L321E:  DEFB $03          ; Number of bytes in table.
321f			DEFB $00          ; $F9DB = Number of rows held in the Above-Screen Line Edit Buffer.
3220			DEFW $F9DE        ; $F9DC/D = Points to next available location within the Above-Screen Line Edit Buffer.
3222
3222			; ------------------------------------------
3222			; Set Above-Screen Line Edit Buffer Settings
3222			; ------------------------------------------
3222			; Sets the default values for the Above-Screen Line Edit Buffer settings.
3222			; Copy 3 bytes from $321F-$3221 (ROM 0) to $F9DB-$F9DD.
3222
3222	L3222:  LD   HL,L321E     ; Default Above-Screen Line Edit Buffer settings.
3225			LD   DE,$F9DB     ; Destination address.
3228			JP   L3FBA        ; Copy bytes.
322b
322b			; ----------------------------------------------------
322b			; Shift Rows Down in the Above-Screen Line Edit Buffer
322b			; ----------------------------------------------------
322b			; If Above-Screen Line Edit Buffer contains row then decrement the count, i.e. less rows off screen.
322b			; If the Above-Screen Line Edit Buffer is empty then load in the new BASIC line at the top of the screen.
322b			; Exit : HL=Address of next row to use within the Above-Screen Line Edit Buffer.
322b			;        Carry flag reset if Above-Screen Line Edit Buffer is empty, i.e. no edit buffer rows were shifted.
322b
322b	L322B:  PUSH BC           ; Save registers.
322c			PUSH DE           ;
322d
322d			LD   HL,$F9DB     ; Point to the Above-Screen Line Edit Buffer settings.
3230			PUSH HL           ; Save address of the Above-Screen Line Edit Buffer settings.
3231
3231			LD   A,(HL)       ; Fetch number of rows of the BASIC line that are off the top of the screen.
3232			OR   A            ; Are there any rows off the top of the screen?
3233			JR   NZ,L3253     ; Jump if there are.
3235
3235			;There are no rows of the BASIC line off the top of the screen so use the top line that is visible on screen
3235
3235			PUSH HL           ; Save address of the Above-Screen Line Edit Buffer settings.
3236
3236			CALL L335F        ; Copy 'Insert Keyword Representation Into Keyword Construction Buffer' routine to RAM.
3239
3239			LD   HL,($FC9A)   ; HL=New line number at top of screen.
323c			CALL L334A        ; Verify the line number exists, or fetch the next line number if not.
323f			JR   NC,L3244     ; Jump if the line does not exist.
3241
3241			LD   ($FC9A),HL   ; Store the line number found as the one at the top of screen.
3244
3244	L3244:  LD   B,H          ;
3245			LD   C,L          ; BC=New line number at top of screen.
3246
3246			POP  HL           ; HL=Address of the Above-Screen Line Edit Buffer settings.
3247			INC  HL           ;
3248			INC  HL           ;
3249			INC  HL           ; Point to the first row of the Above-Screen Line Edit Buffer.
324a			JR   NC,L325D     ; Jump if the line did not exist.
324c
324c			;The line specified as the one at the top of the screen does exists
324c
324c			; [*BUG* - HL points to the start of the first row of the Above-Screen Line Edit Buffer but it should point to the settings fields
324c			;          3 bytes earlier since the call to $32D6 (ROM 0) will advance HL by 3 bytes.
324c			;          The bug manifests itself when modifying a BASIC line that spans off the top of the screen. It causes corruption
324c			;          to the line number, causing a new BASIC line to be inserted rather than updating the line being edited. When editing lines with
324c			;          a high line number, the corrupted line number can end up larger 9999 and hence the line is deemed invalid when Enter is pressed
324c			;          to insert the line into the BASIC program. The effects of the bug are often masked by the bug at $2DA1 (ROM 0) which performs LD HL,($F9DB)
324c			;          instead of LD HL,$F9DB and thereby fails to detect when the end of the Above-Screen Line Edit Buffer has been reached. The bug can
324c			;          be fixed by inserted three DEC HL instructions before the call to $32D6 (ROM 0). Credit: Paul Farrow]
324c
324c			CALL L32D6        ; Copy the new BASIC line into the Above-Screen Line Edit Buffer.
324f
324f			DEC  A            ; Decrement the count of the number of rows held in the Above-Screen Line Edit Buffer.
3250			EX   DE,HL        ; HL=Start of the next row in the Above-Screen Line Edit Buffer.
3251			JR   L325D        ; Jump ahead to continue.
3253
3253			;There are rows of the BASIC line off the top of the screen
3253
3253	L3253:  LD   HL,($F9DC)   ; HL=Address of the next location within the Above-Screen Line Edit Buffer to use.
3256			LD   BC,$0023     ;
3259			SBC  HL,BC        ; Point to the previous row location within the Above-Screen Line Edit Buffer.
325b			SCF               ; Signal to update the number of rows held in the Above-Screen Line Edit Buffer.
325c			DEC  A            ; Decrement the count of the number of rows held in the Above-Screen Line Edit Buffer.
325d
325d			;A=New number of rows held in the Above-Screen Line Edit Buffer.
325d			;HL=Address of a next row to use within the Above-Screen Line Edit Buffer.
325d			;Carry flag reset if no need to update the count of the number of rows in the Above-Screen Line Edit Buffer.
325d
325d	L325D:  EX   DE,HL        ; DE=Address of next row to use within the Above-Screen Line Edit Buffer.
325e			POP  HL           ; HL=Address of the Above-Screen Line Edit Buffer settings.
325f			JR   NC,L3262     ; Jump if no need to update the count of the number of rows in the Above-Screen Line Edit Buffer.
3261
3261			LD   (HL),A       ; Store the number of rows held in the Above-Screen Line Edit Buffer.
3262
3262	L3262:  INC  HL           ;
3263			LD   (HL),E       ;
3264			INC  HL           ;
3265			LD   (HL),D       ; Store the address of the next row to use within the Above-Screen Line Edit Buffer.
3266			EX   DE,HL        ; HL=Address of next row to use within the Above-Screen Line Edit Buffer.
3267
3267			POP  DE           ; Restore registers.
3268			POP  BC           ;
3269			RET               ;
326a
326a			; ---------------------------------------------------------------
326a			; Shift Row Up into the Above-Screen Line Edit Buffer if Required
326a			; ---------------------------------------------------------------
326a			; This routine is used to shift up a Screen Line Edit Buffer or a Below-Screen Line Edit Buffer row into the Above-Screen Line Edit Buffer.
326a			; If shifting the top row of the Screen Line Edit Buffer would result in a straggle into the Above-Screen Line Edit Buffer
326a			; then the top row is shifted into the next available location within the Above-Screen Line Edit Buffer. If the shift would
326a			; place the start of a BASIC line on the top row then the Above-Screen Line Edit Buffer is set as empty.
326a			; The routine is also called when relisting the BASIC program. The first BASIC line may straggle above the screen and so it is necessary to
326a			; load the BASIC line into the Above-Screen Line Edit Buffer. This is achieved by using the Below-Screen Line Edit Buffer as a temporary
326a			; line workspace. This routine is called to shift each row into the Above-Screen Line Edit Buffer as appropriate.
326a			; Entry: DE=Start address of the first row in the Screen Line Edit Buffer, or start address of a Below-Screen Line Edit Buffer row.
326a			; Exit : HL=Address of next row to use within the Below-Screen or Screen Line Edit Buffer.
326a			;        Carry flag set if the Line Edit Buffer if not full.
326a
326a	L326A:  PUSH BC           ; Save registers.
326b			PUSH DE           ;
326c
326c			LD   HL,$0020     ;
326f			ADD  HL,DE        ; Point to the flag byte for this row within the Below-Screen or Screen Line Edit Buffer.
3270			LD   A,(HL)       ; Fetch the flag byte.
3271			CPL               ;
3272			AND  $11          ;
3274			JR   NZ,L3282     ; Jump if not the first row of the BASIC line or no associated line number stored.
3276
3276			;First row of the BASIC line and associated line number stored
3276
3276			PUSH DE           ; DE=Start address of the row.
3277			PUSH HL           ; HL=Address of the flag byte for the row in the Line Edit Buffer.
3278
3278			INC  HL           ;
3279			LD   D,(HL)       ;
327a			INC  HL           ;
327b			LD   E,(HL)       ; DE=Line number of the corresponding BASIC line.
327c			LD   ($FC9A),DE   ; Store this as the line number that is at the top of the screen.
3280
3280			POP  HL           ; HL=Address of the flag byte for the row in the Below-Screen or Screen Line Edit Buffer.
3281			POP  DE           ; DE=Start address of the row.
3282
3282	L3282:  BIT  3,(HL)       ; Is this the last row of the BASIC line?
3284			LD   HL,$F9DB     ; Point to the Above-Screen Line Edit Buffer settings.
3287			PUSH HL           ; Stack the address of the Above-Screen Line Edit Buffer settings.
3288			JR   Z,L32A0      ; Jump if not the last row of the BASIC line.
328a
328a			;The last row of the BASIC line
328a
328a			PUSH HL           ; Stack the address of the Above-Screen Line Edit Buffer settings.
328b
328b			CALL L335F        ; Copy 'Insert Keyword Representation Into Keyword Construction Buffer' routine to RAM.
328e
328e			LD   HL,($FC9A)   ; Line number at top of screen.
3291			CALL L3352        ; Create line number representation in the Keyword Construction Buffer of the next BASIC line.
3294			LD   ($FC9A),HL   ; Update the line number at top of screen.
3297
3297			POP  HL           ; HL=Address of the Above-Screen Line Edit Buffer settings.
3298			INC  HL           ;
3299			INC  HL           ;
329a			INC  HL           ; Point to the start of the Above-Screen Line Edit Buffer.
329b
329b			LD   A,$00        ; No rows held in the Above-Screen Line Edit Buffer. [Could have saved 1 byte by using XOR A]
329d			SCF               ; Signal to update the number of rows count.
329e			JR   L325D        ; Jump back to store the new Above-Screen Line Edit Buffer settings.
32a0
32a0			;Not the last row of the BASIC line
32a0
32a0	L32A0:  LD   A,(HL)       ; Fetch the number of rows held in the Above-Screen or Screen Line Edit Buffer.
32a1			CP   $14          ; Are there 20 rows, i.e. the buffer is full?
32a3			JR   Z,L32B3      ; Jump if the buffer is full, with the carry flag reset.
32a5
32a5			;Shift the top row of the Screen Line Edit Buffer into the Above-Screen Line Edit Buffer
32a5
32a5			INC  A            ; Increment the count of the number of rows in the Above-Screen Line Edit Buffer.
32a6			LD   HL,($F9DC)   ; Fetch the address of the next row to use within the Above-Screen Line Edit Buffer.
32a9			LD   BC,$0023     ; The length of one row in the edit buffer, including the 3 data bytes.
32ac			EX   DE,HL        ; DE=Address of next location within the Above-Screen Line Edit Buffer, HL=Address of the row in the Below-Screen or Screen Line Edit Buffer to store.
32ad			LDIR              ; Copy the row of the BASIC line into the Above-Screen Line Edit Buffer.
32af
32af			EX   DE,HL        ; HL=Address of next row to use within the Above-Screen Line Edit Buffer.
32b0			SCF               ; Signal to update the count of the number of rows.
32b1			JR   L325D        ; Jump back to store the new Above-Screen Line Edit Buffer settings.
32b3
32b3			;Above-Screen Line Edit Buffer is full
32b3
32b3	L32B3:  POP  HL           ; HL=Address of the Above-Screen Line Edit Buffer settings.
32b4			POP  DE           ; Restore registers.
32b5			POP  BC           ;
32b6			RET               ;
32b7
32b7			; -------------------------------------------------
32b7			; Find Row Address in Above-Screen Line Edit Buffer
32b7			; -------------------------------------------------
32b7			; Find the address in the Above-Screen Line Edit Buffer of the specified row.
32b7			; This routine calculates DE = $F9DE + $0023*C.
32b7			; Entry: C=Row number.
32b7			; Exit : DE=Address of edit row.
32b7			;
32b7	L32B7:  LD   HL,$F9DE     ; Point to the start of the Above-Screen Line Edit Buffer.
32ba			JP   L30B7        ; Find the row address.
32bd
32bd			; ----------------------------------------------
32bd			; BASIC Line Character Action Handler Jump Table
32bd			; ----------------------------------------------
32bd
32bd	L32BD:  DEFB $08          ; Number of table entries.
32be			DEFB $0D          ; Code: Enter.
32bf			DEFW L35CC        ; Address of the 'Enter' action handler routine.
32c1			DEFB $01          ; Code: NULL.
32c2			DEFW L35DA        ; Null remaining columns of an edit buffer row.
32c4			DEFB $12          ; Code: FLASH.
32c5			DEFW L335A        ; Fetch next de-tokenized character from the BASIC line within the program area.
32c7			DEFB $13          ; Code: BRIGHT.
32c8			DEFW L335A        ; Fetch next de-tokenized character from the BASIC line within the program area.
32ca			DEFB $14          ; Code: INVERSE.
32cb			DEFW L335A        ; Fetch next de-tokenized character from the BASIC line within the program area.
32cd			DEFB $15          ; Code: OVER.
32ce			DEFW L335A        ; Fetch next de-tokenized character from the BASIC line within the program area.
32d0			DEFB $10          ; Code: INK.
32d1			DEFW L335A        ; Fetch next de-tokenized character from the BASIC line within the program area.
32d3			DEFB $11          ; Code: PAPER.
32d4			DEFW L335A        ; Fetch next de-tokenized character from the BASIC line within the program area.
32d6
32d6			; ------------------------------------------------------------------------
32d6			; Copy a BASIC Line into the Above-Screen or Below-Screen Line Edit Buffer
32d6			; ------------------------------------------------------------------------
32d6			; Copy a BASIC line into the Above-Screen or Below-Screen Line Edit Buffer, handling indentation.
32d6			; Entry: HL=Address of the previous row's flag byte in Above-Screen or Below-Screen Line Edit Buffer.
32d6			;        BC=Line number corresponding to the row being edited.
32d6			; Exit : A=Number of rows in the Above-Screen Line Edit Buffer.
32d6			;        HL=Address of the first row of the BASIC line being edited in the Above-Screen Line Edit Buffer.
32d6			;        DE=Address of the last row of the BASIC line being edited in the Above-Screen Line Edit Buffer.
32d6
32d6	L32D6:  LD   D,H          ; HL=Address of the previous row's flag byte in the Above-Screen/Below-Screen Line Edit Buffer.
32d7			LD   E,L          ; DE=Address of the previous row's flag byte in the Above-Screen/Below-Screen Line Edit Buffer.
32d8			INC  DE           ;
32d9			INC  DE           ;
32da			INC  DE           ; Advance to the start of the row in the edit buffer.
32db			PUSH DE           ; DE=Address of the start of the BASIC line in the Above-Screen/Below-Screen Line Edit Buffer.
32dc
32dc			LD   HL,$0020     ;
32df			ADD  HL,DE        ; Point to the flag byte for the row.
32e0			LD   (HL),$01     ; Signal the first row of the BASIC line.
32e2			INC  HL           ;
32e3			LD   (HL),B       ;
32e4			INC  HL           ;
32e5			LD   (HL),C       ; Store the corresponding BASIC line number.
32e6
32e6			LD   C,$01        ; Row 1.
32e8			LD   B,$00        ; Column 0.
32ea
32ea			;Enter a loop to process each character from the current BASIC line
32ea
32ea	L32EA:  PUSH BC           ; Save the column and row numbers.
32eb			PUSH DE           ; Save the Above-Screen/Below-Screen Line Edit Buffer address.
32ec
32ec			LD   A,($EC0E)    ; Fetch mode.
32ef			CP   $04          ; Calculator mode?
32f1			CALL NZ,L3517     ; If not then fetch the next de-tokenized character from the BASIC line within the program area.
32f4
32f4			POP  DE           ; Retrieve the Above-Screen/Below-Screen Line Edit Buffer address.
32f5			POP  BC           ; Retrieve the column and row numbers.
32f6			JR   C,L3307      ; Jump if Editor mode and a character was available (if calculator mode then carry flag was reset by test above).
32f8
32f8			;Calculator mode, or Editor mode and a character was not available
32f8
32f8			LD   A,C          ; A=Row number.
32f9			CP   $01          ; Is it row 1?
32fb			LD   A,$0D        ; A='Enter' character.
32fd			JR   NZ,L3307     ; Jump if not.
32ff
32ff			;Row 1
32ff
32ff			LD   A,B          ; A=Column number.
3300			OR   A            ; Is it column 0?
3301			LD   A,$01        ; A='Null' character, the code used to indicate to null edit positions.
3303			JR   Z,L3307      ; Jump if so.
3305
3305			LD   A,$0D        ; A='Enter' character.
3307
3307	L3307:  LD   HL,L32BD     ; The action handler table.
330a			CALL L3FCE        ; Call the action handler routine to process the character.
330d			JR   C,L332C      ; Jump if no more characters are available.
330f
330f			JR   Z,L32EA      ; Jump back if an action handler was found so as to process the next character.
3311
3311			;A character was available but there was no action handler routine to process it
3311
3311			PUSH AF           ; A=Character.
3312			LD   A,$1F        ;
3314			CP   B            ; Exceeded column 31?
3315			JR   NC,L3326     ; Jump ahead if not.
3317
3317			;Exceeded last column
3317
3317			LD   A,$12        ; New flag byte value indicating the row spans onto another row and there is an associated line number.
3319			CALL L3331        ; Mark this row as spanning onto the next and clear the following row's flags.
331c			JR   C,L3323      ; Jump ahead if not at bottom of the line edit buffer.
331e
331e			;At the bottom of the edit buffer so process the line as if an 'Enter' character had been encountered
331e
331e			POP  AF           ; Discard the stacked item.
331f			LD   A,$0D        ; A='Enter' character.
3321			JR   L3307        ; Jump back to process the 'Enter' code.
3323
3323			;The edit buffer has room for another character
3323
3323	L3323:  CALL L35F4        ; Indent the row by setting the appropriate number of null characters in the current Above-Screen Line Edit Buffer row.
3326
3326	L3326:  POP  AF           ; A=Character.
3327			CALL L35C5        ; Store the character in the current row/column in the Above-Screen Line Edit Buffer.
332a			JR   L32EA        ; Jump back to handle the next character.
332c
332c			;No more characters are available
332c
332c	L332C:  POP  HL           ; HL=Address of the BASIC line being edited in the Above-Screen Line Edit Buffer.
332d			LD   A,C          ; A=Number of rows in the Above-Screen Line Edit Buffer.
332e			RET  Z            ; [Redundant since carry flag is always set by here, and zero flag never subsequently checked]
332f
332f			SCF               ; [Redundant since never subsequently checked]
3330			RET               ;
3331
3331			; ------------------------------------------
3331			; Set 'Continuation' Row in Line Edit Buffer
3331			; ------------------------------------------
3331			; This routine is used when the insertion of a BASIC line needs to span onto a another row.
3331			; It marks the current row as 'not the last row of the BASIC line' and clears the following
3331			; row's flags
3331			; Entry: DE=Address of start of line edit buffer row.
3331			;        B=Column number (will be $20).
3331			;        C=Row number.
3331			;        A=New flag byte value (will be $12).
3331			; Exit : Carry flag reset if bottom of line edit buffer reached.
3331			;        HL=Address of the flag byte for the new row.
3331
3331	L3331:  PUSH AF           ; Save the new flag byte value.
3332			CALL L35E6        ; HL=Address of flag byte for the row.
3335			POP  AF           ; Retrieve the new flag byte value.
3336			XOR  (HL)         ; Toggle to set 'associated line number' and 'row spans onto another row' flags.
3337			LD   (HL),A       ; Store the new flag byte value.
3338
3338			LD   A,C          ; A=Row number.
3339			CP   $14          ; At bottom of line edit buffer?
333b			RET  NC           ; Return if so.
333c
333c			INC  C            ; Advance the row number.
333d			LD   HL,$0023     ;
3340			ADD  HL,DE        ; Point to the start of the next row.
3341			EX   DE,HL        ;
3342			LD   HL,$0020     ;
3345			ADD  HL,DE        ; Point to the flag byte for the next row.
3346			LD   (HL),$00     ; Clear the flags to indicate no BASIC line on this row.
3348			SCF               ; Signal still on a row within the edit buffer.
3349			RET               ;
334a
334a
334a			; ============================
334a			; BASIC Line Handling Routines
334a			; ============================
334a
334a			; -----------------------------------------------------
334a			; Find Address of BASIC Line with Specified Line Number
334a			; -----------------------------------------------------
334a			; This routine finds the address of the BASIC line in the program area with the specified line number,
334a			; or the next line is the specified one does not exist.
334a			; Entry: HL=Line number.
334a			; Exit : Carry flag set if line exists.
334a			;        DE=Points to the command of the BASIC line within the program area.
334a			;        HL=Line number ($0000 for no line number).
334a
334a	L334A:  CALL L34B6        ; Find the address of the BASIC line in the program area with the specified line number.
334d			RET  C            ; Return if the line exists.
334e
334e			LD   HL,$0000     ; No line number.
3351			RET               ;
3352
3352			; ---------------------------------------------------------------------
3352			; Create Next Line Number Representation in Keyword Construction Buffer
3352			; ---------------------------------------------------------------------
3352			; This routine is used to create a string representation of the line number for the next line after the specified line,
3352			; and store it in the Keyword Construction Buffer.
3352			; Entry: HL=Line number.
3352			;        A=Print leading space flag ($00=Print leading space).
3352			; Exit : Carry flag set to indicate specified line exists.
3352			;        DE=Points to the command field of the BASIC line.
3352			;        HL=Line number, or $0000 if line does not exist.
3352
3352	L3352:  CALL L3430        ; Create next line number representation in the Keyword Construction Buffer.
3355			RET  C            ; Return if line exists.
3356
3356			LD   HL,$0000     ; Line not found.
3359			RET               ;
335a
335a			; --------------------------------------------------------------------------
335a			; Fetch Next De-tokenized Character from Selected BASIC Line in Program Area
335a			; --------------------------------------------------------------------------
335a			; Exit: Carry flag reset if a character was available.
335a			;       A=Character fetched.
335a
335a	L335A:  CALL L3517        ; Fetch the next de-tokenized character from the BASIC line within the program area.
335d			CCF               ;
335e			RET  NC           ; Return if a character was available. [*BUG* - This should just be a RET. Its effect is harmless since the routine
335f			; below has previously been called and hence simply overwrites the data already copied to RAM. Credit: Ian Collier (+3), Andrew Owen (128)]
335f
335f			; --------------------------------------------------------------------------------------
335f			; Copy 'Insert Keyword Representation into Keyword Construction Buffer' Routine into RAM
335f			; --------------------------------------------------------------------------------------
335f			; Copies Insert Keyword Representation Into Keyword Construction Buffer routine into physical RAM bank 7, and resets pointers to indicate
335f			; that there is no BASIC line currently being de-tokenized.
335f
335f	L335F:  LD   HL,$0000     ; Signal no line number of command.
3362			LD   ($FC9F),HL   ; Signal no further character to fetch from the BASIC line within the program area.
3365			LD   ($FCA1),HL   ; Signal no further character to fetch from the Keyword Construction Buffer.
3368
3368			LD   HL,L3374     ; Source for Insert Keyword Representation Into Keyword Construction Buffer routine.
336b			LD   DE,$FCAE     ; Destination for Insert Keyword Representation Into Keyword Construction Buffer routine.
336e			LD   BC,$00BC     ;
3371			LDIR              ; Copy the routine to RAM bank 7 at address $FCAE.
3373			RET               ;
3374
3374			; ----------------------------------------------------------------------------------
3374			; Insert Keyword Representation into Keyword Construction Buffer <<< RAM Routine >>>
3374			; ----------------------------------------------------------------------------------
3374			; This routine copies a keyword string from ROM 1 into the Keyword Construction Buffer,
3374			; terminating it with an 'end of BASIC line' marker (code $80+' '). Only standard Spectrum
3374			; keywords are handled by this routine (SPECTRUM and PLAY are processed elsewhere).
3374			; The routine is run from RAM bank 7 at $FCAE so that access to both ROMs is available.
3374			; Depending on the value of A (which should be the ASCII code less $A5,
3374			; e.g. 'RND', the first (48K) keyword, has A=0), a different index into the
3374			; token table is taken. This is to allow speedier lookup since there are never more
3374			; than 15 keywords to advance through.
3374			; Entry: A=Keyword character code-$A5 (range $00-$5A).
3374			;        DE=Insertion address within Keyword Construction Buffer.
3374			;
3374			; Copied to physical RAM bank 7 at $FCAE-$FCFC by subroutine at $335F (ROM 0).
3374
3374	L3374:  DI                ; Disable interrupts whilst paging.
3375
3375			LD   BC,$7FFD     ;
3378			LD   D,$17        ; Page in ROM 1, SCREEN 0, no locking, RAM bank 7.
337a			OUT  (C),D        ;
337c
337c			CP   $50          ; Was the token $F5 or above?
337e			JR   NC,L33B1     ;
3380
3380			CP   $40          ; Was the token $E5 or above?
3382			JR   NC,L33AA     ;
3384
3384			CP   $30          ; Was the token $D5 or above?
3386			JR   NC,L33A3     ;
3388
3388			CP   $20          ; Was the token $C5 or above?
338a			JR   NC,L339C     ;
338c
338c			CP   $10          ; Was the token $B5 or above?
338e			JR   NC,L3395     ;
3390
3390			;Used for token range $A5-$B4 ($00 <= A <= $0F)
3390
3390			LD   HL,TOKENS+$0001 ; $0096. Token table entry "RND" in ROM 1.
3393			JR   L33B6        ;
3395
3395			;Used for token range $B5-$C4 ($10 <= A <= $1F)
3395
3395	L3395:  SUB  $10          ;
3397			LD   HL,TOKENS+$003A ; $00CF. Token table entry "ASN" in ROM 1.
339a			JR   L33B6        ;
339c
339c			;Used for token range $C5-$D4 ($20 <= A <= $2F)
339c
339c	L339C:  SUB  $20          ;
339e			LD   HL,TOKENS+$006B ; $0100. Token table entry "OR" in ROM 1.
33a1			JR   L33B6        ;
33a3
33a3			;Used for token range $D5-$E4 ($30 <= A <= $3F)
33a3
33a3	L33A3:  SUB  $30          ;
33a5			LD   HL,TOKENS+$00A9 ; $013E. Token table entry "MERGE" in ROM 1.
33a8			JR   L33B6        ;
33aa
33aa			;Used for token range $E5-$F4 ($40 <= A <= $4F)
33aa
33aa	L33AA:  SUB  $40          ;
33ac			LD   HL,TOKENS+$00F6 ; $018B. Token table entry "RESTORE" in ROM 1.
33af			JR   L33B6        ;
33b1
33b1			;Used for token range $F5-$FF (A >= $50)
33b1
33b1	L33B1:  SUB  $50          ;
33b3			LD   HL,TOKENS+$013F ; $01D4. Token table entry "PRINT" in ROM 1.
33b6
33b6	L33B6:  LD   B,A          ; Take a copy of the index value.
33b7			OR   A            ; If A=0 then already have the entry address.
33b8
33b8	L33B8:  JR   Z,L33C3      ; If indexed item found then jump ahead to copy the characters of the token.
33ba
33ba	L33BA:  LD   A,(HL)       ; Fetch a character.
33bb			INC  HL           ; Point to next character.
33bc			AND  $80          ; Has end of token marker been found?
33be			JR   Z,L33BA      ; Loop back for next character if not.
33c0
33c0			DEC  B            ; Count down the index of the required token.
33c1			JR   L33B8        ; Jump back to test whether the required token has been reached.
33c3
33c3			; -------------------------------------------
33c3			; Copy Keyword Characters <<< RAM Routine >>>
33c3			; -------------------------------------------
33c3			; This routine copies a keyword string from ROM 1 into the Keyword Construction Buffer,
33c3			; terminating it with an 'end of BASIC line' marker (code $80+' '). A leading space will
33c3			; be inserted if required and a trailing space is always inserted.
33c3			; The routine is run from physical RAM bank 7 so that access to both ROMs is available.
33c3			; Entry: HL=Address of keyword string in ROM 1.
33c3			;        DE=Insertion address within Keyword Construction Buffer.
33c3			;
33c3			; Copied to physical RAM bank 7 at $FCFD-$FD2D by subroutine at $335F (ROM 0).
33c3
33c3	L33C3:  LD   DE,$FCA3     ; DE=Keyword Construction Buffer.
33c6			LD   ($FCA1),DE   ; Store the start address of the constructed keyword.
33ca
33ca			LD   A,($FC9E)    ; Print a leading space?
33cd			OR   A            ;
33ce			LD   A,$00        ;
33d0			LD   ($FC9E),A    ; Signal leading space not required.
33d3			JR   NZ,L33D9     ; Jump if leading space not required.
33d5
33d5			LD   A,$20        ; Print a leading space.
33d7			LD   (DE),A       ; Insert a leading space.
33d8			INC  DE           ; Advance to next buffer position.
33d9
33d9	L33D9:  LD   A,(HL)       ; Fetch a character of the keyword.
33da			LD   B,A          ; Store it.
33db			INC  HL           ; Advance to next keyword character.
33dc			LD   (DE),A       ; Store the keyword character in the BASIC line buffer.
33dd			INC  DE           ; Advance to the next buffer position.
33de			AND  $80          ; Test if the end of the keyword string.
33e0			JR   Z,L33D9      ; Jump back if not to repeat for all characters of the keyword.
33e2
33e2			LD   A,B          ; Get keyword character back.
33e3			AND  $7F          ; Mask off bit 7 which indicates the end of string marker.
33e5			DEC  DE           ; Point back at the last character of the keyword copied into the buffer
33e6			LD   (DE),A       ; and store it.
33e7
33e7			INC  DE           ; Advance to the position in the buffer after the last character of the keyword.
33e8			LD   A,$80+' '    ; $A0. Space + end marker.
33ea			LD   (DE),A       ; Store an 'end of BASIC line so far' marker.
33eb
33eb			LD   A,$07        ;
33ed			LD   BC,$7FFD     ;
33f0			OUT  (C),A        ; Page in ROM 0, SCREEN 0, no locking, RAM bank 7.
33f2			EI                ; Re-enable interrupts.
33f3			RET               ;
33f4
33f4			; -------------------------
33f4			; Identify Token from Table
33f4			; -------------------------
33f4			; This routine identifies the string within the Keyword Conversion Buffer and returns
33f4			; the character code. The last character of the string to identify has bit 7 set.
33f4			; Only 48K mode tokens are identified.
33f4			; Exit: Carry flag set if token identified.
33f4			;       A=Character code.
33f4			;
33f4			; Copied to RAM at $FD2E-$FD69 by routine at $335F (ROM 0).
33f4
33f4	L33F4:  DI                ; Disable interrupts whilst paging.
33f5			LD   BC,$7FFD     ;
33f8			LD   D,$17        ; Select ROM 1, SCREEN 0, RAM bank 7.
33fa			OUT  (C),D        ;
33fc
33fc			LD   HL,TOKENS+1  ; $0096. Address of token table in ROM 1.
33ff			LD   B,$A5        ; Character code of the first token - 'RND'.
3401
3401			;Entry point here used to match 128K mode tokens and mis-spelled tokens
3401
3401	L3401:  LD   DE,$FD74     ; Keyword Conversion Buffer holds the text to match against.
3404
3404	L3404:  LD   A,(DE)       ; Fetch a character from the buffer.
3405			AND  $7F          ; Mask off terminator bit.
3407			CP   $61          ; Is it lowercase?
3409			LD   A,(DE)       ; Fetch the character again from the buffer.
340a			JR   C,L340E      ; Jump if uppercase.
340c
340c			AND  $DF          ; Make the character uppercase.
340e
340e	L340E:  CP   (HL)         ; Does the character match the current item in the token table?
340f			JR   NZ,L341A     ; Jump if it does not.
3411
3411			INC  HL           ; Point to the next character in the buffer.
3412			INC  DE           ; Point to the next character in the token table.
3413			AND  $80          ; Has the terminator been reached?
3415			JR   Z,L3404      ; Jump back if not to test the next character in the token.
3417
3417			;A match was found
3417
3417			SCF               ; Signal a match was found.
3418			JR   L3426        ; Jump ahead to continue.
341a
341a	L341A:  INC  B            ; The next character code to test against.
341b			JR   Z,L3425      ; Jump if all character codes tested.
341d
341d			;The token does not match so skip to the next entry in the token table
341d
341d	L341D:  LD   A,(HL)       ; Fetch the character from the token table.
341e			AND  $80          ; Has the end terminator been found?
3420			INC  HL           ; Point to the next character.
3421			JR   Z,L341D      ; Jump back if no terminator found.
3423
3423			JR   L3401        ; Jump back to test against the next token.
3425
3425			;All character codes tested and no match found
3425
3425	L3425:  OR   A            ; Clear the carry flag to indicate no match found.
3426
3426			;The common exit point
3426
3426	L3426:  LD   A,B          ; Fetch the character code of the matching token ($00 for no match).
3427
3427			LD   D,$07        ; Select ROM 0, SCREEN 0, RAM bank 7.
3429			LD   BC,$7FFD     ;
342c			OUT  (C),D        ;
342e			EI                ; Re-enable interrupts.
342f			RET               ; <<< Last byte copied to RAM >>>
3430
3430			; ---------------------------------------------------------------------
3430			; Create Next Line Number Representation in Keyword Construction Buffer
3430			; ---------------------------------------------------------------------
3430			; This routine is used to create a string representation of the line number for the next line after the specified line,
3430			; and store it in the Keyword Construction Buffer.
3430			; Entry: HL=Line number.
3430			;        A=Print leading space flag ($00=Print leading space).
3430			; Exit : Carry flag set to indicate specified line available.
3430			;        DE=Points to the command field of the BASIC line.
3430			;        HL=Line number.
3430
3430	L3430:  CALL L34EA        ; Clear BASIC line construction pointers (address of next character in the Keyword Construction Buffer and the
3433			; address of the next character in the BASIC line within the program area being de-tokenized).
3433			OR   A            ; [*BUG* - Supposed to be XOR A to ensure that a leading space is shown before a command keyword is printed.
3434			; However, most of the time the A register will enter the routine holding $00 and so the bug is probably harmless. Credit: Paul Farrow]
3434			LD   ($FC9E),A    ; Print a leading space flag.
3437
3437			CALL L1F20        ; Use Normal RAM Configuration (physical RAM bank 0).
343a
343a			CALL L34F6        ; Find address of the specified BASIC line, into HL.
343d			JR   NC,L3491     ; Jump if suitable line number not found, i.e. end of program reached.
343f
343f			JR   NZ,L344D     ; Jump if line number did not match, i.e. is higher than the line requested.
3441
3441			;The line number requested exists
3441
3441			LD   A,B          ; BC=Line number.
3442			OR   C            ;
3443			JR   Z,L344D      ; Jump if the first program line requested (line number of 0).
3445
3445			;Fetch the next line
3445
3445			CALL L34CF        ; Move to the start of the next BASIC line.
3448			CALL L34D9        ; Check whether at the end of the BASIC program.
344b			JR   NC,L3491     ; Jump if at the end of the BASIC program.
344d
344d			;Insert line number into the BASIC Line Construction Buffer
344d
344d	L344D:  LD   D,(HL)       ; HL=Address of the BASIC line.
344e			INC  HL           ;
344f			LD   E,(HL)       ; DE=Line number.
3450
3450			CALL L1F45        ; Use Workspace RAM configuration (physical RAM bank 7).
3453
3453			PUSH DE           ; Save the line number.
3454			PUSH HL           ; Save the address of the BASIC line+1.
3455			PUSH IX           ; Save IX.
3457
3457			LD   IX,$FCA3     ; IX=Keyword Construction Buffer, the location where the line number will be created.
345b			LD   ($FCA1),IX   ; Store the start of the buffer as the next location to store a character in.
345f
345f			EX   DE,HL        ; HL=Line number.
3460			LD   B,$00        ; Signal no digit printed yet.
3462			LD   DE,$FC18     ; -1000.
3465			CALL L3495        ; Insert the thousand digit.
3468			LD   DE,$FF9C     ; -100.
346b			CALL L3495        ; Insert the hundred digit.
346e			LD   DE,$FFF6     ; -10.
3471			CALL L3495        ; Insert the ten digit.
3474			LD   DE,$FFFF     ; -1.
3477			CALL L3495        ; Insert the units digits. [Note that this is not designed to handle line number 0, which technically is not supported by Sinclair BASIC.
347a			; The call would need to be preceded by a LD B,$01 instruction to make this function support a line number of 0. Credit: Ian Collier (+3), Andrew Owen (128)]
347a
347a			DEC  IX           ; IX points to previous ASCII digit.
347c			LD   A,(IX+$00)   ;
347f			OR   $80          ;
3481			LD   (IX+$00),A   ; Set bit 7 to mark it as the end of the line number representation.
3484
3484			POP  IX           ; Restore registers.
3486			POP  HL           ; HL=Address of the BASIC line+1.
3487			POP  DE           ; DE=Line number.
3488
3488			INC  HL           ; HL=Points to length field of the BASIC line.
3489			INC  HL           ;
348a			INC  HL           ; HL=Points to the command field of the BASIC line.
348b			LD   ($FC9F),HL   ; Store it as the next character to fetch when parsing the BASIC line to de-tokenize it.
348e
348e			EX   DE,HL        ; DE=Points to the command field of the BASIC line, HL=Line number.
348f			SCF               ; Signal line exists.
3490			RET               ;
3491
3491			;End of program reached, no line number available
3491
3491	L3491:  CALL L1F45        ; Use Workspace RAM configuration (physical RAM bank 7).
3494			RET               ; Return with carry flag reset to signal line does not exist.
3495
3495			; ------------------------------
3495			; Insert ASCII Line Number Digit
3495			; ------------------------------
3495			; Insert text representation of a line number digit in a buffer.
3495			; Insert a $00 character for every leading zero.
3495			; Entry: DE=Subtraction amount (-1000, -100, -10, -1).
3495			;        HL=Line number.
3495			;        IX=Address of the buffer to write the ASCII line number to.
3495			;        B=Indicates if digit printed yet ($00=not printed).
3495			; Exit : IX points to next buffer location.
3495			;        B=$01 if digit printed.
3495			;        HL=Line number remainder.
3495
3495	L3495:  XOR  A            ; A=Counter.
3496
3496	L3496:  ADD  HL,DE        ; Keep adding DE
3497			INC  A            ; and incrementing the counter
3498			JR   C,L3496      ; until there is no carry.
349a
349a			SBC  HL,DE        ; Adjust for the last addition and.
349c			DEC  A            ; counter value that caused the overflow.
349d
349d			;A=Number of multiples of DE in the line number
349d
349d			ADD  A,$30        ; Convert to an ASCII digit.
349f			LD   (IX+$00),A   ; Store in the buffer.
34a2			CP   '0'          ; $30. Is it a zero?
34a4			JR   NZ,L34B1     ; Jump ahead if not.
34a6
34a6			LD   A,B          ; Get the 'digit printed' flag.
34a7			OR   A            ;
34a8			JR   NZ,L34B3     ; Jump ahead if already printed a digit.
34aa
34aa			LD   A,$00        ; Otherwise this is a leading zero, so
34ac			LD   (IX+$00),A   ; store a zero byte to indicate 'nothing to print'.
34af			JR   L34B3        ; and jump ahead to point to the next buffer location.
34b1
34b1	L34B1:  LD   B,$01        ; Indicate 'digit printed'.
34b3
34b3	L34B3:  INC  IX           ; Point to the next buffer location.
34b5			RET               ;
34b6
34b6			; -----------------------------------------------------
34b6			; Find Address of BASIC Line with Specified Line Number
34b6			; -----------------------------------------------------
34b6			; This routine finds the address of the BASIC line in the program area with the specified line number,
34b6			; or the next line is the specified one does not exist.
34b6			; Entry: HL=Line number.
34b6			;        A=$00 to print a leading space.
34b6			; Exit : Carry flag set if line exists.
34b6			;        DE=Points to the command of the BASIC line within the program area.
34b6			;        HL=Line number.
34b6
34b6	L34B6:  CALL L34EA        ; Clear BASIC line construction pointers (address of next character in the Keyword Construction Buffer and the
34b9			; address of the next character in the BASIC line within the program area being de-tokenized).
34b9			OR   A            ; [*BUG* - Supposed to be XOR A to ensure that a leading space is shown before a command keyword is printed.
34ba			; However, most of the time the A register will enter the routine holding $00 and so the bug is probably harmless. Credit: Paul Farrow]
34ba			LD   ($FC9E),A    ; Store 'print a leading space' flag.
34bd
34bd			CALL L1F20        ; Use Normal RAM Configuration (physical RAM bank 0).
34c0
34c0			CALL L34F6        ; Find the address of the BASIC line with this line number, or the next line otherwise.
34c3			JR   NC,L3491     ; Jump if does not exist.
34c5
34c5			EX   DE,HL        ; HL=Address of BASIC line.
34c6			LD   A,L          ;
34c7			OR   H            ; Address of $0000, i.e. no line exists?
34c8			SCF               ; Assume line number found.
34c9			JP   NZ,L344D     ; Jump if a line was found.
34cc
34cc			CCF               ; Reset carry flag to indicate line number does not exist
34cd			JR   L3491        ; and jump to make a return.
34cf
34cf			; -----------------------
34cf			; Move to Next BASIC Line
34cf			; -----------------------
34cf			; Entry: HL=Address of current BASIC line.
34cf			; Exit : HL=Address of next BASIC line.
34cf			;        DE=Address of current BASIC line.
34cf
34cf	L34CF:  PUSH HL           ; Save the address of the original line.
34d0
34d0			INC  HL           ; Skip past the line number.
34d1			INC  HL           ;
34d2			LD   E,(HL)       ; Retrieve the line length into DE.
34d3			INC  HL           ;
34d4			LD   D,(HL)       ;
34d5			INC  HL           ;
34d6			ADD  HL,DE        ; Point to the start of the next line.
34d7
34d7			POP  DE           ; DE=Address of original line.
34d8			RET               ;
34d9
34d9			; --------------------------------
34d9			; Check if at End of BASIC Program
34d9			; --------------------------------
34d9			; Check whether at the end of the BASIC program.
34d9			; Entry: HL=Address of BASIC line.
34d9			; Exit : Carry flag reset if end of BASIC program reached.
34d9
34d9	L34D9:  LD   A,(HL)       ;
34da			AND  $C0          ;
34dc			SCF               ; Signal not at end of BASIC.
34dd			RET  Z            ; Return if not at end of program.
34de
34de			CCF               ; Signal at end of BASIC.
34df			RET               ;
34e0
34e0			; --------------------
34e0			; Compare Line Numbers
34e0			; --------------------
34e0			; Compare line number at (HL) has line number held in BC.
34e0			; Entry: HL=Address of first line number.
34e0			;        BC=Second line number.
34e0			; Exit : Carry flag and zero flag set if the line number matches.
34e0			;        Zero flag reset if no match, with carry flag set if line number held in BC
34e0			;        is lower than the line number pointed to by HL.
34e0
34e0	L34E0:  LD   A,B          ; Test the first byte.
34e1			CP   (HL)         ;
34e2			RET  NZ           ; Return if not the same.
34e3
34e3			LD   A,C          ; Test the second byte.
34e4			INC  HL           ;
34e5			CP   (HL)         ;
34e6			DEC  HL           ;
34e7			RET  NZ           ; Return if not the same.
34e8
34e8			SCF               ; Signal line number matches.
34e9			RET               ;
34ea
34ea			; --------------------------------------
34ea			; Clear BASIC Line Construction Pointers
34ea			; --------------------------------------
34ea
34ea	L34EA:  PUSH HL           ;
34eb
34eb			LD   HL,$0000     ;
34ee			LD   ($FCA1),HL   ; Signal no next character to fetch from the Keyword Construction Buffer.
34f1			LD   ($FC9F),HL   ; Signal no next character to fetch within the BASIC line in the program area.
34f4
34f4			POP  HL           ;
34f5			RET               ;
34f6
34f6			; --------------------------
34f6			; Find Address of BASIC Line
34f6			; --------------------------
34f6			; This routine finds the address of the BASIC line within the program area with the specified line number.
34f6			; Entry: HL=Line number to find ($0000 for first program line).
34f6			; Exit : Carry flag set if requested or next line exists.
34f6			;        Zero flag reset if no match, with carry flag set if line number is lower than the first program line number.
34f6			;        HL=Address of the BASIC line number, or $0000 if line does not exist.
34f6			;        DE=Address of previous BASIC line number, or $0000 if line does not exist.
34f6			;        BC=Line number.
34f6
34f6	L34F6:  PUSH HL           ;
34f7			POP  BC           ; BC=Line number. [Quicker to have used the instructions LD B,H / LD C,L]
34f8
34f8			LD   DE,$0000     ;
34fb
34fb			LD   HL,($5C53)   ; PROG. Address of the start of BASIC program.
34fe			CALL L34D9        ; Test for end of BASIC program.
3501			RET  NC           ; Return if at end of program.
3502
3502			CALL L34E0        ; Compare line number at (HL) with BC.
3505			RET  C            ; Return if line number matches or is lower than the first program line number.
3506
3506			LD   A,B          ;
3507			OR   C            ;
3508			SCF               ;
3509			RET  Z            ; Return with carry and zero flags set if first program line was requested (line number 0).
350a
350a	L350A:  CALL L34CF        ; Get address of next BASIC line.
350d			CALL L34D9        ; Test for end of BASIC program.
3510			RET  NC           ; Return if at end of program.
3511
3511			CALL L34E0        ; Compare line number at (HL) with BC.
3514			JR   NC,L350A     ; If line number not the same or greater then back to test next line.
3516
3516			RET               ; Exit with carry flag set if line found.
3517
3517			; -----------------------------------------------------------------
3517			; Fetch Next De-tokenized Character from BASIC Line in Program Area
3517			; -----------------------------------------------------------------
3517			; This routine translates a tokenized BASIC line within the program area into the equivalent 'typed' line, i.e. non-tokenized.
3517			; The line number has been previously converted into a string representation and is held within the Keyword Construction Buffer
3517			; at $FCA3. On each call of this routine, the next character of the BASIC line representation is fetched. Initially this is the
3517			; line number characters from the Keyword Construction Buffer, and then the characters from the program line itself. As a token
3517			; character is encountered, it is converted into its string representation and stored in the Keyword Construction Buffer. Then
3517			; each character of this string is fetched in turn. Once all of these characters have been fetched, the next character will be
3517			; from the last position accessed within the BASIC line in the program area.
3517			; Exit: Carry flag set to indicate that a character was available.
3517			;       A=Character fetched.
3517
3517	L3517:  LD   HL,($FCA1)   ; Fetch the address of the character within the Keyword Construction Buffer.
351a			LD   A,L          ;
351b			OR   H            ; Is there an address defined, i.e. characters still within the buffer to fetch?
351c			JR   Z,L353C      ; Jump ahead if not.
351e
351e			;There is a character within the Keyword Construction Buffer
351e
351e			LD   A,(HL)       ; Fetch a character from the buffer.
351f			INC  HL           ; Point to the next character.
3520			CP   $80+' '      ; $A0. Was it a trailing space, i.e. the last character?
3522			LD   B,A          ; Save the character.
3523			LD   A,$00        ; Signal 'print a leading space'.
3525			JR   NZ,L3529     ; Jump ahead if not.
3527
3527			LD   A,$FF        ; Signal 'do not print a leading space'.
3529
3529	L3529:  LD   ($FC9E),A    ; Store the 'print a leading space' flag value.
352c
352c			LD   A,B          ; Get the character back.
352d			BIT  7,A          ; Is it the last character in the buffer, i.e. the terminator bit is set?
352f			JR   Z,L3534      ; Jump ahead if not.
3531
3531			LD   HL,$0000     ; Signal no more characters within the Keyword Construction Buffer to fetch.
3534
3534	L3534:  LD   ($FCA1),HL   ; Store the address of the next line number/keyword character within the construction buffer, or $0000 if no more characters.
3537			AND  $7F          ; Mask off the terminator bit.
3539			JP   L358F        ; Jump ahead to continue. [Could have saved 1 byte by using JR $358F (ROM 0)]
353c
353c			;There is no line number/keyword defined within the buffer so fetch the next tokenized character from the BASIC line in the program area
353c
353c	L353C:  LD   HL,($FC9F)   ; Fetch the address of the next character within the BASIC line construction workspace.
353f			LD   A,L          ;
3540			OR   H            ; Is there a character defined, i.e. end of line not yet reached?
3541			JP   Z,L3591      ; Jump ahead if not. [Could have saved 1 byte by using JR $3591 (ROM 0)]
3544
3544			CALL L1F20        ; Use Normal RAM Configuration (physical RAM bank 0).
3547
3547	L3547:  LD   A,(HL)       ; Fetch a character from the buffer.
3548			CP   $0E          ; Is it the hidden number marker indicating a floating-point representation?
354a			JR   NZ,L3554     ; Jump ahead if it is not.
354c
354c			INC  HL           ; Skip over it the floating-point representation.
354d			INC  HL           ;
354e			INC  HL           ;
354f			INC  HL           ;
3550			INC  HL           ;
3551			INC  HL           ;
3552			JR   L3547        ; Jump back to fetch the next character.
3554
3554	L3554:  CALL L1F45        ; Use Workspace RAM configuration (physical RAM bank 7).
3557
3557			INC  HL           ; Point to the next character.
3558			LD   ($FC9F),HL   ; Store the address of the next command within the BASIC line to fetch.
355b			CP   $A5          ; 'RND'. Is the current character a standard '48K' keyword? ('RND' = first 48K keyword)
355d			JR   C,L3567      ; Jump ahead if not.
355f
355f			SUB  $A5          ; Reduce command code range to $00-$5A.
3561
3561			; [*BUG* - The routine assumes all tokens require a leading and trailing space.
3561			;          However, this is not true for tokens '<=', '>=' and '<>'. Credit: Ian Collier (+3), Paul Farrow (128)]
3561
3561			; [To fix the bug, the call to $FCAE would need to be replaced with code such as the following. Credit: Paul Farrow.
3561			;
3561			;       PUSH AF
3561			;       CALL $FCAE        ; Construct a string representation of the keyword in the Keyword Construction Buffer.
3561			;       POP  AF           ; DE=Address of last character copied.
3561			;
3561			;       CP   $22          ; Was it '<=' or above?
3561			;       JR   C,$3517 (ROM 0) ; Jump back if not to fetch and return the first character of the keyword string.
3561			;
3561			;       CP   $25          ; Was it '<>' or below?
3561			;       JR   NC,$3517 (ROM 0) ; Jump back if not to fetch and return the first character of the keyword string.
3561			;
3561			;       LD   HL,($FCA1)   ; Is there a leading space?
3561			;       LD   A,(HL)
3561			;       CP   ' '
3561			;       JR   NZ,NOT_LEADING ; Jump if there is not.
3561			;
3561			;       INC  HL
3561			;       LD   ($FCA1),HL   ; Skip past the leading space.
3561			;
3561			;NOT_LEADING:
3561			;       LD   A,$FF        ; Signal 'do not print a leading space'.
3561			;       LD   ($FC9E),A
3561			;
3561			;       LD   A,(DE)       ; Is there a trailing space?
3561			;       CP   $80+' '
3561			;       JR   NZ,NOT_TRAILING ; Jump if there is not.
3561			;
3561			;       DEC  DE
3561			;       EX   DE,HL
3561			;       SET  7,(HL)       ; Set the terminator bit on the preceding character.
3561			;
3561			;NOT_TRAILING:            ; ]
3561
3561			CALL $FCAE        ; Construct a string representation of the keyword in the Keyword Construction Buffer.
3564			JP   L3517        ; Jump back to fetch and return the first character of the keyword string. [Could have saved 1 byte by using JR $3517 (ROM 0)]
3567
3567			;It is not a standard 48K keyword
3567
3567	L3567:  CP   $A3          ; Is it a '128K' keyword, i.e. 'SPECTRUM' or 'PLAY'?
3569			JR   C,L357B      ; Jump if not.
356b
356b			;It is a 128K keyword
356b
356b			JR   NZ,L3572     ; Jump if it is 'PLAY'.
356d
356d			;Handle 'SPECTRUM'
356d
356d			LD   HL,L3594     ; Keyword string "SPECTRUM".
3570			JR   L3575        ; Jump forward.
3572
3572	L3572:  LD   HL,L359C     ; Keyword string "PLAY".
3575
3575	L3575:  CALL $FCFD        ; Copy the keyword string characters into the Keyword Construction Buffer.
3578			JP   L3517        ; Jump back to fetch and return the first character of the keyword string. [Could have saved 1 byte by using JR $3517 (ROM 0)]
357b
357b			;Not a keyword
357b
357b	L357B:  PUSH AF           ; Save the character.
357c			LD   A,$00        ;
357e			LD   ($FC9E),A    ; Signal to print a trailing space.
3581			POP  AF           ; Get the character back.
3582			CP   $0D          ; Is it an 'Enter' character?
3584			JR   NZ,L358F     ; Jump if not to exit.
3586
3586			;The end of the line was found so signal no further characters to fetch
3586
3586			LD   HL,$0000     ;
3589			LD   ($FCA1),HL   ; Signal no further character to fetch from the Keyword Construction Buffer.
358c			LD   ($FC9F),HL   ; Signal no further character to fetch from the BASIC line within the program area.
358f
358f	L358F:  SCF               ; Set the carry flag to indicate that a character was available.
3590			RET               ;
3591
3591			;There was no character within the buffer
3591
3591	L3591:  SCF               ;
3592			CCF               ; Reset the carry flag to indicate that a character was not available.
3593			RET               ;
3594
3594
3594			; =============================
3594			; Edit Buffer Routines - Part 2
3594			; =============================
3594
3594			; ---------------------
3594			; Keywords String Table
3594			; ---------------------
3594			; The following strings are terminated by having bit 7 set, referenced at $356D (ROM 0) and $3F87 (ROM 0).
3594			; The table consists of the new 128K mode keywords and mis-spelled keywords.
3594
3594	L3594:  DEFM "SPECTRU"
359b			DEFB $80+'M'
359c	L359C:  DEFM "PLA"
359f			DEFB $80+'Y'
35a0			DEFM "GOT"
35a3			DEFB $80+'O'
35a4			DEFM "GOSU"
35a8			DEFB $80+'B'
35a9			DEFM "DEFF"
35ad			DEFB $80+'N'
35ae			DEFM "OPEN"
35b2			DEFB $80+'#'
35b3			DEFM "CLOSE"
35b8			DEFB $80+'#'
35b9
35b9			; --------------------
35b9			; Indentation Settings
35b9			; --------------------
35b9			; Copied to $FD6A-$FD6B.
35b9
35b9	L35B9:  DEFB $02          ; Number of bytes in table.
35ba			DEFB $01          ; Flag never subsequently used. Possibly intended to indicate the start of a new BASIC line and hence whether indentation required.
35bb			DEFB $05          ; Number of characters to indent by.
35bc
35bc			; ------------------------
35bc			; Set Indentation Settings
35bc			; ------------------------
35bc
35bc	L35BC:  LD   HL,L35B9     ; HL=Address of the indentation settings data table.
35bf			LD   DE,$FD6A     ; Destination address.
35c2			JP   L3FBA        ; Copy two bytes from $35B9-$35BA (ROM 0) to $FD6A-$FD6B.
35c5
35c5			; --------------------------------------------
35c5			; Store Character in Column of Edit Buffer Row
35c5			; --------------------------------------------
35c5			; Store character in the specified column of the current edit buffer row.
35c5			; Entry: B=Column number.
35c5			;        DE=Start address of row.
35c5			;        A=Character to insert.
35c5			; Exit : B=Next column number.
35c5
35c5	L35C5:  LD   L,B          ;
35c6			LD   H,$00        ;
35c8			ADD  HL,DE        ; Point to the required column.
35c9			LD   (HL),A       ; Store the character.
35ca			INC  B            ; Advance to the next column.
35cb			RET               ;
35cc
35cc			; ------------------------------
35cc			; 'Enter' Action Handler Routine
35cc			; ------------------------------
35cc			; Entry: B=Initial column to null.
35cc			;        DE=Address of start of edit row.
35cc			; Exit : Carry flag set to indicate no more characters are available, i.e. end of line.
35cc
35cc	L35CC:  CALL L35E6        ; Null remaining column positions in the edit buffer row.
35cf
35cf			LD   A,(HL)       ; Fetch the flag byte.
35d0			OR   $18          ; Signal associated line number and last row in the BASIC line.
35d2			LD   (HL),A       ; Update the flag byte.
35d3
35d3			LD   HL,$FD6A     ; [Redundant since flag never subsequently tested. Deleting these instructions would have saved 5 bytes]
35d6			SET  0,(HL)       ; Flag possibly intended to indicate the start of a new BASIC line and hence whether indentation required.
35d8
35d8			SCF               ; Signal no more characters are available, i.e. end of line.
35d9			RET               ;
35da
35da			; -------------------------------------
35da			; 'Null Columns' Action Handler Routine
35da			; -------------------------------------
35da			; Entry: B=Initial column to null.
35da			;        DE=Address of start of edit row.
35da			; Exit : Carry flag set to indicate no more characters are available, i.e. end of line.
35da
35da	L35DA:  CALL L35E6        ; Null remaining column positions in the edit buffer row.
35dd
35dd			SET  3,(HL)       ; Signal last row of the BASIC line in the row flag byte.
35df
35df			LD   HL,$FD6A     ; [Redundant since flag never subsequently tested. Deleting these instructions would have saved 5 bytes]
35e2			SET  0,(HL)       ; Flag possibly intended to indicate the start of a new BASIC line and hence whether indentation required.
35e4
35e4			SCF               ; Signal no more characters are available, i.e. end of line.
35e5			RET               ;
35e6
35e6			; ---------------------
35e6			; Null Column Positions
35e6			; ---------------------
35e6			; This routine inserts null characters into the remainder of a line edit buffer row.
35e6			; Entry: B=Initial column to null.
35e6			;        DE=Address of start of edit row.
35e6			; Exit : HL=Address of the row's flag byte.
35e6
35e6	L35E6:  LD   L,B          ;
35e7			LD   H,$00        ; HL=Number of columns.
35e9			ADD  HL,DE        ; Point to column position in line edit buffer row.
35ea			LD   A,$20        ; 32 columns.
35ec
35ec	L35EC:  CP   B            ; Found specified column?
35ed			RET  Z            ; Return if so.
35ee
35ee			LD   (HL),$00     ; Store a null in the location.
35f0			INC  HL           ; Next buffer position.
35f1			INC  B            ; Increment column position counter.
35f2			JR   L35EC        ; Repeat for next column.
35f4
35f4			; ----------------------
35f4			; Indent Edit Buffer Row
35f4			; ----------------------
35f4			; Indent a row by setting the appropriate number of characters in
35f4			; an edit buffer row to nulls, i.e. character $00.
35f4			; Entry: DE=Address of row within edit buffer.
35f4			; Exit : B=First usable column number in the row.
35f4
35f4	L35F4:  LD   A,($FD6B)    ; Get the number of indentation columns.
35f7			LD   B,$00        ; Start at first column.
35f9
35f9	L35F9:  LD   H,$00        ;
35fb			LD   L,B          ; HL=Column position.
35fc			ADD  HL,DE        ;
35fd			LD   (HL),$00     ; Put a null in the column position.
35ff			INC  B            ; Next position.
3600			DEC  A            ;
3601			JR   NZ,L35F9     ; Repeat for all remaining columns.
3603
3603			RET               ;
3604
3604			; -------------------------------------------------
3604			; Print Edit Buffer Row to Display File if Required
3604			; -------------------------------------------------
3604			; Print a row of the edit buffer to the display file if required.
3604			; Entry: HL=Address of edit buffer row.
3604
3604	L3604:  PUSH BC           ; Save registers.
3605			PUSH DE           ;
3606			PUSH HL           ;
3607
3607			PUSH HL           ; Save edit buffer row address.
3608			LD   HL,$EEF5     ;
360b			BIT  2,(HL)       ; Is printing of the edit buffer row required?
360d			POP  HL           ; Retrieve edit buffer row address.
360e			JR   NZ,L3614     ; Jump if printing is not required.
3610
3610			LD   B,C          ; B=Cursor row position.
3611			CALL L3B1E        ; Print the edit buffer row to the screen. Returns with the carry flag set.
3614
3614	L3614:  POP  HL           ; Restore registers.
3615			POP  DE           ;
3616			POP  BC           ;
3617			RET               ;
3618
3618			; ----------------------------------------------
3618			; Shift Up Edit Rows in Display File if Required
3618			; ----------------------------------------------
3618			; This routine shifts edit rows in the display file up if required, replacing the bottom row with the
3618			; top entry from the Below-Screen Line Edit Buffer.
3618			; Entry: HL=Address of first row within the Below-Screen Line Edit Buffer.
3618			;        C =Number of editing rows on screen.
3618			;        B =Row number to shift from.
3618
3618	L3618:  PUSH BC           ; Save registers.
3619			PUSH DE           ;
361a			PUSH HL           ;
361b
361b			PUSH HL           ; Save edit buffer row address.
361c			LD   HL,$EEF5     ;
361f			BIT  2,(HL)       ; Is updating of the display file required?
3621			POP  HL           ; Retrieve edit buffer row address.
3622			JR   NZ,L3628     ; Jump if updating is not required.
3624
3624			LD   E,C          ; E=Cursor row position, i.e. row to shift from.
3625			CALL L3ABF        ; Shift up edit rows in the display file, replacing the bottom row with the
3628			; top entry from the Below-Screen Line Edit Buffer.
3628
3628	L3628:  POP  HL           ; Restore registers.
3629			POP  DE           ;
362a			POP  BC           ;
362b			RET               ;
362c
362c			; ------------------------------------------------
362c			; Shift Down Edit Rows in Display File if Required
362c			; ------------------------------------------------
362c			; This routine shifts edit rows in the display file down if required, replacing the top row with the
362c			; bottom entry from the Above-Screen Line Edit Buffer.
362c			; Entry: HL=Address of next row to use within the Above-Screen Line Edit Buffer.
362c			;        C =Number of editing rows on screen.
362c			;        B =Row number to shift from.
362c
362c	L362C:  PUSH BC           ; Save registers.
362d			PUSH DE           ;
362e			PUSH HL           ;
362f
362f			PUSH HL           ; Save edit buffer row address.
3630			LD   HL,$EEF5     ;
3633			BIT  2,(HL)       ; Is updating of the display file required?
3635			POP  HL           ; Retrieve edit buffer row address.
3636			JR   NZ,L363C     ; Jump if updating is not required.
3638
3638			LD   E,C          ; E=Cursor row position, i.e. row to shift from.
3639			CALL L3AC6        ; Shift down edit rows in the display file, replacing the top row with the
363c			; bottom entry from the Above-Screen Line Edit Buffer.
363c
363c	L363C:  POP  HL           ; Restore registers.
363d			POP  DE           ;
363e			POP  BC           ;
363f			RET               ;
3640
3640			; ---------------------------
3640			; Set Cursor Attribute Colour
3640			; ---------------------------
3640			; Entry: C=Row number, B=Column number.
3640
3640	L3640:  PUSH AF           ; Save registers.
3641			PUSH BC           ;
3642			PUSH DE           ;
3643			PUSH HL           ;
3644
3644			LD   A,B          ; Swap B with C.
3645			LD   B,C          ;
3646			LD   C,A          ;
3647			CALL L3A9D        ; Set cursor position attribute.
364a
364a			POP  HL           ; Restore registers.
364b			POP  DE           ;
364c			POP  BC           ;
364d			POP  AF           ;
364e			RET               ;
364f
364f			; ------------------------------------------
364f			; Restore Cursor Position Previous Attribute
364f			; ------------------------------------------
364f			; Entry: C=row, B=column.
364f
364f	L364F:  PUSH AF           ; Save registers
3650			PUSH BC           ;
3651			PUSH DE           ;
3652			PUSH HL           ;
3653
3653			LD   A,B          ; Column.
3654			LD   B,C          ; Row.
3655			LD   C,A          ; Column.
3656			CALL L3AB2        ; Restore cursor position attribute.
3659
3659			POP  HL           ; Restore registers.
365a			POP  DE           ;
365b			POP  BC           ;
365c			POP  AF           ;
365d			RET               ;
365e
365e			; --------------
365e			; Reset 'L' Mode
365e			; --------------
365e
365e	L365E:  LD   A,$00        ; Select 'L' mode.
3660			LD   ($5C41),A    ; MODE.
3663
3663			LD   A,$02        ; Reset repeat key duration.
3665			LD   ($5C0A),A    ; REPPER
3668
3668	L3668:  LD   HL,$5C3B     ; FLAGS.
366b			LD   A,(HL)       ;
366c			OR   $0C          ; Select L-Mode and Print in L-Mode.
366e			LD   (HL),A       ;
366f
366f			LD   HL,$EC0D     ; Editor flags.
3672			BIT  4,(HL)       ; Return to the calculator?
3674			LD   HL,FLAGS3    ; $5B66.
3677			JR   NZ,L367C     ; Jump ahead if so.
3679
3679			RES  0,(HL)       ; Select Editor/Menu mode.
367b			RET               ;
367c
367c	L367C:  SET  0,(HL)       ; Select BASIC/Calculator mode.
367e			RET               ;
367f
367f			; --------------------
367f			; Wait for a Key Press
367f			; --------------------
367f			; Exit: A holds key code.
367f
367f	L367F:  PUSH HL           ; Preserve contents of HL.
3680
3680	L3680:  LD   HL,$5C3B     ; FLAGS.
3683
3683	L3683:  BIT  5,(HL)       ;
3685			JR   Z,L3683      ; Wait for a key press.
3687
3687			RES  5,(HL)       ; Clear the new key indicator flag.
3689
3689			LD   A,($5C08)    ; Fetch the key pressed from LAST_K.
368c			LD   HL,$5C41     ; MODE.
368f			RES  0,(HL)       ; Remove extended mode.
3691
3691			CP   $20          ; Is it a control code?
3693			JR   NC,L36A2     ; Jump if not to accept all characters and token codes (used for the keypad).
3695
3695			CP   $10          ; Is it a cursor key?
3697			JR   NC,L3680     ; Jump back if not to wait for another key.
3699
3699			CP   $06          ; Is it a cursor key?
369b			JR   C,L3680      ; Jump back if not to wait for another key.
369d
369d			;Control code or cursor key
369d
369d			CALL L36A4        ; Handle CAPS LOCK code and 'mode' codes.
36a0			JR   NC,L3680     ; Jump back if mode might have changed.
36a2
36a2	L36A2:  POP  HL           ; Restore contents of HL.
36a3			RET               ;
36a4
36a4	L36A4:  RST  28H          ;
36a5			DEFW KEY_M_CL     ; $10DB. Handle CAPS LOCK code and 'mode' codes via ROM 1.
36a7			RET               ;
36a8
36a8
36a8			; ======================
36a8			; MENU ROUTINES - PART 5
36a8			; ======================
36a8
36a8			; ------------
36a8			; Display Menu
36a8			; ------------
36a8			; HL=Address of menu text.
36a8
36a8	L36A8:  PUSH HL           ; Save address of menu text.
36a9
36a9			CALL L373B        ; Store copy of menu screen area and system variables.
36ac
36ac			LD   HL,$5C3C     ; TVFLAG.
36af			RES  0,(HL)       ; Signal using main screen.
36b1
36b1			POP  HL           ; HL=Address of menu text.
36b2
36b2			LD   E,(HL)       ; Fetch number of table entries.
36b3			INC  HL           ; Point to first entry.
36b4
36b4			PUSH HL           ;
36b5			LD   HL,L37EC     ; Set title colours.
36b8			CALL L3733        ; Print them.
36bb			POP  HL           ;
36bc
36bc			CALL L3733        ; Print menu title pointed to by HL.
36bf
36bf			PUSH HL           ;
36c0			CALL L3822        ; Print Sinclair stripes.
36c3			LD   HL,L37FA     ; Black ' '.
36c6			CALL L3733        ; Print it.
36c9			POP  HL           ; HL=Address of first menu item text.
36ca
36ca			PUSH DE           ; Save number of menu items left to print.
36cb
36cb			LD   BC,$0807     ;
36ce			CALL L372B        ; Perform 'Print AT 8,7;' (this is the top left position of the menu).
36d1
36d1	L36D1:  PUSH BC           ; Save row print coordinates.
36d2
36d2			LD   B,$0C        ; Number of columns in a row of the menu.
36d4
36d4			LD   A,$20        ; Print ' '.
36d6			RST  10H          ;
36d7
36d7	L36D7:  LD   A,(HL)       ; Fetch menu item character.
36d8			INC  HL           ;
36d9			CP   $80          ; End marker found?
36db			JR   NC,L36E0     ; Jump if end of text found.
36dd
36dd			RST  10H          ; Print menu item character
36de			DJNZ L36D7        ; Repeat for all characters in menu item text.
36e0
36e0	L36E0:  AND  $7F          ; Clear bit 7 to yield a final text character.
36e2			RST  10H          ; Print it.
36e3
36e3	L36E3:  LD   A,$20        ;
36e5			RST  10H          ; Print trailing spaces
36e6			DJNZ L36E3        ; Until all columns filled.
36e8
36e8			POP  BC           ; Fetch row print coordinates.
36e9			INC  B            ; Next row.
36ea			CALL L372B        ; Print AT.
36ed
36ed			DEC  E            ;
36ee			JR   NZ,L36D1     ; Repeat for all menu items.
36f0
36f0			LD   HL,$6F38     ; Coordinates, pixel (111, 56) = end row 13, column 7.
36f3
36f3			POP  DE           ; Fetch number of menu items to E.
36f4			SLA  E            ;
36f6			SLA  E            ;
36f8			SLA  E            ; Determine number of pixels to span all menu items.
36fa			LD   D,E          ;
36fb			DEC  D            ; D=8*Number of menu items - 1.
36fc
36fc			LD   E,$6F        ; Number of pixels in width of menu.
36fe			LD   BC,$FF00     ; B=-1, C=0. Plot a vertical line going up.
3701			LD   A,D          ; A=Number of vertical pixels to plot.
3702			CALL L3719        ; Plot line.
3705
3705			LD   BC,$0001     ; B=0, C=1. Plot a horizontal line going to the right.
3708			LD   A,E          ; A=Number of horizontal pixels to plot.
3709			CALL L3719        ; Plot line.
370c
370c			LD   BC,$0100     ; B=1, C=0. Plot a vertical line going down.
370f			LD   A,D          ; A=Number of vertical pixels to plot.
3710			INC  A            ; Include end pixel.
3711			CALL L3719        ; Plot line.
3714
3714			XOR  A            ; A=Index of menu option to highlight.
3715			CALL L37CA        ; Toggle menu option selection so that it is highlight.
3718			RET               ; [Could have saved one byte by using JP $37CA (ROM 0)]
3719
3719			; -----------
3719			; Plot a Line
3719			; -----------
3719			; Entry: H=Line pixel coordinate.
3719			;        L=Column pixel coordinate.
3719			;        B=Offset to line pixel coordinate ($FF, $00 or $01).
3719			;        C=Offset to column pixel coordinate ($FF, $00 or $01).
3719			;        A=number of pixels to plot.
3719
3719	L3719:  PUSH AF           ; Save registers.
371a			PUSH HL           ;
371b			PUSH DE           ;
371c			PUSH BC           ;
371d
371d			LD   B,H          ; Coordinates to BC.
371e			LD   C,L          ;
371f			RST  28H          ;
3720			DEFW PLOT_SUB+4   ; $22E9. Plot pixel
3722
3722			POP  BC           ; Restore registers.
3723			POP  DE           ;
3724			POP  HL           ;
3725			POP  AF           ;
3726
3726			ADD  HL,BC        ; Determine coordinates of next pixel.
3727			DEC  A            ;
3728			JR   NZ,L3719     ; Repeat for all pixels.
372a
372a			RET               ;
372b
372b			; -------------------------
372b			; Print "AT B,C" Characters
372b			; -------------------------
372b
372b	L372B:  LD   A,$16        ; 'AT'.
372d			RST  10H          ; Print.
372e			LD   A,B          ; B=Row number.
372f			RST  10H          ; Print.
3730			LD   A,C          ; C=Column number.
3731			RST  10H          ; Print.
3732			RET               ;
3733
3733			; ------------
3733			; Print String
3733			; ------------
3733			; Print characters pointed to by HL until $FF found.
3733
3733	L3733:  LD   A,(HL)       ; Fetch a character.
3734			INC  HL           ; Advance to next character.
3735			CP   $FF          ; Reach end of string?
3737			RET  Z            ; Return if so.
3738
3738			RST  10H          ; Print the character.
3739			JR   L3733        ; Back for the next character.
373b
373b			; ----------------------
373b			; Store Menu Screen Area
373b			; ----------------------
373b			; Store copy of menu screen area and system variables.
373b
373b	L373B:  SCF               ; Set carry flag to signal to save screen area.
373c			JR   L373F        ; Jump ahead to continue.
373e
373e			; ------------------------
373e			; Restore Menu Screen Area
373e			; ------------------------
373e			; Restore menu screen area and system variables from copy.
373e			; Entry: IX=Address of the cursor settings information.
373e
373e	L373E:  AND  A            ; Reset carry flag to signal restore screen area.
373f
373f	L373F:  LD   DE,$EEF6     ; Store for TVFLAG.
3742			LD   HL,$5C3C     ; TVFLAG.
3745			JR   C,L3748      ; Jump if storing copies.
3747
3747			EX   DE,HL        ; Exchange source and destination pointers.
3748
3748	L3748:  LDI               ; Transfer the byte.
374a			JR   C,L374D      ; Jump if storing copies.
374c
374c			EX   DE,HL        ; Restore source and destination pointers.
374d
374d	L374D:  LD   HL,$5C7D     ; COORDS. DE=$EEF7 by now.
3750			JR   C,L3753      ; Jump if storing copies.
3752
3752			EX   DE,HL        ; Exchange source and destination pointers.
3753
3753	L3753:  LD   BC,$0014     ; Copy 20 bytes.
3756			LDIR              ; Copy COORDS until ATTR_T.
3758			JR   C,L375B      ; Jump if storing copies.
375a
375a			EX   DE,HL        ; Restore source and destination pointers.
375b
375b	L375B:  EX   AF,AF'       ; Save copy direction flag.
375c
375c			LD   BC,$0707     ; Menu will be at row 7, column 7.
375f			CALL L3B94        ; B=Number of rows to end row of screen. C=Number of columns to the end column of the screen.
3762
3762			LD   A,(IX+$01)   ; A=Rows above the editing area ($16 when using the lower screen, $00 when using the main screen).
3765			ADD  A,B          ; B=Row number within editing area.
3766			LD   B,A          ; B=Bottom screen row to store.
3767			LD   A,$0C        ; A=Number of rows to store. [Could have been just $07 freeing up 630 bytes of workspace]
3769
3769	L3769:  PUSH BC           ; B holds number of row to store.
376a			PUSH AF           ; A holds number of rows left to store.
376b			PUSH DE           ; DE=End of destination address.
376c
376c			RST  28H          ;
376d			DEFW CL_ADDR      ; $0E9B. HL=Display file address of row B.
376f			LD   BC,$0007     ; Menu always starts at column 7.
3772			ADD  HL,BC        ; HL=Address of attribute byte at column 7.
3773			POP  DE           ;
3774
3774			CALL L377E        ; Store / restore menu screen row.
3777
3777			POP  AF           ;
3778			POP  BC           ;
3779			DEC  B            ; Next row.
377a			DEC  A            ; More rows to store / restore?
377b			JR   NZ,L3769     ; Repeat for next row
377d
377d			RET               ;
377e
377e			; -------------------------------
377e			; Store / Restore Menu Screen Row
377e			; -------------------------------
377e			; Entry: HL=Start address of menu row in display file.
377e			;        DE=Screen location/Workspace store for screen row.
377e			;        AF'=Carry flag set for store to workspace, reset for restore to screen.
377e			; Exit : DE=Screen location/workspace store for next screen row.
377e
377e			;Save the display file bytes
377e
377e	L377E:  LD   BC,$080E     ; B=Menu row is 8 lines deep. C=Menu is 14 columns wide.
3781
3781	L3781:  PUSH BC           ; Save number of row lines.
3782			LD   B,$00        ; Just keep the column count in BC.
3784
3784			PUSH HL           ; Save display file starting address.
3785
3785			EX   AF,AF'       ; Retrieve copy direction flag.
3786			JR   C,L3789      ; Jump if storing copies of display file bytes.
3788
3788			EX   DE,HL        ; Exchange source and destination pointers.
3789
3789	L3789:  LDIR              ; Copy the row of menu display file bytes.
378b			JR   C,L378E      ; Jump if storing copies of display file bytes.
378d
378d			EX   DE,HL        ; Restore source and destination pointers.
378e
378e	L378E:  EX   AF,AF'       ; Save copy direction flag.
378f
378f			POP  HL           ; Fetch display file starting address.
3790			INC  H            ; Advance to next line
3791
3791			POP  BC           ; Fetch number of lines.
3792			DJNZ L3781        ; Repeat for next line.
3794
3794			;Now save the attributes
3794
3794			PUSH BC           ; B=0. C=Number of columns.
3795			PUSH DE           ; DE=Destination address.
3796			RST  28H          ;
3797			DEFW CL_ATTR      ; $0E88. HL=Address of attribute byte.
3799			EX   DE,HL        ; DE=Address of attribute byte.
379a			POP  DE           ;
379b			POP  BC           ;
379c
379c			EX   AF,AF'       ; Retrieve copy direction flag.
379d			JR   C,L37A0      ; Jump if storing copies of attribute bytes.
379f
379f			EX   DE,HL        ; Restore source and destination pointers.
37a0
37a0	L37A0:  LDIR              ; Copy the row of menu attribute bytes.
37a2			JR   C,L37A5      ; Jump if storing copies of attribute bytes.
37a4
37a4			EX   DE,HL        ; Restore source and destination pointers.
37a5
37a5	L37A5:  EX   AF,AF'       ; Save copy direction flag.
37a6			RET               ;
37a7
37a7			; ------------
37a7			; Move Up Menu
37a7			; ------------
37a7
37a7	L37A7:  CALL L37CA        ; Toggle old menu item selection to de-highlight it.
37aa			DEC  A            ; Decrement menu index.
37ab			JP   P,L37B1      ; Jump if not exceeded top of menu.
37ae
37ae			LD   A,(HL)       ; Fetch number of menu items.
37af			DEC  A            ; Ignore the title.
37b0			DEC  A            ; Make it indexed from 0.
37b1
37b1	L37B1:  CALL L37CA        ; Toggle new menu item selection to highlight it.
37b4			SCF               ; Ensure carry flag is set to prevent immediately
37b5			RET               ; calling menu down routine upon return.
37b6
37b6			; --------------
37b6			; Move Down Menu
37b6			; --------------
37b6
37b6	L37B6:  PUSH DE           ; Save DE.
37b7
37b7			CALL L37CA        ; Toggle old menu item selection to de-highlight it.
37ba
37ba			INC  A            ; Increment menu index.
37bb			LD   D,A          ; Save menu index.
37bc
37bc			LD   A,(HL)       ; fetch number of menu items.
37bd			DEC  A            ; Ignore the title.
37be			DEC  A            ; Make it indexed from 0.
37bf			CP   D            ; Has bottom of menu been exceeded?
37c0			LD   A,D          ; Fetch menu index.
37c1			JP   P,L37C5      ; Jump if bottom menu not exceeded.
37c4
37c4			XOR  A            ; Select top menu item.
37c5
37c5	L37C5:  CALL L37CA        ; Toggle new menu item selection to highlight it.
37c8
37c8			POP  DE           ; Restore DE.
37c9			RET               ;
37ca
37ca			; --------------------------------------
37ca			; Toggle Menu Option Selection Highlight
37ca			; --------------------------------------
37ca			; Entry: A=Menu option index to highlight.
37ca
37ca	L37CA:  PUSH AF           ; Save registers.
37cb			PUSH HL           ;
37cc			PUSH DE           ;
37cd
37cd			LD   HL,$5907     ; First attribute byte at position (9,7).
37d0			LD   DE,$0020     ; The increment for each row.
37d3			AND  A            ;
37d4			JR   Z,L37DA      ; Jump ahead if highlighting the first entry.
37d6
37d6	L37D6:  ADD  HL,DE        ; Otherwise increase HL
37d7			DEC  A            ; for each row.
37d8			JR   NZ,L37D6     ;
37da
37da	L37DA:  LD   A,$78        ; Flash 0, Bright 1, Paper 7, Ink 0 = Bright white.
37dc			CP   (HL)         ; Is the entry already highlighted?
37dd			JR   NZ,L37E1     ; Jump ahead if not.
37df
37df			LD   A,$68        ; Flash 0, Bright 1, Paper 5, Ink 0 = Bright cyan.
37e1
37e1	L37E1:  LD   D,$0E        ; There are 14 columns to set.
37e3
37e3	L37E3:  LD   (HL),A       ; Set the attributes for all columns.
37e4			INC  HL           ;
37e5			DEC  D            ;
37e6			JR   NZ,L37E3     ;
37e8
37e8			POP  DE           ; Restore registers.
37e9			POP  HL           ;
37ea			POP  AF           ;
37eb			RET               ;
37ec
37ec			; ------------------------
37ec			; Menu Title Colours Table
37ec			; ------------------------
37ec
37ec	L37EC:  DEFB $16, $07, $07 ; AT 7,7;
37ef			DEFB $15, $00      ; OVER 0;
37f1			DEFB $14, $00      ; INVERSE 0;
37f3			DEFB $10, $07      ; INK 7;
37f5			DEFB $11, 00       ; PAPER 0;
37f7			DEFB $13, $01      ; BRIGHT 1;
37f9			DEFB $FF           ;
37fa
37fa			; ----------------------
37fa			; Menu Title Space Table
37fa			; ----------------------
37fa
37fa	L37FA:  DEFB $11, $00      ; PAPER 0;
37fc			DEFB ' '           ;
37fd			DEFB $11, $07      ; PAPER 7;
37ff			DEFB $10, $00      ; INK 0;
3801			DEFB $FF           ;
3802
3802			; -----------------------------
3802			; Menu Sinclair Stripes Bitmaps
3802			; -----------------------------
3802			; Bit-patterns for the Sinclair stripes used on the menus.
3802
3802	L3802:  DEFB $01          ; 0 0 0 0 0 0 0 1           X
3803			DEFB $03          ; 0 0 0 0 0 0 1 1          XX
3804			DEFB $07          ; 0 0 0 0 0 1 1 1         XXX
3805			DEFB $0F          ; 0 0 0 0 1 1 1 1        XXXX
3806			DEFB $1F          ; 0 0 0 1 1 1 1 1       XXXXX
3807			DEFB $3F          ; 0 0 1 1 1 1 1 1      XXXXXX
3808			DEFB $7F          ; 0 1 1 1 1 1 1 1     XXXXXXX
3809			DEFB $FF          ; 1 1 1 1 1 1 1 1    XXXXXXXX
380a
380a			DEFB $FE          ; 1 1 1 1 1 1 1 0    XXXXXXX
380b			DEFB $FC          ; 1 1 1 1 1 1 0 0    XXXXXX
380c			DEFB $F8          ; 1 1 1 1 1 0 0 0    XXXXX
380d			DEFB $F0          ; 1 1 1 1 0 0 0 0    XXXX
380e			DEFB $E0          ; 1 1 1 0 0 0 0 0    XXX
380f			DEFB $C0          ; 1 1 0 0 0 0 0 0    XX
3810			DEFB $80          ; 1 0 0 0 0 0 0 0    X
3811			DEFB $00          ; 0 0 0 0 0 0 0 0
3812
3812			; ---------------------
3812			; Sinclair Strip 'Text'
3812			; ---------------------
3812			; CHARS points to RAM at $5A98, and characters ' ' and '!' redefined
3812			; as the Sinclair strips using the bit patterns above.
3812
3812	L3812:  DEFB $10, $02, ' ' ; INK 2;
3815			DEFB $11, $06, '!' ; PAPER 6;
3818			DEFB $10, $04, ' ' ; INK 4;
381b			DEFB $11, $05, '!' ; PAPER 5;
381e			DEFB $10, $00, ' ' ; INK 0;
3821			DEFB $FF           ;
3822
3822			; --------------------------------------
3822			; Print the Sinclair stripes on the menu
3822			; --------------------------------------
3822
3822	L3822:  PUSH BC           ; Save registers.
3823			PUSH DE           ;
3824			PUSH HL           ;
3825
3825			LD   HL,L3802     ; Graphics bit-patterns
3828			LD   DE,STRIP1    ; $5B98.
382b			LD   BC,$0010     ; Copy two characters.
382e			LDIR              ;
3830
3830			LD   HL,($5C36)   ; Save CHARS.
3833			PUSH HL           ;
3834
3834			LD   HL,STRIP1-$0100 ; $5A98.
3837			LD   ($5C36),HL   ; Set CHARS to point to new graphics.
383a
383a			LD   HL,L3812     ; Point to the strip string.
383d			CALL L3733        ; Print it.
3840
3840			POP  HL           ; Restore CHARS.
3841			LD   ($5C36),HL   ;
3844
3844			POP  HL           ; Restore registers.
3845			POP  DE           ;
3846			POP  BC           ;
3847			RET               ;
3848
3848			; ------------------------
3848			; Print '128 BASIC' Banner
3848			; ------------------------
3848
3848	L3848:  LD   HL,L2769     ; "128 BASIC" text from main menu.
384b			JR   L385A        ; Jump ahead to print banner.
384d
384d			; -------------------------
384d			; Print 'Calculator' Banner
384d			; -------------------------
384d
384d	L384D:  LD   HL,L2772     ; "Calculator" text from main menu.
3850			JR   L385A        ; Jump ahead to print banner.
3852
3852			; --------------------------
3852			; Print 'Tape Loader' Banner
3852			; --------------------------
3852
3852	L3852:  LD   HL,L275E     ; "Tape Loader" text from main menu.
3855			JR   L385A        ; Jump ahead to print banner.
3857
3857			; --------------------------
3857			; Print 'Tape Tester' Banner
3857			; --------------------------
3857
3857	L3857:  LD   HL,L2784     ; "Tape Tester" text from main menu.
385a
385a			; ------------
385a			; Print Banner
385a			; ------------
385a
385a	L385A:  PUSH HL           ; Address in memory of the text of the selected menu item.
385b
385b			CALL L3881        ; Clear lower editing area display.
385e
385e			LD   HL,$5AA0     ; Address of banner row in attributes.
3861			LD   B,$20        ; 32 columns.
3863			LD   A,$40        ; FLASH 0, BRIGHT 1, PAPER 0, INK 0.
3865
3865	L3865:  LD   (HL),A       ; Set a black row.
3866			INC  HL           ;
3867			DJNZ L3865        ;
3869
3869			LD   HL,L37EC     ; Menu title colours table.
386c			CALL L3733        ; Print the colours as a string.
386f
386f			LD   BC,$1500     ;
3872			CALL L372B        ; Perform 'Print AT 21,0;'.
3875
3875			POP  DE           ; Address in memory of the text of the selected menu item.
3876			CALL L057D        ; Print the text.
3879
3879			LD   C,$1A        ; B has not changed and still holds 21.
387b			CALL L372B        ; Perform 'Print AT 21,26;'.
387e			JP   L3822        ; Print Sinclair stripes and return to calling routine.
3881
3881			; ---------------------------
3881			; Clear Lower Editing Display
3881			; ---------------------------
3881
3881	L3881:  LD   B,$15        ; Top row of editing area.
3883			LD   D,$17        ; Bottom row of editing area.
3885			JP   L3B5E        ; Reset Display.
3888
3888
3888			; ================
3888			; RENUMBER ROUTINE
3888			; ================
3888			; Exit: Carry flag reset if required to produce an error beep.
3888
3888	L3888:  CALL L1F20        ; Use Normal RAM Configuration (physical RAM bank 0).
388b
388b			CALL L3A05        ; DE=Count of the number of BASIC lines.
388e			LD   A,D          ;
388f			OR   E            ; Were there any BASIC lines?
3890			JP   Z,L39C0      ; Jump if not to return since there is nothing to renumber.
3893
3893			LD   HL,(RNSTEP)  ; $5B96. Fetch the line number increment for Renumber.
3896			RST  28H          ;
3897			DEFW HL_MULT_DE   ; $30A9. HL=HL*DE in ROM 1. HL=Number of lines * Line increment = New last line number.
3899			; [*BUG* - If there are more than 6553 lines then an arithmetic overflow will occur and hence
3899			; the test below to check if line 9999 would be exceeded will fail. The carry flag will be set
3899			; upon such an overflow and simply needs to be tested. The bug can be resolved by following the
3899			; call to HL_MULT_DE with a JP C,$39C0 (ROM 0) instruction. Credit: Ian Collier (+3), Andrew Owen (128)]
3899			EX   DE,HL        ; DE=Offset of new last line number from the first line number.
389a
389a			LD   HL,(RNFIRST) ; $5B94. Starting line number for Renumber.
389d			ADD  HL,DE        ; HL=New last line number.
389e			LD   DE,$2710     ; 10000.
38a1			OR   A            ;
38a2			SBC  HL,DE        ; Would the last line number above 9999?
38a4			JP   NC,L39C0     ; Jump if so to return since Renumber cannot proceed.
38a7
38a7			;There is a program that can be renumbered
38a7
38a7			LD   HL,($5C53)   ; PROG. HL=Address of first BASIC line.
38aa
38aa	L38AA:  RST  28H          ; Find the address of the next BASIC line from the
38ab			DEFW NEXT_ONE     ; $19B8.  location pointed to by HL, returning it in DE.
38ad
38ad			INC  HL           ; Advance past the line number bytes to point
38ae			INC  HL           ; at the line length bytes.
38af			LD   (RNLINE),HL  ; $5B92. Store the address of the BASIC line's length bytes.
38b2
38b2			INC  HL           ; Advance past the line length bytes to point
38b3			INC  HL           ; at the command.
38b4			LD   (N_STR1+4),DE ; $5B6B. Store the address of the next BASIC line.
38b8
38b8	L38B8:  LD   A,(HL)       ; Get a character from the BASIC line.
38b9			RST  28H          ; Advance past a floating point number, if present.
38ba			DEFW NUMBER       ; $18B6.
38bc
38bc			CP   $0D          ; Is the character an 'ENTER'?
38be			JR   Z,L38C5      ; Jump if so to examine the next line.
38c0
38c0			CALL L390E        ; Parse the line, renumbering any tokens that may be followed by a line number.
38c3			JR   L38B8        ; Repeat for all remaining character until end of the line.
38c5
38c5	L38C5:  LD   DE,(N_STR1+4) ; $5B6B. DE=Address of the next BASIC line.
38c9			LD   HL,($5C4B)   ; VARS. Fetch the address of the end of the BASIC program.
38cc			AND  A            ;
38cd			SBC  HL,DE        ; Has the end of the BASIC program been reached?
38cf			EX   DE,HL        ; HL=Address of start of the current BASIC line.
38d0			JR   NZ,L38AA     ; Jump back if not to examine the next line.
38d2
38d2			;The end of the BASIC program has been reached so now it is time to update
38d2			;the line numbers and line lengths.
38d2
38d2			CALL L3A05        ; DE=Count of the number of BASIC lines.
38d5			LD   B,D          ;
38d6			LD   C,E          ; BC=Count of the number of BASIC lines.
38d7			LD   DE,$0000     ;
38da			LD   HL,($5C53)   ; PROG. HL=Address of first BASIC line.
38dd
38dd	L38DD:  PUSH BC           ; BC=Count of number of lines left to update.
38de			PUSH DE           ; DE=Index of the current line.
38df
38df			PUSH HL           ; HL=Address of current BASIC line.
38e0
38e0			LD   HL,(RNSTEP)  ; $5B96. HL=Renumber line increment.
38e3			RST  28H          ; Calculate new line number offset, i.e. Line increment * Line index.
38e4			DEFW HL_MULT_DE   ; $30A9. HL=HL*DE in ROM 1.
38e6			LD   DE,(RNFIRST) ; $5B94. The initial line number when renumbering.
38ea			ADD  HL,DE        ; HL=The new line number for the current line.
38eb			EX   DE,HL        ; DE=The new line number for the current line.
38ec
38ec			POP  HL           ; HL=Address of current BASIC line.
38ed
38ed			LD   (HL),D       ; Store the new line number for this line.
38ee			INC  HL           ;
38ef			LD   (HL),E       ;
38f0			INC  HL           ;
38f1			LD   C,(HL)       ; Fetch the line length.
38f2			INC  HL           ;
38f3			LD   B,(HL)       ;
38f4			INC  HL           ;
38f5			ADD  HL,BC        ; Point to the next line.
38f6
38f6			POP  DE           ; DE=Index of the current line.
38f7			INC  DE           ; Increment the line index.
38f8
38f8			POP  BC           ; BC=Count of number of lines left to update.
38f9			DEC  BC           ; Decrement counter.
38fa			LD   A,B          ;
38fb			OR   C            ;
38fc			JR   NZ,L38DD     ; Jump back while more lines to update.
38fe
38fe			CALL L1F45        ; Use Workspace RAM configuration (physical RAM bank 7).
3901			LD   (RNLINE),BC  ; $5B92. Clear the address of line length bytes of the 'current line being renumbered'.
3905			; [No need to clear this]
3905			SCF               ; Signal not to produce an error beep.
3906			RET               ;
3907
3907			; -------------------------
3907			; Tokens Using Line Numbers
3907			; -------------------------
3907			; A list of all tokens that maybe followed by a line number and hence
3907			; require consideration.
3907
3907	L3907:  DEFB $CA          ; 'LINE'.
3908			DEFB $F0          ; 'LIST'.
3909			DEFB $E1          ; 'LLIST'.
390a			DEFB $EC          ; 'GO TO'.
390b			DEFB $ED          ; 'GO SUB'.
390c			DEFB $E5          ; 'RESTORE'.
390d			DEFB $F7          ; 'RUN'.
390e
390e			; -----------------------------------------------
390e			; Parse a Line Renumbering Line Number References
390e			; -----------------------------------------------
390e			; This routine examines a BASIC line for any tokens that may be followed by a line number reference
390e			; and if one is found then the new line number if calculated and substituted for the old line number
390e			; reference. Although checks are made to ensure an out of memory error does not occur, the routine
390e			; simply returns silently in such scenarios and the renumber routine will continue onto the next BASIC
390e			; line.
390e			; Entry: HL=Address of current character in the current BASIC line.
390e			;        A=Current character.
390e
390e	L390E:  INC  HL           ; Point to the next character.
390f			LD   (HD_11+1),HL ; $5B79. Store it.
3912
3912			EX   DE,HL        ; DE=Address of next character.
3913			LD   BC,$0007     ; There are 7 tokens that may be followed by a line
3916			LD   HL,L3907     ; number, and these are listed in the table at $3907 (ROM 0).
3919			CPIR              ; Search for a match for the current character.
391b			EX   DE,HL        ; HL=Address of next character.
391c			RET  NZ           ; Return if no match found.
391d
391d			;A token that might be followed by a line number was found. If it is followed by a
391d			;line number then proceed to renumber the line number reference. Note that the statements
391d			;such as GO TO VAL "100" will not be renumbered. The line numbers of each BASIC line will
391d			;be renumbered as the last stage of the renumber process at $38D2 (ROM 0).
391d
391d			LD   C,$00        ; Counts the number of digits in the current line number representation.
391f			; B will be $00 from above.
391f
391f	L391F:  LD   A,(HL)       ; Fetch the next character.
3920			CP   ' '          ; $20. Is it a space?
3922			JR   Z,L393F      ; Jump ahead if so to parse the next character.
3924
3924			RST  28H          ;
3925			DEFW NUMERIC      ; $2D1B. Is the character a numeric digit?
3927			JR   NC,L393F     ; Jump if a numeric digit to parse the next character.
3929
3929			CP   '.'          ; $2E. Is it a decimal point?
392b			JR   Z,L393F      ; Jump ahead if so to parse the next character.
392d
392d			CP   $0E          ; Does it indicate a hidden number?
392f			JR   Z,L3943      ; Jump ahead if so to process it.
3931
3931			OR   $20          ; Convert to lower case.
3933			CP   'e'          ; $65. Is it an exponent 'e'?
3935			JR   NZ,L393B     ; Jump if not to parse the next character.
3937
3937			LD   A,B          ; Have any digits been found?
3938			OR   C            ;
3939			JR   NZ,L393F     ; Jump ahead to parse the next character.
393b
393b			;A line number reference was not found
393b
393b	L393B:  LD   HL,(HD_11+1) ; $5B79. Retrieve the address of the next character.
393e			RET               ;
393f
393f	L393F:  INC  BC           ; Increment the number digit counter.
3940			INC  HL           ; Point to the next character.
3941			JR   L391F        ; Jump back to parse the character at this new address.
3943
3943			;An embedded number was found
3943
3943	L3943:  LD   (HD_00),BC   ; $5B71. Note the number of digits in the old line number reference.
3947
3947			PUSH HL           ; Save the address of the current character.
3948
3948			RST  28H          ;
3949			DEFW NUMBER       ; $18B6. Advance past internal floating point representation, if present.
394b
394b			CALL L3A36        ; Skip over any spaces.
394e
394e			LD   A,(HL)       ; Fetch the new character.
394f			POP  HL           ; HL=Address of the current character.
3950			CP   ':'          ; $3A. Is it ':'?
3952			JR   Z,L3957      ; Jump if so.
3954
3954			CP   $0D          ; Is it 'ENTER'?
3956			RET  NZ           ; Return if not.
3957
3957			;End of statement/line found
3957
3957	L3957:  INC  HL           ; Point to the next character.
3958
3958			RST  28H          ;
3959			DEFW STACK_NUM    ; $33B4. Move floating point number to the calculator stack.
395b			RST  28H          ;
395c			DEFW FP_TO_BC     ; $2DA2. Fetch the number line to BC. [*BUG* - This should test the carry flag to check whether
395e			; the number was too large to be transferred to BC. If so then the line number should be set to 9999,
395e			; as per the instructions at $396A (ROM 0). As a result, the call the LINE_ADDR below can result in a crash.
395e			; The bug can be resolved using a JR C,$396A (ROM 0) instruction. Credit: Ian Collier (+3), Andrew Owen (128)]
395e			LD   H,B          ;
395f			LD   L,C          ; Transfer the number line to HL.
3960
3960			RST  28H          ; Find the address of the line number specified by HL.
3961			DEFW LINE_ADDR    ; $196E. HL=Address of the BASIC line, or the next one if it does not exist.
3963			JR   Z,L396F      ; Jump if the line exists.
3965
3965			LD   A,(HL)       ; Has the end of the BASIC program been reached?
3966			CP   $80          ; [*BUG* - This tests for the end of the variables area and not the end of the BASIC program area. Therefore,
3968			; the renumber routine will not terminate properly if variables exist in memory when it is called.
3968			; Executing CLEAR prior to renumbering will overcome this bug.
3968			; It can be fixed by replacing CP $80 with the instructions AND $C0 / JR Z,$396F (ROM 0). Credit: Ian Collier (+3), Andrew Owen (128)]
3968			JR   NZ,L396F     ; Jump ahead if not.
396a
396a			LD   HL,$270F     ; Make the reference point to line 9999.
396d			JR   L3980        ; Jump ahead to update the reference to use the new line number.
396f
396f			;The reference line exists
396f
396f	L396F:  LD   (HD_0F+1),HL ; $5B77. Store the address of the referenced line.
3972			CALL L3A0B        ; DE=Count of the number of BASIC lines up to the referenced line.
3975			LD   HL,(RNSTEP)  ; $5B96. Fetch the line number increment.
3978			RST  28H          ;
3979			DEFW HL_MULT_DE   ; $30A9. HL=HL*DE in ROM 1. HL=Number of lines * Line increment = New referenced line number.
397b			; [An overflow could occur here and would not be detected. The code at $3898 (ROM 0)
397b			; should have trapped that such an overflow would occur and hence there would have been
397b			; no possibility of it occurring here.]
397b			LD   DE,(RNFIRST) ; $5B94. Starting line number for Renumber.
397f			ADD  HL,DE        ; HL=New referenced line number.
3980
3980			;HL=New line number being referenced
3980
3980	L3980:  LD   DE,HD_0B+1   ; $5B73. Temporary buffer to generate ASCII representation of the new line number.
3983			PUSH HL           ; Save the new line number being referenced.
3984			CALL L3A3C        ; Create the ASCII representation of the line number in the buffer.
3987
3987			LD   E,B          ;
3988			INC  E            ;
3989			LD   D,$00        ; DE=Number of digits in the new line number.
398b
398b			PUSH DE           ; DE=Number of digits in the new line number.
398c			PUSH HL           ; HL=Address of the first non-'0' character in the buffer.
398d
398d			LD   L,E          ;
398e			LD   H,$00        ; HL=Number of digits in the new line number.
3990			LD   BC,(HD_00)   ; $5B71. Fetch the number of digits in the old line number reference.
3994			OR   A            ;
3995			SBC  HL,BC        ; Has the number of digits changed?
3997			LD   (HD_00),HL   ; $5B71. Store the difference between the number of digits in the old and new line numbers.
399a			JR   Z,L39CF      ; Jump if they are the same length.
399c
399c			JR   C,L39C5      ; Jump if the new line number contains less digits than the old.
399e
399e			;The new line number contains more digits than the old line number
399e
399e			LD   B,H          ;
399f			LD   C,L          ; BC=Length of extra space required for the new line number.
39a0			LD   HL,(HD_11+1) ; $5B79. Fetch the start address of the old line number representation within the BASIC line.
39a3			PUSH HL           ; Save start address of the line number reference.
39a4			PUSH DE           ; DE=Number of non-'0' characters in the line number string.
39a5
39a5			LD   HL,($5C65)   ; STKEND. Fetch the start of the spare memory.
39a8			ADD  HL,BC        ; Would a memory overflow occur if the space were created?
39a9			JR   C,L39BE      ; Jump if not to return without changing the line number reference.
39ab
39ab			EX   DE,HL        ; DE=New STKEND address.
39ac			LD   HL,$0082     ; Would there be at least 130 bytes at the top of RAM?
39af			ADD  HL,DE        ;
39b0			JR   C,L39BE      ; Jump if not to return without changing the line number reference.
39b2
39b2			SBC  HL,SP        ; Is the new STKEND address below the stack?
39b4			CCF               ;
39b5			JR   C,L39BE      ; Jump if not to return without changing the line number reference.
39b7
39b7			POP  DE           ; DE=Number of non-'0' characters in the line number string.
39b8			POP  HL           ; HL=Start address of line number reference.
39b9			RST  28H          ;
39ba			DEFW MAKE_ROOM    ; $1655. Create the space for the extra line number digits.
39bc			JR   L39CF        ; Jump ahead to update the number digits.
39be
39be			;No room available to insert extra line number digits
39be
39be	L39BE:  POP DE            ; Discard stacked items.
39bf			POP HL            ;
39c0
39c0			; [At this point the stack contains 3 surplus items. These are not explicitly popped off the stack since the call to $1F45 (ROM 0) will restore
39c0			; the stack to the state it was in at $3888 (ROM 0) when the call to $1F20 (ROM 0) saved it.]
39c0
39c0			;Exit if no BASIC program, renumbering would cause a line number overflow or renumbering would cause an out of memory condition
39c0
39c0	L39C0:  CALL L1F45        ; Use Workspace RAM configuration (physical RAM bank 7).
39c3			AND  A            ; Reset the carry flag so that an error beep will be produced.
39c4			RET               ;
39c5
39c5			;The new line number contains less digits than the old line number
39c5
39c5	L39C5:  DEC  BC           ; BC=Number of digits in the old line number reference.
39c6			DEC  E            ; Decrement number of digits in the new line number.
39c7			JR   NZ,L39C5     ; Repeat until BC has been decremented by the number of digits in the new line number,
39c9			; thereby leaving BC holding the number of digits in the BASIC line to be discarded.
39c9
39c9			LD   HL,(HD_11+1) ; $5B79. Fetch the start address of the old line number representation within the BASIC line.
39cc			RST  28H          ;
39cd			DEFW RECLAIM_2    ; $19E8. Discard the redundant bytes.
39cf
39cf			;The appropriate amount of space now exists in the BASIC line so update the line number value
39cf
39cf	L39CF:  LD   DE,(HD_11+1) ; $5B79. Fetch the start address of the old line number representation within the BASIC line.
39d3			POP  HL           ; HL=Address of the first non-'0' character in the buffer.
39d4			POP  BC           ; BC=Number of digits in the new line number.
39d5			LDIR              ; Copy the new line number into place.
39d7
39d7			EX   DE,HL        ; HL=Address after the line number text in the BASIC line.
39d8			LD   (HL),$0E     ; Store the hidden number marker.
39da
39da			POP  BC           ; Retrieve the new line number being referenced.
39db			INC  HL           ; HL=Address of the next position within the BASIC line.
39dc			PUSH HL           ;
39dd
39dd			RST  28H          ;
39de			DEFW STACK_BC     ; $2D2B. Put the line number on the calculator stack, returning HL pointing to it.
39e0			; [*BUG* - This stacks the new line number so that the floating point representation can be copied.
39e0			; However, the number is not actually removed from the calculator stack. Therefore the
39e0			; amount of free memory reduces by 5 bytes as each line with a line number reference is renumbered.
39e0			; A call to FP_TO_BC (at $2DA2 within ROM 1) after the floating point form has been copied would fix
39e0			; the bug. Note that all leaked memory is finally reclaimed when control is returned to the Editor but the
39e0			; bug could prevent large programs from being renumbered. Credit: Paul Farrow]
39e0			POP  DE           ; DE=Address of the next position within the BASIC line.
39e1			LD   BC,$0005     ;
39e4			LDIR              ; Copy the floating point form into the BASIC line.
39e6			EX   DE,HL        ; HL=Address of character after the newly inserted floating point number bytes.
39e7			PUSH HL           ;
39e8
39e8			LD   HL,(RNLINE)  ; $5B92. HL=Address of the current line's length bytes.
39eb			PUSH HL           ;
39ec
39ec			LD   E,(HL)       ;
39ed			INC  HL           ;
39ee			LD   D,(HL)       ; DE=Existing length of the current line.
39ef			LD   HL,(HD_00)   ; $5B71. HL=Change in length of the line.
39f2			ADD  HL,DE        ;
39f3			EX   DE,HL        ; DE=New length of the current line.
39f4
39f4			POP  HL           ; HL=Address of the current line's length bytes.
39f5			LD   (HL),E       ;
39f6			INC  HL           ;
39f7			LD   (HL),D       ; Store the new length.
39f8
39f8			LD   HL,(N_STR1+4) ; $5B6B. HL=Address of the next BASIC line.
39fb			LD   DE,(HD_00)   ; $5B71. DE=Change in length of the current line.
39ff			ADD  HL,DE        ;
3a00			LD   (N_STR1+4),HL ; $5B6B. Store the new address of the next BASIC line.
3a03
3a03			POP  HL           ; HL=Address of character after the newly inserted floating point number bytes.
3a04			RET               ;
3a05
3a05			; -------------------------------
3a05			; Count the Number of BASIC Lines
3a05			; -------------------------------
3a05			; This routine counts the number of lines in the BASIC program, or if entered at $3A0B (ROM 0) counts
3a05			; the number of lines up in the BASIC program to the address specified in HD_0F+1.
3a05			; Exit: DE=Number of lines.
3a05
3a05	L3A05:  LD   HL,($5C4B)   ; VARS. Fetch the address of the variables
3a08			LD   (HD_0F+1),HL ; $5B77.  and store it.
3a0b
3a0b	L3A0B:  LD   HL,($5C53)   ; PROG. Fetch the start of the BASIC program
3a0e			LD   DE,(HD_0F+1) ; $5B77.  and compare against the address of
3a12			OR   A            ; the end address to check whether there is
3a13			SBC  HL,DE        ; a BASIC program.
3a15			JR   Z,L3A31      ; Jump if there is no BASIC program.
3a17
3a17			LD   HL,($5C53)   ; PROG. Fetch the start address of the BASIC program.
3a1a			LD   BC,$0000     ; A count of the number of lines.
3a1d
3a1d	L3A1D:  PUSH BC           ; Save the line number count.
3a1e
3a1e			RST  28H          ; Find the address of the next BASIC line from the
3a1f			DEFW NEXT_ONE     ; $19B8.  location pointed to by HL, returning it in DE.
3a21
3a21			LD   HL,(HD_0F+1) ; $5B77. Fetch the start of the variables area,
3a24			AND  A            ; i.e. end of the BASIC program.
3a25			SBC  HL,DE        ;
3a27			JR   Z,L3A2E      ; Jump if end of BASIC program reached.
3a29
3a29			EX   DE,HL        ; HL=Address of current line.
3a2a
3a2a			POP  BC           ; Retrieve the line number count.
3a2b			INC  BC           ; Increment line number count.
3a2c			JR   L3A1D        ; Jump back to look for the next line.
3a2e
3a2e	L3A2E:  POP  DE           ; Retrieve the number of BASIC lines and
3a2f			INC  DE           ; increment since originally started on a line.
3a30			RET               ;
3a31
3a31			;No BASIC program
3a31
3a31	L3A31:  LD   DE,$0000     ; There are no BASIC lines.
3a34			RET               ;
3a35
3a35			; -----------
3a35			; Skip Spaces
3a35			; -----------
3a35
3a35	L3A35:  INC  HL           ; Point to the next character.
3a36
3a36	L3A36:  LD   A,(HL)       ; Fetch the next character.
3a37			CP   ' '          ; $20. Is it a space?
3a39			JR   Z,L3A35      ; Jump if so to skip to next character.
3a3b
3a3b			RET               ;
3a3c
3a3c			; ---------------------------------------
3a3c			; Create ASCII Line Number Representation
3a3c			; ---------------------------------------
3a3c			; Creates an ASCII representation of a line number, replacing leading
3a3c			; zeros with spaces.
3a3c			; Entry: HL=The line number to convert.
3a3c			;        DE=Address of the buffer to build ASCII representation in.
3a3c			;        B=Number of non-'0' characters minus 1 in the ASCII representation.
3a3c			; Exit : HL=Address of the first non-'0' character in the buffer.
3a3c
3a3c	L3A3C:  PUSH DE           ; Store the buffer address.
3a3d
3a3d			LD   BC,$FC18     ; BC=-1000.
3a40			CALL L3A60        ; Insert how many 1000s there are.
3a43			LD   BC,$FF9C     ; BC=-100.
3a46			CALL L3A60        ; Insert how many 100s there are.
3a49			LD   C,$F6        ; BC=-10.
3a4b			CALL L3A60        ; Insert how many 10s there are.
3a4e			LD   A,L          ; A=Remainder.
3a4f			ADD  A,'0'        ; $30. Convert into an ASCII character ('0'..'9').
3a51			LD   (DE),A       ; Store it in the buffer.
3a52			INC  DE           ; Point to the next buffer position.
3a53
3a53			; Now skip over leading zeros
3a53
3a53			LD   B,$03        ; Skip over 3 leading zeros at most.
3a55			POP  HL           ; Retrieve the buffer start address.
3a56
3a56	L3A56:  LD   A,(HL)       ; Fetch a character.
3a57			CP   '0'          ; $30. Is it a leading zero?
3a59			RET  NZ           ; Return as soon as a non-'0' character is found.
3a5a
3a5a			LD   (HL),' '     ; $20. Replace it with a space.
3a5c			INC  HL           ; Point to the next buffer location.
3a5d			DJNZ L3A56        ; Repeat until all leading zeros removed.
3a5f
3a5f			RET               ;
3a60
3a60			; ------------------------
3a60			; Insert Line Number Digit
3a60			; ------------------------
3a60			; This routine effectively works out the result of HL divided by BC. It does this by
3a60			; repeatedly adding a negative value until no overflow occurs.
3a60			; Entry: HL=Number to test.
3a60			;        BC=Negative amount to add.
3a60			;        DE=Address of buffer to insert ASCII representation of the number of divisions.
3a60			; Exit : HL=Remainder.
3a60			;        DE=Next address in the buffer.
3a60
3a60	L3A60:  XOR  A            ; Assume a count of 0 additions.
3a61
3a61	L3A61:  ADD  HL,BC        ; Add the negative value.
3a62			INC  A            ; Increment the counter.
3a63			JR   C,L3A61      ; If no overflow then jump back to add again.
3a65
3a65			SBC  HL,BC        ; Undo the last step
3a67			DEC  A            ; and the last counter increment.
3a68
3a68			ADD  A,'0'        ; $30. Convert to an ASCII character ('0'..'9').
3a6a			LD   (DE),A       ; Store it in the buffer.
3a6b			INC  DE           ; Point to the next buffer position.
3a6c			RET               ;
3a6d
3a6d
3a6d			; ========================
3a6d			; EDITOR ROUTINES - PART 4
3a6d			; ========================
3a6d
3a6d			; ------------------------------------
3a6d			; Initial Lower Screen Cursor Settings
3a6d			; ------------------------------------
3a6d			; Copied to $FD6C-$FD73.
3a6d
3a6d	L3A6D:  DEFB $08          ; Number of bytes in table.
3a6e			DEFB $00          ; $FD6C. [Setting never used]
3a6f			DEFB $00          ; $FD6D = Rows above the editing area.
3a70			DEFB $14          ; $FD6E. [Setting never used]
3a71			DEFB $00          ; $FD6F. [Setting never used]
3a72			DEFB $00          ; $FD70. [Setting never used]
3a73			DEFB $00          ; $FD71. [Setting never used]
3a74			DEFB $0F          ; $FD72 = Cursor attribute colour (blue paper, white ink).
3a75			DEFB $00          ; $FD73 = Stored cursor position screen attribute colour (None = black paper, black ink).
3a76
3a76			; -----------------------------------
3a76			; Initial Main Screen Cursor Settings
3a76			; -----------------------------------
3a76			; Copied to $FD6C-$FD73.
3a76
3a76	L3A76:  DEFB $08          ; Number of bytes in table.
3a77			DEFB $00          ; $FD6C. [Setting never used]
3a78			DEFB $16          ; $FD6D = Rows above the editing area.
3a79			DEFB $01          ; $FD6E. [Setting never used]
3a7a			DEFB $00          ; $FD6F. [Setting never used]
3a7b			DEFB $00          ; $FD70. [Setting never used]
3a7c			DEFB $00          ; $FD71. [Setting never used]
3a7d			DEFB $0F          ; $FD72 = Cursor attribute colour (blue paper, white ink).
3a7e			DEFB $00          ; $FD73 = Stored cursor position screen attribute colour (None = black paper, black ink).
3a7f
3a7f			; --------------------------------------
3a7f			; Set Main Screen Editing Cursor Details
3a7f			; --------------------------------------
3a7f			; Set initial cursor editing settings when using the main screen.
3a7f			; Copies 8 bytes from $3A6E-$3A75 (ROM 0) to $FD6C-$FD73.
3a7f
3a7f	L3A7F:  LD   IX,$FD6C     ; Point IX at cursor settings in workspace.
3a83
3a83			LD   HL,L3A6D     ; Initial values table for the lower screen cursor settings.
3a86			JR   L3A8B        ; Jump ahead.
3a88
3a88			; ---------------------------------------
3a88			; Set Lower Screen Editing Cursor Details
3a88			; ---------------------------------------
3a88			; Set initial cursor editing settings when using the lower screen.
3a88			; Copies 8 bytes from $3A77-$3A7E (ROM 0) to $FD6C-$FD73.
3a88
3a88	L3A88:  LD   HL,L3A76     ; Initial values table for the main screen cursor settings.
3a8b
3a8b	L3A8B:  LD   DE,$FD6C     ; DE=Cursor settings in workspace.
3a8e			JP   L3FBA        ; Jump to copy the settings.
3a91
3a91
3a91			; ========================
3a91			; UNUSED ROUTINES - PART 2
3a91			; ========================
3a91
3a91			; ----------
3a91			; Print 'AD'
3a91			; ----------
3a91			; This routine prints to the current channel the contents of register A and then the contents of register D.
3a91			;
3a91			; [Never called by ROM].
3a91
3a91	L3A91:  RST  10H          ; Print character held in A.
3a92			LD   A,D          ;
3a93			RST  10H          ; Print character held in D.
3a94			SCF               ;
3a95			RET               ;
3a96
3a96
3a96			; ========================
3a96			; EDITOR ROUTINES - PART 5
3a96			; ========================
3a96
3a96			; -------------------
3a96			; Store Cursor Colour
3a96			; -------------------
3a96			; Entry: A=Cursor attribute byte.
3a96			;        IX=Address of the cursor settings information.
3a96
3a96	L3A96:  AND  $3F          ; Mask off flash and bright bits.
3a98			LD   (IX+$06),A   ; Store it as the new cursor attribute value.
3a9b			SCF               ;
3a9c			RET               ;
3a9d
3a9d			; -----------------------------
3a9d			; Set Cursor Position Attribute
3a9d			; -----------------------------
3a9d			; Entry: B=Row number
3a9d			;        C=Column number.
3a9d			;        IX=Address of the cursor settings information.
3a9d
3a9d	L3A9D:  LD   A,(IX+$01)   ; A=Rows above the editing area ($16 when using the lower screen, $00 when using the main screen).
3aa0			ADD  A,B          ; B=Row number within editing area.
3aa1			LD   B,A          ; B=Screen row number.
3aa2			CALL L3BA0        ; Get address of attribute byte into HL.
3aa5
3aa5			LD   A,(HL)       ; Fetch current attribute byte.
3aa6			LD   (IX+$07),A   ; Store the current attribute byte.
3aa9			CPL               ; Invert colours.
3aaa			AND  $C0          ; Mask off flash and bright bits.
3aac			OR   (IX+$06)     ; Get cursor colour.
3aaf			LD   (HL),A       ; Store new attribute value to screen.
3ab0
3ab0			SCF               ; [Redundant since calling routine preserves AF]
3ab1			RET               ;
3ab2
3ab2			; ---------------------------------
3ab2			; Restore Cursor Position Attribute
3ab2			; ---------------------------------
3ab2			; Entry: B=Row number
3ab2			;        C=Column number.
3ab2			;        IX=Address of the cursor settings information.
3ab2
3ab2	L3AB2:  LD   A,(IX+$01)   ; A=Rows above the editing area ($16 when using the lower screen, $00 when using the main screen).
3ab5			ADD  A,B          ; B=Row number within editing area.
3ab6			LD   B,A          ; B=Screen row number.
3ab7			CALL L3BA0        ; Get address of attribute byte into HL.
3aba			LD   A,(IX+$07)   ; Get previous attribute value.
3abd			LD   (HL),A       ; Set colour.
3abe			RET               ;
3abf
3abf			; ----------------------------------
3abf			; Shift Up Edit Rows in Display File
3abf			; ----------------------------------
3abf			; This routine shifts edit rows in the display file up, replacing the bottom row with the
3abf			; top entry from the Below-Screen Line Edit Buffer.
3abf			; Entry: HL=Address of first row in the Below-Screen Line Edit Buffer.
3abf			;        E =Number of editing rows on screen.
3abf			;        B =Row number to shift from.
3abf
3abf	L3ABF:  PUSH HL           ; Save the address of the Below-Screen Line Edit Buffer row.
3ac0
3ac0			LD   H,$00        ; Indicate to shift rows up.
3ac2			LD   A,E          ; A=Number of editing rows on screen.
3ac3			SUB  B            ; A=Number of rows to shift, i.e. from current row to end of edit screen.
3ac4			JR   L3ACD        ; Jump ahead.
3ac6
3ac6			; ------------------------------------
3ac6			; Shift Down Edit Rows in Display File
3ac6			; ------------------------------------
3ac6			; This routine shifts edit rows in the display file down, replacing the top row with the
3ac6			; bottom entry from the Above-Screen Line Edit Buffer.
3ac6			; Entry: HL=Address of next row to use within the Above-Screen Line Edit Buffer.
3ac6			;        E =Number of editing rows on screen.
3ac6			;        B =Row number to shift from.
3ac6
3ac6	L3AC6:  PUSH HL           ; Save the address of the first row in Below-Screen Line Edit Buffer.
3ac7
3ac7			LD   A,E          ; A=Number of editing rows on screen.
3ac8			LD   E,B          ; E=Row number to shift from.
3ac9			LD   B,A          ; B=Number of editing rows on screen.
3aca			SUB  E            ; A=Number of rows to shift, i.e. from current row to end of edit screen.
3acb			LD   H,$FF        ; Indicate to shift rows down.
3acd
3acd			; Shift Rows
3acd			; ----------
3acd
3acd	L3ACD:  LD   C,A          ; C=Number of rows to shift.
3ace
3ace			LD   A,B          ; A=Row number to shift from.
3acf			CP   E            ; Is it the final row of the editing screen?
3ad0			JR   Z,L3B1D      ; Jump if so to simply display the row.
3ad2
3ad2			;Shift all display file and attributes rows up
3ad2
3ad2			PUSH DE           ; Save number of editing rows on screen, in E.
3ad3			CALL L3B98        ; B=Inverted row number, i.e. 24-row number.
3ad6
3ad6	L3AD6:  PUSH BC           ; B=Inverted row number, C=Number of rows left to shift.
3ad7			LD   C,H          ; Store the direction flag.
3ad8
3ad8			RST  28H          ;
3ad9			DEFW CL_ADDR      ; $0E9B. HL=Destination display file address, for the row number specified by 24-B.
3adb			EX   DE,HL        ; DE=Destination display file address.
3adc
3adc			XOR  A            ;
3add			OR   C            ; Fetch the direction flag.
3ade			JR   Z,L3AE3      ; Jump if moving up to the previous row.
3ae0
3ae0			INC  B            ; Move to the previous row (note that B is inverted, i.e. 24-row number).
3ae1			JR   L3AE4        ; Jump ahead.
3ae3
3ae3	L3AE3:  DEC  B            ; Move to the next row (note that B is inverted, i.e. 24-row number).
3ae4
3ae4	L3AE4:  PUSH DE           ; DE=Destination display file address.
3ae5			RST  28H          ;
3ae6			DEFW CL_ADDR      ; $0E9B. HL=Source display file address, for the row number held in B.
3ae8			POP DE            ; DE=Destination display file address.
3ae9
3ae9			;Copy one row of the display file
3ae9
3ae9			LD   A,C          ; Fetch the direction flag.
3aea			LD   C,$20        ; 32 columns.
3aec			LD   B,$08        ; 8 lines.
3aee
3aee	L3AEE:  PUSH BC           ;
3aef			PUSH HL           ;
3af0			PUSH DE           ;
3af1			LD   B,$00        ;
3af3			LDIR              ; Copy one line in the display file.
3af5			POP  DE           ;
3af6			POP  HL           ;
3af7			POP  BC           ;
3af8
3af8			INC  H            ; Next source line in the display file.
3af9			INC  D            ; Next destination line in the display file.
3afa			DJNZ L3AEE        ; Repeat for all lines in the row.
3afc
3afc			;Copy one row of display attributes
3afc
3afc			PUSH AF           ; Save the duration flag.
3afd			PUSH DE           ; DE=Address of next destination row in the display file.
3afe
3afe			RST  28H          ; HL=Address of next source row in the display file.
3aff			DEFW CL_ATTR      ; $0E88. DE=Address of corresponding attribute cell.
3b01			EX   DE,HL        ; HL=Address of corresponding source attribute cell.
3b02			EX   (SP),HL      ; Store source attribute cell on the stack, and fetch the next destination row in the display file in HL.
3b03
3b03			RST  28H          ; HL=Address of next destination row in the display file.
3b04			DEFW CL_ATTR      ; $0E88. DE=Address of corresponding destination attribute cell.
3b06			EX   DE,HL        ; HL=Address of corresponding destination attribute cell.
3b07			EX   (SP),HL      ; Store destination attribute cell on the stack, and fetch the source attribute cell in HL.
3b08			POP  DE           ; DE=Destination attribute cell.
3b09
3b09			LD   BC,$0020     ;
3b0c			LDIR              ; Copy one row of the attributes file.
3b0e
3b0e			;Repeat to shift the next row
3b0e
3b0e			POP  AF           ; Retrieve the direction flag.
3b0f			POP  BC           ; B=Inverted row number, C=Number of rows left to shift.
3b10			AND  A            ; Shifting up or down?
3b11			JR   Z,L3B16      ; Jump if shifting rows up.
3b13
3b13			INC  B            ; Move to the previous row, i.e. the row to copy (note that B is inverted, i.e. 24-row number).
3b14			JR   L3B17        ; Jump ahead.
3b16
3b16	L3B16:  DEC  B            ; Move to the next row, i.e. the row to copy (note that B is inverted, i.e. 24-row number).
3b17
3b17	L3B17:  DEC  C            ; Decrement the row counter.
3b18			LD   H,A          ; H=Direction flag.
3b19			JR   NZ,L3AD6     ; Jump if back more rows to shift.
3b1b
3b1b			POP  DE           ; E=Number of editing rows on screen.
3b1c			LD   B,E          ; B=Number of editing rows on screen.
3b1d
3b1d	L3B1D:  POP  HL           ; HL=Address of the Line Edit Buffer row to print (either in the Above-Screen Line Edit Buffer or in the Below-Screen Line Edit Buffer).
3b1e
3b1e			; --------------------------------------------
3b1e			; Print a Row of the Edit Buffer to the Screen
3b1e			; --------------------------------------------
3b1e			; This routine prints all 32 characters of a row in the edit buffer to the display file.
3b1e			; When shifting all rows up, this routine prints the top entry of the Below-Screen Line Edit Buffer
3b1e			; to the first row of the display file.
3b1e			; When shifting all rows down, this routine prints the bottom entry of the Above-Screen Line Edit Buffer
3b1e			; to the last editing row of the display file.
3b1e			; Entry: B =Row number to print at.
3b1e			;        HL=Address of edit buffer row to print.
3b1e
3b1e	L3B1E:  CALL L3BB8        ; Exchange colour items.
3b21
3b21			EX   DE,HL        ; Transfer address of edit buffer row to DE.
3b22
3b22			LD   A,($5C3C)    ; TVFLAG.
3b25			PUSH AF           ;
3b26			LD   HL,$EC0D     ; Editor flags.
3b29			BIT  6,(HL)       ; Test the editing area flag.
3b2b			RES  0,A          ; Allow leading space.
3b2d			JR   Z,L3B31      ; Jump if editing area is the main screen.
3b2f
3b2f			SET  0,A          ; Suppress leading space.
3b31
3b31	L3B31:  LD   ($5C3C),A    ; TVFLAG.
3b34
3b34			LD   C,$00        ; The first column position of the edit row.
3b36			CALL L372B        ; Print AT.
3b39
3b39			EX   DE,HL        ; HL=Address of edit buffer row.
3b3a			LD   B,$20        ; 32 columns.
3b3c
3b3c	L3B3C:  LD   A,(HL)       ; Character present in this position?
3b3d			AND  A            ;
3b3e			JR   NZ,L3B42     ; Jump if character found.
3b40
3b40			LD   A,$20        ; Display a space for a null character.
3b42
3b42	L3B42:  CP   $90          ; Is it a single character or UDG?
3b44			JR   NC,L3B55     ; Jump if it is a UDG.
3b46
3b46			RST  28H          ; Print the character.
3b47			DEFW PRINT_A_1    ; $0010.
3b49
3b49	L3B49:  INC  HL           ;
3b4a			DJNZ L3B3C        ; Repeat for all column positions.
3b4c
3b4c			POP  AF           ; Restore original suppress leading space status.
3b4d			LD   ($5C3C),A    ; TVFLAG.
3b50
3b50			CALL L3BB8        ; Exchange colour items.
3b53			SCF               ; [Redundant since never subsequently checked]
3b54			RET               ;
3b55
3b55	L3B55:  CALL L1F20        ; Use Normal RAM Configuration (physical RAM bank 0).
3b58			RST  10H          ; Print it (need to page in RAM bank 0 to allow access to UDGs).
3b59			CALL L1F45        ; Use Workspace RAM configuration (physical RAM bank 7).
3b5c			JR   L3B49        ; Jump back for next character.
3b5e
3b5e			; ------------------
3b5e			; Clear Display Rows
3b5e			; ------------------
3b5e			; Entry: B=Top row to clear from.
3b5e			;        D=Bottom row to clear to.
3b5e
3b5e	L3B5E:  CALL L3BB8        ; Exchange 48 and 128 editing colour items.
3b61
3b61			LD   A,D          ; Bottom row to clear.
3b62			SUB  B            ;
3b63			INC  A            ; A=Number of rows to clear.
3b64			LD   C,A          ; C=Number of rows to clear.
3b65			CALL L3B98        ; B=Number of rows to end of screen.
3b68
3b68			;Clear display file row
3b68
3b68	L3B68:  PUSH BC           ; B=Row number. C=Row to clear.
3b69
3b69			RST  28H          ;
3b6a			DEFW CL_ADDR      ; $0E9B. Find display file address.
3b6c
3b6c			LD   C,$08        ; 8 lines in the row.
3b6e
3b6e	L3B6E:  PUSH HL           ; Save start of row address.
3b6f
3b6f			LD   B,$20        ; 32 columns.
3b71			XOR  A            ;
3b72
3b72	L3B72:  LD   (HL),A       ; Blank the row.
3b73			INC  HL           ;
3b74			DJNZ L3B72        ;
3b76
3b76			POP  HL           ; Get start of row address.
3b77			INC  H            ; Next line.
3b78			DEC  C            ;
3b79			JR   NZ,L3B6E     ; Repeat for all rows.
3b7b
3b7b			LD   B,$20        ; 32 columns.
3b7d			PUSH BC           ;
3b7e			RST  28H          ;
3b7f			DEFW CL_ATTR      ; $0E88. Find attribute address.
3b81			EX   DE,HL
3b82			POP  BC           ; BC=32 columns.
3b83
3b83			;Reset display file attributes
3b83
3b83			LD   A,($5C8D)    ; ATTR_P.
3b86
3b86	L3B86:  LD   (HL),A       ; Set display file position attribute.
3b87			INC  HL           ;
3b88			DJNZ L3B86        ; Repeat for all attributes in the row.
3b8a
3b8a			;Repeat for next row
3b8a
3b8a			POP  BC           ; B=Row number. C=Number of rows to clear.
3b8b			DEC  B            ;
3b8c			DEC  C            ;
3b8d			JR   NZ,L3B68     ; Repeat for all rows.
3b8f
3b8f			CALL L3BB8        ; Exchange 48 and 128 editing colour items.
3b92			SCF               ; [Redundant since never subsequently checked]
3b93			RET               ;
3b94
3b94			; --------------------------------------
3b94			; Find Rows and Columns to End of Screen
3b94			; --------------------------------------
3b94			; This routine calculates the number of rows to the end row of the screen and
3b94			; the number of columns to the end column of the screen. It takes into account
3b94			; the number of rows above the editing area.
3b94			; Entry: B=Row number.
3b94			;        C=Column number.
3b94			; Exit : B=Number of rows to end row of screen.
3b94			;        C=Number of columns to the end column of the screen.
3b94
3b94	L3B94:  LD   A,$21        ; Reverse column number.
3b96			SUB  C            ;
3b97			LD   C,A          ; C=33-C. Columns to end of screen.
3b98
3b98			; --------------------------
3b98			; Find Rows to End of Screen
3b98			; --------------------------
3b98			; This routine calculates the number of rows to the end row of the screen. It
3b98			; takes into account the number of rows above the editing area.
3b98			; Entry: B=Row number.
3b98			; Exit : B=Number of rows to end of screen.
3b98			;        IX=Address of the cursor settings information.
3b98
3b98	L3B98:  LD   A,$18        ; Row 24.
3b9a			SUB  B            ; A=24-B.
3b9b			SUB  (IX+$01)     ; Subtract the number of rows above the editing area.
3b9e			LD   B,A          ; B=Rows to end of screen.
3b9f			RET               ;
3ba0
3ba0			; ---------------------
3ba0			; Get Attribute Address
3ba0			; ---------------------
3ba0			; Get the address of the attribute byte for the character position (B,C).
3ba0			; Entry: B=Row number.
3ba0			;        C=Column number.
3ba0			; Exit : HL=Address of attribute byte.
3ba0
3ba0	L3BA0:  PUSH BC           ; Save BC.
3ba1
3ba1			XOR  A            ; A=0.
3ba2			LD   D,B          ;
3ba3			LD   E,A          ; DE=B*256.
3ba4			RR   D            ;
3ba6			RR   E            ;
3ba8			RR   D            ;
3baa			RR   E            ;
3bac			RR   D            ;
3bae			RR   E            ; DE=B*32.
3bb0			LD   HL,$5800     ; Start of attributes file.
3bb3			LD   B,A          ; B=0.
3bb4			ADD  HL,BC        ; Add column offset.
3bb5			ADD  HL,DE        ; Add row offset.
3bb6
3bb6			POP  BC           ; Restore BC.
3bb7			RET               ;
3bb8
3bb8			; ---------------------
3bb8			; Exchange Colour Items
3bb8			; ---------------------
3bb8			; Exchange 128 Editor and main colour items.
3bb8
3bb8	L3BB8:  PUSH AF           ; Save registers.
3bb9			PUSH HL           ;
3bba			PUSH DE           ;
3bbb
3bbb			LD   HL,($5C8D)   ; ATTR_P, MASK_P. Fetch main colour items.
3bbe			LD   DE,($5C8F)   ; ATTR_T, MASK_T.
3bc2			EXX               ; Store them.
3bc3
3bc3			LD   HL,($EC0F)   ; Alternate Editor ATTR_P, MASK_P. Fetch alternate Editor colour items.
3bc6			LD   DE,($EC11)   ; Alternate Editor ATTR_T, MASK_T.
3bca			LD   ($5C8D),HL   ; ATTR_P, MASK_P. Store alternate Editor colour items as main colour items.
3bcd			LD   ($5C8F),DE   ; ATTR_T, MASK_T.
3bd1
3bd1			EXX               ; Retrieve main colour items ATTR_T and MASK_T.
3bd2			LD   ($EC0F),HL   ; Alternate Editor ATTR_P, MASK_P.
3bd5			LD   ($EC11),DE   ; Alternate Editor ATTR_T, MASK_T. Store alternate Editor colour items as main colour items.
3bd9
3bd9			LD   HL,$EC13     ; Alternate P_FLAG. Temporary Editor store for P_FLAG.
3bdc			LD   A,($5C91)    ; P_FLAG.
3bdf			LD   D,(HL)       ; Fetch alternate Editor version.
3be0			LD   (HL),A       ; Store main version in alternate Editor store.
3be1			LD   A,D          ; A=Alternate Editor version.
3be2			LD   ($5C91),A    ; P_FLAG. Store it as main version.
3be5
3be5			POP  DE           ; Restore registers.
3be6			POP  HL           ;
3be7			POP  AF           ;
3be8			RET               ;
3be9
3be9
3be9			; ===================
3be9			; TAPE TESTER ROUTINE
3be9			; ===================
3be9
3be9			; The Tape Tester routine displays a bright blue bar completely across row 8,
3be9			; with 6 black markers evenly distributed above it on row 7 (columns 1, 7, 13,
3be9			; 19, 25 and 31). The tape port is read 2048 times and the number of highs/lows
3be9			; counted. A cyan marker is placed on the blue bar to indicate the ratio of high
3be9			; and lows. The higher the tape player volume, the further to the right the cyan
3be9			; marker will appear. The Tape Tester can be exited by pressing BREAK (though only
3be9			; SPACE checked), ENTER or EDIT (though only key 1 checked). Note that no attempt
3be9			; to read the keypad is made and so it cannot be used to exit the Tape Tester.
3be9			;
3be9			; Although the Sinclair manual suggests setting the tape player volume such that
3be9			; the cyan marker appears as far to the right of the screen as possible, this does
3be9			; not guarantee the best possible loading volume. Instead, it appears better to
3be9			; aim for the cyan marker appearing somewhere near the mid point of the blue bar.
3be9			;
3be9			; There are bugs in the Tape Tester code that can cause the cyan level marker to
3be9			; spill over onto the first column of the row below. This is most likely to occur
3be9			; when the Tape Tester is selected whilst a tape is already playing. The routine
3be9			; initially reads the state of the tape input and assumes this represents silence.
3be9			; It then monitors the tape input for 2048 samples and counts how many high levels
3be9			; appear on the tape input. Should this initial reading of the tape port not
3be9			; correspond to silence then when a true period of silence does occur it will be
3be9			; interpreted as continuous noise and hence a maximum sample count. It is a maximum
3be9			; sample count that leads to the cyan marker spilling onto the next row.
3be9
3be9	L3BE9:  CALL L3C56        ; Signal no key press.
3bec
3bec			DI                ; Turn interrupts off since need accurate timing.
3bed			IN   A,($FE)      ; Read tape input port (bit 5).
3bef			AND  $40          ; Set the zero flag based on the state of the input line.
3bf1
3bf1			; [*BUG* - Ideally the input line should be read indefinitely and the routine only continue
3bf1			;          once the level has remained the same for a large number of consecutive samples.
3bf1			;          The chances of the bug occurring can be minimised by replacing the port read
3bf1			;          instructions above with the following code. Credit: Paul Farrow.
3bf1			;
3bf1			;       LD   BC,$7FFE     ; Tape input port and keyboard row B to SPACE.
3bf1			;       IN   A,(C)        ; Read the tape input port.
3bf1			;       AND  $40          ; Keep only the state of the input line.
3bf1			;
3bf1			;BF23_START:
3bf1			;       LD   E,A          ; Save the initial state of the tape input line.
3bf1			;       LD   HL,$1000     ; Number of samples to monitor for changes in input line state.
3bf1			;
3bf1			;BF23_LOOP:
3bf1			;       IN   A,(C)        ; Read the keyboard and tape input port.
3bf1			;       BIT  0,A          ; Test for SPACE (i.e. BREAK).
3bf1			;       JP   Z,$3C56 (ROM 0) ; Exit Tape Tester if SPACE/BREAK pressed.
3bf1			;
3bf1			;       AND  $40          ; Keep only the state of the input line.
3bf1			;       CP   E            ; Has the line input state changed?
3bf1			;       JR   NZ,BF23_START ; Jump if so to restart the sampling procedure.
3bf1			;
3bf1			;       DEC  HL           ; Decrement the number of samples left to test.
3bf1			;       LD   A,H          ;
3bf1			;       OR   L            ;
3bf1			;       JR   NZ,BF23_LOOP ; Jump if more samples to test.
3bf1			;
3bf1			;       LD   A,E          ; Fetch the input line state.]
3bf1
3bf1			EX   AF,AF'       ; Save initial state of the tape input.
3bf2
3bf2			;Print 6 black attribute square across row 7, at 6 column intervals.
3bf2
3bf2			LD   HL,$58E1     ; Screen attribute position (7,1).
3bf5			LD   DE,$0006     ; DE=column spacing of the black squares.
3bf8			LD   B,E          ; Count 6 black squares.
3bf9			LD   A,D          ; A=Flash 0, Bright 0, Paper black, Ink black.
3bfa
3bfa	L3BFA:  LD   (HL),A       ; Set a black square.
3bfb			ADD  HL,DE        ; Move to next column position.
3bfc			DJNZ L3BFA        ; Repeat for all 6 black squares.
3bfe
3bfe			;Now enter the main loop checking for the tape input signal
3bfe
3bfe	L3BFE:  LD   HL,$0000     ; Count of the number of high signals read from the tape port.
3c01			LD   DE,$0800     ; Read 2048 tape samples. [*BUG* - This should be $07C0 so that the maximum sample count corresponds
3c04			; to column 31 and not column 32, and hence a spill over onto the following row. Credit: Paul Farrow]
3c04
3c04	L3C04:  LD   BC,$BFFE     ; Read keyboard row H to ENTER.
3c07			IN   A,(C)        ;
3c09			BIT  0,A          ; Test for ENTER.
3c0b			JR   Z,L3C56      ; Jump to exit Tape Tester if ENTER pressed.
3c0d
3c0d			LD   B,$7F        ; Read keyboard row B to SPACE.
3c0f			IN   A,(C)        ;
3c11			BIT  0,A          ; Test for SPACE (i.e. BREAK).
3c13			JR   Z,L3C56      ; Jump to exit Tape Tester if SPACE/BREAK pressed.
3c15
3c15			LD   B,$F7        ; Read keyboard row 1 to 5.
3c17			IN   A,(C)        ;
3c19			BIT  0,A          ; Test for 1 (i.e. EDIT).
3c1b			JR   Z,L3C56      ; Jump to exit Tape Tester if 1/EDIT pressed.
3c1d
3c1d	L3C1D:  DEC  DE           ; Decrement sample counter.
3c1e			LD   A,D          ;
3c1f			OR   E            ;
3c20			JR   Z,L3C2B      ; Zero flag set if all samples read.
3c22
3c22			IN   A,($FE)      ;
3c24			AND  $40          ; Read the tape port.
3c26			JR   Z,L3C1D      ; If low then continue with next sample.
3c28
3c28			INC  HL           ; Tape port was high so increment high signal counter.
3c29			JR   L3C1D        ; Continue with next sample.
3c2b
3c2b	L3C2B:  RL   L            ; HL could hold up to $0800.
3c2d			RL   H            ;
3c2f			RL   L            ;
3c31			RL   H            ; HL=HL*4. HL could now hold $0000 to $2000.
3c33
3c33			EX   AF,AF'       ; Retrieve initial state of the tape port.
3c34			JR   Z,L3C3D      ; This dictates how to interpret the number of high signals counted.
3c36
3c36			;If the initial tape port level was high then invert the count in H, i.e. determine number of low signals.
3c36			;Note that if H holds $00 then the following code will result in a column position for the cyan marker of 32,
3c36			;and hence it will appear in the first column of the row below.
3c36
3c36			EX   AF,AF'       ; Re-store initial state of the tape port.
3c37			LD   A,$20        ; A=Column 32.
3c39			SUB  H            ; A=32-H. H could hold up to $20 so A could be $00.
3c3a			LD   L,A          ; L=32-H. L holds a value between $00 to $20.
3c3b			JR   L3C3F        ;
3c3d
3c3d			;If the initial tape port level was low then H holds the number of high signals found.
3c3d
3c3d	L3C3D:  EX   AF,AF'       ; Retrieve initial state of the tape port.
3c3e			LD   L,H          ; L holds a value between $00 to $20.
3c3f
3c3f			;L holds the column at which to show the cyan marker.
3c3f
3c3f	L3C3F:  XOR  A            ;
3c40			LD   H,A          ; Set H to $00.
3c41			LD   DE,$591F     ; Attribute position (8,31).
3c44			LD   B,$20        ; Print a blue bar 32 columns wide underneath the 6 black squares.
3c46			; It is drawn here so that it erases the previous cyan marker.
3c46			LD   A,$48        ; Flash 0, Bright 1, Paper blue, Ink black = Bright blue.
3c48
3c48			EI                ;
3c49			HALT              ; Wait for the screen to be redrawn.
3c4a			DI                ;
3c4b
3c4b	L3C4B:  LD   (DE),A       ; Set each blue square in the attributes file.
3c4c			DEC  DE           ; Move to previous attribute position.
3c4d			DJNZ L3C4B        ; Repeat for all 32 columns.
3c4f
3c4f			INC  DE           ; Move back to first attribute column.
3c50			ADD  HL,DE        ; Determine column to show cyan marker at.
3c51			LD   A,$68        ; Flash 0, Bright 1, paper cyan, Ink 0 = Bright cyan.
3c53			LD   (HL),A       ; Show the cyan marker.
3c54
3c54			JR   L3BFE        ; Go back and count a new set of samples.
3c56
3c56			;Half second delay then clear key press flag. This is called upon entry and exit of the Tape Tester.
3c56
3c56	L3C56:  EI                ; Re-enable interrupts.
3c57			LD   B,$19        ; Count 25 interrupts.
3c59
3c59	L3C59:  HALT              ; Wait for half a second.
3c5a			DJNZ L3C59        ;
3c5c
3c5c			LD   HL,$5C3B     ; FLAGS.
3c5f			RES  5,(HL)       ; Signal no key press
3c61			SCF               ; Setting the carry flag here serves no purpose.
3c62			RET               ;
3c63
3c63
3c63			; ========================
3c63			; EDITOR ROUTINES - PART 5
3c63			; ========================
3c63
3c63			; -------------------
3c63			; Tokenize BASIC Line
3c63			; -------------------
3c63			; This routine serves two purposes. The first is to tokenize a typed BASIC line into a tokenized version. The second is when a syntax error is subsequently
3c63			; detected within the tokenized line, and it is then used to search for the position within the typed line where the error marker should be shown.
3c63			;
3c63			; This routine parses the BASIC line entered by the user and generates a tokenized version in the workspace area as pointed to by system variable E_LINE.
3c63			; It suffers from a number of bugs related to the handling of '>' and '<' characters. The keywords '<>', '>=' and '<=' are the only keywords that
3c63			; do not commence with letters and the routine traps these in a different manner to all other keywords. If a '<' or '>' is encountered then it is not
3c63			; immediately copied to the BASIC line workspace since the subsequent character must be examined as it could be a '>' or '=' character and therefore
3c63			; might form the keywords '<>', '>=' or '<='. A problem occurs if the subsequent character is a letter since the parser now expects the start of a
3c63			; possible keyword. It should at this point insert the '<' or '>' into the BASIC line workspace but neglects to do this. It is only when the next non-letter
3c63			; character is encountered that the '<' or '>' gets inserted, but this is now after the previously found string has been inserted. This results the following
3c63			; types of errors:
3c63			;
3c63			; 'PRINT varA>varB' is seen by the parser as 'PRINT varAvarB>' and hence a syntax error occurs.
3c63			; 'PRINT varA>varB1' is seen by the parser as 'PRINT varAvarB>1' and hence is accepted as a valid statement.
3c63			;
3c63			; A work-around is to follow the '<' or '>' with a space since this forces the '<' or '>' to be inserted before the next potential keyword is examined.
3c63			;
3c63			; A consequence of shifting a '<' or '>' is that a line such as 'PRINT a$>b$' is seen by the parser as 'PRINT a$b$>' and so it throws a syntax error.
3c63			; The parser saved the '>' character for consideration when the next character was examined to see if it was part of the keywords '<>', '>=' or '<=',
3c63			; but fails to discard it if the end of the statement is immediately encountered. Modifying the statement to a form that will be accepted will still cause
3c63			; a syntax error since the parser mistakenly believes the '>' character applies to this statement.
3c63			;
3c63			; The parser identifies string literals contained within quotes and will not tokenize any keywords that appear inside them, except for the keywords "<>",
3c63			; "<=" and ">=" which it neglects to check for. Keywords are also not tokenized following a REM statement, except again for "<>", "<=" and ">=", until the
3c63			; end of the line is reached. This differs slightly to 48K BASIC mode. In 48K BASIC mode, typing a ':' following a REM statement will cause a change from
3c63			; 'L' cursor mode to 'K' cursor mode and hence the next key press results in a keyword token being inserted. In 128K BASIC mode, typing a ':' will not change
3c63			; to 'K' cursor mode and hence the next key press will just be the letter, number or symbol. This does not affect the running of the program since 48K BASIC
3c63			; mode will ignore all characters after a REM command until the end of the line. However, creating such a REM statement in 128K BASIC mode that appears similar
3c63			; to one created in 48K BASIC mode will result in more memory being used since the 'keyword' must be spelled out letter by letter.
3c63			;
3c63			; When being used to locate the error marker position, the same process is performed as when tokenizing but no characters are actually inserted into the workspace
3c63			; (they are still there from when the line was originally tokenized). Instead, a check is made after each character is processed to see if the error marker address
3c63			; held in system variable X_PTR has been reached. If it does match then the routine returns with BC holding the character position where the error marker should
3c63			; be displayed at.
3c63
3c63			;Entry point - A syntax error was detected so the error marker must be located
3c63
3c63	L3C63:  LD   A,$01        ; Signal to locate the error marker.
3c65			JR   L3C69        ; Jump forward.
3c67
3c67			;Entry point - Tokenize the BASIC line
3c67
3c67	L3C67:  LD   A,$00        ; Signal to tokenize the BASIC line. [Could have saved 1 byte by using XOR A]
3c69
3c69	L3C69:  LD   ($FD8A),A    ; Store the 'locate error marker' flag.
3c6c
3c6c			LD   HL,$0000     ;
3c6f			LD   ($FD85),HL   ; Reset count of the number of characters in the typed BASIC line being inserted.
3c72			LD   ($FD87),HL   ; Reset count of the number of characters in the tokenized version of the BASIC line being inserted.
3c75			ADD  HL,SP        ;
3c76			LD   ($FD8B),HL   ; Store the stack pointer.
3c79
3c79			CALL L34EA        ; Clear BASIC line construction pointers (address of next character in the Keyword Construction Buffer and the
3c7c			; address of the next character in the BASIC line within the program area being de-tokenized).
3c7c
3c7c			LD   A,$00        ; [Could have saved 1 byte by using XOR A]
3c7e			LD   ($FD84),A    ; Signal last character was not a keyword and was not a space.
3c81			; [*BUG* - Should reset the '<' and '>' store at $FD89 to $00 here. Attempting to insert a BASIC line
3c81			; such as 'PRINT VAL a$>b' will fail since the parser does not like '>' immediately after 'a$', due to the bug at $3CB8 (ROM 0).
3c81			; The parser stores the '>' in $FD89 since it will check the following character in case it should replace the two
3c81			; characters with the token '<>', '>=' or '<='. After the parser throws the syntax error, it does not clear
3c81			; $FD89 and so even if the line is modified such that it should be accepted, e.g. 'PRINT VAL a$=b', the parser
3c81			; believes the line is really '>PRINT VAL n$=b' and so throws another syntax error. Since a letter follows the '>',
3c81			; the contents of $FD89 will get cleared and hence a second attempt to insert the line will now succeed. Credit: Paul Farrow]
3c81
3c81			LD   HL,$FD74     ; HL=Start address of the Keyword Conversion Buffer.
3c84			LD   ($FD7D),HL   ; Store as the next available location.
3c87
3c87			CALL L1F20        ; Use Normal RAM Configuration (physical RAM bank 0).
3c8a			RST  28H          ;
3c8b			DEFW SET_MIN      ; $16B0. Clear the editing areas.
3c8d			CALL L1F45        ; Use Workspace RAM configuration (physical RAM bank 7).
3c90
3c90			LD   A,$00        ; [Could have saved 1 byte by using XOR A, or 2 bytes by clearing this above]
3c92			LD   ($FD81),A    ; Clear Keyword Conversion Buffer flags - not within REM, not with Quotes, no characters in the buffer.
3c95
3c95			LD   HL,($5C59)   ; E_LINE.
3c98			LD   ($FD82),HL   ; Store the address of the workspace for the tokenized BASIC line.
3c9b
3c9b			LD   HL,$0000     ; [Could have saved 1 byte by using LD H,A followed by LD L,A]
3c9e			LD   ($FD7F),HL   ; Signal no space character between words in the Keyword Conversion Buffer.
3ca1
3ca1			;Enter a loop to fetch each character from the BASIC line and insert it into the workspace, tokenizing along the way
3ca1
3ca1	L3CA1:  LD   HL,($FD85)   ;
3ca4			INC  HL           ; Increment count of the number of characters in the typed BASIC line.
3ca5			LD   ($FD85),HL   ;
3ca8
3ca8			CALL L3D9D        ; Fetch the next character from BASIC line being inserted, return in B.
3cab			LD   C,A          ; Save the character status value.
3cac
3cac			;C=$01 if not a space, not a letter, not a '#' and not a '$'.
3cac			;  $02 if a '#' or '$'.
3cac			;  $03 if a space.
3cac			;  $06 if a letter.
3cac			;B=Character fetched.
3cac
3cac			LD   A,($FD81)    ; Have any Keyword Conversion Buffer flags been set?
3caf			CP   $00          ; Has anything be put into the buffer yet?
3cb1			JR   NZ,L3CF4     ; Jump if so.
3cb3
3cb3			;The first character to potentially put into the Keyword Conversion Buffer
3cb3
3cb3	L3CB3:  LD   A,C          ; Retrieve the character status value.
3cb4			AND  $04          ; Is the character a letter?
3cb6			JR   Z,L3CED      ; Jump if not.
3cb8
3cb8			;Insert the character
3cb8
3cb8	L3CB8:
3cb8
3cb8			; [*BUG* - At this point a '>' or '<' that was previously stored should be inserted into the BASIC line workspace. However, the routine proceeds with the new potential
3cb8			;          keyword and this is entered into the BASIC line workspace next. The '>' or '<' will only be inserted when the next non-letter character is encountered. This causes
3cb8			;          an expression such as 'a>b1' to be translated into 'ab>1'. Credit: Ian Collier (+3), Paul Farrow (128)]
3cb8
3cb8			; [The bug can be fixed by testing if whether a '<' or '>' character is stored. Credit: Paul Farrow.
3cb8			;
3cb8			;       LD   A,($FD89)    ;
3cb8			;       AND  A            ; Was the last character a '>' or '<'?
3cb8			;       JR   Z,INSERT     ; Jump if not.
3cb8			;
3cb8			;       PUSH BC           ; Save the new character.
3cb8			;       LD   B,A          ;
3cb8			;       CALL $3E64 (ROM 0) ; Insert the '>' or '<' into the BASIC line workspace.
3cb8			;       POP  BC           ; Retrieve the new character.
3cb8			;       XOR  A            ;
3cb8			;       LD   ($FD89),A    ; Clear the '>' or '<'.
3cb8			;
3cb8			;INSERT:                  ; ]
3cb8
3cb8			CALL L3DE9        ; Insert the character into the Keyword Conversion Buffer.
3cbb			JR   NC,L3CC4     ; Jump if no more room within the buffer, hence string is too large to be a token.
3cbd
3cbd			LD   A,$01        ; Signal Keyword Conversion Buffer contains characters.
3cbf			LD   ($FD81),A    ;
3cc2			JR   L3CA1        ; Jump back to fetch and process the next character.
3cc4
3cc4			;No room to insert the character into the Keyword Conversion Buffer hence string is too large to be a valid token
3cc4
3cc4	L3CC4:  LD   HL,($FD7F)   ; Fetch the address of the space character between words within the Keyword Conversion Buffer.
3cc7			LD   A,L          ;
3cc8			OR   H            ; Is there an address set?
3cc9			JP   NZ,L3D1E     ; Jump if so to copy the first word into the BASIC line workspace and the move the second word to the
3ccc			; start of the Keyword Conversion Buffer. Further characters can then be appended and the contents
3ccc			; re-evaluated in case a complete keyword is then available.
3ccc
3ccc			;Copy the Keyword Conversion Buffer into the BASIC line workspace
3ccc
3ccc	L3CCC:  PUSH BC           ; Save the character to insert.
3ccd			CALL L3DCD        ; Copy Keyword Conversion Buffer contents into BASIC line workspace.
3cd0			POP  BC           ; Retrieve the character to insert.
3cd1
3cd1			LD   A,$00        ;
3cd3			LD   ($FD81),A    ; Signal the Keyword Conversion Buffer is empty.
3cd6
3cd6			;C=$01 if not a space, not a letter, not a '#' and not a '$'.
3cd6			;  $02 if a '#' or '$'.
3cd6			;  $03 if a space.
3cd6			;  $06 if a letter.
3cd6			;B=Character fetched.
3cd6
3cd6	L3CD6:  LD   A,C          ; Retrieve the character status value.
3cd7			AND  $01          ; Is it a space, or not a letter and not a '#' and not a '$'?
3cd9			JR   NZ,L3CB3     ; Jump back if so to insert the character either into the Keyword Conversion Buffer or the BASIC line workspace.
3cdb
3cdb			;The string was too long to be a keyword and was followed by a space, a '#' or a '$'. Enter a loop to insert each character of the
3cdb			;string into the BASIC line workspace.
3cdb
3cdb			LD   A,B          ; Retrieve the character to insert.
3cdc			CALL L3E16        ; Insert character into BASIC line workspace.
3cdf			RET  NC           ; Return if tokenizing is complete.
3ce0
3ce0			LD   HL,($FD85)   ;
3ce3			INC  HL           ; Increment the count of the number of characters in the typed BASIC line being inserted.
3ce4			LD   ($FD85),HL   ;
3ce7
3ce7			CALL L3D9D        ; Fetch the next character from BASIC line being inserted.
3cea			LD   C,A          ; Save the flags.
3ceb
3ceb			JR   L3CD6        ; Jump back to insert the character of the non-keyword string into the BASIC line workspace.
3ced
3ced			;The character is not a letter so insert directly into the BASIC line workspace
3ced
3ced	L3CED:  LD   A,B          ; Retrieve the character to insert.
3cee			CALL L3E16        ; Insert character into BASIC line workspace, tokenizing '<>', '<=' and '>=' if encountered.
3cf1			RET  NC           ; Return if tokenizing is complete.
3cf2
3cf2			JR   L3CA1        ; Jump back to fetch and process the next character.
3cf4
3cf4			;Keyword Conversion buffer flags are set - either the buffer already contains characters, or within quotes or within a REM statement
3cf4
3cf4	L3CF4:  CP   $01          ; Is the Keyword Conversion Buffer empty or the contents marked as being within quotes or within a REM?
3cf6			JR   NZ,L3CED     ; Jump back if so to insert the character since this is either the first character of a new word or is within quotes or within a REM.
3cf8
3cf8			;C=$01 if not a space, not a letter, not a '#' and not a '$'.
3cf8			;  $02 if a '#' or '$'.
3cf8			;  $03 if a space.
3cf8			;  $06 if a letter.
3cf8
3cf8			LD   A,C          ; Retrieve the character status value.
3cf9			AND  $01          ; Is it a letter or a '#' or a '$'?
3cfb			JR   Z,L3CB8      ; Jump if so to simply insert the character.
3cfd
3cfd			;The character is a space, or is not a letter and not a '#' and not a '$', i.e. the last character was the end of a potential keyword
3cfd
3cfd			PUSH BC           ; Save the next character to insert and the character status value.
3cfe
3cfe	L3CFE:  CALL L3F7E        ; Attempt to identify the string in Keyword Conversion Buffer.
3d01			POP  BC           ; Retrieve the next character to insert and the character status value.
3d02			JR   C,L3D7D      ; Jump if keyword identified.
3d04
3d04			;The string in the Keyword Conversion Buffer was not identified as a keyword
3d04
3d04			LD   HL,($FD7F)   ; Fetch the address of the space character between words within the Keyword Conversion Buffer.
3d07			LD   A,H          ;
3d08			OR   L            ; Is there an address set, i.e. a space between words?
3d09			JR   NZ,L3D1E     ; Jump if there is a space character.
3d0b
3d0b			LD   A,C          ; Retrieve the character status value.
3d0c			AND  $02          ; Is it a space?
3d0e			JR   Z,L3CCC      ; Jump if not to copy Keyword Conversion Buffer into the workspace since it is not a keyword.
3d10
3d10			;Character is a space. Allow this as the keyword could be DEF FN, GO TO, GO SUB, etc.
3d10
3d10			CALL L3DE9        ; Insert the character into the Keyword Conversion Buffer.
3d13			JR   NC,L3CC4     ; Jump back if no room to insert the character, i.e. not a keyword since too large.
3d15
3d15			LD   HL,($FD7D)   ; Fetch the next location address.
3d18			DEC  HL           ; Point back to the last character.
3d19			LD   ($FD7F),HL   ; Store as the address of the space character. This is used for double keywords such as DEF FN.
3d1c			JR   L3CA1        ; Jump back to fetch and process the next character.
3d1e
3d1e			;The string in the Keyword Conversion Buffer contains two words separated by a space that do not form a
3d1e			;valid double keyword (such as DEF FN, GO SUB, GO TO, etc).
3d1e			;For a BASIC line such as 'IF FLAG THEN' the Keyword Conversion Buffer holds the characters 'FLAG THEN'.
3d1e			;The 'FLAG' characters get moved to the workspace and the 'THEN' characters are shifted to the start of the
3d1e			;Keyword Conversion Buffer before being re-evaluated to see if they form a keyword.
3d1e
3d1e	L3D1E:  PUSH BC           ; Save the character to insert and the character status value.
3d1f
3d1f			LD   HL,$FD74     ; Point to the start address of the Keyword Conversion Buffer.
3d22			LD   DE,($FD7F)   ; Fetch the address of the space character between words within the Keyword Conversion Buffer.
3d26			LD   A,D          ;
3d27			CP   H            ; Is the space possibly at the start of the buffer?
3d28			JR   NZ,L3D2F     ; Jump if not.
3d2a
3d2a			LD   A,E          ;
3d2b			CP   L            ; Is the space at the start of the buffer?
3d2c			JR   NZ,L3D2F     ; Jump if not.
3d2e
3d2e			INC  DE           ; Point to the next location within the buffer, counter-acting the following decrement.
3d2f
3d2f	L3D2F:  DEC  DE           ; Point to the previous location within the buffer.
3d30			JR   L3D33        ; Jump ahead to copy all characters to the BASIC line workspace.
3d32
3d32			;Copy all characters from the Keyword Conversion Buffer prior to the space into the BASIC line workspace
3d32
3d32	L3D32:  INC  HL           ; Point to the next location within the Keyword Conversion Buffer.
3d33
3d33	L3D33:  LD   A,(HL)       ; Fetch a character from the Keyword Conversion Buffer.
3d34			AND  $7F          ; Mask off the terminator bit.
3d36			PUSH HL           ; HL=Location within Keyword Conversion Buffer.
3d37			PUSH DE           ; DE=Location of last character within the Keyword conversion Buffer.
3d38			CALL L3E16        ; Insert character into BASIC line workspace, including a stored '<' or '>' character.
3d3b			POP  DE           ;
3d3c			POP  HL           ;
3d3d
3d3d			LD   A,H          ;
3d3e			CP   D            ; Possibly reached the character prior to the space?
3d3f			JR   NZ,L3D32     ; Jump back if not to copy the next character.
3d41
3d41			LD   A,L          ;
3d42			CP   E            ; Reached the character prior to the space?
3d43			JR   NZ,L3D32     ; Jump back if not to copy the next character.
3d45
3d45			;Now proceed to handle the next word
3d45
3d45			LD   DE,($FD7F)   ; DE=Address of the space character between words.
3d49			LD   HL,$FD74     ;
3d4c			LD   ($FD7F),HL   ; Set the address of the space character to be the start of the buffer.
3d4f
3d4f			LD   BC,($FD7D)   ; BC=Next location within the Keyword Conversion Buffer.
3d53			DEC  BC           ; Point to the last used location.
3d54
3d54			LD   A,D          ;
3d55			CP   H            ; Is the space possibly at the start of the buffer?
3d56			JR   NZ,L3D70     ; Jump if not.
3d58
3d58			LD   A,E          ;
3d59			CP   L            ; Is the space at the start of the buffer?
3d5a			JR   NZ,L3D70     ; Jump if not.
3d5c
3d5c			;The space character is at the start of the Keyword Conversion Buffer
3d5c
3d5c			INC  DE           ; DE=Address after the space character within the Keyword Conversion Buffer.
3d5d			PUSH HL           ; HL=Start address of the Keyword Conversion Buffer.
3d5e			LD   HL,$0000     ;
3d61			LD   ($FD7F),HL   ; Signal no space character between words.
3d64			POP  HL           ; HL=Start address of the Keyword Conversion Buffer.
3d65
3d65			LD   A,B          ;
3d66			CP   H            ; Is the space possibly the last character in the buffer?
3d67			JR   NZ,L3D70     ; Jump if not.
3d69
3d69			LD   A,C          ;
3d6a			CP   L            ; Is the space the last character in the buffer?
3d6b			JR   NZ,L3D70     ; Jump if not.
3d6d
3d6d			POP  BC           ; Retrieve the character to insert and the character status value.
3d6e			JR   L3D8F        ; Jump ahead to continue.
3d70
3d70			;The space is not at the start of the Keyword Conversion Buffer, i.e. the buffer contains another word after the space.
3d70			;The first word has already been copied to the BASIC line workspace so now copy the second word to the start of the Keyword Conversion Buffer
3d70			;and then see if it is a valid keyword. [It is not recommended to name a variable as per a keyword since statements such as 'PRINT then' will
3d70			;fail the syntax check since the variable 'then' is interpreted as the keyword 'THEN' and so the statement is seen as 'PRINT THEN', which in
3d70			;this case is invalid.]
3d70
3d70			;HL points to the start of the Keyword Conversion Buffer.
3d70			;DE points to the space between the two words.
3d70
3d70	L3D70:  LD   A,(DE)       ; Fetch a character from the second word.
3d71			LD   (HL),A       ; Store it at the beginning of the buffer.
3d72			INC  HL           ;
3d73			INC  DE           ;
3d74			AND  $80          ; Reached the last character in the buffer, i.e. the terminator bit set?
3d76			JR   Z,L3D70      ; Jump if not to copy the next character.
3d78
3d78			LD   ($FD7D),HL   ; Store the new address of the next free location.
3d7b			JR   L3CFE        ; Jump back to attempt identification of the 'second' word as a keyword.
3d7d
3d7d			;The string in the Keyword Conversion Buffer was identified as a keyword, so insert the token character code of the
3d7d			;keyword into the BASIC line workspace.
3d7d			;A=Character code of identified token.
3d7d
3d7d	L3D7D:  PUSH BC           ; Save the next character to insert and the character status value.
3d7e			CALL L3E16        ; Insert character held in A into BASIC line workspace.
3d81			POP  BC           ; Retrieve the next character to insert and the character status value.
3d82
3d82			;The token has been inserted into the BASIC line workspace so reset the Keyword Conversion Buffer
3d82
3d82			LD   HL,$0000     ;
3d85			LD   ($FD7F),HL   ; Indicate no space character between words in the Keyword Conversion Buffer.
3d88
3d88			LD   A,($FD81)    ; Fetch the flag bits.
3d8b			CP   $04          ; Within a REM statement?
3d8d			JR   Z,L3D94      ; Jump if so to retain the 'within a REM' flag bit.
3d8f
3d8f	L3D8F:  LD   A,$00        ;
3d91			LD   ($FD81),A    ; Signal no characters within the Keyword Conversion Buffer.
3d94
3d94	L3D94:  LD   HL,$FD74     ; Start address of the Keyword Conversion Buffer.
3d97			LD   ($FD7D),HL   ; Store this as the next location within the buffer.
3d9a			JP   L3CB3        ; Jump back to insert the next character either into the Keyword Conversion Buffer or the BASIC line workspace.
3d9d
3d9d			; -------------------------------------------------------------------
3d9d			; Fetch Next Character and Character Status from BASIC Line to Insert
3d9d			; -------------------------------------------------------------------
3d9d			; Fetch the next character from the BASIC line being inserted and check whether a letter, a space, a '#' or a '$'.
3d9d			; Exit: B=Character.
3d9d			;       A=$01 if not a space, not a letter, not a '#' and not a '$'.
3d9d			;         $02 if a '#' or '$'.
3d9d			;         $03 if a space.
3d9d			;         $06 if a letter.
3d9d
3d9d	L3D9D:  CALL L2D54        ; Fetch the next character from the BASIC line being inserted.
3da0			LD   B,A          ; Save the character.
3da1			CP   '?'          ; $3F. Is it below '?' (the error marker)?
3da3			JR   C,L3DAF      ; Jump if so.
3da5
3da5			OR   $20          ; Make lowercase.
3da7			CALL L3DC6        ; Is it a letter?
3daa			JR   C,L3DC3      ; Jump if so.
3dac
3dac	L3DAC:  LD   A,$01        ; Indicate not space, not letter, not '#' and not '$'.
3dae			RET               ;
3daf
3daf	L3DAF:  CP   $20          ; Is it a space?
3db1			JR   Z,L3DC0      ; Jump if so.
3db3
3db3			CP   '#'          ; $23. Is it '#'?
3db5			JR   Z,L3DBD      ; Jump if so.
3db7
3db7			JR   C,L3DAC      ; Jump if below '#'.
3db9
3db9			CP   '$'          ; $24. Is it '$'?
3dbb			JR   NZ,L3DAC     ; Jump if not.
3dbd
3dbd	L3DBD:  LD   A,$02        ; Indicate a '#' or '$'.
3dbf			RET               ;
3dc0
3dc0	L3DC0:  LD   A,$03        ; Indicate a space.
3dc2			RET               ;
3dc3
3dc3	L3DC3:  LD   A,$06        ; Indicate a letter.
3dc5			RET               ;
3dc6
3dc6			; --------------------
3dc6			; Is Lowercase Letter?
3dc6			; --------------------
3dc6			; Entry: A=Character code.
3dc6			; Exit : Carry flag set is a lowercase letter.
3dc6
3dc6	L3DC6:  CP   $7B          ; Is the character above 'z'?
3dc8			RET  NC           ; Return with carry flag reset if above 'z'.
3dc9
3dc9			CP   $61          ; Is the character below 'a'?
3dcb			CCF               ; Return with carry flag reset if below 'a'.
3dcc			RET               ;
3dcd
3dcd			; -----------------------------------------------------------------
3dcd			; Copy Keyword Conversion Buffer Contents into BASIC Line Workspace
3dcd			; -----------------------------------------------------------------
3dcd
3dcd	L3DCD:
3dcd
3dcd			; [To fix the error marker bug at $3EFB (ROM 0), the code below up until the instruction at $3DDA (ROM 0) should have been as follows]
3dcd			;
3dcd			;       LD   HL,$FD74     ; Start address of the Keyword Conversion Buffer.
3dcd			;       CALL $3DDA (ROM 0) ; Copy all characters into the BASIC line workspace.
3dcd			;       LD   HL,$FD74     ; Start address of the Keyword Conversion Buffer.
3dcd			;       LD   ($FD7D),HL   ; Store the next available location.
3dcd			;       SUB  A            ; A=0.
3dcd			;       LD   ($FD7F),A    ;
3dcd			;       LD   ($FD80),A    ; Signal no space character between words in the Keyword Conversion Buffer.
3dcd			;       RET
3dcd
3dcd			LD   HL,$FD74     ; Start address of the Keyword Conversion Buffer.
3dd0			LD   ($FD7D),HL   ; Store the next available location.
3dd3			SUB  A            ; A=0.
3dd4			LD   ($FD7F),A    ;
3dd7			LD   ($FD80),A    ; Signal no space character between words in the Keyword Conversion Buffer.
3dda
3dda	L3DDA:  LD   A,(HL)       ; Fetch a character from the buffer.
3ddb			AND  $7F          ; Mask off the terminator bit.
3ddd
3ddd			PUSH HL           ; Save buffer location.
3dde			CALL L3E9C        ; Insert the character into the BASIC line workspace, suppressing spaces as required.
3de1			POP  HL           ; Retrieve buffer location.
3de2
3de2			LD   A,(HL)       ; Re-fetch the character from the buffer.
3de3			AND  $80          ; Is it the terminator character?
3de5			RET  NZ           ; Return if so.
3de6
3de6			INC  HL           ; Point to the next character in the buffer.
3de7			JR   L3DDA        ; Jump back to handle next buffer character.
3de9
3de9			; -----------------------------------------------
3de9			; Insert Character into Keyword Conversion Buffer
3de9			; -----------------------------------------------
3de9			; Entry; B=Character to insert.
3de9			; Exit : Carry flag reset if no room to insert the character within the buffer.
3de9
3de9	L3DE9:  LD   HL,($FD7D)   ; Fetch address within Keyword Conversion Buffer.
3dec			LD   DE,$FD7D     ; Address after Keyword Conversion Buffer.
3def			LD   A,D          ;
3df0			CP   H            ; Has end of buffer possibly been reached?
3df1			JR   NZ,L3DF8     ; Jump if not.
3df3
3df3			LD   A,E          ;
3df4			CP   L            ; Has end of buffer been reached?
3df5			JP   Z,L3E13      ; Jump if so. [Could have saved a byte by using JR instead of JP]
3df8
3df8			;End of buffer not reached
3df8
3df8	L3DF8:  LD   DE,$FD74     ; Start address of Keyword Conversion Buffer.
3dfb			LD   A,D          ;
3dfc			CP   H            ; Possibly at the start of the buffer?
3dfd			JR   NZ,L3E03     ; Jump if not.
3dff
3dff			LD   A,E          ;
3e00			CP   L            ; At the start of the buffer?
3e01			JR   Z,L3E09      ; Jump if so to simply store the character.
3e03
3e03			;Not at the start of the buffer so need to remove terminator bit from the previous character
3e03
3e03	L3E03:  DEC  HL           ; Point to the last character.
3e04			LD   A,(HL)       ;
3e05			AND  $7F          ; Clear the terminator bit from the last character.
3e07			LD   (HL),A       ;
3e08			INC  HL           ; Point back at the current location.
3e09
3e09	L3E09:  LD   A,B          ; Retrieve the new character.
3e0a			OR   $80          ; Set the terminator bit.
3e0c			LD   (HL),A       ; Store the character in the buffer.
3e0d			INC  HL           ; Point to the next location.
3e0e			LD   ($FD7D),HL   ; Store the address of the next location.
3e11
3e11			SCF               ; Signal character inserted.
3e12			RET               ;
3e13
3e13			;End of buffer reached
3e13
3e13	L3E13:  SCF               ;
3e14			CCF               ; Clear the carry flag to indicate no room to insert the character within the buffer.
3e15			RET               ;
3e16
3e16			; ----------------------------------------------------------------
3e16			; Insert Character into BASIC Line Workspace, Handling '>' and '<'
3e16			; ----------------------------------------------------------------
3e16			; This routine inserts a character into the BASIC line workspace, tokenizing '>=', '<=' and '<>'.
3e16			; Entry: A=Character to insert.
3e16			; Exit : If tokenizing a BASIC line then returns with carry flag reset if tokenizing is complete.
3e16			;        If searching for the error marker location then returns with the carry flag set if the error marker has not been found,
3e16			;        otherwise a return is made to the main calling routine with BC holding the number of characters in the typed BASIC line,
3e16			;        i.e. the error marker location is at the end of the line.
3e16
3e16	L3E16:  PUSH AF           ; Save the character to insert.
3e17
3e17			; [*BUG* - The string characters "<>", "<=" and ">=" get tokenized to a single character '<>', '<=' and '>=' respectively
3e17			;          even within quotes or a REM statement. Credit: Paul Collins (+3), Paul Farrow (128)]
3e17			;
3e17			; [*BUG* - 128 BASIC mode handles a colon character found following a REM statement differently to 48K mode. In 48K mode, typing
3e17			;          a colon returns the cursor into 'K' mode and hence the next key press inserts a keyword token. In 128K mode, typing a colon
3e17			;          does not cause the characters following it to be interpreted as a possible keyword. There is no noticeable difference when
3e17			;          executing the REM statement since subsequent statements are ignored following a REM command. However, for consistency the
3e17			;          128K mode editor ought to generate identical BASIC lines to those that would be created from 48K mode. Credit: Paul Farrow]
3e17			;
3e17			; [The following instructions would be required fix the two bugs described above. Credit: Paul Farrow.
3e17			;
3e17			;       LD   A,($FD81)    ;
3e17			;       BIT  1,A          ; Within quotes?
3e17			;       JR   NZ,WITHIN    ; Jump forward if within quotes.
3e17			;
3e17			;       BIT  2,A          ; Within a REM statement?
3e17			;       JR   Z,NOT_WITHIN ; Jump forward if not within a REM statement.
3e17			;
3e17			;       POP  AF           ;
3e17			;       PUSH AF           ;
3e17			;       CP   ':'          ;
3e17			;       JR   NZ,WITHIN    ; Jump if not a colon.
3e17			;
3e17			;       LD   A,($FD81)    ;
3e17			;       AND  $FB          ; Signal not within a REM statement.
3e17			;       LD   ($FD81),A    ;
3e17			;
3e17			;WITHIN:
3e17			;       POP  AF           ; Retrieve the character to insert.
3e17			;       JP   $3E64 (ROM 0) ; Simply insert the character into the BASIC line workspace.
3e17			;
3e17			;NOT_WITHIN:              ; ]
3e17
3e17			LD   A,($FD89)    ; Was the previous character '<' or '>'?
3e1a			OR   A            ;
3e1b			JR   NZ,L3E2F     ; Jump if so.
3e1d
3e1d			POP  AF           ; Retrieve the character to insert.
3e1e			CP   '>'          ; $3E. Is it '>'?
3e20			JR   Z,L3E2A      ; Jump if so to store for special treatment later.
3e22
3e22			CP   '<'          ; $3C. Is it '<'?
3e24			JR   Z,L3E2A      ; Jump if so to store for special treatment later.
3e26
3e26	L3E26:  CALL L3E64        ; Insert the character into the BASIC line workspace.
3e29			RET               ; [Could have saved 1 byte by using JP $3E64 (ROM 0)]
3e2a
3e2a			;The character was '<' or '>'
3e2a
3e2a	L3E2A:  LD   ($FD89),A    ; Store '<' or '>'.
3e2d			SCF               ; Signal tokenizing not complete or error marker not found.
3e2e			RET               ;
3e2f
3e2f			;The previous character was '<' or '>'
3e2f
3e2f	L3E2F:  CP   '<'          ; $3C. Was the previous character '<'?
3e31			LD   A,$00        ; Reset the indicator that the previous
3e33			LD   ($FD89),A    ; character was '<' or '>'.
3e36			JR   NZ,L3E52     ; Jump ahead if not '<'.
3e38
3e38			;Previous character was '<'
3e38
3e38			POP  AF           ; Retrieve the character to insert.
3e39			CP   '>'          ; $3E. Is it '>'?
3e3b			JR   NZ,L3E41     ; Jump ahead if not.
3e3d
3e3d			LD   A,$C9        ; Tokenize to the single character '<>'.
3e3f			JR   L3E26        ; Jump back to insert the character and return.
3e41
3e41	L3E41:  CP   '='          ; $3D. Is it '='?
3e43			JR   NZ,L3E49     ; Jump ahead if not.
3e45
3e45			LD   A,$C7        ; Tokenize to '<='.
3e47			JR   L3E26        ; Jump back to insert the character and return.
3e49
3e49			;Previous character was '<' and new character is '<'
3e49
3e49	L3E49:  PUSH AF           ; Save the current character to insert.
3e4a			LD   A,'<'        ; $3C.
3e4c			CALL L3E64        ; Put the preceding '<' character into the line.
3e4f			POP  AF           ; Retrieve the character to insert.
3e50			JR   L3E26        ; Jump back to insert the character and return.
3e52
3e52			;Previous character was '>'
3e52
3e52	L3E52:  POP  AF           ; Retrieve the character to insert.
3e53			CP   '='          ; $3D. Is it '='?
3e55			JR   NZ,L3E5B     ; Jump ahead if not.
3e57
3e57			LD   A,$C8        ; Tokenize to '>='.
3e59			JR   L3E26        ; Jump back to insert the character and return.
3e5b
3e5b			;Previous character was '>' and new character is '>'
3e5b
3e5b	L3E5B:  PUSH AF           ; Save the current character to insert.
3e5c			LD   A,'>'        ; $3E.
3e5e			CALL L3E64        ; Put the preceding '>' character into the line.
3e61			POP  AF           ; Retrieve the character to insert.
3e62			JR   L3E26        ; Jump back to insert the character and return.
3e64
3e64			; ---------------------------------------------------------------------
3e64			; Insert Character into BASIC Line Workspace, Handling 'REM' and Quotes
3e64			; ---------------------------------------------------------------------
3e64			; This routine inserts a character into the BASIC line workspace, with special handling of a 'REM' command
3e64			; and strings contained within quotes.
3e64			; Entry: A=Character to insert.
3e64			; Exit : If tokenizing a BASIC line then returns with carry flag reset if tokenizing is complete.
3e64			;        If searching for the error marker location then returns with the carry flag set if the error marker has not been found,
3e64			;        otherwise a return is made directly to the main calling routine with BC holding the number of characters in the typed BASIC line,
3e64			;        i.e. the error marker location is at the end of the line.
3e64
3e64	L3E64:  CP   $0D          ; Is it 'ENTER'?
3e66			JR   Z,L3E88      ; Jump ahead if so.
3e68
3e68			CP   $EA          ; Is it 'REM'?
3e6a			LD   B,A          ; Save the character.
3e6b			JR   NZ,L3E74     ; Jump ahead if not REM.
3e6d
3e6d			;It is a 'REM' character
3e6d
3e6d			LD   A,$04        ; Indicate that within a REM statement.
3e6f			LD   ($FD81),A    ;
3e72			JR   L3E82        ; Jump ahead to insert the character into the BASIC line workspace.
3e74
3e74	L3E74:  CP   $22          ; Is it a quote?
3e76			JR   NZ,L3E82     ; Jump ahead if not.
3e78
3e78			;It is a quote character
3e78
3e78			LD   A,($FD81)    ;
3e7b			AND  $FE          ; Signal last character was not a keyword.
3e7d			XOR  $02          ; Toggle the 'within quotes' flag. Will be 1 for an opening quote, then 0 for a closing quote.
3e7f			LD   ($FD81),A    ;
3e82
3e82	L3E82:  LD   A,B          ; Retrieve the character.
3e83			CALL L3E9C        ; Insert the character into the BASIC line workspace, suppressing spaces as required.
3e86
3e86			SCF               ; Indicate BASIC line tokenization not complete.
3e87			RET               ;
3e88
3e88			;It is an 'ENTER' character
3e88
3e88			; [*BUG* - At this point a check should be made to see whether the last character was a space. If it was then it will not have
3e88			;          been inserted but instead the flag in $FD84 (ROM 0) will have been set. The purpose of the flag is to filter out double
3e88			;          spaces caused by the leading/trailing spaces of tokens. Only if the following character is not a space will the previous
3e88			;          character, the space, be inserted. When the end of the line is found, there is no attempt to insert this space.
3e88			;          The bug can be fixed by the two modifications shown below. Credit: Paul Farrow]
3e88
3e88	L3E88:  LD   A,($FD8A)    ; Fetch the 'locate error marker' flag.
3e8b			CP   $00          ; Searching for the error marker following a syntax error? [Could have saved 1 byte by using AND A]
3e8d			JR   Z,L3E99      ; Jump if tokenizing the BASIC line.
3e8f
3e8f			;The end of the line was reached and no error marker was found so assume the error marker exists at the end of the typed line
3e8f
3e8f			LD   BC,($FD85)   ; BC=Count of number of the characters in the typed BASIC line being inserted.
3e93			LD   HL,($FD8B)   ;
3e96
3e96			; [The first part of the fix for the trailing space bug is as follows:
3e96			;
3e96			;       LD   A,($FD84)    ; Fetch the BASIC line insertion flags.
3e96			;       AND  $02          ; Was the last character a space?
3e96			;       JR   Z,GOT_COUNT  ; Jump if not.
3e96			;
3e96			;       INC  BC           ; Increment to account for the final space.
3e96			;
3e96			;GOT_COUNT:               ; ]
3e96
3e96			LD   SP,HL        ; Restore the stack pointer.
3e97			SCF               ; Indicate the error marker was not found within the tokenized BASIC line.
3e98			RET               ; Return back to the top level calling routine, to $2D04 (ROM 0).
3e99
3e99			;Tokenizing the BASIC line
3e99
3e99	L3E99:
3e99
3e99			; [The second part of the fix for the trailing space bug is as follows:
3e99			;
3e99			;       LD   A,($FD84)    ; Fetch the BASIC line insertion flags.
3e99			;       AND  $02          ; Was the last character a space?
3e99			;       LD   A,$20        ; Insert a space into the line.
3e99			;       CALL NZ,$3EFB (ROM 0) ; If so then insert the character into the BASIC line workspace.]
3e99
3e99			SCF               ;
3e9a			CCF               ; Carry flag reset to indicate tokenizing complete.
3e9b			RET               ;
3e9c
3e9c			; -----------------------------------------------------------------
3e9c			; Insert Character into BASIC Line Workspace With Space Suppression
3e9c			; -----------------------------------------------------------------
3e9c			; This routine is called to insert a character into the BASIC line workspace, suppressing both leading and trailing spaces
3e9c			; around tokens, e.g. 'PRINT 10' does not require a space stored between 'PRINT' and '10' within the BASIC line.
3e9c			; The routine maintains two flags which indicate whether the last character was a space or was a token. Whenever a space
3e9c			; is encountered, it is noted but not inserted straight away. It is only after the subsequent character is examined that
3e9c			; the routine can determine whether the space should or should not be inserted.
3e9c			; Entry: A=Character to insert.
3e9c			; Exit : A=Updated BASIC line insertion flags.
3e9c
3e9c	L3E9C:  LD   E,A          ; Save the character to insert in E.
3e9d
3e9d			LD   A,($FD84)    ;
3ea0			LD   D,A          ; D=BASIC line insertion flags.
3ea1
3ea1			LD   A,E          ; Restore character to insert back to A.
3ea2			CP   $20          ; Is it a space?
3ea4			JR   NZ,L3EC6     ; Jump ahead if not.
3ea6
3ea6			;Character to insert is a space
3ea6
3ea6			LD   A,D          ; A=BASIC line insertion flags.
3ea7			AND  $01          ; Was the last character a token?
3ea9			JR   NZ,L3EBF     ; Jump ahead if so.
3eab
3eab			LD   A,D          ; A=BASIC line insertion flags.
3eac			AND  $02          ; Was the last character a space?
3eae			JR   NZ,L3EB7     ; Jump ahead if so.
3eb0
3eb0			;Character to insert is a space and the last character was not a space/token. This could be the start of a new keyword
3eb0			;so note the space but do not insert it now.
3eb0
3eb0			LD   A,D          ; A=BASIC line insertion flags.
3eb1			OR   $02          ; Signal the last character was a space.
3eb3			LD   ($FD84),A    ; Store the updated BASIC line insertion flags.
3eb6			RET               ;
3eb7
3eb7			;Character to insert is a space and the last character was a space. The new space could be the start of a new keyword
3eb7			;so keep the 'last character was a space' flag set but insert a space for the previous space that was noted.
3eb7
3eb7	L3EB7:  LD   A,E          ; Retrieve the character to insert.
3eb8			CALL L3EFB        ; Insert the character into the BASIC line workspace.
3ebb			LD   A,($FD84)    ; A=BASIC line insertion flags.
3ebe			RET               ;
3ebf
3ebf			;Character to insert is a space and the last character was a token. Do not insert trailing spaces for tokens.
3ebf
3ebf	L3EBF:  LD   A,D          ; A=BASIC line insertion flags.
3ec0			AND  $FE          ; Signal last character was not a token.
3ec2			LD   ($FD84),A    ; Store the updated BASIC line insertion flags.
3ec5			RET               ; [Could have saved 2 bytes by using JR $3EB3 (ROM 0)]
3ec6
3ec6			;Character to insert is not a space
3ec6
3ec6	L3EC6:  CP   $A3          ; Compare against the token 'SPECTRUM' (the first 128K keyword).
3ec8			JR   NC,L3EEE     ; Jump ahead if a token.
3eca
3eca			;Character to insert is not a space and not a token
3eca
3eca			LD   A,D          ; A=BASIC line insertion flags.
3ecb			AND  $02          ; Was the last character a space?
3ecd			JR   NZ,L3EDA     ; Jump ahead if it was.
3ecf
3ecf			;Character to insert is not a space and not a token and the last character inserted was not a space, so just insert the character
3ecf
3ecf			LD   A,D          ; A=BASIC line insertion flags.
3ed0			AND  $FE          ; Signal last character was not a keyword.
3ed2			LD   ($FD84),A    ; Store the new flags.
3ed5
3ed5			LD   A,E          ; Retrieve the character to insert.
3ed6			CALL L3EFB        ; Insert the character into the BASIC line workspace.
3ed9			RET               ; [Could have saved one byte by using JP $3EFB (ROM 0)]
3eda
3eda			;Character to insert is not a space and not a token and the last character was a space. Since the new character is not a token, the previous
3eda			;space was not the start of a new keyword so insert a space and then the new character.
3eda
3eda	L3EDA:  PUSH DE           ; Save the BASIC line insertion flags.
3edb			LD   A,$20        ; Insert a space into the line.
3edd			CALL L3EFB        ; Insert the character into the BASIC line workspace.
3ee0			POP  DE           ; Retrieve the flags.
3ee1
3ee1			LD   A,D          ; A=BASIC line insertion flags.
3ee2			AND  $FE          ; Signal last character was not a keyword.
3ee4			AND  $FD          ; Signal last character was not a space.
3ee6			LD   ($FD84),A    ; Store the updated BASIC line insertion flags. [Could have saved 6 bytes by using JR $3ED2 (ROM 0)]
3ee9
3ee9			LD   A,E          ; Retrieve the character to insert.
3eea			CALL L3EFB        ; Insert the character into the BASIC line workspace.
3eed			RET               ;
3eee
3eee			;Character to insert is a token. Clear any previously noted space since leading spaces are not required for tokens.
3eee
3eee	L3EEE:  LD   A,D          ; A=BASIC line insertion flags.
3eef			AND  $FD          ; Signal last character was not a space.
3ef1			OR   $01          ; Signal last character was a keyword.
3ef3			LD   ($FD84),A    ; Store the updated BASIC line insertion flags. [Could have saved 6 bytes by using JR $3ED2 (ROM 0)]
3ef6
3ef6			LD   A,E          ; Retrieve the character to insert.
3ef7			CALL L3EFB        ; Insert the character into the BASIC line workspace.
3efa			RET               ;
3efb
3efb			; --------------------------------------------
3efb			; Insert a Character into BASIC Line Workspace
3efb			; --------------------------------------------
3efb			; This routine is called for two purposes. The first use is for inserting a character or token into the BASIC line workspace (situated at E_LINE).
3efb			; The second use is after a syntax error has been identified within the tokenized BASIC line in the workspace and the location of the error marker needs to be
3efb			; established. For the second case, the system variable X_PTR holds the address of where the error occurred within the tokenized BASIC line in the workspace.
3efb			; The Editor needs to identify how many characters there are before the equivalent error position is reached within the typed BASIC line. To locate it, the typed BASIC
3efb			; line is re-parsed but this time without inserting any characters into the BASIC line workspace, since this still contains the tokenized line from before. This tokenized line
3efb			; will now also include embedded floating point numbers for any numeric literals contained within the BASIC line. As the typed line is re-parsed, a count of the characters
3efb			; examined so far is kept and instead of inserting tokenized characters within the BASIC line workspace, a check is made to see whether the insertion location has
3efb			; reached the address of the error marker. If it has then the parsing of the BASIC line terminates and the count of the typed line characters indicates the equivalent
3efb			; position within it of the error. However, should the last character have been a token then the typed line count will also include the number of characters that form
3efb			; the keyword, and so this must be subtracted from the count.
3efb			; Entry: A=Character to insert.
3efb			;        DE=Address of insertion position within the BASIC line workspace.
3efb			; Exit : If searching for the error marker position and it is found then a return is made directly to the top level calling routine with BC holding the number of characters in
3efb			;        the typed BASIC line prior to the equivalent error marker position.
3efb
3efb	L3EFB:  LD   HL,($FD87)   ;
3efe			INC  HL           ; Increment the count of the number of characters in the tokenized BASIC line.
3eff			LD   ($FD87),HL   ;
3f02
3f02			LD   HL,($FD82)   ; HL=Address of next insertion position in the BASIC line workspace.
3f05			LD   B,A          ; Save the character to insert.
3f06
3f06			LD   A,($FD8A)    ; Fetch the 'locate error marker' flag.
3f09			CP   $00          ; Searching for the error marker following a syntax error? [Could have saved 1 byte by using AND A]
3f0b			LD   A,B          ; A=Character to insert.
3f0c			JR   Z,L3F33      ; Jump if tokenizing the BASIC line.
3f0e
3f0e			;Locating the error marker
3f0e
3f0e			LD   DE,($5C5F)   ; X_PTR. Fetch the address of the character after the error marker.
3f12			LD   A,H          ;
3f13			CP   D            ; Has the error marker position possibly been reached?
3f14			JR   NZ,L3F30     ; Jump ahead if not.
3f16
3f16			LD   A,L          ;
3f17			CP   E            ; Has the error marker position been reached?
3f18			JR   NZ,L3F30     ; Jump ahead if not.
3f1a
3f1a			;The error marker has been reached
3f1a
3f1a			; [*BUG* - The desired character count until the error marker is held at address $FD85 and needs the length of the last character to be removed from it,
3f1a			;          which for a token would be several bytes. However, the routine simply returns the lower of the tokenized and typed counts, and this yields
3f1a			;          very unhelpful error marker positions shown within the typed BASIC line. Credit: Ian Collier (+3), Andrew Owen (128)]
3f1a
3f1a			; [The code below up until the instruction at $3F2A (ROM 0) should have been as follows. Changes to the code at $3DCD (ROM 0) are also required. Credit: Paul Farrow.
3f1a			;
3f1a			;       LD   HL,($FD7D)   ; Fetch the next address within the Keyword Conversion Buffer.
3f1a			;       LD   DE,$FD74     ; Fetch the start address of the Keyword Conversion Buffer.
3f1a			;       AND  A            ;
3f1a			;       SBC  HL,DE        ; HL=Length of the keyword (excluding leading or trailing spaces).
3f1a			;       EX   DE,HL        ; DE=Length of the keyword (excluding leading or trailing spaces).
3f1a			;       LD   HL,($FD85)   ; BC=Count of the number of characters in the typed BASIC line until the error marker location was found.
3f1a			;       SBC  HL,DE        ; Subtract the number of characters in the keyword text.
3f1a			;       LD   B,H          ;
3f1a			;       LD   C,L          ; Transfer the result to BC, and then return via the instructions at $3F2A (ROM 0) onwards.]
3f1a
3f1a			LD   BC,($FD85)   ; Count of the number of characters in the typed BASIC line until the error marker location was found.
3f1e			LD   HL,($FD87)   ; Count of the number of characters in the tokenized BASIC line until the error marker location.
3f21			AND  A            ;
3f22			SBC  HL,BC        ;
3f24			JR   NC,L3F2A     ; Jump if the tokenized version is longer than the typed version.
3f26
3f26			LD   BC,($FD87)   ; Count of the number of characters in the tokenized version of the BASIC line until the error marker location.
3f2a
3f2a	L3F2A:  LD   HL,($FD8B)   ; Fetch the saved stack pointer.
3f2d			LD   SP,HL        ; Restore the stack pointer.
3f2e			SCF               ; Set the carry flag to indicate the error marker has been located.
3f2f			RET               ; Return back to the top level calling routine, to $2D04 (ROM 0).
3f30
3f30			;The error marker has not yet been reached
3f30
3f30	L3F30:  SCF               ; Set the carry flag to indicate error marker locating mode.
3f31			JR   L3F35        ; Jump ahead to continue.
3f33
3f33			;Tokenizing the BASIC line
3f33
3f33	L3F33:  SCF               ;
3f34			CCF               ; Reset carry flag to signal BASIC line tokenizing mode.
3f35
3f35	L3F35:  CALL L1F20        ; Use Normal RAM Configuration (physical RAM bank 0).
3f38
3f38			JR   NC,L3F47     ; Jump if tokenizing the BASIC line.
3f3a
3f3a			;Searching for the error marker so need to consider embedded floating point numbers
3f3a
3f3a			; [*BUG* - This should fetch the next character from the tokenized BASIC line and not the current character. This routine
3f3a			;          is called to process every visible character in the BASIC line, but is not called for embedded floating point numbers.
3f3a			;          It must therefore test whether the current character is followed by an embedded floating point number and if so to skip
3f3a			;          over it. The routine does make an attempt to detect embedded floating point numbers but incorrectly performs the test
3f3a			;          on the visible character and not the character that follows it. The bug can be fixed as replacing the LD A,(HL) instruction
3f3a			;          with the following instructions. Credit: Paul Farrow.
3f3a			;
3f3a			;       INC  HL           ; Advance to the next character in the tokenized BASIC line.
3f3a			;       LD   A,(HL)       ; Fetch the next character in the tokenized BASIC line.
3f3a			;       DEC  HL           ; Point back to the current character in the tokenized BASIC line.]
3f3a
3f3a			LD   A,(HL)       ; Fetch the current character in the tokenized BASIC line.
3f3b			EX   DE,HL        ; DE=Insert position within the tokenized BASIC line.
3f3c			CP   $0E          ; Is it the 'number' marker?
3f3e			JR   NZ,L3F5D     ; Jump ahead if not.
3f40
3f40			INC  DE           ; Skip over the 5 byte hidden number representation.
3f41			INC  DE           ; [*BUG* - There should be another INC DE instruction here to take into account the character that the tokenizer would
3f42			INC  DE           ; have inserted. As a result, the attempt to locate the error marker location will drift off by one byte for every numeric
3f43			INC  DE           ; literal within the BASIC statement, and if there are many numeric literals in the statement then the error marker location
3f44			INC  DE           ; may never be found before the end of the statement is parsed. Credit: Ian Collier (+3), Andrew Owen (128)]
3f45			JR   L3F5D        ; Jump ahead to continue.
3f47
3f47			;Come here if tokenizing the BASIC line
3f47
3f47	L3F47:  PUSH AF           ; Save the character to insert and the carry flag reset.
3f48
3f48			LD   BC,$0001     ; Request to insert 1 byte.
3f4b			PUSH HL           ;
3f4c			PUSH DE           ;
3f4d			CALL L3F66        ; Check that there is memory available for 1 byte,
3f50			POP  DE           ; automatically producing error '4' if not.
3f51			POP  HL           ;
3f52			RST  28H          ; BC=Number of bytes. HL=Address location before the position.
3f53			DEFW POINTERS     ; $1664. Update all system variables due to the insertion. Exit with DE pointing to old STKEND position, BC with number of bytes 'shifted'.
3f55			LD   HL,($5C65)   ; STKEND. Fetch the start of the spare memory.
3f58			EX   DE,HL        ; DE=Address of spare memory. HL=Address of character in the BASIC line.
3f59			LDDR              ; Shift up all affected bytes to make the room for the new character.
3f5b
3f5b			POP  AF           ; Retrieve the character to insert and the flags. The carry flag will be reset and hence will indicate that tokenizing the BASIC line is not complete.
3f5c			LD   (DE),A       ; Store the character in the BASIC line workspace.
3f5d
3f5d	L3F5D:  INC  DE           ; Advance to the next character in the BASIC line.
3f5e
3f5e			CALL L1F45        ; Use Workspace RAM configuration (physical RAM bank 7).
3f61
3f61			LD   ($FD82),DE   ; Store the address of the next insertion position within the BASIC line workspace.
3f65			RET               ;
3f66
3f66			; ------------------
3f66			; Room for BC Bytes?
3f66			; ------------------
3f66			; Test whether there is room for the specified number of bytes in the spare memory,
3f66			; producing error "4 Out of memory" if not.
3f66			; Entry: BC=Number of bytes required.
3f66			; Exit : Returns if the room requested room is available else an error '4' is produced.
3f66
3f66	L3F66:  LD   HL,($5C65)   ; STKEND.
3f69			ADD  HL,BC        ; Would adding the specified number of bytes overflow the RAM area?
3f6a			JR   C,L3F76      ; Jump to produce an error if so.
3f6c
3f6c			EX   DE,HL        ; DE=New end address.
3f6d			LD   HL,$0082     ; Would there be at least 130 bytes at the top of RAM?
3f70			ADD  HL,DE        ;
3f71			JR   C,L3F76      ; Jump to produce an error if not.
3f73
3f73			SBC  HL,SP        ; If the stack is lower in memory, would there still be enough room?
3f75			RET  C            ; Return if there would.
3f76
3f76	L3F76:  LD   A,$03        ;
3f78			LD   ($5C3A),A    ; ERR_NR. Signal error "4 Out of Memory".
3f7b			JP   L0321        ; Jump to error handler routine.
3f7e
3f7e			; ----------------
3f7e			; Identify Keyword
3f7e			; ----------------
3f7e			; This routine identifies the string within the Keyword Conversion Buffer and returns
3f7e			; the token character code. The last character of the string has bit 7 set.
3f7e			; The routine attempts to identify 48K mode keywords, 128K mode keywords and a number of
3f7e			; mis-spelled keywords (those that require a space within them).
3f7e			; Exit: Carry flag set if a keyword was identified.
3f7e			;       A=Token character code.
3f7e
3f7e	L3F7E:  CALL $FD2E        ; Attempt to identify 48K mode keyword.
3f81			RET  C            ; Return if keyword identified.
3f82
3f82			;Attempt to identify 128K mode keywords and mis-spelled keywords.
3f82
3f82			LD   B,$F9        ; Base character code (results in codes $F9-$FF).
3f84			LD   DE,$FD74     ; DE=Address of Keyword Conversion Buffer.
3f87			LD   HL,L3594     ; HL=Keywords string table.
3f8a			CALL $FD3B        ; Attempt to identify 128K mode/mis-spelled keyword.
3f8d			RET  NC           ; Return if no keyword identified.
3f8e
3f8e			;Attempt to convert mis-spelled keywords
3f8e
3f8e			CP   $FF          ; Was it "CLOSE#"?
3f90			JR   NZ,L3F96     ;
3f92
3f92			LD   A,$D4        ; Use character code for 'CLOSE #'.
3f94			JR   L3FB8        ; Jump ahead to continue.
3f96
3f96	L3F96:  CP   $FE          ; Was it "OPEN#"?
3f98			JR   NZ,L3F9E     ; Jump if not.
3f9a
3f9a			LD   A,$D3        ; Use character code for 'OPEN #'.
3f9c			JR   L3FB8        ; Jump ahead to continue.
3f9e
3f9e	L3F9E:  CP   $FD          ; Was it "DEFFN"?
3fa0			JR   NZ,L3FA6     ; Jump if not.
3fa2
3fa2			LD   A,$CE        ; Use character code for 'DEF FN'.
3fa4			JR   L3FB8        ; Jump ahead to continue.
3fa6
3fa6	L3FA6:  CP   $FC          ; Was it "GOSUB"?
3fa8			JR   NZ,L3FAE     ; Jump if not.
3faa
3faa			LD   A,$ED        ; Use character code for 'GO SUB'.
3fac			JR   L3FB8        ; Jump ahead to continue.
3fae
3fae	L3FAE:  CP   $FB          ; Was it "GOTO"?
3fb0			JR   NZ,L3FB6     ; Jump if not.
3fb2
3fb2			LD   A,$EC        ; Use character code for 'GO TO'.
3fb4			JR   L3FB8        ; Jump ahead to continue.
3fb6
3fb6	L3FB6:  SUB  $56          ; Reduce to $A3 for 'SPECTRUM' and $A4 for 'PLAY'.
3fb8
3fb8	L3FB8:  SCF               ; Signal keyword identified.
3fb9			RET               ;
3fba
3fba			; ---------------
3fba			; Copy Data Block
3fba			; ---------------
3fba			; This routine is used on 8 occasions to copy a block of default data.
3fba			; Entry: DE=Destination address.
3fba			;        HL=Address of source data table, which starts with the number of bytes to copy
3fba			;           followed by the bytes themselves.
3fba
3fba	L3FBA:  LD   B,(HL)       ; Get number of bytes to copy.
3fbb			INC  HL           ; Point to the first byte to copy.
3fbc
3fbc	L3FBC:  LD   A,(HL)       ; Fetch the byte from the source
3fbd			LD   (DE),A       ; and copy it to the destination.
3fbe			INC  DE           ; Increment destination address.
3fbf			INC  HL           ; Increment source address.
3fc0			DJNZ L3FBC        ; Repeat for all bytes.
3fc2
3fc2			RET               ;
3fc3
3fc3			; -------------------------------------
3fc3			; Get Numeric Value for ASCII Character
3fc3			; -------------------------------------
3fc3			; Exit: Carry flag set if character was numeric and A holding value.
3fc3			;
3fc3			; [Never called by this ROM]
3fc3
3fc3	L3FC3:  CP   '0'          ; $30. Test against '0'.
3fc5			CCF               ;
3fc6			RET  NC           ; Return with carry flag reset if not numeric character.
3fc7
3fc7			CP   ':'          ; $3A. Test against ':'.
3fc9			RET  NC           ; Return with carry flag reset if not numeric character.
3fca
3fca			SUB  '0'          ; $30. Get numeric value.
3fcc			SCF               ; Return with carry flag set to indicate a numeric character.
3fcd			RET               ;
3fce
3fce			; ---------------------------
3fce			; Call Action Handler Routine
3fce			; ---------------------------
3fce			; If the code in A matches an entry in the table pointed to by HL
3fce			; then execute the action specified by the entry's routine address.
3fce			; Entry: A=Code.
3fce			;        HL=Address of action table.
3fce			; Exit : Zero flag reset if no match found.
3fce			;        Carry flag reset if an error beep is required, or to signal no suitable action handler found.
3fce			;        HL=Address of next table entry if a match was found.
3fce
3fce	L3FCE:  PUSH BC           ; Save registers.
3fcf			PUSH DE           ;
3fd0
3fd0			LD   B,(HL)       ; Fetch number of table entries.
3fd1			INC  HL           ; Point to first entry.
3fd2
3fd2	L3FD2:  CP   (HL)         ; Possible match for A?
3fd3			INC  HL           ;
3fd4			LD   E,(HL)       ;
3fd5			INC  HL           ;
3fd6			LD   D,(HL)       ; DE=Address to call if a match.
3fd7			JR   Z,L3FE1      ; Jump if a match.
3fd9
3fd9			INC  HL           ; Next table entry.
3fda			DJNZ L3FD2        ; Repeat for next table entry.
3fdc
3fdc			;No match found
3fdc
3fdc			SCF               ; Return with carry flag reset to signal an error beep is required
3fdd			CCF               ; and with the zero flag reset to signal a match was not found.
3fde
3fde			POP  DE           ; Restore registers.
3fdf			POP  BC           ;
3fe0			RET               ;
3fe1
3fe1			;Found a match
3fe1
3fe1	L3FE1:  EX   DE,HL        ; HL=Action routine to call.
3fe2
3fe2			POP  DE           ;
3fe3			POP  BC           ;
3fe4
3fe4			CALL L3FEE        ; Indirectly call the action handler routine.
3fe7			JR   C,L3FEB      ; Jump if no error beep is required.
3fe9
3fe9			CP   A            ; Set zero flag to indicate a match was found.
3fea			RET               ; Exit with carry flag reset to indicate error beep required.
3feb
3feb	L3FEB:  CP   A            ; Set zero flag to indicate a match was found.
3fec			SCF               ; Signal no error beep required.
3fed			RET               ;
3fee
3fee	L3FEE:  JP   (HL)         ; Jump to the action handler routine.
3fef
3fef
3fef			; =====================
3fef			; PROGRAMMERS' INITIALS
3fef			; =====================
3fef			; [Provided by Andrew Owen]
3fef
3fef	L3FEF:  DEFB $00
3ff0			DEFM "MB"        ; Martin Brennan.
3ff2			DEFB $00
3ff3			DEFM "SB"        ; Steve Berry.
3ff5			DEFB $00
3ff6			DEFM "AC"        ; Andrew Cummins.
3ff8			DEFB $00
3ff9			DEFM "RG"        ; Rupert Goodwins.
3ffb			DEFB $00
3ffc			DEFM "KM"        ; Kevin Males.
3ffe			DEFB $00
3fff
3fff
3fff			; =================
3fff			; END OF ROM MARKER
3fff			; =================
3fff
3fff	L3FFF:  DEFB $01         ;
4000
4000			END




 			; ==============================

			; REFERENCE INFORMATION - PART 2

			; ==============================



			; ==================================

			; Routines Copied/Constructed in RAM

			; ==================================



			; --------------------------------

			; Construct Keyword Representation

			; --------------------------------

			; This routine copies a keyword string from ROM 1 into the BASIC Line Construction Buffer,

			; terminating it with an 'end of BASIC line' marker (code $80+' '). Only standard Spectrum

			; keywords are handled by this routine (SPECTRUM and PLAY are processed elsewhere).

			; The routine is run from RAM bank 7 at $FCAE so that access to both ROMs is available.

			; Depending on the value of A (which should be the ASCII code less $A5,

			; e.g. 'RND', the first (48K) keyword, has A=0), a different index into the

			; token table is taken. This is to allow speedier lookup since there are never more

			; than 15 keywords to advance through.

			; Entry: A=Keyword character code-$A5 (range $00-$5A).

			;        DE=Insertion address within BASIC Line Construction Buffer.

			;

			; Copied to physical RAM bank 7 at $FCAE-$FCFC by routine at $335F (ROM 0).

			;

			;$FCAE  DI                ; Disable interrupts whilst paging.

			;

			;       LD   BC,$7FFD     ;

			;       LD   D,$17        ; Page in ROM 1, SCREEN 0, no locking, RAM bank 7.

			;       OUT  (C),D        ;

			;

			;       CP   $50          ; Was the token $F5 or above?

			;       JR   NC,$FCEB     ;

			;

			;       CP   $40          ; Was the token $E5 or above?

			;       JR   NC,$FCE4     ;

			;

			;       CP   $30          ; Was the token $D5 or above?

			;       JR   NC,$FCDD     ;

			;

			;       CP   $20          ; Was the token $C5 or above?

			;       JR   NC,$FCD6     ;

			;

			;       CP   $10          ; Was the token $B5 or above?

			;       JR   NC,$FCCF     ;

			;

			;Used for token range $A5-$B4 ($00 <= A <= $0F)

			;

			;       LD   HL,$0096     ; Token table entry 'RND' in ROM 1.

			;       JR   $FCF0        ;

			;

			;Used for token range $B5-$C4 ($10 <= A <= $1F)

			;

			;$FCCF  SUB  $10          ;

			;       LD   HL,$00CF     ; Token table entry 'ASN' in ROM 1.

			;       JR   $FCF0        ;

			;

			;Used for token range $C5-$D4 ($20 <= A <= $2F)

			;

			;$FCD6  SUB  $20          ;

			;       LD   HL,$0100     ; Token table entry 'OR' in ROM 1.

			;       JR   $FCF0        ;

			;

			;Used for token range $D5-$E4 ($30 <= A <= $3F)

			;

			;$FCDD  SUB  $30          ;

			;       LD   HL,$013E     ; Token table entry 'MERGE' in ROM 1.

			;       JR   $FCF0        ;

			;

			;Used for token range $E5-$F4 ($40 <= A <= $4F)

			;

			;$FCE4  SUB  $40          ;

			;       LD   HL,$018B     ; Token table entry 'RESTORE' in ROM 1.

			;       JR   $FCF0        ;

			;

			;Used for token range $F5-$FF (A >= $50)

			;

			;$FCEB  SUB  $50          ;

			;       LD   HL,$01D4     ; Token table entry 'PRINT' in ROM 1.

			;

			;$FCF0  LD   B,A          ; Take a copy of the index value.

			;       OR   A            ; If A=0 then already have the entry address.

			;

			;$FCF2  JR   Z,$FCFD      ; If indexed item found then jump ahead to copy the characters of the token.

			;

			;$FCF4  LD   A,(HL)       ; Fetch a character.

			;       INC  HL           ; Point to next character.

			;       AND  $80          ; Has end of token marker been found?

			;       JR   Z,$FCF4      ; Loop back for next character if not.

			;

			;       DEC  B            ; Count down the index of the required token.

			;$FCFC  JR   $FCF2        ; Jump back to test whether the required token has been reached.



			; -----------------------

			; Copy Keyword Characters

			; -----------------------

			; This routine copies a keyword string from ROM 1 into the BASIC Line Construction Buffer,

			; terminating it with an 'end of BASIC line' marker (code $80+' ').

			; The routine is run from RAM bank 7 so that access to both ROMs is available.

			; Entry: HL=Address of keyword string in ROM 1.

			;        DE=Insertion address within BASIC Line Construction Buffer.

			;

			; Copied to physical RAM bank 7 at $FCFD-$FD2D by subroutine at $335F (ROM 0).

			;

			;$FCFD  LD   DE,$FCA3     ; DE=Keyword Construction Buffer.

			;       LD   ($FCA1),DE   ; Store the start address of the constructed keyword.

			;

			;       LD   A,($FC9E)    ; Print a leading space?

			;       OR   A            ;

			;       LD   A,$00        ;

			;       LD   ($FC9E),A    ; Signal leading space not required.

			;       JR   NZ,$FD13     ; Jump if leading space not required.

			;

			;       LD   A,$20        ; Print a leading space.

			;       LD   (DE),A       ; Insert a leading space.

			;       INC  DE           ; Advance to next buffer position.

			;

			;$FD13  LD   A,(HL)       ; Fetch a character of the keyword.

			;       LD   B,A          ; Store it.

			;       INC  HL           ; Advance to next keyword character.

			;       LD   (DE),A       ; Store the keyword character in the BASIC line buffer.

			;       INC  DE           ; Advance to the next buffer position.

			;       AND  $80          ; Test if the end of the keyword string.

			;       JR   Z,$FD13      ; Jump back if not to repeat for all characters of the keyword.

			;

			;       LD   A,B          ; Get keyword character back.

			;       AND  $7F          ; Mask of bit 7 which indicates the end of string marker.

			;       DEC  DE           ; Point back at the last character of the keyword copied into the buffer

			;       LD   (DE),A       ; and store it.

			;

			;       INC  DE           ; Advance to the position in the buffer after the last character of the keyword.

			;       LD   A,$80+' '    ; $A0. ' ' + end marker

			;       LD   (DE),A       ; Store an 'end of BASIC line so far' marker.

			;

			;       LD   A,$07        ;

			;       LD   BC,$7FFD     ;

			;       OUT  (C),A        ; Page in ROM 0, SCREEN 0, no locking, RAM bank 7.

			;       EI                ; Re-enable interrupts.

			;$FD2D  RET               ;



			; --------------

			; Identify Token

			; --------------

			; This routine identifies the string within the Keyword Conversion Buffer and returns

			; the character code. The last character of the string to identify has bit 7 set.

			; Exit: Carry flag set if token identified.

			;       B=Character code.

			;

			; Copied to physical RAM bank 7 at $FD2E-$FD69 by subroutine at $335F (ROM 0).

			;

			;$FD2E  DI                ; Disable interrupts whilst paging.

			;       LD   BC,$7FFD     ;

			;       LD   D,$17        ; Select ROM 1, SCREEN 0, RAM bank 7.

			;       OUT  (C),D        ;

			;

			;       LD   HL,$0096     ; Address of token table in ROM 1.

			;       LD   B,$A5        ; Character code of the first token - 'RND'.

			;

			;Entry point here used to match 128K mode tokens and mis-spelled tokens

			;

			;$FD3B  LD   DE,$FD74     ; Keyword Conversion Buffer holds the text to match against.

			;

			;$FD3E  LD   A,(DE)       ; Fetch a character from the buffer.

			;       AND  $7F          ; Mask off terminator bit.

			;       CP   $61          ; Is it lowercase?

			;       LD   A,(DE)       ; Fetch the character again from the buffer.

			;       JR   C,$FD48      ; Jump if uppercase.

			;

			;       AND  $DF          ; Make the character uppercase.

			;

			;$FD48  CP   (HL)         ; Does the character match the current item in the token table?

			;       JR   NZ,$FD54     ; Jump if it does not.

			;

			;       INC  HL           ; Point to the next character in the buffer.

			;       INC  DE           ; Point to the next character in the token table.

			;       AND  $80          ; Has the terminator been reached?

			;       JR   Z,$FD3E      ; Jump back if not to test the next character in the token.

			;

			;A match was found

			;

			;       SCF               ; Signal a match was found.

			;       JR   $FD60        ; Jump ahead to continue.

			;

			;$FD54  INC  B            ; The next character code to test against.

			;       JR   Z,$FD5F      ; Jump if all character codes tested.

			;

			;The token does not match so skip to the next entry in the token table

			;

			;$FD57  LD   A,(HL)       ; Fetch the character from the token table.

			;       AND  $80          ; Has the end terminator been found?

			;       INC  HL           ; Point to the next character.

			;       JR   Z,$FD57      ; Jump back if no terminator found.

			;

			;       JR   $FD3B        ; Jump back to test against the next token.

			;

			;All character codes tested and no match found

			;

			;$FD5F  OR   A            ; Clear the carry flag to indicate no match found.

			;

			;The common exit point

			;

			;$FD60  LD   A,B          ; Fetch the character code of the matching token ($00 for no match).

			;

			;       LD   D,$07        ; Select ROM 0, SCREEN 0, RAM bank 7.

			;       LD   BC,$7FFD     ;

			;       OUT  (C),D        ;

			;       EI                ; Re-enable interrupts.

			;$FD69  RET               ;



			; ----------------------------------

			; Insert Character into Display File

			; ----------------------------------

			; Copy a character into the display file.

			; Entry: HL=Character data.

			;        DE=Display file address.

			; This routine is constructed from three segments and stitched together in physical RAM bank 7 to form a single routine.

			;

			; Created in physical RAM Bank 7 at $FF28-$FF60 by routine at $246F (ROM 0). [Construction routine never actually called by the ROM]

			;

			;$FF28  PUSH BC           ; Save BC

			;

			;       DI                ; Disable interrupts whilst paging.

			;

			;       LD   BC,$7FFD     ;

			;       LD   A,(BANK_M)   ; $5B5C. Fetch current paging configuration.

			;       XOR  $10          ; Toggle ROMs.

			;       OUT  (C),A        ; Perform paging.

			;       EI                ; Re-enable interrupts.

			;       EX   AF,AF'       ; Save the new configuration in A'.

			;

			;       LD   C,D          ; Save D.

			;

			;       LD   A,(HL)       ;

			;       LD   (DE),A       ; Copy byte 1.

			;

			;       INC  HL           ;

			;       INC  D            ;

			;       LD   A,(HL)       ;

			;       LD   (DE),A       ; Copy byte 2.

			;

			;       INC  HL           ;

			;       INC  D            ;

			;       LD   A,(HL)       ;

			;       LD   (DE),A       ; Copy byte 3.

			;

			;       INC  HL           ;

			;       INC  D            ;

			;       LD   A,(HL)       ;

			;       LD   (DE),A       ; Copy byte 4.

			;

			;       INC  HL           ;

			;       INC  D            ;

			;       LD   A,(HL)       ;

			;       LD   (DE),A       ; Copy byte 5.

			;

			;       INC  HL           ;

			;       INC  D            ;

			;       LD   A,(HL)       ;

			;       LD   (DE),A       ; Copy byte 6.

			;

			;       INC  HL           ;

			;       INC  D            ;

			;       LD   A,(HL)       ;

			;       LD   (DE),A       ; Copy byte 7.

			;

			;       INC  HL           ;

			;       INC  D            ;

			;       LD   A,(HL)       ;

			;       LD   (DE),A       ; Copy byte 8.

			;

			;       LD   D,C          ; Restore D.

			;

			;       EX   AF,AF'       ; Retrieve current paging configuration.

			;       DI                ; Disable interrupts whilst paging.

			;       LD   C,$FD        ; Restore Paging I/O port number.

			;       XOR  $10          ; Toggle ROMs.

			;       OUT  (C),A        ; Perform paging.

			;       EI                ; Re-enable interrupts.

			;

			;       POP  BC           ; Restore BC.

			;$FF60  RET               ;





			; ===========================

			; Standard Error Report Codes

			; ===========================



			; 0 - OK                      Successful completion, or jump to a line number bigger than any existing.

			; 1 - NEXT without FOR        The control variable does not exist (it has not been set up by a FOR statement),

			;                             but there is an ordinary variable with the same name.

			; 2 - Variable not found      For a simple variable, this will happen if the variable is used before it has been assigned

			;                             to by a LET, READ or INPUT statement, loaded from disk (or tape), or set up in a FOR statement.

			;                             For a subscripted variable, it will happen if the variable is used before it has been

			;                             dimensioned in a DIM statement, or loaded from disk (or tape).

			; 3 - Subscript wrong         A subscript is beyond the dimension of the array or there are the wrong number of subscripts.

			; 4 - Out of memory           There is not enough room in the computer for what you are trying to do.

			; 5 - Out of screen           An INPUT statement has tried to generate more than 23 lines in the lower half of the screen.

			;                             Also occurs with 'PRINT AT 22,xx'.

			; 6 - Number too big          Calculations have yielded a number greater than approximately 10^38.

			; 7 - RETURN without GO SUB   There has been one more RETURN than there were GO SUBs.

			; 8 - End of file             Input returned unacceptable character code.

			; 9 - STOP statement          After this, CONTINUE will not repeat the STOP but carries on with the statement after.

			; A - Invalid argument        The argument for a function is unsuitable.

			; B - Integer out of range    When an integer is required, the floating point argument is rounded to the nearest integer.

			;                             If this is outside a suitable range, then this error results.

			; C - Nonsense in BASIC       The text of the (string) argument does not form a valid expression.

			; D - BREAK - CONT repeats    BREAK was pressed during some peripheral operation.

			; E - Out of DATA             You have tried to READ past the end of the DATA list.

			; F - Invalid file name       SAVE with filename empty or longer than 10 characters.

			; G - No room for line        There is not enough room left in memory to accommodate the new program line.

			; H - STOP in INPUT           Some INPUT data started with STOP.

			; I - FOR without NEXT        A FOR loop was to be executed no times (e.g. FOR n=1 TO 0) and corresponding NEXT statement could not be found.

			; J - Invalid I/O device      Attempting to input characters from or output characters to a device that doesn't support it.

			; K - Invalid colour          The number specified is not an appropriate value.

			; L - BREAK into program      BREAK pressed. This is detected between two statements.

			; M - RAMTOP no good          The number specified for RAMTOP is either too big or too small.

			; N - Statement lost          Jump to a statement that no longer exists.

			; O - Invalid Stream          Trying to input from or output to a stream that isn't open or that is out of range (0...15),

			;                             or trying to open a stream that is out of range.

			; P - FN without DEF          User-defined function used without a corresponding DEF in the program.

			; Q - Parameter error         Wrong number of arguments, or one of them is the wrong type.

			; R - Tape loading error      A file on tape was found but for some reason could not be read in, or would not verify.





			; =========================

			; Standard System Variables

			; =========================

			; These occupy addresses $5C00-$5CB5.

			;

			; KSTATE   $5C00   8   IY-$3A   Used in reading the keyboard.

			; LASTK    $5C08   1   IY-$32   Stores newly pressed key.

			; REPDEL   $5C09   1   IY-$31   Time (in 50ths of a second) that a key must be held down before it repeats. This starts off at 35.

			; REPPER   $5C0A   1   IY-$30   Delay (in 50ths of a second) between successive repeats of a key held down - initially 5.

			; DEFADD   $5C0B   2   IY-$2F   Address of arguments of user defined function (if one is being evaluated), otherwise 0.

			; K_DATA   $5C0D   1   IY-$2D   Stores second byte of colour controls entered from keyboard.

			; TVDATA   $5C0E   2   IY-$2C   Stores bytes of colour, AT and TAB controls going to TV.

			; STRMS    $5C10  38   IY-$2A   Addresses of channels attached to streams.

			; CHARS    $5C36   2   IY-$04   256 less than address of character set, which starts with ' ' and carries on to '(c)'.

			; RASP     $5C38   1   IY-$02   Length of warning buzz.

			; PIP      $5C39   1   IY-$01   Length of keyboard click.

			; ERR_NR   $5C3A   1   IY+$00   1 less than the report code. Starts off at 255 (for -1) so 'PEEK 23610' gives 255.

			; FLAGS    $5C3B   1   IY+$01   Various flags to control the BASIC system:

			;                                 Bit 0: 1=Suppress leading space.

			;                                 Bit 1: 1=Using printer, 0=Using screen.

			;                                 Bit 2: 1=Print in L-Mode, 0=Print in K-Mode.

			;                                 Bit 3: 1=L-Mode, 0=K-Mode.

			;                                 Bit 4: 1=128K Mode, 0=48K Mode. [Always 0 on 48K Spectrum]

			;                                 Bit 5: 1=New key press code available in LAST_K.

			;                                 Bit 6: 1=Numeric variable, 0=String variable.

			;                                 Bit 7: 1=Line execution, 0=Syntax checking.

			; TVFLAG   $5C3C   1   IY+$02   Flags associated with the TV:

			;                                 Bit 0  : 1=Using lower editing area, 0=Using main screen.

			;                                 Bit 1-2: Not used (always 0).

			;                                 Bit 3  : 1=Mode might have changed.

			;                                 Bit 4  : 1=Automatic listing in main screen, 0=Ordinary listing in main screen.

			;                                 Bit 5  : 1=Lower screen requires clearing after a key press.

			;                                 Bit 6  : 1=Tape Loader option selected (set but never tested). [Always 0 on 48K Spectrum]

			;                                 Bit 7  : Not used (always 0).

			; ERR_SP   $5C3D   2   IY+$03   Address of item on machine stack to be used as error return.

			; LISTSP   $5C3F   2   IY+$05   Address of return address from automatic listing.

			; MODE     $5C41   1   IY+$07   Specifies cursor type:

			;                                 $00='L' or 'C'.

			;                                 $01='E'.

			;                                 $02='G'.

			;                                 $04='K'.

			; NEWPPC   $5C42   2   IY+$08   Line to be jumped to.

			; NSPPC    $5C44   1   IY+$0A   Statement number in line to be jumped to.

			; PPC      $5C45   2   IY+$0B   Line number of statement currently being executed.

			; SUBPPC   $5C47   1   IY+$0D   Number within line of statement currently being executed.

			; BORDCR   $5C48   1   IY+$0E   Border colour multiplied by 8; also contains the attributes normally used for the lower half

			;                               of the screen.

			; E_PPC    $5C49   2   IY+$0F   Number of current line (with program cursor).

			; VARS     $5C4B   2   IY+$11   Address of variables.

			; DEST     $5C4D   2   IY+$13   Address of variable in assignment.

			; CHANS    $5C4F   2   IY+$15   Address of channel data.

			; CURCHL   $5C51   2   IY+$17   Address of information currently being used for input and output.

			; PROG     $5C53   2   IY+$19   Address of BASIC program.

			; NXTLIN   $5C55   2   IY+$1B   Address of next line in program.

			; DATADD   $5C57   2   IY+$1D   Address of terminator of last DATA item.

			; E_LINE   $5C59   2   IY+$1F   Address of command being typed in.

			; K_CUR    $5C5B   2   IY+$21   Address of cursor.

			; CH_ADD   $5C5D   2   IY+$23   Address of the next character to be interpreted - the character after the argument of PEEK,

			;                               or the NEWLINE at the end of a POKE statement.

			; X_PTR    $5C5F   2   IY+$25   Address of the character after the '?' marker.

			; WORKSP   $5C61   2   IY+$27   Address of temporary work space.

			; STKBOT   $5C63   2   IY+$29   Address of bottom of calculator stack.

			; STKEND   $5C65   2   IY+$2B   Address of start of spare space.

			; BREG     $5C67   1   IY+$2D   Calculator's B register.

			; MEM      $5C68   2   IY+$2E   Address of area used for calculator's memory (usually MEMBOT, but not always).

			; FLAGS2   $5C6A   1   IY+$30   Flags:

			;                                 Bit 0  : 1=Screen requires clearing.

			;                                 Bit 1  : 1=Printer buffer contains data.

			;                                 Bit 2  : 1=In quotes.

			;                                 Bit 3  : 1=CAPS LOCK on.

			;                                 Bit 4  : 1=Using channel 'K'.

			;                                 Bit 5-7: Not used (always 0).

			; DF_SZ    $5C6B   1   IY+$31   The number of lines (including one blank line) in the lower part of the screen.

			; S_TOP    $5C6C   2   IY+$32   The number of the top program line in automatic listings.

			; OLDPPC   $5C6E   2   IY+$34   Line number to which CONTINUE jumps.

			; OSPPC    $5C70   1   IY+$36   Number within line of statement to which CONTINUE jumps.

			; FLAGX    $5C71   1   IY+$37   Flags:

			;                                 Bit 0  : 1=Simple string complete so delete old copy.

			;                                 Bit 1  : 1=Indicates new variable, 0=Variable exists.

			;                                 Bit 2-4: Not used (always 0).

			;                                 Bit 5  : 1=INPUT mode.

			;                                 Bit 6  : 1=Numeric variable, 0=String variable. Holds nature of existing variable.

			;                                 Bit 7  : 1=Using INPUT LINE.

			; STRLEN   $5C72   2   IY+$38   Length of string type destination in assignment.

			; T_ADDR   $5C74   2   IY+$3A   Address of next item in syntax table.

			; SEED     $5C76   2   IY+$3C   The seed for RND. Set by RANDOMIZE.

			; FRAMES   $5C78   3   IY+$3E   3 byte (least significant byte first), frame counter incremented every 20ms.

			; UDG      $5C7B   2   IY+$41   Address of first user-defined graphic. Can be changed to save space by having fewer

			;                               user-defined characters.

			; COORDS   $5C7D   1   IY+$43   X-coordinate of last point plotted.

			;          $5C7E   1   IY+$44   Y-coordinate of last point plotted.

			; P_POSN   $5C7F   1   IY+$45   33-column number of printer position.

			; PR_CC    $5C80   2   IY+$46   Full address of next position for LPRINT to print at (in ZX Printer buffer).

			;                               Legal values $5B00 - $5B1F. [Not used in 128K mode]

			; ECHO_E   $5C82   2   IY+$48   33-column number and 24-line number (in lower half) of end of input buffer.

			; DF_CC    $5C84   2   IY+$4A   Address in display file of PRINT position.

			; DF_CCL   $5C86   2   IY+$4C   Like DF CC for lower part of screen.

			; S_POSN   $5C88   1   IY+$4E   33-column number for PRINT position.

			;          $5C89   1   IY+$4F   24-line number for PRINT position.

			; SPOSNL   $5C8A   2   IY+$50   Like S_POSN for lower part.

			; SCR_CT   $5C8C   1   IY+$52   Counts scrolls - it is always 1 more than the number of scrolls that will be done before

			;                               stopping with 'scroll?'.

			; ATTR_P   $5C8D   1   IY+$53   Permanent current colours, etc, as set up by colour statements.

			; MASK_P   $5C8E   1   IY+$54   Used for transparent colours, etc. Any bit that is 1 shows that the corresponding attribute

			;                               bit is taken not from ATTR_P, but from what is already on the screen.

			; ATTR_T   $5C8F   1   IY+$55   Temporary current colours (as set up by colour items).

			; MASK_T   $5C90   1   IY+$56   Like MASK_P, but temporary.

			; P_FLAG   $5C91   1   IY+$57   Flags:

			;                                 Bit 0: 1=OVER 1, 0=OVER 0.

			;                                 Bit 1: Not used (always 0).

			;                                 Bit 2: 1=INVERSE 1, 0=INVERSE 0.

			;                                 Bit 3: Not used (always 0).

			;                                 Bit 4: 1=Using INK 9.

			;                                 Bit 5: Not used (always 0).

			;                                 Bit 6: 1=Using PAPER 9.

			;                                 Bit 7: Not used (always 0).

			; MEMBOT   $5C92  30   IY+$58   Calculator's memory area - used to store numbers that cannot conveniently be put on the

			;                               calculator stack.

			;          $5CB0   2   IY+$76   Not used on standard Spectrum. [Used by ZX Interface 1 Edition 2 for printer WIDTH]

			; RAMTOP   $5CB2   2   IY+$78   Address of last byte of BASIC system area.

			; P_RAMT   $5CB4   2   IY+$7A   Address of last byte of physical RAM.





			; ==========

			; Memory Map

			; ==========

			; The conventional memory is used as follows:

			;

			; +---------+-----------+------------+--------------+-------------+--

			; | BASIC   |  Display  | Attributes |  New System  |   System    |

			; |  ROM    |   File    |    File    |  Variables   |  Variables  |

			; +---------+-----------+------------+--------------+-------------+--

			; ^         ^           ^            ^              ^             ^

			; $0000   $4000       $5800        $5B00          $5C00         $5CB6 = CHANS

			;

			;

			;  --+----------+---+---------+-----------+---+------------+--+---+--

			;    | Channel  |$80|  BASIC  | Variables |$80| Edit Line  |NL|$80|

			;    |   Info   |   | Program |   Area    |   | or Command |  |   |

			;  --+----------+---+---------+-----------+---+------------+--+---+--

			;    ^              ^         ^               ^                   ^

			;  CHANS           PROG      VARS           E_LINE              WORKSP

			;

			;

			;                             ------>         <-------  <------

			;  --+-------+--+------------+-------+-------+---------+-------+-+---+------+

			;    | INPUT |NL| Temporary  | Calc. | Spare | Machine | GOSUB |?|$3E| UDGs |

			;    | data  |  | Work Space | Stack |       |  Stack  | Stack | |   |      |

			;  --+-------+--+------------+-------+-------+---------+-------+-+---+------+

			;    ^                       ^       ^       ^                   ^   ^      ^

			;  WORKSP                  STKBOT  STKEND   SP               RAMTOP UDG  P_RAMT





			; ==========

			; I Register

			; ==========

			; The I register is used along with the R register by the Z80 for automatic memory refreshing. Setting the I register to a value between $40 and $7F

			; causes memory refreshes to occur to the lower 16K RAM. This RAM is contended with the ULA which uses it for the generation of the video display.

			; The memory refreshes get interpreted by the ULA as the CPU requesting to access the lower 16K RAM bank very rapidly and very often. The ULA is not

			; able to handle reads at such a high frequency, with the consequence that it fails to fetch and output the next screen byte. Instead it uses re-uses

			; the byte previously read. This causes a visible corruption to the video display output, often referred to a 'snow', although no actual corruption

			; occurs to the video display RAM. This also happens when the I register is set to a value between $C0 and $FF when a contended RAM bank is paged in

			; and, unlike the Spectrum 16K/48K, can lead to a machine crash.





			; ===================

			; Screen File Formats

			; ===================

			; The two screens available on the Spectrum 128, the normal screen in RAM bank 5 ($4000-$5AFF) and the shadow screen in

			; RAM bank 7 ($C000-$FFFF), both use the same file format.

			;

			; ------------

			; Display File

			; ------------

			; The display file consists of 3 areas, each consisting of 8 characters rows, with each row consisting of 8 pixel lines.

			; Each pixel line consists of 32 cell columns, with each cell consisting of a byte that represents 8 pixels.

			;

			; The address of a particular cell is formed as follows:

			;

			;      +---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+

			;      | s | 1 | 0 | a | a | l | l | l |  | r | r | r | c | c | c | c | c |

			;      +---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+

			; Bit:  15  14  13  12  11  10   9   8      7   6   5   4   3   2   1   0

			;

			; where: s     = Screen (0-1: 0=Normal screen, 1=Shadow Screen)

			;        aa    = Area   (0-2)

			;        rrr   = Row    (0-7)

			;        lll   = Line   (0-7)

			;        ccccc = Column (0-31)

			;

			; An area value of 3 denotes the attributes file, which consists of a different format.

			;

			; ---------------

			; Attributes File

			; ---------------

			; The attributes file consists of 24 characters rows, with each row consisting of 32 cell columns.

			; Each cell consisting of a byte that holds the colour information.

			;

			; The address of a particular cell is formed as follows:

			;

			;      +---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+

			;      | s | 1 | 0 | 1 | 1 | 0 | r | r |  | r | r | r | c | c | c | c | c |

			;      +---+---+---+---+---+---+---+---+  +---+---+---+---+---+---+---+---+

			; Bit:  15  14  13  12  11  10   9   8      7   6   5   4   3   2   1   0

			;

			; where: s     = Screen (0-1: 0=Normal screen, 1=Shadow Screen)

			;        rrrrr = Row    (0-23)

			;        ccccc = Column (0-31)

			;

			;

			; Each cell holds a byte of colour information:

			;

			;      +---+---+---+---+---+---+---+---+

			;      | f | b | p | p | p | i | i | i |

			;      +---+---+---+---+---+---+---+---+

			; Bit:   7   6   5   4   3   2   1   0

			;

			; where: f   = Flash  (0-1: 0=Off, 1=On)

			;        b   = Bright (0-1: 0=Off, 1=On)

			;        ppp = Paper  (0-7: 0=Black, 1=Blue, 2=Red, 3=Magenta, 4=Green, 5=Cyan, 6=Yellow, 7=White)

			;        iii = Ink    (0-7: 0=Black, 1=Blue, 2=Red, 3=Magenta, 4=Green, 5=Cyan, 6=Yellow, 7=White)

			;

			; -----------------------------------------------------------

			; Address Conversion Between Display File and Attributes File

			; -----------------------------------------------------------

			; The address of the attribute cell corresponding to an address in the display file can be constructed by moving bits 11 to 12 (the area value)

			; to bit positions 8 to 9, setting bit 10 to 0 and setting bits 11 to 12 to 1.

			;

			; The address of the display file character cell corresponding to an address in the attributes file can be constructed by moving bits 8 to 9 (the row value)

			; to bit positions 11 to 12, and then setting bits 8 to 9 to 0.





			; ==================

			; Standard I/O Ports

			; ==================



			; --------

			; Port $FE

			; --------

			; This controls the cassette interface, the speaker, the border colour and is used to read the keyboard.

			; Since it is the ULA that controls these facilities, it will introduce a delay when accessing the port if

			; it is busy at the time, and hence I/O port $FE is subject to contention.

			;

			; OUTPUT:

			;

			; Bit 0-2: Border colour  (0=Black, 1=Blue, 2=Red, 3=Magenta, 4=Green, 5=Cyan, 6=Yellow, 7=White).

			; Bit 3  : MIC output     (1=Off, 0=On).

			; Bit 4  : Speaker output (1=On, 0=Off).

			; Bit 5-7: Not used.

			;

			; INPUT:

			;

			; Upper byte selects keyboard row to read.

			;

			;          Bit0  Bit1  Bit2  Bit3  Bit4    Bit4  Bit3  Bit2  Bit1  Bit0

			;          ----  ----  ----  ----  ----    ----  ----  ----  ----  ----

			; $F7FE =    1     2     3     4     5       6     7     8     9     0   = $EFFE

			; $FBFE =    Q     W     E     R     T       Y     U     I     O     P   = $DFFE

			; $FDFE =    A     S     D     F     G       H     J     K     L   ENTER = $BFFE

			; $FEFE =  SHIFT   Z     X     C     V       B     N     M    SYM  SPACE = $7FFE

			;

			; Bit 0-4 : Key states (corresponding bit is 0 if the key is pressed).

			; Bit 5   : Not used (always 1).

			; Bit 6   : EAR input.

			; Bit 7   : Not used (always 1).





			; ======================

			; Cassette Header Format

			; ======================

			;

			; A file consists of a header block followed by a data block. Each block begins with a flag that

			; indicates whether it is a header block or a data block. Next are the header or data bytes,

			; and finally a checksum of the flag and header/data bytes.

			;

			; Flag     - A value of $00 for a header and $FF for a data block.

			; Bytes    - The bytes forming the header information or the file data.

			; Checksum - An XOR checksum of the Flag and Bytes fields.

			;

			; The header information consists of 17 bytes and these describe the size and type of data that the

			; data block contains.

			;

			; The header bytes have the following meaning:

			;   Byte  $00    : File type - $00=Program, $01=Numeric array, $02=Character array, $03=Code/Screen$.

			;   Bytes $01-$0A: File name, padding with trailing spaces.

			;   Bytes $0B-$0C: Length of program/code block/screen$/array ($1B00 for screen$).

			;   Bytes $0D-$0E: For a program, it holds the auto-run line number ($80 in byte $0E if no auto-run).

			;                  For code block/screen$ it holds the start address ($4000 for screen$).

			;                  For an array, it holds the variable name in byte $0E.

			;   Bytes $0F-$10: Offset to the variables (i.e. length of program) if a program.





			; ================================================

			; AY-3-8912 Programmable Sound Generator Registers

			; ================================================

			; This is controlled through output I/O port $FFFD. It is driven from a 1.77345 MHz clock.

			; The datasheet for the AY-3-8912 lists to the registers in octal, but below they are listed in decimal.

			;

			; -----------------

			; Registers 0 and 1 (Channel A Tone Generator)

			; -----------------

			; Forms a 12 bit pitch control for sound channel A. The basic unit of tone is the clock

			; frequency divided by 16, i.e. 110.841 kHz. With a 12 bit counter range, 4095 different

			; frequencies from 27.067 Hz to 110.841 kHz (in increments of 27.067 Hz) can be generated.

			;

			;   Bits 0-7  : Contents of register 0.

			;   Bits 8-11 : Contents of lower nibble of register 1.

			;   Bits 12-15: Not used.

			;

			; -----------------

			; Registers 2 and 3 (Channel B Tone Generator)

			; -----------------

			; Forms a 12 bit pitch control for sound channel B.

			;

			;   Bits 0-7  : Contents of register 2.

			;   Bits 8-11 : Contents of lower nibble of register 3.

			;   Bits 12-15: Not used.

			;

			; -----------------

			; Registers 4 and 5 (Channel C Tone Generator)

			; -----------------

			; Forms a 12 bit pitch control for sound channel C.

			;

			;   Bits 0-7  : Contents of register 4.

			;   Bits 8-11 : Contents of lower nibble of register 5.

			;   Bits 12-15: Not used.

			;

			; ----------

			; Register 6 (Noise Generator)

			; ----------

			; The frequency of the noise is obtained in the PSG by first counting down the input

			; clock by 16 (i.e. 110.841 kHz), then by further counting down the result by the programmed

			; 5 bit noise period value held in bits 0-4 of register 6. With a 5 bit counter range, 31 different

			; frequencies from 3.576 kHz to 110.841 kHz (in increments of 3.576 kHz) can be generated.

			;

			; ----------

			; Register 7 (Mixer - I/O Enable)

			; ----------

			; This controls the enable status of the noise and tone mixers for the three channels,

			; and also controls the I/O port used to drive the RS232 and Keypad sockets.

			;

			; Bit 0: Channel A Tone Enable (0=enabled).

			; Bit 1: Channel B Tone Enable (0=enabled).

			; Bit 2: Channel C Tone Enable (0=enabled).

			; Bit 3: Channel A Noise Enable (0=enabled).

			; Bit 4: Channel B Noise Enable (0=enabled).

			; Bit 5: Channel C Noise Enable (0=enabled).

			; Bit 6: I/O Port Enable (0=input, 1=output).

			; Bit 7: Not used.

			;

			; ----------

			; Register 8 (Channel A Volume)

			; ----------

			; This controls the volume of channel A.

			;

			; Bits 0-4: Channel A volume level.

			; Bit 5   : 1=Use envelope defined by register 13 and ignore the volume setting.

			; Bits 6-7: Not used.

			;

			; ----------

			; Register 9 (Channel B Volume)

			; ----------

			; This controls the volume of channel B.

			;

			; Bits 0-4: Channel B volume level.

			; Bit 5   : 1=Use envelope defined by register 13 and ignore the volume setting.

			; Bits 6-7: Not used.

			;

			; -----------

			; Register 10 (Channel C Volume)

			; -----------

			; This controls the volume of channel C.

			;

			; Bits 0-4: Channel C volume level.

			; Bit 5   : 1=Use envelope defined by register 13 and ignore the volume setting.

			; Bits 6-7: Not used.

			;

			; ------------------

			; Register 11 and 12 (Envelope Period)

			; ------------------

			; These registers allow the frequency of the envelope to be selected.

			; The frequency of the envelope is obtained in the PSG by first counting down

			; the input clock by 256 (6.927 kHz), then further counting down the result by the programmed

			; 16 bit envelope period value. With a 16 bit counter range, 65535 different

			; frequencies from 1.691 Hz to 110.841 kHz (in increments of 1.691 Hz) can be generated.

			;

			; Bits 0-7 : Contents of register 11.

			; Bits 8-15: Contents of register 12.

			;

			; -----------

			; Register 13 (Envelope Shape)

			; -----------

			; This register allows the shape of the envelope to be selected.

			; The envelope generator further counts down the envelope frequency by 16, producing

			; a 16-state per cycle envelope pattern. The particular shape and cycle pattern of any

			; desired envelope is accomplished by controlling the count pattern of the 4 bit counter

			; and by defining a single cycle or repeat cycle pattern.

			;

			; Bit 0   : Hold.

			; Bit 1   : Alternate.

			; Bit 2   : Attack.

			; Bit 3   : Continue.

			; Bits 4-7: Not used.

			;

			; These control bits can produce the following envelope waveforms:

			;

			; Bit: 3 2 1 0

			;      -------

			;

			;      0 0 X X  \                         Single decay then off.

			;                \______________________  Used by W0 PLAY command.

			;

			;

			;      0 1 X X   /|                       Single attack then off.

			;               / |_____________________  Used by W1 PLAY command.

			;

			;

			;      1 0 0 0  \ |\ |\ |\ |\ |\ |\ |\ |  Repeated decay.

			;                \| \| \| \| \| \| \| \|  Used by W4 PLAY command.

			;

			;

			;      1 0 0 1  \                         Single decay then off.

			;                \______________________  Not used PLAY command (use W0 instead).

			;

			;

			;      1 0 1 0  \  /\  /\  /\  /\  /\  /  Repeated decay-attack.

			;                \/  \/  \/  \/  \/  \/   Used by W7 PLAY command.

			;

			;                  _____________________

			;      1 0 1 1  \ |                       Single decay then hold.

			;                \|                       Used by W2 PLAY command.

			;

			;

			;      1 1 0 0   /| /| /| /| /| /| /| /|  Repeated attack.

			;               / |/ |/ |/ |/ |/ |/ |/ |  Used by W5 PLAY command.

			;

			;                 ______________________

			;      1 1 0 1   /                        Single attack then hold.

			;               /                         Used by W3 PLAY command.

			;

			;

			;      1 1 1 0   /\  /\  /\  /\  /\  /\   Repeated attack-decay.

			;               /  \/  \/  \/  \/  \/  \  Used by W6 PLAY command.

			;

			;

			;      1 1 1 1   /|                       Single attack then off.

			;               / |_____________________  Not used by PLAY command (use W1 instead).

			;

			;

			;           -->|  |<--  Envelope Period

			;

			; -----------

			; Register 14 (I/O Port)

			; -----------

			; This controls the RS232 and Keypad sockets.

			; Once the register has been selected, it can be read via port $FFFD and written via port $BFFD.

			;

			; Bit 0: KEYPAD CTS (out) - 0=Spectrum ready to receive, 1=Busy

			; Bit 1: KEYPAD RXD (out) - 0=Transmit high bit,         1=Transmit low bit

			; Bit 2: RS232  CTS (out) - 0=Spectrum ready to receive, 1=Busy

			; Bit 3: RS232  RXD (out) - 0=Transmit high bit,         1=Transmit low bit

			; Bit 4: KEYPAD DTR (in)  - 0=Keypad ready for data,     1=Busy

			; Bit 5: KEYPAD TXD (in)  - 0=Receive high bit,          1=Receive low bit

			; Bit 6: RS232  DTR (in)  - 0=Device ready for data,     1=Busy

			; Bit 7: RS232  TXD (in)  - 0=Receive high bit,          1=Receive low bit

			;

			; The RS232 port also doubles up as a MIDI port, with communications to MIDI devices occurring at 31250 baud.

			; Commands and data can be sent to MIDI devices. Command bytes have the most significant bit set, whereas data bytes have it reset.





			; ===============

			; Socket Pin Outs

			; ===============



			; -----------------

			; RS232/MIDI Socket

			; -----------------

			; The RS232/MIDI socket is controlled by register 14 of the AY-3-8912 sound generator.

			;    _____________

			;  _|             |

			; |               | Front View

			; |_  6 5 4 3 2 1 |

			;   |_|_|_|_|_|_|_|

			;

			; Pin   Signal

			; ---   ------

			; 1     0V

			; 2     TXD - In  (Bit 7)

			; 3     RXD - Out (Bit 3)

			; 4     DTR - In  (Bit 6)

			; 5     CTS - Out (Bit 2)

			; 6     12V



			; -------------

			; Keypad Socket

			; -------------

			; The keypad socket is controlled by register 14 of the AY-3-8912 sound generator.

			; Only bits 0 and 5 are used for communications with the keypad (pins 2 and 5).

			; Writing a 1 to bit 0 (pin 2) will eventually force the keypad to reset.

			; Summary information about the keypad and its communications protocol can be found in the Spectrum 128 Service Manual and

			; a detailed description can be found at www.fruitcake.plus.com.

			;    _____________

			;  _|             |

			; |               | Front View

			; |_  6 5 4 3 2 1 |

			;   |_|_|_|_|_|_|_|

			;

			; Pin   Signal

			; ---   ------

			; 1     0V

			; 2     OUT - Out (Bit 0)

			; 3     n/u - In  (Bit 4)

			; 4     n/u - Out (Bit 1)

			; 5     IN  - In  (Bit 5)

			; 6     12V

			;

			; n/u = Not used for keypad communications.

			;

			; The keypad socket was later used by Amstrad to support a lightgun. There are no routines within the ROMs to handle communication

			; with the lightgun so each game has to implement its own control software. Only bits 4 and 5 are used for communication with the lightgun (pins 3 and 5).

			; The connections to the lightgun are as follows:

			;

			; Pin   Signal

			; ---   ------

			; 1     0V

			; 2     n/u     - Out (Bit 0)

			; 3     SENSOR  - In  (Bit 4)

			; 4     n/u     - Out (Bit 1)

			; 5     TRIGGER - In  (Bit 5)

			; 6     12V

			;

			; n/u = Not used for lightgun communication.



			; --------------

			; Monitor Socket

			; --------------

			;

			;         *******

			;      ***       ***

			;    **             **

			;   * --7--     --6-- *

			;  *         |         *

			; *  --3--   8   --1--  *  Front View

			; *          |          *

			; *      /       \      *

			;  *    5    |    4    *

			;   *  /     2     \  *

			;    **      |      **

			;      ***       ***

			;         *******

			;

			; Pin   Signal           Level

			; ---   ------           -----

			; 1     Composite PAL    1.2V pk-pk (75 Ohms)

			; 2     0 Volts          0V

			; 3     Bright Output    TTL

			; 4     Composite Sync   TTL

			; 5     Vertical Sync    TTL

			; 6     Green            TTL

			; 7     Red              TTL

			; 8     Blue             TTL

			;

			; A detailed description of the monitor socket and circuitry, and how to construct a suitable RGB SCART cable

			; can be found at www.fruitcake.plus.com.



			; --------------

			; Edge Connector

			; --------------

			;

			; Pin   Side A   Side B

			; ---   ------   ------

			; 1     A15      A14

			; 2     A13      A12

			; 3     D7       +5V

			; 4     n/u      +9V

			; 5     Slot     Slot

			; 6     D0       0V

			; 7     D1       0V

			; 8     D2       /CLK

			; 9     D6       A0

			; 10    D5       A1

			; 11    D3       A2

			; 12    D4       A3

			; 13    /INT     /IORQULA

			; 14    /NMI     0V

			; 15    /HALT    n/u (On 48K Spectrum = VIDEO)

			; 16    /MREQ    n/u (On 48K Spectrum = /Y)

			; 17    /IORQ    n/u (On 48K Spectrum = V)

			; 18    /RD      n/u (On 48K Spectrum = U)

			; 19    /WR      /BUSREQ

			; 20    -5V      /RESET

			; 21    /WAIT    A7

			; 22    +12V     A6

			; 23    -12V     A5

			; 24    /M1      A4

			; 25    /RFSH    /ROMCS

			; 26    A8       /BUSACK

			; 27    A10      A9

			; 28    n/u      A11

			;

			; Side A=Component Side, Side B=Underside.

			; n/u = Not used.



# End of file rom128_0.asm
4000
